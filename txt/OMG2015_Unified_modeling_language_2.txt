Date: March 2015

OMG Unified Modeling Language TM (OMG UML)

Version 2.5

OMG Document Number

formal/2015-03-01

Normative Reference:

http://www.omg.org/spec/UML/2.5

Associated Normative Machine Consumable Files:

http://www.omg.org/spec/UML/20131001/PrimitiveTypes.xmi
http://www.omg.org/spec/UML/20131001/UML.xmi
http://www.omg.org/spec/UML/20131001/StandardProfile.xmi
http://www.omg.org/spec/UML/20131001/UMLDI.xmi

Version 2.5 is formally a minor revision to the UML 2.4.1 specification, having been substantially re-
written as solicited by the UML Specification Simplification RFP ad/09-12-10. It supersedes 
formal/2011-08-05 (Infrastructure) and formal/2011-08-06 (Superstructure).

Copyright © 2009-2013 88Solutions
Copyright © 2009-2010 Artisan Software Tools
Copyright © 2001-2013 Adaptive
Copyright © 2009-2010 Armstrong Process Group, Inc.
Copyright © 2001-2010 Alcatel
Copyright © 2001-2010 Borland Software Corporation
Copyright © 2009-2010 Commissariat à l'Energie Atomique
Copyright © 2001-2010 Computer Associates International, Inc.
Copyright © 2009-2010 Computer Sciences Corporation
Copyright © 2009-2013 Data Access Technologies, Inc. (Model Driven Solutions)
Copyright © 2009-2013 Deere & Company
Copyright © 2009-2013 European Aeronautic Defence and Space Company
Copyright © 2001-2013 Fujitsu
Copyright © 2001-2010 Hewlett-Packard Company
Copyright © 2001-2010 I-Logix Inc.
Copyright © 2001-2013 International Business Machines Corporation
Copyright © 2001-2010 IONA Technologies
Copyright © 2013 Ivar Jacobson International SA
Copyright © 2001-2010 Kabira Technologies, Inc.
Copyright © 2009-2010 Lockheed Martin
Copyright © 2001-2010 MEGA International
Copyright © 2009-2010 Mentor Graphics Corporation
Copyright © 2009-2013 Microsoft Corporation
Copyright © 2001-2010 Motorola, Inc.
Copyright © 2009-2010 National Aeronautics and Space Administration
Copyright © 2009-2013 No Magic, Inc.
Copyright © 1997-2015 Object Management Group, Inc
Copyright © 2009-2010 oose Innovative Informatik GmbH
Copyright © 2001-2010 Oracle Corporation
Copyright © 2009-2010 Oslo Software, Inc.
Copyright © 2009-2010 Purdue University
Copyright © 2012-2013 Simula Research Laboratory
Copyright © 2009-2010 SINTEF
Copyright © 2001-2010 SOFTEAM
Copyright © 2009-2013 Sparx Systems Pty Ltd
Copyright © 2001-2010 Telefonaktiebolaget LM Ericsson
Copyright © 2009-2010 THALES
Copyright © 2001-2013 Unisys
Copyright © 2001-2010 X-Change Technologies Group, LLC

USE OF SPECIFICATION - TERMS, CONDITIONS & NOTICES

The material in this document details an Object Management Group specification in accordance with the terms, 
conditions and notices set forth below. This document does not represent a commitment to implement any portion of 
this specification in any company's products. The information contained in this document is subject to change without 
notice.

LICENSES

The companies listed above have granted to the Object Management Group, Inc. (OMG) a nonexclusive, royalty-free, 
paid up, worldwide license to copy and distribute this document and to modify this document and distribute copies of 
the modified version. Each of the copyright holders listed above has agreed that no person shall be deemed to have 
infringed the copyright in the included material of any such copyright holder by reason of having used the specification 
set forth herein or having conformed any computer software to the specification.

ii

Unified Modeling Language 2.5

Subject to all of the terms and conditions below, the owners of the copyright in this specification hereby grant you a 
fully-paid up, non-exclusive, nontransferable, perpetual, worldwide license (without the right to sublicense), to use this 
specification to create and distribute software and special purpose specifications that are based upon this specification, 
and to use, copy, and distribute this specification as provided under the Copyright Act; provided that: (1) both the 
copyright notice identified above and this permission notice appear on any copies of this specification; (2) the use of the 
specifications is for informational purposes and will not be copied or posted on any network computer or broadcast in 
any media and will not be otherwise resold or transferred for commercial purposes; and (3) no modifications are made 
to this specification. This limited permission automatically terminates without notice if you breach any of these terms or 
conditions. Upon termination, you will destroy immediately any copies of the specifications in your possession or 
control.

PATENTS

The attention of adopters is directed to the possibility that compliance with or adoption of OMG specifications may 
require use of an invention covered by patent rights. OMG shall not be responsible for identifying patents for which a 
license may be required by any OMG specification, or for conducting legal inquiries into the legal validity or scope of 
those patents that are brought to its attention. OMG specifications are prospective and advisory only. Prospective users 
are responsible for protecting themselves against liability for infringement of patents.
This specification is published under the “RF on Limited Terms” IPR mode listed in the OMG Intellectual Property 
Rights Policy Statement, OMG Document ipr/12-09-02, available at: http://doc.omg.org/ipr/12-09-02

GENERAL USE RESTRICTIONS

Any unauthorized use of this specification may violate copyright laws, trademark laws, and communications regulations 
and statutes. This document contains information which is protected by copyright. All Rights Reserved. No part of this 
work covered by copyright herein may be reproduced or used in any form or by any means--graphic, electronic, or 
mechanical, including photocopying, recording, taping, or information storage and retrieval systems--without 
permission of the copyright owner.

DISCLAIMER OF WARRANTY

WHILE THIS PUBLICATION IS BELIEVED TO BE ACCURATE, IT IS PROVIDED "AS IS" AND MAY CONTAIN 
ERRORS OR MISPRINTS. THE OBJECT MANAGEMENT GROUP AND THE COMPANIES LISTED ABOVE 
MAKE NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH REGARD TO THIS PUBLICATION, 
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF TITLE OR OWNERSHIP, IMPLIED WARRANTY 
OF MERCHANTABILITY OR WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE.
IN NO EVENT SHALL THE OBJECT MANAGEMENT GROUP OR ANY OF THE COMPANIES LISTED ABOVE 
BE LIABLE FOR ERRORS CONTAINED HEREIN OR FOR DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
CONSEQUENTIAL, RELIANCE OR COVER DAMAGES, INCLUDING LOSS OF PROFITS, REVENUE, DATA 
OR USE, INCURRED BY ANY USER OR ANY THIRD PARTY IN CONNECTION WITH THE FURNISHING, 
PERFORMANCE, OR USE OF THIS MATERIAL, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGES.
The entire risk as to the quality and performance of software developed using this specification is borne by you. This 
disclaimer of warranty constitutes an essential part of the license granted to you to use this specification.

RESTRICTED RIGHTS LEGEND

Use, duplication or disclosure by the U.S. Government is subject to the restrictions set forth in subparagraph (c) (1) (ii) 
of The Rights in Technical Data and Computer Software Clause at DFARS 252.227-7013 or in subparagraph (c)(1) and 
(2) of the Commercial Computer Software - Restricted Rights clauses at 48 C.F.R. 52.227-19 or as specified in 48 

Unified Modeling Language 2.5

iii

C.F.R. 227-7202-2 of the DoD F.A.R. Supplement and its successors, or as specified in 48 C.F.R. 12.212 of the Federal 
Acquisition Regulations and its successors, as applicable. The specification copyright owners are as indicated above and 
may be contacted through the Object Management Group, 109 Highland Avenue, Needham, MA 02494, U.S.A.

TRADEMARKS

IMM®, MDA®, Model Driven Architecture®, UML®, UML Cube logo®, OMG Logo®, CORBA® and XMI® are 
registered trademarks of the Object Management Group, Inc., and Object Management Group™, OMG™, Unified 
Modeling Language™, Model Driven Architecture Logo™, Model Driven Architecture Diagram™, CORBA logos™, 
XMI Logo™, CWM™, CWM Logo™, IIOP™, MOF™, OMG Interface Definition Language (IDL™), and OMG 
Systems Modeling Language (OMG SysML™) are trademarks of the Object Management Group. All other products or 
company names mentioned are used for identification purposes only, and may be trademarks of their respective owners.

COMPLIANCE

The copyright holders listed above acknowledge that the Object Management Group (acting itself or through its 
designees) is and shall at all times be the sole entity that may authorize developers, suppliers and sellers of computer 
software to use certification marks, trademarks or other special designations to indicate compliance with these 
materials.
Software developed under the terms of this license may claim compliance or conformance with this specification if and 
only if the software compliance is of a nature fully matching the applicable compliance points as stated in the 
specification. Software developed only partially matching the applicable compliance points may claim only that the 
software was based on this specification, but may not claim compliance or conformance with this specification. In the 
event that testing suites are implemented or approved by Object Management Group, Inc., software developed using 
this specification may claim compliance or conformance with the specification only if the software satisfactorily 
completes the testing suites.

iv

Unified Modeling Language 2.5

OMG’s Issue Reporting Procedure

All OMG specifications are subject to continuous review and improvement. As part of this process we encourage 
readers to report any ambiguities, inconsistencies, or inaccuracies they may find by completing the Issue Reporting 
Form listed on the main web page http://www.omg.org, under Documents, Report a Bug/Issue 
(http://www.omg.org/report_issue.htm).

Unified Modeling Language 2.5

v

Table of Contents

1 Scope...............................................................................................................................1
2 Conformance................................................................................................................... 3
3 Normative References.....................................................................................................5
4
Terms and Definitions...................................................................................................... 7
5 Notational Conventions....................................................................................................9
Key words for Requirement Statements.............................................................................. 9
5.1
5.2
Annotations on Example Diagrams......................................................................................9
6 Additional Information.................................................................................................... 11
Specification Simplification................................................................................................ 11
6.1
6.2
Architectural Alignment...................................................................................................... 11
On the Semantics of UML..................................................................................................12
6.3
Models and What They Model................................................................................................... 12
6.3.1
Semantic Areas.......................................................................................................................... 13
6.3.2
6.3.3
Stable and Transient Behavioral Semantics.............................................................................. 15
How to Read this Specification.......................................................................................... 16
6.4
Specification Format.................................................................................................................. 16
6.4.1
6.4.2
Diagram Format......................................................................................................................... 18
Acknowledgements........................................................................................................... 19
6.5
Primary Authors......................................................................................................................... 19
6.5.1
Technical Support...................................................................................................................... 19
6.5.2
6.5.3
Reviewers.................................................................................................................................. 19
Submitters.................................................................................................................................. 20
6.5.4
7 Common Structure.........................................................................................................21
7.1
Summary........................................................................................................................... 21
Root................................................................................................................................... 21
7.2
Summary................................................................................................................................... 21
7.2.1
Abstract Syntax.......................................................................................................................... 21
7.2.2
7.2.3
Semantics.................................................................................................................................. 22
Notation..................................................................................................................................... 22
7.2.4
7.2.5
Examples................................................................................................................................... 22
Templates.......................................................................................................................... 22
7.3
Summary................................................................................................................................... 22
7.3.1
Abstract Syntax.......................................................................................................................... 23
7.3.2
Semantics.................................................................................................................................. 24
7.3.3
7.3.4
Notation..................................................................................................................................... 26
Namespaces..................................................................................................................... 27
7.4
Summary................................................................................................................................... 27
7.4.1
Abstract Syntax.......................................................................................................................... 27
7.4.2
7.4.3
Semantics.................................................................................................................................. 27
Notation..................................................................................................................................... 29
7.4.4

vi

Unified Modeling Language 2.5

7.4.5
7.5
7.5.1
7.5.2
7.5.3
7.5.4
7.5.5
7.6
7.6.1
7.6.2
7.6.3
7.6.4
7.6.5
7.7
7.7.1
7.7.2
7.7.3
7.7.4
7.7.5
7.8
7.8.1
7.8.2
7.8.3
7.8.4
7.8.5
7.8.6
7.8.7
7.8.8
7.8.9
7.8.10
7.8.11
7.8.12
7.8.13
7.8.14
7.8.15
7.8.16
7.8.17
7.8.18
7.8.19
7.8.20
7.8.21
7.8.22
7.8.23
7.8.24
7.9
7.9.1
7.9.2
7.9.3
7.9.4

 Examples.................................................................................................................................. 30
Types and Multiplicity........................................................................................................ 32
Summary................................................................................................................................... 32
Abstract Syntax.......................................................................................................................... 33
Semantics.................................................................................................................................. 33
Notation..................................................................................................................................... 34
Examples................................................................................................................................... 35
Constraints........................................................................................................................ 35
Summary................................................................................................................................... 35
Abstract Syntax.......................................................................................................................... 36
Semantics.................................................................................................................................. 36
Notation..................................................................................................................................... 36
Examples................................................................................................................................... 37
Dependencies................................................................................................................... 38
Summary................................................................................................................................... 38
Abstract Syntax.......................................................................................................................... 38
Semantics.................................................................................................................................. 38
Notation..................................................................................................................................... 39
Examples................................................................................................................................... 39
Classifier Descriptions....................................................................................................... 40
Abstraction [Class]..................................................................................................................... 40
Comment [Class]....................................................................................................................... 40
Constraint [Class]....................................................................................................................... 41
Dependency [Class]................................................................................................................... 42
DirectedRelationship [Abstract Class]........................................................................................ 42
Element [Abstract Class]............................................................................................................ 43
ElementImport [Class]................................................................................................................ 44
MultiplicityElement [Abstract Class]........................................................................................... 45
NamedElement [Abstract Class]................................................................................................ 47
Namespace [Abstract Class]...................................................................................................... 50
PackageImport [Class]............................................................................................................... 52
PackageableElement [Abstract Class]....................................................................................... 52
ParameterableElement [Abstract Class].................................................................................... 53
Realization [Class]..................................................................................................................... 54
Relationship [Abstract Class]..................................................................................................... 54
TemplateBinding [Class]............................................................................................................ 55
TemplateParameter [Class]........................................................................................................ 55
TemplateParameterSubstitution [Class]..................................................................................... 56
TemplateSignature [Class]......................................................................................................... 57
TemplateableElement [Abstract Class]...................................................................................... 58
Type [Abstract Class]................................................................................................................. 59
TypedElement [Abstract Class].................................................................................................. 59
Usage [Class]............................................................................................................................ 60
VisibilityKind [Enumeration]........................................................................................................60
Association Descriptions....................................................................................................61
A_actual_templateParameterSubstitution [Association].............................................................61
A_annotatedElement_comment [Association]........................................................................... 61
A_clientDependency_client [Association].................................................................................. 61
A_constrainedElement_constraint [Association]........................................................................ 61

Unified Modeling Language 2.5

vii

7.9.5
7.9.6
7.9.7
7.9.8
7.9.9
7.9.10
7.9.11
7.9.12
7.9.13
7.9.14
7.9.15
7.9.16
7.9.17
7.9.18
7.9.19
7.9.20
7.9.21
7.9.22
7.9.23
7.9.24
7.9.25
7.9.26
7.9.27
7.9.28
7.9.29
7.9.30
7.9.31
7.9.32
7.9.33
7.9.34
7.9.35
7.9.36

A_default_templateParameter [Association].............................................................................. 61
A_elementImport_importingNamespace [Association]...............................................................62
A_formal_templateParameterSubstitution [Association]............................................................ 62
A_importedElement_import [Association].................................................................................. 62
A_importedMember_namespace [Association].......................................................................... 62
A_importedPackage_packageImport [Association].................................................................... 63
A_lowerValue_owningLower [Association]................................................................................. 63
A_mapping_abstraction [Association]........................................................................................ 63
A_member_memberNamespace [Association].......................................................................... 63
A_nameExpression_namedElement [Association].....................................................................63
A_ownedActual_owningTemplateParameterSubstitution [Association]......................................64
A_ownedComment_owningElement [Association]..................................................................... 64
A_ownedDefault_templateParameter [Association]................................................................... 64
A_ownedElement_owner [Association]...................................................................................... 64
A_ownedMember_namespace [Association]............................................................................. 65
A_ownedParameter_signature [Association]............................................................................. 65
A_ownedParameteredElement_owningTemplateParameter [Association]................................65
A_ownedRule_context [Association].......................................................................................... 65
A_ownedTemplateSignature_template [Association]................................................................. 65
A_packageImport_importingNamespace [Association].............................................................. 66
A_parameterSubstitution_templateBinding [Association]...........................................................66
A_parameter_templateSignature [Association].......................................................................... 66
A_parameteredElement_templateParameter [Association]....................................................... 66
A_relatedElement_relationship [Association]............................................................................. 67
A_signature_templateBinding [Association]............................................................................... 67
A_source_directedRelationship [Association]............................................................................ 67
A_specification_owningConstraint [Association]........................................................................ 67
A_supplier_supplierDependency [Association].......................................................................... 67
A_target_directedRelationship [Association]..............................................................................68
A_templateBinding_boundElement [Association]...................................................................... 68
A_type_typedElement [Association]...........................................................................................68
A_upperValue_owningUpper [Association]................................................................................ 68
8 Values............................................................................................................................ 69
Summary........................................................................................................................... 69
8.1
Literals............................................................................................................................... 69
8.2
Summary................................................................................................................................... 69
8.2.1
8.2.2
Abstract Syntax.......................................................................................................................... 69
Semantics.................................................................................................................................. 69
8.2.3
8.2.4
Notation..................................................................................................................................... 70
Expressions....................................................................................................................... 70
8.3
Summary................................................................................................................................... 70
8.3.1
Abstract Syntax.......................................................................................................................... 71
8.3.2
Semantics.................................................................................................................................. 71
8.3.3
8.3.4
Notation..................................................................................................................................... 72
8.3.5
Examples................................................................................................................................... 72
Time.................................................................................................................................. 73
8.4
Summary................................................................................................................................... 73
8.4.1
8.4.2
Abstract Syntax.......................................................................................................................... 73
Semantics.................................................................................................................................. 74
8.4.3

viii

Unified Modeling Language 2.5

8.4.4
8.4.5
8.5
8.5.1
8.5.2
8.5.3
8.5.4
8.5.5
8.6
8.6.1
8.6.2
8.6.3
8.6.4
8.6.5
8.6.6
8.6.7
8.6.8
8.6.9
8.6.10
8.6.11
8.6.12
8.6.13
8.6.14
8.6.15
8.6.16
8.6.17
8.6.18
8.6.19
8.6.20
8.6.21
8.6.22
8.7
8.7.1
8.7.2
8.7.3
8.7.4
8.7.5
8.7.6
8.7.7
8.7.8
8.7.9
8.7.10
8.7.11
8.7.12
8.7.13
8.7.14
8.7.15
8.7.16
8.7.17
8.7.18

Notation..................................................................................................................................... 75
Examples................................................................................................................................... 75
Intervals............................................................................................................................. 75
Summary................................................................................................................................... 75
Abstract Syntax.......................................................................................................................... 76
Semantics.................................................................................................................................. 76
Notation..................................................................................................................................... 77
Examples................................................................................................................................... 77
Classifier Descriptions....................................................................................................... 78
Duration [Class]......................................................................................................................... 78
DurationConstraint [Class]......................................................................................................... 78
DurationInterval [Class].............................................................................................................. 79
DurationObservation [Class]...................................................................................................... 79
Expression [Class]..................................................................................................................... 80
Interval [Class]........................................................................................................................... 81
IntervalConstraint [Class]........................................................................................................... 81
LiteralBoolean [Class]................................................................................................................ 82
LiteralInteger [Class].................................................................................................................. 82
LiteralNull [Class]....................................................................................................................... 83
LiteralReal [Class]...................................................................................................................... 83
LiteralSpecification [Abstract Class]........................................................................................... 84
LiteralString [Class].................................................................................................................... 84
LiteralUnlimitedNatural [Class]................................................................................................... 85
Observation [Abstract Class]..................................................................................................... 85
OpaqueExpression [Class]........................................................................................................ 85
StringExpression [Class]............................................................................................................ 87
TimeConstraint [Class]............................................................................................................... 88
TimeExpression [Class]............................................................................................................. 89
TimeInterval [Class]................................................................................................................... 89
TimeObservation [Class]............................................................................................................ 90
ValueSpecification [Abstract Class]............................................................................................ 90
Association Descriptions....................................................................................................91
A_behavior_opaqueExpression [Association]............................................................................ 91
A_event_durationObservation [Association].............................................................................. 92
A_event_timeObservation [Association].................................................................................... 92
A_expr_duration [Association]................................................................................................... 92
A_expr_timeExpression [Association]........................................................................................ 92
A_max_durationInterval [Association]........................................................................................ 92
A_max_interval [Association]..................................................................................................... 93
A_max_timeInterval [Association].............................................................................................. 93
A_min_durationInterval [Association]......................................................................................... 93
A_min_interval [Association]...................................................................................................... 93
A_min_timeInterval [Association]............................................................................................... 94
A_observation_duration [Association]........................................................................................ 94
A_observation_timeExpression [Association]............................................................................ 94
A_operand_expression [Association]......................................................................................... 94
A_result_opaqueExpression [Association]................................................................................. 95
A_specification_durationConstraint [Association]...................................................................... 95
A_specification_intervalConstraint [Association]........................................................................ 95
A_specification_timeConstraint [Association]............................................................................ 95

Unified Modeling Language 2.5

ix

8.7.19

A_subExpression_owningExpression [Association]................................................................... 96
9 Classification..................................................................................................................97
Summary........................................................................................................................... 97
9.1
Classifiers.......................................................................................................................... 97
9.2
9.2.1
Summary................................................................................................................................... 97
Abstract Syntax.......................................................................................................................... 97
9.2.2
Semantics.................................................................................................................................. 97
9.2.3
Notation..................................................................................................................................... 99
9.2.4
9.2.5
Examples................................................................................................................................. 101
Classifier Templates.........................................................................................................101
9.3
Summary................................................................................................................................. 101
9.3.1
Abstract Syntax........................................................................................................................ 102
9.3.2
9.3.3
Semantics................................................................................................................................ 102
Notation................................................................................................................................... 103
9.3.4
9.3.5
Examples................................................................................................................................. 104
Features.......................................................................................................................... 105
9.4
Summary................................................................................................................................. 105
9.4.1
Abstract Syntax........................................................................................................................ 105
9.4.2
Semantics................................................................................................................................ 105
9.4.3
9.4.4
Notation................................................................................................................................... 108
Properties........................................................................................................................ 109
9.5
Summary................................................................................................................................. 109
9.5.1
Abstract Syntax........................................................................................................................ 109
9.5.2
9.5.3
Semantics................................................................................................................................ 109
Notation.................................................................................................................................... 111
9.5.4
9.5.5
Examples................................................................................................................................. 113
Operations....................................................................................................................... 114
9.6
Summary.................................................................................................................................. 114
9.6.1
Abstract Syntax........................................................................................................................ 114
9.6.2
Semantics................................................................................................................................ 114
9.6.3
9.6.4
Notation.................................................................................................................................... 115
9.6.5
Examples................................................................................................................................. 117
Generalization Sets......................................................................................................... 117
9.7
Summary.................................................................................................................................. 117
9.7.1
9.7.2
Abstract Syntax........................................................................................................................ 117
Semantics................................................................................................................................ 117
9.7.3
Notation.................................................................................................................................... 118
9.7.4
9.7.5
Examples................................................................................................................................. 120
Instances......................................................................................................................... 124
9.8
Summary................................................................................................................................. 124
9.8.1
Abstract Syntax........................................................................................................................ 124
9.8.2
Semantics................................................................................................................................ 125
9.8.3
9.8.4
Notation................................................................................................................................... 126
9.8.5
Examples................................................................................................................................. 126
Classifier Descriptions..................................................................................................... 127
9.9
9.9.1
AggregationKind [Enumeration]............................................................................................... 127
BehavioralFeature [Abstract Class]..........................................................................................128
9.9.2

x

Unified Modeling Language 2.5

CallConcurrencyKind [Enumeration]........................................................................................ 129
9.9.3
Classifier [Abstract Class]........................................................................................................ 130
9.9.4
ClassifierTemplateParameter [Class]....................................................................................... 134
9.9.5
Feature [Abstract Class].......................................................................................................... 136
9.9.6
Generalization [Class].............................................................................................................. 136
9.9.7
GeneralizationSet [Class]........................................................................................................ 137
9.9.8
InstanceSpecification [Class]................................................................................................... 138
9.9.9
InstanceValue [Class].............................................................................................................. 139
9.9.10
Operation [Class]..................................................................................................................... 139
9.9.11
OperationTemplateParameter [Class]...................................................................................... 142
9.9.12
Parameter [Class].................................................................................................................... 143
9.9.13
ParameterDirectionKind [Enumeration]....................................................................................145
9.9.14
ParameterEffectKind [Enumeration].........................................................................................145
9.9.15
ParameterSet [Class]............................................................................................................... 146
9.9.16
Property [Class]....................................................................................................................... 147
9.9.17
RedefinableElement [Abstract Class].......................................................................................151
9.9.18
RedefinableTemplateSignature [Class].................................................................................... 152
9.9.19
Slot [Class]............................................................................................................................... 153
9.9.20
StructuralFeature [Abstract Class]........................................................................................... 154
9.9.21
9.9.22
Substitution [Class].................................................................................................................. 154
9.10 Association Descriptions..................................................................................................155
9.10.1
A_attribute_classifier [Association].......................................................................................... 155
A_bodyCondition_bodyContext [Association].......................................................................... 155
9.10.2
A_classifier_instanceSpecification [Association]......................................................................155
9.10.3
A_classifier_templateParameter_parameteredElement [Association]......................................155
9.10.4
9.10.5
A_collaborationUse_classifier [Association].............................................................................155
A_condition_parameterSet [Association]................................................................................. 156
9.10.6
A_constrainingClassifier_classifierTemplateParameter [Association]...................................... 156
9.10.7
A_contract_substitution [Association]...................................................................................... 156
9.10.8
9.10.9
A_defaultValue_owningParameter [Association]......................................................................156
A_defaultValue_owningProperty [Association]......................................................................... 157
9.10.10
A_definingFeature_slot [Association]....................................................................................... 157
9.10.11
A_extendedSignature_redefinableTemplateSignature [Association]........................................157
9.10.12
9.10.13
A_feature_featuringClassifier [Association]............................................................................. 157
A_general_classifier [Association]........................................................................................... 157
9.10.14
A_general_generalization [Association]................................................................................... 158
9.10.15
A_generalizationSet_generalization [Association]................................................................... 158
9.10.16
9.10.17
A_generalization_specific [Association]................................................................................... 158
A_inheritedMember_inheritingClassifier [Association]............................................................. 158
9.10.18
A_inheritedParameter_redefinableTemplateSignature [Association].......................................158
9.10.19
A_instance_instanceValue [Association].................................................................................. 159
9.10.20
9.10.21
A_method_specification [Association]......................................................................................159
A_operation_templateParameter_parameteredElement [Association].....................................159
9.10.22
A_opposite_property [Association]...........................................................................................159
9.10.23
A_ownedParameterSet_behavioralFeature [Association]........................................................ 160
9.10.24
9.10.25
A_ownedParameter_operation [Association]........................................................................... 160
A_ownedParameter_ownerFormalParam [Association]...........................................................160
9.10.26
A_ownedTemplateSignature_classifier [Association]............................................................... 160
9.10.27
A_ownedUseCase_classifier [Association].............................................................................. 160
9.10.28
9.10.29
A_parameterSet_parameter [Association]............................................................................... 161
A_postcondition_postContext [Association]............................................................................. 161
9.10.30

Unified Modeling Language 2.5

xi

9.10.31
9.10.32
9.10.33
9.10.34
9.10.35
9.10.36
9.10.37
9.10.38
9.10.39
9.10.40
9.10.41
9.10.42
9.10.43
9.10.44
9.10.45
9.10.46
9.10.47

A_powertypeExtent_powertype [Association].......................................................................... 161
A_precondition_preContext [Association]................................................................................ 161
A_qualifier_associationEnd [Association]................................................................................ 161
A_raisedException_behavioralFeature [Association]............................................................... 162
A_raisedException_operation [Association]............................................................................. 162
A_redefinedClassifier_classifier [Association]..........................................................................162
A_redefinedElement_redefinableElement [Association].......................................................... 162
A_redefinedOperation_operation [Association]........................................................................162
A_redefinedProperty_property [Association]............................................................................163
A_redefinitionContext_redefinableElement [Association].........................................................163
A_representation_classifier [Association]................................................................................ 163
A_slot_owningInstance [Association]....................................................................................... 163
A_specification_owningInstanceSpec [Association].................................................................164
A_subsettedProperty_property [Association]........................................................................... 164
A_substitution_substitutingClassifier [Association].................................................................. 164
A_type_operation [Association]................................................................................................164
A_value_owningSlot [Association]........................................................................................... 164
10 Simple Classifiers........................................................................................................ 165
10.1 Summary......................................................................................................................... 165
10.2 DataTypes....................................................................................................................... 165
10.2.1
Summary................................................................................................................................. 165
Abstract Syntax........................................................................................................................ 165
10.2.2
Semantics................................................................................................................................ 165
10.2.3
10.2.4
Notation................................................................................................................................... 166
10.2.5
Examples................................................................................................................................. 166
10.3 Signals............................................................................................................................. 167
Summary................................................................................................................................. 167
10.3.1
10.3.2
Abstract Syntax........................................................................................................................ 167
Semantics................................................................................................................................ 167
10.3.3
Notation................................................................................................................................... 168
10.3.4
10.3.5
Examples................................................................................................................................. 168
Interfaces......................................................................................................................... 168
10.4
Summary................................................................................................................................. 168
10.4.1
Abstract Syntax........................................................................................................................ 169
10.4.2
Semantics................................................................................................................................ 169
10.4.3
10.4.4
Notation................................................................................................................................... 170
10.4.5
Examples................................................................................................................................. 170
10.5 Classifier Descriptions..................................................................................................... 172
BehavioredClassifier [Abstract Class]...................................................................................... 172
10.5.1
10.5.2
DataType [Class]...................................................................................................................... 172
Enumeration [Class]................................................................................................................. 173
10.5.3
EnumerationLiteral [Class]....................................................................................................... 173
10.5.4
Interface [Class]....................................................................................................................... 174
10.5.5
10.5.6
InterfaceRealization [Class]..................................................................................................... 175
PrimitiveType [Class]............................................................................................................... 175
10.5.7
Reception [Class]..................................................................................................................... 176
10.5.8
10.5.9
Signal [Class]........................................................................................................................... 176
10.6 Association Descriptions..................................................................................................177

xii

Unified Modeling Language 2.5

10.6.1
10.6.2
10.6.3
10.6.4
10.6.5
10.6.6
10.6.7
10.6.8
10.6.9
10.6.10
10.6.11
10.6.12
10.6.13
10.6.14
10.6.15
10.6.16

A_classifierBehavior_behavioredClassifier [Association]......................................................... 177
A_classifier_enumerationLiteral [Association]..........................................................................177
A_contract_interfaceRealization [Association]......................................................................... 177
A_interfaceRealization_implementingClassifier [Association].................................................. 177
A_nestedClassifier_interface [Association].............................................................................. 178
A_ownedAttribute_datatype [Association]................................................................................178
A_ownedAttribute_interface [Association]................................................................................178
A_ownedAttribute_owningSignal [Association]........................................................................ 178
A_ownedBehavior_behavioredClassifier [Association]............................................................ 178
A_ownedLiteral_enumeration [Association]............................................................................. 179
A_ownedOperation_datatype [Association]............................................................................. 179
A_ownedOperation_interface [Association]............................................................................. 179
A_ownedReception_interface [Association]............................................................................. 179
A_protocol_interface [Association]........................................................................................... 180
A_redefinedInterface_interface [Association]...........................................................................180
A_signal_reception [Association]............................................................................................. 180
11 Structured Classifiers...................................................................................................181
11.1 Summary......................................................................................................................... 181
11.2 Structured Classifiers...................................................................................................... 181
Summary................................................................................................................................. 181
11.2.1
11.2.2
Abstract Syntax........................................................................................................................ 181
Semantics................................................................................................................................ 182
11.2.3
Notation................................................................................................................................... 183
11.2.4
11.2.5
Examples................................................................................................................................. 184
11.3 Encapsulated Classifiers................................................................................................. 187
Summary................................................................................................................................. 187
11.3.1
Abstract Syntax........................................................................................................................ 188
11.3.2
11.3.3
Semantics................................................................................................................................ 188
Notation................................................................................................................................... 189
11.3.4
11.3.5
Examples................................................................................................................................. 190
11.4 Classes............................................................................................................................192
11.4.1
Summary................................................................................................................................. 192
Abstract Syntax........................................................................................................................ 192
11.4.2
Semantics................................................................................................................................ 192
11.4.3
Notation................................................................................................................................... 193
11.4.4
11.4.5
Examples................................................................................................................................. 193
11.5 Associations.................................................................................................................... 197
Summary................................................................................................................................. 197
11.5.1
Abstract Syntax........................................................................................................................ 197
11.5.2
11.5.3
Semantics................................................................................................................................ 197
Notation................................................................................................................................... 199
11.5.4
11.5.5
Examples................................................................................................................................. 201
11.6 Components.................................................................................................................... 206
Summary................................................................................................................................. 206
11.6.1
Abstract Syntax........................................................................................................................ 207
11.6.2
Semantics................................................................................................................................ 207
11.6.3
11.6.4
Notation................................................................................................................................... 208
Examples................................................................................................................................. 209
11.6.5

Unified Modeling Language 2.5

xiii

11.7 Collaborations..................................................................................................................213
11.7.1
Summary................................................................................................................................. 213
Abstract Syntax........................................................................................................................ 213
11.7.2
Semantics................................................................................................................................ 214
11.7.3
Notation................................................................................................................................... 215
11.7.4
11.7.5
Examples................................................................................................................................. 215
11.8 Classifier Descriptions..................................................................................................... 217
Association [Class]................................................................................................................... 217
11.8.1
AssociationClass [Class].......................................................................................................... 218
11.8.2
11.8.3
Class [Class]............................................................................................................................ 219
Collaboration [Class]................................................................................................................ 220
11.8.4
CollaborationUse [Class]......................................................................................................... 221
11.8.5
Component [Class].................................................................................................................. 222
11.8.6
11.8.7
ComponentRealization [Class]................................................................................................. 223
ConnectableElement [Abstract Class]......................................................................................224
11.8.8
ConnectableElementTemplateParameter [Class].....................................................................224
11.8.9
Connector [Class].................................................................................................................... 225
11.8.10
11.8.11
ConnectorEnd [Class].............................................................................................................. 226
ConnectorKind [Enumeration].................................................................................................. 227
11.8.12
EncapsulatedClassifier [Abstract Class].................................................................................. 228
11.8.13
11.8.14
Port [Class].............................................................................................................................. 228
11.8.15
StructuredClassifier [Abstract Class]........................................................................................230
11.9 Association Descriptions..................................................................................................231
A_collaborationRole_collaboration [Association]..................................................................... 231
11.9.1
11.9.2
A_connectableElement_templateParameter_parameteredElement [Association]...................231
A_contract_connector [Association]......................................................................................... 232
11.9.3
A_definingEnd_connectorEnd [Association]............................................................................ 232
11.9.4
A_endType_association [Association]......................................................................................232
11.9.5
11.9.6
A_end_connector [Association]................................................................................................232
A_end_role [Association]......................................................................................................... 232
11.9.7
A_extension_metaclass [Association]...................................................................................... 233
11.9.8
A_memberEnd_association [Association]................................................................................ 233
11.9.9
11.9.10
A_navigableOwnedEnd_association [Association].................................................................. 233
A_nestedClassifier_nestingClass [Association]....................................................................... 233
11.9.11
A_ownedAttribute_class [Association]..................................................................................... 234
11.9.12
A_ownedAttribute_structuredClassifier [Association]............................................................... 234
11.9.13
11.9.14
A_ownedConnector_structuredClassifier [Association]............................................................234
A_ownedEnd_owningAssociation [Association].......................................................................234
11.9.15
A_ownedOperation_class [Association]................................................................................... 235
11.9.16
A_ownedPort_encapsulatedClassifier [Association]................................................................ 235
11.9.17
11.9.18
A_ownedReception_class [Association].................................................................................. 235
A_packagedElement_component [Association]....................................................................... 235
11.9.19
A_partWithPort_connectorEnd [Association]........................................................................... 235
11.9.20
A_part_structuredClassifier [Association]................................................................................ 236
11.9.21
11.9.22
A_protocol_port [Association].................................................................................................. 236
A_provided_component [Association]...................................................................................... 236
11.9.23
A_provided_port [Association]................................................................................................. 236
11.9.24
A_realization_abstraction_component [Association]................................................................ 236
11.9.25
11.9.26
A_realizingClassifier_componentRealization [Association]...................................................... 237
A_redefinedConnector_connector [Association]...................................................................... 237
11.9.27

xiv

Unified Modeling Language 2.5

11.9.28
11.9.29
11.9.30
11.9.31
11.9.32
11.9.33
11.9.34
11.9.35

A_redefinedPort_port [Association]..........................................................................................237
A_required_component [Association]...................................................................................... 237
A_required_port [Association].................................................................................................. 237
A_roleBinding_collaborationUse [Association].........................................................................238
A_role_structuredClassifier [Association].................................................................................238
A_superClass_class [Association]........................................................................................... 238
A_type_collaborationUse [Association].................................................................................... 238
A_type_connector [Association]............................................................................................... 238
12 Packages..................................................................................................................... 239
12.1 Summary......................................................................................................................... 239
12.2 Packages......................................................................................................................... 239
Summary................................................................................................................................. 239
12.2.1
12.2.2
Abstract Syntax........................................................................................................................ 239
Semantics................................................................................................................................ 239
12.2.3
Notation................................................................................................................................... 246
12.2.4
12.2.5
Examples................................................................................................................................. 247
12.3 Profiles............................................................................................................................ 250
Summary................................................................................................................................. 250
12.3.1
Abstract Syntax........................................................................................................................ 251
12.3.2
Semantics................................................................................................................................ 251
12.3.3
12.3.4
Notation................................................................................................................................... 260
12.3.5
Examples................................................................................................................................. 262
12.4 Classifier Descriptions..................................................................................................... 271
12.4.1
Extension [Class]..................................................................................................................... 271
ExtensionEnd [Class]............................................................................................................... 272
12.4.2
Image [Class]........................................................................................................................... 273
12.4.3
Model [Class]........................................................................................................................... 273
12.4.4
12.4.5
Package [Class]....................................................................................................................... 274
PackageMerge [Class]............................................................................................................. 276
12.4.6
Profile [Class]........................................................................................................................... 276
12.4.7
ProfileApplication [Class]......................................................................................................... 277
12.4.8
12.4.9
Stereotype [Class].................................................................................................................... 278
12.5 Association Descriptions..................................................................................................279
A_appliedProfile_profileApplication [Association].................................................................... 279
12.5.1
A_icon_stereotype [Association].............................................................................................. 279
12.5.2
12.5.3
A_mergedPackage_packageMerge [Association]....................................................................279
A_metaclassReference_profile [Association]........................................................................... 280
12.5.4
A_metamodelReference_profile [Association]......................................................................... 280
12.5.5
A_nestedPackage_nestingPackage [Association]................................................................... 280
12.5.6
12.5.7
A_ownedEnd_extension [Association]..................................................................................... 280
A_ownedStereotype_owningPackage [Association]................................................................ 280
12.5.8
A_ownedType_package [Association]..................................................................................... 281
12.5.9
A_packageMerge_receivingPackage [Association]................................................................. 281
12.5.10
12.5.11
A_packagedElement_owningPackage [Association]............................................................... 281
A_profileApplication_applyingPackage [Association]............................................................... 281
12.5.12
A_profile_stereotype [Association]........................................................................................... 282
12.5.13
12.5.14
A_type_extensionEnd [Association]......................................................................................... 282
13 Common Behavior.......................................................................................................283

Unified Modeling Language 2.5

xv

13.1 Summary......................................................................................................................... 283
13.2 Behaviors........................................................................................................................ 283
Summary................................................................................................................................. 283
13.2.1
Abstract Syntax........................................................................................................................ 284
13.2.2
Semantics................................................................................................................................ 284
13.2.3
13.2.4
Notation................................................................................................................................... 288
13.2.5
Examples................................................................................................................................. 288
13.3 Events............................................................................................................................. 288
Summary................................................................................................................................. 288
13.3.1
13.3.2
Abstract Syntax........................................................................................................................ 289
Semantics................................................................................................................................ 289
13.3.3
Notation................................................................................................................................... 291
13.3.4
13.3.5
Examples................................................................................................................................. 292
13.4 Classifier Descriptions..................................................................................................... 292
AnyReceiveEvent [Class]......................................................................................................... 292
13.4.1
Behavior [Abstract Class]......................................................................................................... 292
13.4.2
13.4.3
CallEvent [Class]...................................................................................................................... 295
ChangeEvent [Class]............................................................................................................... 295
13.4.4
Event [Abstract Class].............................................................................................................. 295
13.4.5
FunctionBehavior [Class]......................................................................................................... 296
13.4.6
13.4.7
MessageEvent [Abstract Class]............................................................................................... 296
OpaqueBehavior [Class].......................................................................................................... 297
13.4.8
SignalEvent [Class].................................................................................................................. 297
13.4.9
TimeEvent [Class].................................................................................................................... 297
13.4.10
13.4.11
Trigger [Class].......................................................................................................................... 298
13.5 Association Descriptions..................................................................................................299
A_changeExpression_changeEvent [Association]................................................................... 299
13.5.1
A_context_behavior [Association]............................................................................................ 299
13.5.2
13.5.3
A_event_trigger [Association].................................................................................................. 299
A_operation_callEvent [Association]........................................................................................ 299
13.5.4
A_ownedParameterSet_behavior [Association]....................................................................... 299
13.5.5
A_ownedParameter_behavior [Association]............................................................................ 300
13.5.6
13.5.7
A_port_trigger [Association]..................................................................................................... 300
A_postcondition_behavior [Association].................................................................................. 300
13.5.8
A_precondition_behavior [Association].................................................................................... 300
13.5.9
A_redefinedBehavior_behavior [Association].......................................................................... 300
13.5.10
13.5.11
A_signal_signalEvent [Association]......................................................................................... 301
A_when_timeEvent [Association]............................................................................................. 301
13.5.12
14 StateMachines............................................................................................................. 303
14.1 Summary......................................................................................................................... 303
14.2 Behavior StateMachines.................................................................................................. 303
Summary................................................................................................................................. 303
14.2.1
14.2.2
Abstract Syntax........................................................................................................................ 304
Semantics................................................................................................................................ 304
14.2.3
Notation................................................................................................................................... 317
14.2.4
14.2.5
Examples................................................................................................................................. 333
14.3 StateMachine Redefinition............................................................................................... 334
Summary................................................................................................................................. 334
14.3.1

xvi

Unified Modeling Language 2.5

Abstract Syntax........................................................................................................................ 335
14.3.2
Semantics................................................................................................................................ 335
14.3.3
Notation................................................................................................................................... 336
14.3.4
14.3.5
Examples................................................................................................................................. 336
14.4 ProtocolStateMachines.................................................................................................... 338
14.4.1
Summary................................................................................................................................. 338
Abstract Syntax ....................................................................................................................... 339
14.4.2
Semantics................................................................................................................................ 339
14.4.3
14.4.4
Notation................................................................................................................................... 342
14.5 Classifier Descriptions..................................................................................................... 343
ConnectionPointReference [Class].......................................................................................... 343
14.5.1
FinalState [Class]..................................................................................................................... 344
14.5.2
ProtocolConformance [Class].................................................................................................. 345
14.5.3
14.5.4
ProtocolStateMachine [Class].................................................................................................. 345
ProtocolTransition [Class]........................................................................................................ 346
14.5.5
Pseudostate [Class]................................................................................................................. 347
14.5.6
PseudostateKind [Enumeration]...............................................................................................349
14.5.7
14.5.8
Region [Class].......................................................................................................................... 350
State [Class]............................................................................................................................ 352
14.5.9
StateMachine [Class]............................................................................................................... 355
14.5.10
Transition [Class]..................................................................................................................... 357
14.5.11
14.5.12
TransitionKind [Enumeration]................................................................................................... 360
14.5.13
Vertex [Abstract Class]............................................................................................................. 360
14.6 Association Descriptions..................................................................................................362
14.6.1
A_conformance_specificMachine [Association]....................................................................... 362
A_connectionPoint_state [Association].................................................................................... 362
14.6.2
A_connectionPoint_stateMachine [Association]...................................................................... 362
14.6.3
A_connection_state [Association]............................................................................................ 363
14.6.4
14.6.5
A_deferrableTrigger_state [Association].................................................................................. 363
A_doActivity_state [Association].............................................................................................. 363
14.6.6
A_effect_transition [Association].............................................................................................. 363
14.6.7
A_entry_connectionPointReference [Association]................................................................... 363
14.6.8
14.6.9
A_entry_state [Association]..................................................................................................... 364
A_exit_connectionPointReference [Association]......................................................................364
14.6.10
A_exit_state [Association]........................................................................................................ 364
14.6.11
A_extendedRegion_region [Association]................................................................................. 364
14.6.12
14.6.13
A_extendedStateMachine_stateMachine [Association]........................................................... 364
A_generalMachine_protocolConformance [Association]..........................................................365
14.6.14
A_guard_transition [Association]..............................................................................................365
14.6.15
A_incoming_target_vertex [Association].................................................................................. 365
14.6.16
14.6.17
A_outgoing_source_vertex [Association]................................................................................. 365
A_postCondition_owningTransition [Association].................................................................... 365
14.6.18
A_preCondition_protocolTransition [Association].....................................................................366
14.6.19
A_redefinedState_state [Association]...................................................................................... 366
14.6.20
14.6.21
A_redefinedTransition_transition [Association]........................................................................ 366
A_redefinitionContext_region [Association]............................................................................. 366
14.6.22
A_redefinitionContext_state [Association]................................................................................367
14.6.23
A_redefinitionContext_transition [Association]......................................................................... 367
14.6.24
14.6.25
A_referred_protocolTransition [Association]............................................................................ 367
A_region_state [Association]................................................................................................... 367
14.6.26

Unified Modeling Language 2.5

xvii

14.6.27
14.6.28
14.6.29
14.6.30
14.6.31
14.6.32

A_region_stateMachine [Association]...................................................................................... 368
A_stateInvariant_owningState [Association]............................................................................ 368
A_submachineState_submachine [Association]...................................................................... 368
A_subvertex_container [Association]....................................................................................... 368
A_transition_container [Association]........................................................................................ 368
A_trigger_transition [Association].............................................................................................369
15 Activities.......................................................................................................................371
15.1 Summary......................................................................................................................... 371
15.2 Activities.......................................................................................................................... 371
Summary................................................................................................................................. 371
15.2.1
Abstract Syntax........................................................................................................................ 372
15.2.2
Semantics................................................................................................................................ 372
15.2.3
15.2.4
Notation................................................................................................................................... 377
15.2.5
Examples................................................................................................................................. 380
15.3 Control Nodes..................................................................................................................385
Summary................................................................................................................................. 385
15.3.1
15.3.2
Abstract Syntax........................................................................................................................ 385
Semantics................................................................................................................................ 385
15.3.3
Notation................................................................................................................................... 388
15.3.4
15.3.5
Examples................................................................................................................................. 390
15.4 Object Nodes................................................................................................................... 394
Summary................................................................................................................................. 394
15.4.1
Abstract Syntax........................................................................................................................ 394
15.4.2
15.4.3
Semantics................................................................................................................................ 395
Notation................................................................................................................................... 397
15.4.4
15.4.5
Examples................................................................................................................................. 399
15.5 Executable Nodes........................................................................................................... 401
15.5.1
Summary................................................................................................................................. 401
Abstract Syntax........................................................................................................................ 401
15.5.2
Semantics................................................................................................................................ 401
15.5.3
15.5.4
Notation................................................................................................................................... 402
15.5.5
Examples................................................................................................................................. 403
15.6 Activity Groups................................................................................................................ 403
Summary................................................................................................................................. 403
15.6.1
15.6.2
Abstract Syntax........................................................................................................................ 404
Semantics................................................................................................................................ 404
15.6.3
Notation................................................................................................................................... 406
15.6.4
15.6.5
Examples................................................................................................................................. 407
15.7 Classifier Descriptions..................................................................................................... 409
Activity [Class].......................................................................................................................... 409
15.7.1
ActivityEdge [Abstract Class]................................................................................................... 411
15.7.2
ActivityFinalNode [Class]......................................................................................................... 412
15.7.3
15.7.4
ActivityGroup [Abstract Class]..................................................................................................412
ActivityNode [Abstract Class]................................................................................................... 413
15.7.5
ActivityParameterNode [Class]................................................................................................ 415
15.7.6
ActivityPartition [Class]............................................................................................................ 416
15.7.7
15.7.8
CentralBufferNode [Class]....................................................................................................... 417
ControlFlow [Class].................................................................................................................. 418
15.7.9

xviii

Unified Modeling Language 2.5

ControlNode [Abstract Class]................................................................................................... 418
15.7.10
DataStoreNode [Class]............................................................................................................ 418
15.7.11
DecisionNode [Class]............................................................................................................... 419
15.7.12
ExceptionHandler [Class]......................................................................................................... 420
15.7.13
ExecutableNode [Abstract Class].............................................................................................422
15.7.14
FinalNode [Abstract Class]...................................................................................................... 422
15.7.15
FlowFinalNode [Class]............................................................................................................. 422
15.7.16
ForkNode [Class]..................................................................................................................... 423
15.7.17
InitialNode [Class].................................................................................................................... 423
15.7.18
InterruptibleActivityRegion [Class]........................................................................................... 424
15.7.19
15.7.20
JoinNode [Class]...................................................................................................................... 424
15.7.21 MergeNode [Class].................................................................................................................. 425
15.7.22 ObjectFlow [Class]................................................................................................................... 426
15.7.23 ObjectNode [Abstract Class].................................................................................................... 427
15.7.24 ObjectNodeOrderingKind [Enumeration]..................................................................................428
15.7.25
Variable [Class]........................................................................................................................ 429
15.8 Association Descriptions..................................................................................................430
15.8.1
A_containedEdge_inGroup [Association].................................................................................430
A_containedNode_inGroup [Association]................................................................................ 430
15.8.2
A_decisionInputFlow_decisionNode [Association]................................................................... 430
15.8.3
A_decisionInput_decisionNode [Association].......................................................................... 430
15.8.4
15.8.5
A_edge_activity [Association].................................................................................................. 430
A_edge_inPartition [Association]............................................................................................. 431
15.8.6
A_exceptionInput_exceptionHandler [Association].................................................................. 431
15.8.7
A_exceptionType_exceptionHandler [Association].................................................................. 431
15.8.8
15.8.9
A_group_inActivity [Association].............................................................................................. 431
A_guard_activityEdge [Association]......................................................................................... 432
15.8.10
A_handlerBody_exceptionHandler [Association]..................................................................... 432
15.8.11
A_handler_protectedNode [Association].................................................................................. 432
15.8.12
15.8.13
A_inInterruptibleRegion_node [Association]............................................................................ 432
A_inPartition_node [Association]............................................................................................. 432
15.8.14
A_inState_objectNode [Association]........................................................................................ 433
15.8.15
A_incoming_target_node [Association].................................................................................... 433
15.8.16
15.8.17
A_interruptingEdge_interrupts [Association]............................................................................ 433
A_joinSpec_joinNode [Association]......................................................................................... 433
15.8.18
A_node_activity [Association].................................................................................................. 433
15.8.19
A_outgoing_source_node [Association]................................................................................... 434
15.8.20
15.8.21
A_parameter_activityParameterNode [Association]................................................................. 434
A_partition_activity [Association]..............................................................................................434
15.8.22
A_redefinedEdge_activityEdge [Association]...........................................................................434
15.8.23
A_redefinedNode_activityNode [Association].......................................................................... 435
15.8.24
15.8.25
A_represents_activityPartition [Association]............................................................................ 435
A_selection_objectFlow [Association]...................................................................................... 435
15.8.26
A_selection_objectNode [Association]..................................................................................... 435
15.8.27
A_structuredNode_activity [Association].................................................................................. 435
15.8.28
15.8.29
A_subgroup_superGroup [Association]................................................................................... 436
A_subpartition_superPartition [Association].............................................................................436
15.8.30
A_transformation_objectFlow [Association]............................................................................. 436
15.8.31
A_upperBound_objectNode [Association]................................................................................436
15.8.32
15.8.33
A_variable_activityScope [Association]....................................................................................436
A_weight_activityEdge [Association]........................................................................................437
15.8.34

Unified Modeling Language 2.5

xix

16 Actions......................................................................................................................... 439
16.1 Summary......................................................................................................................... 439
16.2 Actions............................................................................................................................. 440
Summary................................................................................................................................. 440
16.2.1
Abstract Syntax........................................................................................................................ 440
16.2.2
16.2.3
Semantics................................................................................................................................ 441
Notation................................................................................................................................... 444
16.2.4
16.2.5
Examples................................................................................................................................. 445
Invocation Actions............................................................................................................448
16.3
Summary................................................................................................................................. 448
16.3.1
Abstract Syntax........................................................................................................................ 448
16.3.2
Semantics................................................................................................................................ 448
16.3.3
16.3.4
Notation................................................................................................................................... 451
16.3.5
Examples................................................................................................................................. 454
16.4 Object Actions..................................................................................................................456
Summary................................................................................................................................. 456
16.4.1
16.4.2
Abstract Syntax........................................................................................................................ 456
Semantics................................................................................................................................ 456
16.4.3
Notation................................................................................................................................... 458
16.4.4
16.4.5
Examples................................................................................................................................. 458
Link End Data.................................................................................................................. 459
16.5
Summary................................................................................................................................. 459
16.5.1
Abstract Syntax........................................................................................................................ 459
16.5.2
16.5.3
Semantics................................................................................................................................ 459
Notation................................................................................................................................... 460
16.5.4
16.5.5
Examples................................................................................................................................. 460
Link Actions..................................................................................................................... 460
16.6
16.6.1
Summary................................................................................................................................. 460
Abstract Syntax........................................................................................................................ 461
16.6.2
Semantics................................................................................................................................ 461
16.6.3
Notation................................................................................................................................... 463
16.6.4
16.6.5
Examples................................................................................................................................. 463
Link Object Actions.......................................................................................................... 463
16.7
Summary................................................................................................................................. 463
16.7.1
Abstract Syntax........................................................................................................................ 464
16.7.2
16.7.3
Semantics................................................................................................................................ 464
Notation................................................................................................................................... 465
16.7.4
16.7.5
Examples................................................................................................................................. 465
16.8 Structural Feature Actions............................................................................................... 465
Summary................................................................................................................................. 465
16.8.1
Abstract Syntax........................................................................................................................ 465
16.8.2
Semantics................................................................................................................................ 465
16.8.3
16.8.4
Notation................................................................................................................................... 467
16.8.5
Examples................................................................................................................................. 467
16.9 Variable Actions............................................................................................................... 467
Summary................................................................................................................................. 467
16.9.1
16.9.2
Abstract Syntax........................................................................................................................ 468
Semantics................................................................................................................................ 468
16.9.3

xx

Unified Modeling Language 2.5

Notation................................................................................................................................... 469
16.9.4
Examples................................................................................................................................. 470
16.9.5
16.10  Accept Event Actions...................................................................................................... 470
Summary................................................................................................................................. 470
16.10.1
Abstract Syntax........................................................................................................................ 470
16.10.2
16.10.3
Semantics................................................................................................................................ 470
Notation................................................................................................................................... 472
16.10.4
16.10.5
Examples................................................................................................................................. 472
16.11  Structured Actions.......................................................................................................... 473
16.11.1
Summary................................................................................................................................. 473
Abstract Syntax........................................................................................................................ 474
16.11.2
Semantics................................................................................................................................ 474
16.11.3
16.11.4
Notation................................................................................................................................... 478
16.11.5
Examples................................................................................................................................. 478
16.12  Expansion Regions......................................................................................................... 478
Summary................................................................................................................................. 478
16.12.1
16.12.2
Abstract Syntax........................................................................................................................ 478
Semantics................................................................................................................................ 479
16.12.3
Notation................................................................................................................................... 480
16.12.4
16.12.5
Examples................................................................................................................................. 482
16.13  Other Actions.................................................................................................................. 484
Summary................................................................................................................................. 484
16.13.1
Abstract Syntax........................................................................................................................ 484
16.13.2
Semantics................................................................................................................................ 484
16.13.3
16.13.4
Notation................................................................................................................................... 485
16.13.5
Examples................................................................................................................................. 485
16.14 Classifier Descriptions..................................................................................................... 486
16.14.1
AcceptCallAction [Class].......................................................................................................... 486
AcceptEventAction [Class]....................................................................................................... 487
16.14.2
Action [Abstract Class]............................................................................................................. 488
16.14.3
ActionInputPin [Class].............................................................................................................. 490
16.14.4
16.14.5
AddStructuralFeatureValueAction [Class]................................................................................ 490
AddVariableValueAction [Class]............................................................................................... 491
16.14.6
BroadcastSignalAction [Class]................................................................................................. 492
16.14.7
CallAction [Abstract Class]....................................................................................................... 493
16.14.8
16.14.9
CallBehaviorAction [Class]....................................................................................................... 494
16.14.10 CallOperationAction [Class]..................................................................................................... 495
16.14.11 Clause [Class].......................................................................................................................... 496
16.14.12 ClearAssociationAction [Class]................................................................................................ 497
16.14.13 ClearStructuralFeatureAction [Class]....................................................................................... 497
16.14.14 ClearVariableAction [Class]......................................................................................................498
16.14.15 ConditionalNode [Class].......................................................................................................... 498
16.14.16 CreateLinkAction [Class].......................................................................................................... 500
16.14.17 CreateLinkObjectAction [Class]............................................................................................... 500
16.14.18 CreateObjectAction [Class]...................................................................................................... 501
16.14.19 DestroyLinkAction [Class]........................................................................................................ 502
16.14.20 DestroyObjectAction [Class].................................................................................................... 502
16.14.21 ExpansionKind [Enumeration].................................................................................................. 503
16.14.22 ExpansionNode [Class]............................................................................................................ 503

Unified Modeling Language 2.5

xxi

16.14.23 ExpansionRegion [Class]......................................................................................................... 504
16.14.24 InputPin [Class]........................................................................................................................ 504
16.14.25 InvocationAction [Abstract Class].............................................................................................505
16.14.26 LinkAction [Abstract Class]...................................................................................................... 505
16.14.27 LinkEndCreationData [Class]................................................................................................... 506
16.14.28 LinkEndData [Class]................................................................................................................ 507
16.14.29 LinkEndDestructionData [Class].............................................................................................. 508
16.14.30 LoopNode [Class].................................................................................................................... 509
16.14.31 OpaqueAction [Class].............................................................................................................. 512
16.14.32 OutputPin [Class]..................................................................................................................... 513
16.14.33 Pin [Abstract Class].................................................................................................................. 513
16.14.34 QualifierValue [Class]............................................................................................................... 514
16.14.35 RaiseExceptionAction [Class].................................................................................................. 514
16.14.36 ReadExtentAction [Class]........................................................................................................ 515
16.14.37 ReadIsClassifiedObjectAction [Class]...................................................................................... 515
16.14.38 ReadLinkAction [Class]............................................................................................................ 516
16.14.39 ReadLinkObjectEndAction [Class]........................................................................................... 518
16.14.40 ReadLinkObjectEndQualifierAction [Class].............................................................................. 519
16.14.41 ReadSelfAction [Class]............................................................................................................ 520
16.14.42 ReadStructuralFeatureAction [Class]....................................................................................... 521
16.14.43 ReadVariableAction [Class]......................................................................................................521
16.14.44 ReclassifyObjectAction [Class]................................................................................................ 522
16.14.45 ReduceAction [Class]............................................................................................................... 523
16.14.46 RemoveStructuralFeatureValueAction [Class]......................................................................... 524
16.14.47 RemoveVariableValueAction [Class]........................................................................................ 525
16.14.48 ReplyAction [Class].................................................................................................................. 525
16.14.49 SendObjectAction [Class]........................................................................................................ 526
16.14.50 SendSignalAction [Class]......................................................................................................... 527
16.14.51 SequenceNode [Class]............................................................................................................ 528
16.14.52 StartClassifierBehaviorAction [Class].......................................................................................528
16.14.53 StartObjectBehaviorAction [Class]........................................................................................... 529
16.14.54 StructuralFeatureAction [Abstract Class]................................................................................. 530
16.14.55 StructuredActivityNode [Class].................................................................................................531
16.14.56 TestIdentityAction [Class]......................................................................................................... 533
16.14.57 UnmarshallAction [Class]......................................................................................................... 534
16.14.58 ValuePin [Class]....................................................................................................................... 535
16.14.59 ValueSpecificationAction [Class].............................................................................................. 536
16.14.60 VariableAction [Abstract Class]................................................................................................ 536
16.14.61 WriteLinkAction [Abstract Class].............................................................................................. 537
16.14.62 WriteStructuralFeatureAction [Abstract Class]......................................................................... 537
16.14.63 WriteVariableAction [Abstract Class]........................................................................................ 538
16.15 Association Descriptions..................................................................................................539
A_argument_invocationAction [Association]............................................................................ 539
16.15.1
A_association_clearAssociationAction [Association]............................................................... 539
16.15.2
A_behavior_callBehaviorAction [Association].......................................................................... 539
16.15.3
16.15.4
A_bodyOutput_clause [Association]........................................................................................ 540
A_bodyOutput_loopNode [Association]................................................................................... 540
16.15.5
A_bodyPart_loopNode [Association]........................................................................................540
16.15.6
A_body_clause [Association]................................................................................................... 540
16.15.7
16.15.8
A_classifier_createObjectAction [Association]......................................................................... 540
A_classifier_readExtentAction [Association]............................................................................ 541
16.15.9

xxii

Unified Modeling Language 2.5

16.15.10 A_classifier_readIsClassifiedObjectAction [Association]..........................................................541
16.15.11 A_clause_conditionalNode [Association]................................................................................. 541
16.15.12 A_collection_reduceAction [Association]................................................................................. 541
16.15.13 A_context_action [Association]................................................................................................ 541
16.15.14 A_decider_clause [Association]............................................................................................... 542
16.15.15 A_decider_loopNode [Association].......................................................................................... 542
16.15.16 A_destroyAt_linkEndDestructionData [Association]................................................................. 542
16.15.17 A_edge_inStructuredNode [Association]................................................................................. 542
16.15.18 A_endData_createLinkAction [Association]............................................................................. 542
16.15.19 A_endData_destroyLinkAction [Association]........................................................................... 543
16.15.20 A_endData_linkAction [Association]........................................................................................ 543
16.15.21 A_end_linkEndData [Association]............................................................................................ 543
16.15.22 A_end_readLinkObjectEndAction [Association]....................................................................... 543
16.15.23 A_exception_raiseExceptionAction [Association].....................................................................544
16.15.24 A_executableNode_sequenceNode [Association]................................................................... 544
16.15.25 A_first_testIdentityAction [Association].................................................................................... 544
16.15.26 A_fromAction_actionInputPin [Association]............................................................................. 544
16.15.27 A_inputElement_regionAsInput [Association].......................................................................... 544
16.15.28 A_inputValue_linkAction [Association]..................................................................................... 545
16.15.29 A_inputValue_opaqueAction [Association]............................................................................... 545
16.15.30 A_input_action [Association].................................................................................................... 545
16.15.31 A_insertAt_addStructuralFeatureValueAction [Association].....................................................545
16.15.32 A_insertAt_addVariableValueAction [Association]................................................................... 545
16.15.33 A_insertAt_linkEndCreationData [Association]........................................................................ 546
16.15.34 A_localPostcondition_action [Association]............................................................................... 546
16.15.35 A_localPrecondition_action [Association]................................................................................ 546
16.15.36 A_loopVariableInput_loopNode [Association].......................................................................... 546
16.15.37 A_loopVariable_loopNode [Association].................................................................................. 546
16.15.38 A_newClassifier_reclassifyObjectAction [Association]............................................................. 547
16.15.39 A_node_inStructuredNode [Association]................................................................................. 547
16.15.40 A_object_clearAssociationAction [Association]........................................................................ 547
16.15.41 A_object_readIsClassifiedObjectAction [Association].............................................................. 547
16.15.42 A_object_readLinkObjectEndAction [Association]................................................................... 547
16.15.43 A_object_readLinkObjectEndQualifierAction [Association]...................................................... 548
16.15.44 A_object_reclassifyObjectAction [Association]........................................................................ 548
16.15.45 A_object_startClassifierBehaviorAction [Association].............................................................. 548
16.15.46 A_object_startObjectBehaviorAction [Association].................................................................. 548
16.15.47 A_object_structuralFeatureAction [Association].......................................................................548
16.15.48 A_object_unmarshallAction [Association]................................................................................ 549
16.15.49 A_oldClassifier_reclassifyObjectAction [Association]...............................................................549
16.15.50 A_onPort_invocationAction [Association].................................................................................549
16.15.51 A_operation_callOperationAction [Association]....................................................................... 549
16.15.52 A_outputElement_regionAsOutput [Association]..................................................................... 549
16.15.53 A_outputValue_opaqueAction [Association].............................................................................550
16.15.54 A_output_action [Association].................................................................................................. 550
16.15.55 A_predecessorClause_successorClause [Association]........................................................... 550
16.15.56 A_qualifier_linkEndData [Association]..................................................................................... 550
16.15.57 A_qualifier_qualifierValue [Association]................................................................................... 550
16.15.58 A_qualifier_readLinkObjectEndQualifierAction [Association]................................................... 551
16.15.59 A_reducer_reduceAction [Association].................................................................................... 551
16.15.60 A_removeAt_removeStructuralFeatureValueAction [Association]............................................551

Unified Modeling Language 2.5

xxiii

16.15.61 A_removeAt_removeVariableValueAction [Association].......................................................... 551
16.15.62 A_replyToCall_replyAction [Association].................................................................................. 551
16.15.63 A_replyValue_replyAction [Association]................................................................................... 552
16.15.64 A_request_sendObjectAction [Association]............................................................................. 552
16.15.65 A_result_acceptEventAction [Association]............................................................................... 552
16.15.66 A_result_callAction [Association]............................................................................................. 552
16.15.67 A_result_clearStructuralFeatureAction [Association]............................................................... 552
16.15.68 A_result_conditionalNode [Association]................................................................................... 553
16.15.69 A_result_createLinkObjectAction [Association]........................................................................ 553
16.15.70 A_result_createObjectAction [Association].............................................................................. 553
16.15.71 A_result_loopNode [Association]............................................................................................. 553
16.15.72 A_result_readExtentAction [Association]................................................................................. 554
16.15.73 A_result_readIsClassifiedObjectAction [Association]............................................................... 554
16.15.74 A_result_readLinkAction [Association]..................................................................................... 554
16.15.75 A_result_readLinkObjectEndAction [Association].................................................................... 554
16.15.76 A_result_readLinkObjectEndQualifierAction [Association]....................................................... 554
16.15.77 A_result_readSelfAction [Association]..................................................................................... 555
16.15.78 A_result_readStructuralFeatureAction [Association]................................................................ 555
16.15.79 A_result_readVariableAction [Association].............................................................................. 555
16.15.80 A_result_reduceAction [Association]........................................................................................555
16.15.81 A_result_testIdentityAction [Association]................................................................................. 555
16.15.82 A_result_unmarshallAction [Association]................................................................................. 556
16.15.83 A_result_valueSpecificationAction [Association]......................................................................556
16.15.84 A_result_writeStructuralFeatureAction [Association]............................................................... 556
16.15.85 A_returnInformation_acceptCallAction [Association]............................................................... 556
16.15.86 A_returnInformation_replyAction [Association]........................................................................ 556
16.15.87 A_second_testIdentityAction [Association].............................................................................. 557
16.15.88 A_setupPart_loopNode [Association].......................................................................................557
16.15.89 A_signal_broadcastSignalAction [Association]........................................................................ 557
16.15.90 A_signal_sendSignalAction [Association]................................................................................ 557
16.15.91 A_structuralFeature_structuralFeatureAction [Association]..................................................... 557
16.15.92 A_structuredNodeInput_structuredActivityNode [Association]................................................. 558
16.15.93 A_structuredNodeOutput_structuredActivityNode [Association].............................................. 558
16.15.94 A_target_callOperationAction [Association]............................................................................. 558
16.15.95 A_target_destroyObjectAction [Association]............................................................................ 558
16.15.96 A_target_sendObjectAction [Association]................................................................................ 558
16.15.97 A_target_sendSignalAction [Association]................................................................................ 559
16.15.98 A_test_clause [Association]..................................................................................................... 559
16.15.99 A_test_loopNode [Association]................................................................................................ 559
16.15.100 A_trigger_acceptEventAction [Association]............................................................................. 559
16.15.101 A_unmarshallType_unmarshallAction [Association].................................................................559
16.15.102 A_value_linkEndData [Association]......................................................................................... 560
16.15.103 A_value_qualifierValue [Association]....................................................................................... 560
16.15.104 A_value_valuePin [Association]............................................................................................... 560
16.15.105 A_value_valueSpecificationAction [Association]...................................................................... 560
16.15.106 A_value_writeStructuralFeatureAction [Association]................................................................560
16.15.107 A_value_writeVariableAction [Association].............................................................................. 561
16.15.108 A_variable_scope [Association]............................................................................................... 561
16.15.109 A_variable_variableAction [Association].................................................................................. 561
17 Interactions.................................................................................................................. 563

xxiv

Unified Modeling Language 2.5

17.1 Summary......................................................................................................................... 563
17.1.1
Overview.................................................................................................................................. 563
Basic trace model.................................................................................................................... 563
17.1.2
Partial ordering constraints on valid and invalid traces............................................................ 564
17.1.3
17.1.4
Interaction Diagram Variants.................................................................................................... 564
Interactions...................................................................................................................... 564
17.2
Summary................................................................................................................................. 564
17.2.1
Abstract Syntax........................................................................................................................ 565
17.2.2
Semantics................................................................................................................................ 565
17.2.3
17.2.4
Notation................................................................................................................................... 566
17.2.5
Examples................................................................................................................................. 568
Lifelines........................................................................................................................... 569
17.3
Summary................................................................................................................................. 569
17.3.1
17.3.2
Abstract Syntax........................................................................................................................ 570
Semantics................................................................................................................................ 570
17.3.3
Notation................................................................................................................................... 570
17.3.4
17.3.5
Examples................................................................................................................................. 571
17.4 Messages........................................................................................................................ 571
Summary................................................................................................................................. 571
17.4.1
Abstract Syntax........................................................................................................................ 572
17.4.2
17.4.3
Semantics................................................................................................................................ 572
Notation................................................................................................................................... 574
17.4.4
17.4.5
Examples................................................................................................................................. 576
17.5 Occurrences.................................................................................................................... 577
17.5.1
Summary................................................................................................................................. 577
Abstract Syntax........................................................................................................................ 578
17.5.2
Semantics................................................................................................................................ 578
17.5.3
Notation................................................................................................................................... 579
17.5.4
17.5.5
Examples................................................................................................................................. 579
Fragments....................................................................................................................... 579
17.6
Summary................................................................................................................................. 579
17.6.1
17.6.2
Abstract Syntax........................................................................................................................ 580
Semantics................................................................................................................................ 580
17.6.3
Notation................................................................................................................................... 583
17.6.4
17.6.5
Examples................................................................................................................................. 584
Interaction Uses...............................................................................................................588
17.7
Summary................................................................................................................................. 588
17.7.1
Abstract Syntax........................................................................................................................ 589
17.7.2
Semantics................................................................................................................................ 589
17.7.3
17.7.4
Notation................................................................................................................................... 589
17.7.5
Examples................................................................................................................................. 590
17.8 Sequence Diagrams........................................................................................................ 593
17.8.1
Sequence Diagram Notation.................................................................................................... 593
17.8.2
Example Sequence Diagram................................................................................................... 597
17.9 Communication Diagrams............................................................................................... 597
Communication Diagram Notation........................................................................................... 597
17.9.1
17.9.2
Example Communication Diagram...........................................................................................599
17.10 Interaction Overview Diagrams........................................................................................ 599

Unified Modeling Language 2.5

xxv

Interaction Overview Diagram Notation................................................................................... 599
17.10.1
Examples of Interaction Overview Diagrams........................................................................... 601
17.10.2
17.11 Timing Diagrams..............................................................................................................601
Timing Diagram Notation......................................................................................................... 602
17.11.1
17.11.2
Examples of Timing Diagrams................................................................................................. 603
17.12 Classifier Descriptions..................................................................................................... 604
ActionExecutionSpecification [Class]....................................................................................... 604
17.12.1
BehaviorExecutionSpecification [Class]................................................................................... 605
17.12.2
CombinedFragment [Class]..................................................................................................... 605
17.12.3
17.12.4
ConsiderIgnoreFragment [Class]............................................................................................. 606
Continuation [Class]................................................................................................................. 607
17.12.5
DestructionOccurrenceSpecification [Class]............................................................................ 608
17.12.6
17.12.7
ExecutionOccurrenceSpecification [Class].............................................................................. 609
17.12.8
ExecutionSpecification [Abstract Class]................................................................................... 609
17.12.9 Gate [Class]............................................................................................................................. 610
17.12.10 GeneralOrdering [Class].......................................................................................................... 613
17.12.11 Interaction [Class].................................................................................................................... 613
17.12.12 InteractionConstraint [Class].................................................................................................... 614
17.12.13 InteractionFragment [Abstract Class]....................................................................................... 615
17.12.14 InteractionOperand [Class]...................................................................................................... 616
17.12.15 InteractionOperatorKind [Enumeration]....................................................................................616
17.12.16 InteractionUse [Class].............................................................................................................. 618
17.12.17 Lifeline [Class].......................................................................................................................... 620
17.12.18 Message [Class]...................................................................................................................... 621
17.12.19 MessageEnd [Abstract Class].................................................................................................. 624
17.12.20 MessageKind [Enumeration].................................................................................................... 625
17.12.21 MessageOccurrenceSpecification [Class]................................................................................626
17.12.22 MessageSort [Enumeration].................................................................................................... 626
17.12.23 OccurrenceSpecification [Class].............................................................................................. 627
17.12.24 PartDecomposition [Class]....................................................................................................... 627
17.12.25 StateInvariant [Class]............................................................................................................... 628
17.13 Association Descriptions..................................................................................................629
17.13.1
A_action_actionExecutionSpecification [Association].............................................................. 629
A_action_interaction [Association]........................................................................................... 629
17.13.2
A_actualGate_interactionUse [Association]............................................................................. 629
17.13.3
A_argument_interactionUse [Association]............................................................................... 629
17.13.4
17.13.5
A_argument_message [Association]........................................................................................629
A_before_toAfter [Association]................................................................................................ 630
17.13.6
A_behavior_behaviorExecutionSpecification [Association]...................................................... 630
17.13.7
17.13.8
A_cfragmentGate_combinedFragment [Association]............................................................... 630
17.13.9
A_connector_message [Association]....................................................................................... 630
17.13.10 A_covered_coveredBy [Association]........................................................................................630
17.13.11 A_covered_events [Association].............................................................................................. 631
17.13.12 A_covered_stateInvariant [Association]................................................................................... 631
17.13.13 A_decomposedAs_lifeline [Association].................................................................................. 631
17.13.14 A_execution_executionOccurrenceSpecification [Association]................................................ 631
17.13.15 A_finish_executionSpecification [Association]......................................................................... 631
17.13.16 A_formalGate_interaction [Association]................................................................................... 632
17.13.17 A_fragment_enclosingInteraction [Association]....................................................................... 632
17.13.18 A_fragment_enclosingOperand [Association].......................................................................... 632

xxvi

Unified Modeling Language 2.5

17.13.19 A_generalOrdering_interactionFragment [Association]............................................................632
17.13.20 A_guard_interactionOperand [Association]..............................................................................633
17.13.21 A_invariant_stateInvariant [Association].................................................................................. 633
17.13.22 A_lifeline_interaction [Association]...........................................................................................633
17.13.23 A_maxint_interactionConstraint [Association].......................................................................... 633
17.13.24 A_message_considerIgnoreFragment [Association]................................................................ 633
17.13.25 A_message_interaction [Association]...................................................................................... 634
17.13.26 A_message_messageEnd [Association].................................................................................. 634
17.13.27 A_minint_interactionConstraint [Association]........................................................................... 634
17.13.28 A_operand_combinedFragment [Association]......................................................................... 634
17.13.29 A_receiveEvent_endMessage [Association]............................................................................ 634
17.13.30 A_refersTo_interactionUse [Association]................................................................................. 635
17.13.31 A_represents_lifeline [Association].......................................................................................... 635
17.13.32 A_returnValueRecipient_interactionUse [Association]............................................................. 635
17.13.33 A_returnValue_interactionUse [Association]............................................................................ 635
17.13.34 A_selector_lifeline [Association]...............................................................................................635
17.13.35 A_sendEvent_endMessage [Association]................................................................................ 635
17.13.36 A_signature_message [Association]........................................................................................ 636
17.13.37 A_start_executionSpecification [Association]...........................................................................636
17.13.38 A_toBefore_after [Association]................................................................................................ 636
18 UseCases.................................................................................................................... 637
18.1 Use Cases....................................................................................................................... 637
Summary................................................................................................................................. 637
18.1.1
Abstract Syntax........................................................................................................................ 637
18.1.2
18.1.3
Semantics................................................................................................................................ 637
Notation................................................................................................................................... 639
18.1.4
18.1.5
Examples................................................................................................................................. 641
18.2 Classifier Descriptions..................................................................................................... 645
18.2.1
Actor [Class]............................................................................................................................ 645
Extend [Class].......................................................................................................................... 645
18.2.2
ExtensionPoint [Class]............................................................................................................. 646
18.2.3
18.2.4
Include [Class]......................................................................................................................... 646
18.2.5
UseCase [Class]...................................................................................................................... 647
18.3 Association Descriptions..................................................................................................648
A_addition_include [Association]............................................................................................. 648
18.3.1
18.3.2
A_condition_extend [Association]............................................................................................ 648
A_extend_extension [Association]........................................................................................... 649
18.3.3
A_extendedCase_extend [Association]................................................................................... 649
18.3.4
A_extensionLocation_extension [Association]......................................................................... 649
18.3.5
18.3.6
A_extensionPoint_useCase [Association]................................................................................649
A_include_includingCase [Association]................................................................................... 649
18.3.7
18.3.8
A_subject_useCase [Association]............................................................................................ 650
19 Deployments................................................................................................................651
19.1 Summary......................................................................................................................... 651
19.2 Deployments................................................................................................................... 651
Summary................................................................................................................................. 651
19.2.1
19.2.2
Abstract Syntax........................................................................................................................ 651
Semantics................................................................................................................................ 651
19.2.3

Unified Modeling Language 2.5

xxvii

Notation................................................................................................................................... 652
19.2.4
Examples................................................................................................................................. 652
19.2.5
19.3 Artifacts........................................................................................................................... 654
Summary................................................................................................................................. 654
19.3.1
Abstract Syntax........................................................................................................................ 654
19.3.2
19.3.3
Semantics................................................................................................................................ 654
Notation................................................................................................................................... 655
19.3.4
19.3.5
Examples................................................................................................................................. 655
19.4 Nodes.............................................................................................................................. 655
19.4.1
Summary................................................................................................................................. 655
Abstract Syntax........................................................................................................................ 656
19.4.2
Semantics................................................................................................................................ 656
19.4.3
19.4.4
Notation................................................................................................................................... 656
19.4.5
Examples................................................................................................................................. 657
19.5 Classifier Descriptions..................................................................................................... 658
Artifact [Class].......................................................................................................................... 658
19.5.1
19.5.2
CommunicationPath [Class]..................................................................................................... 659
DeployedArtifact [Abstract Class].............................................................................................659
19.5.3
Deployment [Class].................................................................................................................. 659
19.5.4
DeploymentSpecification [Class]..............................................................................................660
19.5.5
19.5.6
DeploymentTarget [Abstract Class].......................................................................................... 661
Device [Class].......................................................................................................................... 661
19.5.7
ExecutionEnvironment [Class]................................................................................................. 662
19.5.8
Manifestation [Class]................................................................................................................ 662
19.5.9
19.5.10
Node [Class]............................................................................................................................ 662
19.6 Association Descriptions..................................................................................................663
A_configuration_deployment [Association].............................................................................. 663
19.6.1
A_deployedArtifact_deploymentForArtifact [Association].........................................................663
19.6.2
19.6.3
A_deployedElement_deploymentTarget [Association]............................................................. 663
A_deployment_location [Association]...................................................................................... 663
19.6.4
A_manifestation_artifact [Association]..................................................................................... 664
19.6.5
A_nestedArtifact_artifact [Association].....................................................................................664
19.6.6
19.6.7
A_nestedNode_node [Association].......................................................................................... 664
A_ownedAttribute_artifact [Association]...................................................................................664
19.6.8
A_ownedOperation_artifact [Association]................................................................................ 664
19.6.9
19.6.10
A_utilizedElement_manifestation [Association]........................................................................ 665
20 InformationFlows......................................................................................................... 667
Information Flows............................................................................................................ 667
20.1
Summary................................................................................................................................. 667
20.1.1
20.1.2
Abstract Syntax........................................................................................................................ 667
Semantics................................................................................................................................ 667
20.1.3
Notation................................................................................................................................... 668
20.1.4
20.1.5
Examples................................................................................................................................. 669
20.2 Classifier Descriptions..................................................................................................... 670
InformationFlow [Class]........................................................................................................... 670
20.2.1
20.2.2
InformationItem [Class]............................................................................................................ 671
20.3 Association Descriptions..................................................................................................672
A_conveyed_conveyingFlow [Association].............................................................................. 672
20.3.1

xxviii

Unified Modeling Language 2.5

20.3.2
20.3.3
20.3.4
20.3.5
20.3.6
20.3.7
20.3.8

A_informationSource_informationFlow [Association]............................................................... 672
A_informationTarget_informationFlow [Association]................................................................ 673
A_realization_abstraction_flow [Association]........................................................................... 673
A_realizingActivityEdge_informationFlow [Association]........................................................... 673
A_realizingConnector_informationFlow [Association].............................................................. 673
A_realizingMessage_informationFlow [Association]................................................................ 673
A_represented_representation [Association]........................................................................... 674
21 Primitive Types............................................................................................................ 675
21.1 Summary......................................................................................................................... 675
21.2 Semantics........................................................................................................................ 675
21.3 Notation........................................................................................................................... 675
21.4 Examples......................................................................................................................... 675
22 Standard Profile........................................................................................................... 677
22.1 Summary......................................................................................................................... 677
22.2 Model...............................................................................................................................677
22.3 Standard Stereotypes...................................................................................................... 677
Annex A: Diagrams............................................................................................................ 681
Annex B: UML Diagram Interchange................................................................................. 685
Summary......................................................................................................................... 685
B.1
Generic............................................................................................................................ 686
B.2
B.2.1
Summary................................................................................................................................. 686
UML Diagrams and Diagram Elements.................................................................................... 686
B.2.2
UML Shapes and Edges.......................................................................................................... 687
B.2.3
Labels...................................................................................................................................... 687
B.2.4
B.2.5
Compartmentable Shapes....................................................................................................... 689
Stereotype Applications........................................................................................................... 689
B.2.6
B.2.7
UML Styles............................................................................................................................... 691
Structure.......................................................................................................................... 691
B.3
Summary................................................................................................................................. 691
B.3.1
Structure Diagrams.................................................................................................................. 691
B.3.2
Classifier Shapes..................................................................................................................... 693
B.3.3
B.3.4
Multiplicity and Association End Labels................................................................................... 694
B.3.5
Association, Connector, and Link Shapes................................................................................695
Behavior.......................................................................................................................... 695
B.4
Summary................................................................................................................................. 695
B.4.1
B.4.2
Behavior Diagrams.................................................................................................................. 695
Activity Diagram Labels........................................................................................................... 699
B.4.3
State Shapes........................................................................................................................... 700
B.4.4
B.4.5
Interaction Tables..................................................................................................................... 701
Information Flows............................................................................................................ 701
B.5
UML Notations and UML DI Representations.................................................................. 702
B.6
Classifier Descriptions..................................................................................................... 722
B.7
B.7.1
UMLActivityDiagram [Class].................................................................................................... 722
UMLAssociationEndLabel [Class]............................................................................................ 722
B.7.2

Unified Modeling Language 2.5

xxix

B.7.3
B.7.4
B.7.5
B.7.6
B.7.7
B.7.8
B.7.9
B.7.10
B.7.11
B.7.12
B.7.13
B.7.14
B.7.15
B.7.16
B.7.17
B.7.18
B.7.19
B.7.20
B.7.21
B.7.22
B.7.23
B.7.24
B.7.25
B.7.26
B.7.27
B.7.28
B.7.29
B.7.30
B.7.31
B.7.32
B.7.33
B.7.34
B.7.35
B.7.36
B.7.37
B.8
B.8.1
B.8.2
B.8.3
B.8.4
B.8.5
B.8.6
B.8.7
B.8.8
B.8.9
B.8.10
B.8.11
B.8.12
B.8.13
B.8.14
B.8.15

UMLAssociationOrConnectorOrLinkShape [Class].................................................................. 723
UMLAssociationOrConnectorOrLinkShapeKind [Enumeration]............................................... 724
UMLBehaviorDiagram [Abstract Class]....................................................................................724
UMLClassDiagram [Class]....................................................................................................... 724
UMLClassifierShape [Class].................................................................................................... 725
UMLCompartment [Class]........................................................................................................ 725
UMLCompartmentableShape [Class].......................................................................................726
UMLComponentDiagram [Class]............................................................................................. 726
UMLCompositeStructureDiagram [Class]................................................................................ 726
UMLDeploymentDiagram [Class]............................................................................................. 727
UMLDiagram [Abstract Class].................................................................................................. 727
UMLDiagramElement [Abstract Class].....................................................................................728
UMLDiagramWithAssociations [Abstract Class].......................................................................729
UMLEdge [Class]..................................................................................................................... 729
UMLInteractionDiagram [Class]............................................................................................... 729
UMLInteractionDiagramKind [Enumeration].............................................................................730
UMLInteractionTableLabel [Class]........................................................................................... 730
UMLInteractionTableLabelKind [Enumeration]......................................................................... 731
UMLKeywordLabel [Class]....................................................................................................... 731
UMLLabel [Class]..................................................................................................................... 732
UMLMultiplicityLabel [Class].................................................................................................... 732
UMLNameLabel [Class]........................................................................................................... 732
UMLNavigabilityNotationKind [Enumeration]........................................................................... 733
UMLObjectDiagram [Class]..................................................................................................... 733
UMLPackageDiagram [Class].................................................................................................. 733
UMLProfileDiagram [Class]...................................................................................................... 734
UMLRedefinesLabel [Class].................................................................................................... 734
UMLShape [Class]................................................................................................................... 734
UMLStateMachineDiagram [Class].......................................................................................... 735
UMLStateShape [Class]........................................................................................................... 735
UMLStereotypePropertyValueLabel [Class]............................................................................. 736
UMLStructureDiagram [Abstract Class]................................................................................... 737
UMLStyle [Class]..................................................................................................................... 737
UMLTypedElementLabel [Class].............................................................................................. 737
UMLUseCaseDiagram [Class]................................................................................................. 738
Association Descriptions..................................................................................................738
A_UMLActivityDiagram_modelElement_umlDiagramElement [Association]............................738
A_UMLAssociationEndLabel_modelElement_umlDiagramElement [Association]...................738
A_UMLBehaviorDiagram_modelElement_umlDiagramElement [Association].........................738
A_UMLClassifierShape_modelElement_umlDiagramElement [Association]...........................739
A_UMLCompartment_elementInCompartment_owningCompartment [Association]................739
A_UMLCompartmentableShape_compartmentedShape_shape [Association]........................739
A_UMLDiagramElement_localStyle_styledElement [Association]...........................................739
A_UMLDiagramElement_modelElement_umlDiagramElement [Association]..........................739
A_UMLDiagramElement_ownedElement_owningElement [Association]................................. 739
A_UMLDiagramElement_sharedStyle_styledElement [Association]........................................740
A_UMLDiagram_heading_headedDiagram [Association]........................................................ 740
A_UMLEdge_source_sourceEdge [Association]..................................................................... 740
A_UMLEdge_target_targetEdge [Association].........................................................................740
A_UMLInteractionDiagram_modelElement_umlDiagramElement [Association]......................740
A_UMLMultiplicityElement_modelElement_umlDiagramElement [Association]....................... 740

xxx

Unified Modeling Language 2.5

B.8.16
B.8.17
B.8.18
B.8.19
B.8.20
B.8.21

A_UMLNameLabel_modelElement_umlDiagramElement [Association]..................................740
A_UMLRedefines_modelElement_umlDiagramElement [Association]....................................741
A_UMLStateMachine_modelElement_umlDiagramElement [Association]...............................741
A_UMLStateShape_modelElement_umlDiagramElement [Association]..................................741
A_UMLStereotypePropertyValueLabel_modelElement_umlDiagramElement [Association]....741
A_UMLStereotypePropertyValueLabel_stereotypedElement_labelShowingStereotypeValue 
[Association]............................................................................................................................ 741
Annex C: Keywords............................................................................................................743
Annex D: Tabular Notation for Sequence Diagrams.......................................................... 747
D.1
Examples......................................................................................................................... 748
Annex E: XMI Serialization and Schema........................................................................... 751
E.1
Summary......................................................................................................................... 751
XMI Serialization of the UML 2 metamodel...................................................................... 751
E.2
XMI Serialization of the PrimitiveTypes model library......................................................752
E.3
E.4
XMI Serialization of the StandardProfile.......................................................................... 752
XMI Serialization of the UMLDI........................................................................................ 752
E.5

Unified Modeling Language 2.5

xxxi

Table of Figures

Figure 6.1
Semantic Areas of UML........................................................................................................... 14
Figure 7.1
Root......................................................................................................................................... 21
Figure 7.2
Comment notation................................................................................................................... 22
Figure 7.3
Templates................................................................................................................................ 23
Figure 7.4
Template bindings.................................................................................................................... 23
Figure 7.5
Namespaces............................................................................................................................ 27
Figure 7.6
Template package with string parameters............................................................................... 31
Figure 7.7
Example of element import...................................................................................................... 31
Figure 7.8
Example of element import with aliasing..................................................................................32
Figure 7.9
Examples of public and private package imports.....................................................................32
Figure 7.10
Abstract syntax of types and multiplicity elements................................................................... 33
Figure 7.11 Multiplicity within a textual specification................................................................................... 35
Figure 7.12 Multiplicity as an adornment to a symbol................................................................................. 35
Figure 7.13
Abstract Syntax of Constraints.................................................................................................36
Figure 7.14 Constraint in a note symbol..................................................................................................... 37
Figure 7.15 Constraint attached to an attribute........................................................................................... 37
{xor} constraint......................................................................................................................... 37
Figure 7.16
Figure 7.17
Abstract syntax of dependencies............................................................................................. 38
Figure 7.18 Notation for a Dependency between two elements..................................................................39
An example of an «Instantiate» Dependency.......................................................................... 39
Figure 7.19
An example of a «use» Dependency....................................................................................... 39
Figure 7.20
An example of a realization Dependency................................................................................ 40
Figure 7.21
Figure 8.1
Literals..................................................................................................................................... 69
Expressions............................................................................................................................. 71
Figure 8.2
Time and Duration................................................................................................................... 73
Figure 8.3
Intervals................................................................................................................................... 76
Figure 8.4
Figure 8.5
Example of DurationConstraints and TimeConstraints............................................................ 77
Classifiers................................................................................................................................ 97
Figure 9.1
Generalization notation showing different target styles..........................................................101
Figure 9.2
Example of Substitution notation........................................................................................... 101
Figure 9.3
Figure 9.4
Classifier Templates............................................................................................................... 102
Template Class and Bound Class.......................................................................................... 104
Figure 9.5
Anonymous Bound Class...................................................................................................... 104
Figure 9.6
Template Class with constrained Class parameter................................................................ 104
Figure 9.7
Figure 9.8
Bound Class.......................................................................................................................... 105
Features................................................................................................................................ 105
Figure 9.9
Properties.............................................................................................................................. 109
Figure 9.10
Figure 9.11
Examples of attributes........................................................................................................... 113
Figure 9.12
Association-like notation for attributes................................................................................... 114
Figure 9.13 Operations............................................................................................................................. 114
Figure 9.14 Generalization Sets................................................................................................................ 117
Figure 9.15 GeneralizationSets designated by name............................................................................... 118
Figure 9.16 GeneralizationSets designated by shared target................................................................... 118
Figure 9.17 GeneralizationSet designated by dashed line spanning Generalization arrows.....................119
Figure 9.18 GeneralizationSet constraint notation with shared target style...............................................119
Figure 9.19 GeneralizationSet constraint notation with dashed line style................................................. 120
Figure 9.20
Power type notation with shared target style......................................................................... 120
Power type notation with dashed line style............................................................................ 120
Figure 9.21

xxxii

Unified Modeling Language 2.5

Figure 9.22 GeneralizationSet notation options........................................................................................ 121
Figure 9.23 GeneralizationSets and constraints....................................................................................... 121
Figure 9.24
Power type example.............................................................................................................. 122
Figure 9.25 More power type examples.................................................................................................... 123
Figure 9.26 More than one powertype...................................................................................................... 124
Figure 9.27
Instances............................................................................................................................... 124
Specification of an Instance of String.....................................................................................127
Figure 9.28
Slots with values.................................................................................................................... 127
Figure 9.29
InstanceSpecifications representing two objects connected by a link....................................127
Figure 9.30
Figure 9.31
InstanceValue represented textually...................................................................................... 127
Figure 9.32
InstanceValue represented graphically.................................................................................. 127
Figure 10.1 DataTypes............................................................................................................................. 165
Figure 10.2
PrimitiveType Notation........................................................................................................... 166
Figure 10.3 DataType Notation................................................................................................................. 166
Enumeration Notation............................................................................................................ 167
Figure 10.4
Figure 10.5
Signals................................................................................................................................... 167
Figure 10.6 Reception Notation................................................................................................................ 168
Figure 10.7
Interfaces............................................................................................................................... 169
ISensor is a provided Interface of ProximitySensor............................................................... 170
Figure 10.8
ISensor, a provided Interface of ProximitySensor, is shown as inherited by
Figure 10.9
CapacitiveSensor................................................................................................................... 171
Figure 10.10 ISensor is a required Interface of TheftAlarm........................................................................ 171
Figure 10.11 Alternative notation for required and provided Interface........................................................ 171
Figure 10.12 A set of collaborating Interfaces............................................................................................. 171
Structured Classifiers............................................................................................................. 181
Figure 11.1
Figure 11.2
Parts and roles....................................................................................................................... 184
Parts and roles with Ports...................................................................................................... 184
Figure 11.3
Alternative notations for connecting parts and roles with Ports.............................................185
Figure 11.4
Associations compared with Connectors............................................................................... 185
Figure 11.5
Figure 11.6
"Star" Connector pattern........................................................................................................ 186
"Array" Connector pattern...................................................................................................... 186
Figure 11.7
An assembly Connector maps a simple Port of a Component to a matching simple Port
Figure 11.8
of another Component........................................................................................................... 187
An n-ary Connector that assembles four simple Ports using channeled ball-and-socket 
notation.................................................................................................................................. 187
Figure 11.10 Encapsulated Classifiers....................................................................................................... 188
Figure 11.11 Port notation.......................................................................................................................... 190
Figure 11.12 Behavior Port notation........................................................................................................... 190
Figure 11.13 Port notation showing multiple provided Interfaces................................................................191
Figure 11.14 Port examples........................................................................................................................ 191
Figure 11.15 Classes.................................................................................................................................. 192
Figure 11.16 Class notation variants.......................................................................................................... 194
Figure 11.17 Class notation: attributes and Operations grouped according to visibility.............................. 194
Figure 11.18 Active Class........................................................................................................................... 194
Figure 11.19 Connectors and Parts............................................................................................................ 195
Figure 11.20 Connectors and Parts in a structure diagram using multiplicities...........................................195
Figure 11.21 An Instance of the Car Class................................................................................................. 195
Figure 11.22 InstanceSpecification indicating a constructor....................................................................... 196
Figure 11.23 A constructor for the Car Class.............................................................................................. 196
Figure 11.24 Showing that the extended Class is a metaclass................................................................... 196
Figure 11.25 Associations........................................................................................................................... 197

Figure 11.9

Unified Modeling Language 2.5

xxxiii

Figure 11.26 Graphic notation indicating exactly one Association end owned by the Association..............200
Figure 11.27 Binary and ternary Associations.............................................................................................202
Figure 11.28 Association ends with various adornments............................................................................ 202
Figure 11.29 Examples of navigable association-owned ends................................................................... 203
Figure 11.30 Examples of class-owned ends............................................................................................. 204
Figure 11.31 Example of attribute notation for navigable end owned by an end Class...............................204
Figure 11.32 Derived supersets (union)...................................................................................................... 204
Figure 11.33 Composite aggregation is depicted as a black diamond........................................................ 205
Figure 11.34 Composite aggregation sharing a source segment................................................................205
Figure 11.35 Example AssociationClass Job, which is defined between the two Classes Person and 

Company............................................................................................................................... 205
Figure 11.36 Example AssociationClass using diamond symbol................................................................ 206
Figure 11.37 Qualified associations............................................................................................................ 206
Figure 11.38 Components.......................................................................................................................... 207
Figure 11.39 Example of an overview diagram showing Components and their general Dependencies....209
Figure 11.40 A Component with two provided and three required Interfaces.............................................209
Figure 11.41 Black box notation showing a listing of provided and required interfaces.............................. 210
Figure 11.42 Optional “white-box” representation of a Component............................................................ 210
Figure 11.43 Explicit representation of provided and required Interfaces using Dependency notation.......210
Figure 11.44 A representation of the realization of a complex Component................................................. 211
Figure 11.45 An alternative nested representation of a complex Component.............................................211
Figure 11.46 Example model of a Component, its provided and required Interfaces, and wiring

through Dependencies........................................................................................................... 212
Figure 11.47 Internal structure of a Component......................................................................................... 212
Figure 11.48 Delegation Connectors connect externally provided Interfaces to the parts that realize

or require them...................................................................................................................... 213
Figure 11.49 Collaborations........................................................................................................................ 213
Figure 11.50 The internal structure of the Observer Collaboration............................................................. 215
Figure 11.51 Alternative notation for the parts of the Observer Collaboration............................................216
Figure 11.52 The Sale Collaboration.......................................................................................................... 216
Figure 11.53 The BrokeredSale Collaboration............................................................................................ 216
Figure 11.54 A subset of the BrokeredSale Collaboration using «occurrence» and Dependency arrows. .217
Packages............................................................................................................................... 239
Figure 12.1
Figure 12.2
Illustration of the Meaning of Package Merge........................................................................ 240
Figure 12.3 Conceptual View of the Package Merge Semantics.............................................................. 241
Figure 12.4 Notation for Package Merge.................................................................................................. 247
Examples of a Package with Members.................................................................................. 247
Figure 12.5
Figure 12.6
Simple Example of Package Merge....................................................................................... 248
Simple Example of Transformed Packages Following the Merges........................................ 248
Figure 12.7
Figure 12.8
Introducing Additional Package Merges.................................................................................249
Figure 12.9 Result of the Additional Package Merges.............................................................................. 249
Figure 12.10 Three Models Representing Parts of a System..................................................................... 249
Figure 12.11 Two Views of One System Collected in a Container Model................................................... 250
Figure 12.12 Profiles................................................................................................................................... 251
Figure 12.13 Using the HomeExample Profile to Extend a Model.............................................................. 255
Figure 12.14 Specification of an Available Metaclass................................................................................. 257
Figure 12.15 MOF Model Equivalent to Extending "Interface" by the "Home" Stereotype.......................... 259
Figure 12.16 Example of Multiple Metaclass Extension..............................................................................259
Figure 12.17 MOF Model Equivalent to Multiple Metaclass Extension....................................................... 260
Figure 12.18 The Notation for an Extension............................................................................................... 260
Figure 12.19 Example of Using an Extension............................................................................................. 262

xxxiv

Unified Modeling Language 2.5

Figure 12.20 Example of a Required Extension..........................................................................................262
Figure 12.21 Defining a Simple EJB Profile................................................................................................ 263
Figure 12.22 Importing a Package from a Profile........................................................................................263
Figure 12.23 Profiles Applied to a Package................................................................................................ 264
Figure 12.24 Defining a Stereotype............................................................................................................ 264
Figure 12.25 Presentation Options for an Extended Class......................................................................... 264
Figure 12.26 An Instance Diagram when Defining a Stereotype................................................................ 264
Figure 12.27 Defining Multiple Stereotypes on Multiple Stereotypes.......................................................... 265
Figure 12.28 Using a Stereotype................................................................................................................ 265
Figure 12.29 Showing Values of Stereotypes and a Simple Instance Specification....................................265
Figure 12.30 Using Stereotypes and Showing Values................................................................................ 265
Figure 12.31 Other Notational Forms for Depicting Stereotype Values......................................................266
Figure 12.32 Example of a Profile defining Classes and binary composite and non-composite

Associations........................................................................................................................... 266

Figure 12.33 Diagram example of applying a profile defining Classes and Associations and of
creating instances of such Classes. Tools can provide a notation similar to that of
object diagrams for instances of Profile-defined Classes, DataTypes and Associations........269
Behaviors............................................................................................................................... 284
Figure 13.1
Events.................................................................................................................................... 289
Figure 13.2
Figure 14.1
Behavior StateMachines........................................................................................................ 304
Figure 14.2 Compound transition example............................................................................................... 316
Figure 14.3 Notation for a composite State with Regions......................................................................... 317
State notation......................................................................................................................... 317
Figure 14.4
State with a name tab............................................................................................................ 318
Figure 14.5
Figure 14.6
State with compartments....................................................................................................... 318
Figure 14.7 Composite State with two States........................................................................................... 320
Figure 14.8 Composite State with a hidden decomposition indicator icon................................................ 320
Figure 14.9 Composite State with Regions............................................................................................... 320
Figure 14.10 Composite State with two Regions and entry, exit, and do Behaviors...................................321
Figure 14.11 Submachine State example................................................................................................... 322
Figure 14.12 StateMachine with an exit point as part of the StateMachine graph......................................323
Figure 14.13 StateMachine with an exit point on the border....................................................................... 323
Figure 14.14 Submachine Sate that uses an exit point...............................................................................324
Figure 14.15 State list notation option........................................................................................................ 324
Figure 14.16 Diagram equivalent to Figure 14.15 without using statelists.................................................. 325
Figure 14.17 FinalState notation................................................................................................................. 325
Figure 14.18 initial Pseudostate.................................................................................................................. 325
Figure 14.19 shallowHistory Pseudostate................................................................................................... 325
Figure 14.20 deepHistory Pseudostate....................................................................................................... 325
Figure 14.21 entryPoint Pseudostate.......................................................................................................... 326
Figure 14.22 exitPoint Pseudostate............................................................................................................ 326
Figure 14.23 entryPoint and exitPoints on a composite State.....................................................................326
Figure 14.24 junction Pseudostate with incoming and outgoing Transitions............................................... 327
Figure 14.25 choice Pseudostates.............................................................................................................. 327
Figure 14.26 terminate Pseudostate........................................................................................................... 327
Figure 14.27 fork and join Pseudostates.................................................................................................... 328
Figure 14.28 Entry point ConnectionPointReference notation.................................................................... 328
Figure 14.29 Exit point ConnectionPointReference notation...................................................................... 328
Figure 14.30 Alternative entry point ConnectionPointReference notation...................................................329
Figure 14.31 Alternative exit point ConnectionPointReference notation..................................................... 329
Figure 14.32 Symbols for Signal reception, Sending, and Actions on a Transition.....................................331

Unified Modeling Language 2.5

xxxv

Figure 14.33 Deferred Trigger notation....................................................................................................... 332
Figure 14.34 Local Transitions.................................................................................................................... 333
Figure 14.35 External Transitions............................................................................................................... 333
Figure 14.36 StateMachine diagram representing a telephone.................................................................. 334
Figure 14.37 StateMachine redefinition...................................................................................................... 335
Figure 14.38 A general StateMachine......................................................................................................... 337
Figure 14.39 An extended StateMachine.................................................................................................... 337
Figure 14.40 Adding Transitions................................................................................................................. 338
Figure 14.41 ProtocolStateMachines.......................................................................................................... 339
Figure 14.42 An example of a ProtocolTransition associated with the operation "m1"...............................341
Figure 14.43 Example of several ProtocolTransitions associated with the same operation (m1)...............341
Figure 14.44 ProtocolStateMachine example............................................................................................. 342
Figure 14.45 Notation for a State with an invariant..................................................................................... 343
Figure 14.46 ProtocolTransition notation.................................................................................................... 343
Activities................................................................................................................................ 372
Figure 15.1
Activity notation...................................................................................................................... 377
Figure 15.2
Activity class notation............................................................................................................ 378
Figure 15.3
Figure 15.4
ActivityNode notation............................................................................................................. 378
ActivityEdge notation............................................................................................................. 378
Figure 15.5
ActivityEdge connector notation.............................................................................................378
Figure 15.6
Figure 15.7
ActivityEdge notation............................................................................................................. 379
Figure 15.8 ControlFlow notation.............................................................................................................. 379
Figure 15.9 ObjectFlow notations............................................................................................................. 379
Figure 15.10 Specifying selection behavior on an ObjectFlow....................................................................379
Figure 15.11 Eliding objects flowing on the edge........................................................................................380
Figure 15.12 Activity node example (where the arrowed lines are the only non-activity node symbols).....380
Figure 15.13 ActivityEdge examples........................................................................................................... 380
Figure 15.14 ObjectFlow example.............................................................................................................. 381
Figure 15.15 Eliding objects flowing on the edge........................................................................................381
Figure 15.16 Specifying selection and transformation Behaviors on an ObjectFlow...................................381
Figure 15.17 Linking a class diagram to an object node............................................................................. 382
Figure 15.18 Specifying multicast and multireceive on the edge................................................................ 382
Figure 15.19 ActivityEdge connector example............................................................................................ 382
Figure 15.20 Equivalent model................................................................................................................... 382
Figure 15.21 ActivityEdge weight examples............................................................................................... 383
Figure 15.22 Example of an activity with input parameter.......................................................................... 383
Figure 15.23 Part selection workflow example............................................................................................384
Figure 15.24 Trouble ticket workflow example............................................................................................ 384
Figure 15.25 Activity with attributes and operations....................................................................................385
Figure 15.26 Control Nodes........................................................................................................................ 385
Figure 15.27 InitialNode notation................................................................................................................ 388
Figure 15.28 FinalNode notation................................................................................................................. 389
Figure 15.29 ForkNode and JoinNode notation.......................................................................................... 389
Figure 15.30 joinSpec notation................................................................................................................... 389
Figure 15.31 Combined JoinNode/ ForkNode notation............................................................................... 389
Figure 15.32 MergeNode notation.............................................................................................................. 390
Figure 15.33 DecisionNode notation........................................................................................................... 390
Figure 15.34 Combined MergeNode/DecisionNode notation...................................................................... 390
Figure 15.35 InitialNode example............................................................................................................... 390
Figure 15.36 ForkNode example................................................................................................................ 391
Figure 15.37 JoinNode example................................................................................................................. 391

xxxvi

Unified Modeling Language 2.5

Figure 15.38 joinSpec example.................................................................................................................. 391
Figure 15.39 MergeNode example............................................................................................................. 391
Figure 15.40 DecisionNode example.......................................................................................................... 392
Figure 15.41 DecisionNode example with decisionInput............................................................................ 392
Figure 15.42 ActivityFinalNode example.................................................................................................... 392
Figure 15.43 ActivityFinalNode example.................................................................................................... 392
Figure 15.44 ActivityFinalNode example.................................................................................................... 393
Figure 15.45 FlowFinalNode example........................................................................................................ 393
Figure 15.46 FlowFinalNode and ActivityFinalNode example..................................................................... 393
Figure 15.47 ControlNode examples (with accompanying actions and control flows)................................394
Figure 15.48 Object Nodes......................................................................................................................... 394
Figure 15.49 ObjectNode notations............................................................................................................ 397
Figure 15.50 ObjectNode annotations........................................................................................................ 398
Figure 15.51 Specifying selection behavior on an ObjectNode...................................................................398
Figure 15.52 Notation for stream and exception parameters...................................................................... 398
Figure 15.53 Presentation option for flows between pins and parameter nodes.........................................399
Figure 15.54 Optional CentralBufferNode notation..................................................................................... 399
Figure 15.55 DataStoreNode notation........................................................................................................ 399
Figure 15.56 Example of ActivityParameterNodes for regular and exception Parameters..........................399
Figure 15.57 Example of ActivityParameterNodes for streaming Parameters............................................400
Figure 15.58 CentralBufferNode example...................................................................................................400
Figure 15.59 DataStoreNode example....................................................................................................... 400
Figure 15.60 Executable Nodes.................................................................................................................. 401
Figure 15.61 ExecutableNode notation....................................................................................................... 402
Figure 15.62 ExceptionHandler notation..................................................................................................... 403
Figure 15.63 Alternative ExceptionHandler notation................................................................................... 403
Figure 15.64 ExceptionHandler example.................................................................................................... 403
Figure 15.65 ActivityGroups........................................................................................................................ 404
Figure 15.66 ActivityPartition notations....................................................................................................... 406
Figure 15.67 ActivityPartition notations....................................................................................................... 407
Figure 15.68 InterruptableActivityRegion.................................................................................................... 407
Figure 15.69 InterruptableActivityRegion alternative notation..................................................................... 407
Figure 15.70 ActivityPartitions using swimlane notation............................................................................. 408
Figure 15.71 ActivityPartitions using annotation......................................................................................... 408
Figure 15.72 ActivityPartitions using multidimensional swimlane notation..................................................409
Figure 15.73 InterruptableActivityRegion example..................................................................................... 409
Actions................................................................................................................................... 440
Figure 16.1
Figure 16.2
Action..................................................................................................................................... 444
Local pre- and post-conditions............................................................................................... 444
Figure 16.3
Pin notations.......................................................................................................................... 444
Figure 16.4
Pin notations, with arrows...................................................................................................... 445
Figure 16.5
Figure 16.6
Standalone Pin notations....................................................................................................... 445
Examples of Actions.............................................................................................................. 445
Figure 16.7
Example of action using a tool-specific concrete syntax........................................................ 445
Figure 16.8
Figure 16.9
Example of an action with local pre- and post-conditions...................................................... 446
Figure 16.10 Pin examples......................................................................................................................... 446
Figure 16.11 Specifying selection behavior on an ObjectFlow....................................................................447
Figure 16.12 Example abstract syntax model showing the use of ActionInputPins.....................................447
Figure 16.13 Invocation Actions.................................................................................................................. 448
Figure 16.14 Calling a Behavior.................................................................................................................. 452
Figure 16.15 Calling an Activity................................................................................................................... 452

Unified Modeling Language 2.5

xxxvii

Figure 16.16 Calling an Operation.............................................................................................................. 452
Figure 16.17 Calling an Operation, showing the owner name.................................................................... 452
Figure 16.18 Sending a Signal.................................................................................................................... 453
Figure 16.19 Exception Pin annotations..................................................................................................... 453
Figure 16.20 Effect Pin annotations............................................................................................................ 453
Figure 16.21 Stream Pin annotations......................................................................................................... 453
Figure 16.22 Stream Pin annotations, with filled arrows and rectangles.....................................................454
Figure 16.23 Alternative input/outputs using ParameterSet notation.......................................................... 454
Figure 16.24 Invoking an Activity................................................................................................................ 454
Figure 16.25 Sending Signals..................................................................................................................... 455
Figure 16.26 Streaming Pin examples........................................................................................................ 455
Figure 16.27 Exception Pin examples........................................................................................................ 455
Figure 16.28 Pin example with effects........................................................................................................ 455
Figure 16.29 Alternative input/outputs using ParameterSets...................................................................... 455
Figure 16.30 Object Actions........................................................................................................................ 456
Figure 16.31 ValueSpecificationAction notation.......................................................................................... 458
Figure 16.32 ValueSpecificationActions...................................................................................................... 459
Figure 16.33 Link End Data........................................................................................................................ 459
Figure 16.34 Link Actions............................................................................................................................ 461
Figure 16.35 Link Object Actions................................................................................................................ 464
Figure 16.36 Structural Feature Actions..................................................................................................... 465
Figure 16.37 Variable Actions..................................................................................................................... 468
Figure 16.38 Presentation option for AddVariableValueAction.................................................................... 469
Figure 16.39 Accept Event Actions............................................................................................................. 470
Figure 16.40 AcceptEventAction notations................................................................................................. 472
Figure 16.41 Implicitly enabled AcceptEventAction.................................................................................... 473
Figure 16.42 Explicitly enabled AcceptEventAction.................................................................................... 473
Figure 16.43 Repetitive time event............................................................................................................. 473
Figure 16.44 UnmarshallAction................................................................................................................... 473
Figure 16.45 Structured Actions.................................................................................................................. 474
Figure 16.46 Notation for StructuredActivityNode....................................................................................... 478
Figure 16.47 Expansion Regions................................................................................................................ 478
Figure 16.48 Expansion Region.................................................................................................................. 481
Figure 16.49 Shorthand notation for expansion region containing single node..........................................481
Figure 16.50 Full form of previous shorthand notation................................................................................481
Figure 16.51 Notation for expansion region with one behavior invocation.................................................. 481
Figure 16.52 Expansion region with two inputs and one output.................................................................. 482
Figure 16.53 Expansion Region.................................................................................................................. 483
Figure 16.54 Examples of expansion region shorthand.............................................................................. 483
Figure 16.55 Shorthand notation for expansion region............................................................................... 484
Figure 16.56 Other Actions......................................................................................................................... 484
Figure 17.1
Interactions............................................................................................................................ 565
Figure 17.2 Overlapping ExecutionSpecifications.....................................................................................567
Figure 17.3
An example of an Interaction in the form of a Sequence Diagram.........................................568
Figure 17.4 OccurrenceSpecification........................................................................................................ 568
Figure 17.5
Sequence Diagram with time and timing concepts................................................................ 569
Figure 17.6
Lifelines................................................................................................................................. 570
Figure 17.7 Messages.............................................................................................................................. 572
Figure 17.8 DestructionOccurrenceSpecification symbol......................................................................... 576
Figure 17.9 Occurrences.......................................................................................................................... 578
Figure 17.10 Example showing GeneralOrdering in a sequence diagram.................................................. 579

xxxviii

Unified Modeling Language 2.5

Internal Structure).................................................................................................................. 592
Figure 17.24 Describing Collaborations and their binding.......................................................................... 593
Figure 17.25 Overview of Metamodel elements of a Sequence Diagram................................................... 597
Figure 17.26 Communication diagram........................................................................................................ 599
Figure 17.27 Interaction Overview Diagram representing a High Level Interaction diagram......................601
Figure 17.28 A Lifeline for a discrete object................................................................................................ 603
Figure 17.29 Compact Lifeline with States................................................................................................. 604
Figure 17.30 Timing Diagram with more than one Lifeline and with Messages..........................................604
Figure 18.1 UseCases.............................................................................................................................. 637
Figure 18.2 Class diagram of a Package owning a set of UseCases, Actors, and a Subsystem..............641
Example Extend..................................................................................................................... 641
Figure 18.3
Figure 18.4
Example Include.................................................................................................................... 642
Figure 18.5 UseCase using Classifier rectangle notation......................................................................... 642
Actor notation using stick-man............................................................................................... 642
Figure 18.6
Actor notation using Class rectangle..................................................................................... 642
Figure 18.7
Figure 18.8
Actor notation using icon....................................................................................................... 642
Figure 18.9 Notation for UseCase owned by Classifier............................................................................ 643
Figure 18.10 Example ATM system with UseCases and Actors..................................................................643
Figure 18.11 Example UseCases owned by Packages.............................................................................. 644
Figure 18.12 Example UseCase with associated StateMachine................................................................. 644
Figure 19.1 Deployments.......................................................................................................................... 651
Figure 19.2

A visual representation of the deployment location of artifacts, including a dependency 
between them, inside a DeployedTarget graphic................................................................... 652
Alternative deployment representation of using a dependency called «deploy» used
when DeployedArtifacts are visually outside their DeployedTarget graphics.........................652
Textual list based representation of DeployedArtifacts.......................................................... 653

Figure 19.4
Figure 19.5 DeploymentSpecification for an artifact. On the left, a type-level specification, and on

Figure 19.3

Figure 17.11 Fragments............................................................................................................................. 580
Figure 17.12 Critical Region....................................................................................................................... 585
Figure 17.13 - Loop CombinedFragment.................................................................................................... 586
Figure 17.14 CombinedFragment............................................................................................................... 586
Figure 17.15 Continuation........................................................................................................................... 587
Figure 17.16 Continuation interpretation..................................................................................................... 587
Figure 17.17 Ignore, consider, assert with StateInvariants......................................................................... 588
Figure 17.18 InteractionUses...................................................................................................................... 589
Figure 17.19 InteractionUse........................................................................................................................ 590
Figure 17.20 InteractionUse with value return............................................................................................ 591
Figure 17.21 PartDecomposition - the decomposed part............................................................................ 591
Figure 17.22 PartDecomposition - the decomposition................................................................................ 591
Figure 17.23 Sequence Diagrams where two Lifelines refer to the same set of Parts (and

the right, an instance-level specification................................................................................ 653
Figure 19.6 DeploymentSpecifications related to the DeployedArtifacts that they parameterize..............653
A DeploymentSpecification for a DeployedArtifact................................................................. 654
Figure 19.7
Artifacts.................................................................................................................................. 654
Figure 19.8
Figure 19.9
An Artifact instance................................................................................................................ 655
Figure 19.10 A Manifestation relationship between an Artifact and a Component...................................... 655
Figure 19.11 Nodes.................................................................................................................................... 656
Figure 19.12 Notation for a Device containing an ExecutionEnvironment and connected to another

Device by a CommunicationPath link.................................................................................... 657
Figure 19.13 Notation for a ExecutionEnvironment.................................................................................... 657
Figure 19.14 An instance of a Node........................................................................................................... 657

Unified Modeling Language 2.5

xxxix

Figure 19.15 CommunicationPath between AppServer with deployed Artifacts and a DBServer................657
Figure 19.16 Deployed component Artifacts on a Node..............................................................................657
Information Flows.................................................................................................................. 667
Figure 20.1
Example of InformationFlows conveying InformationItems.................................................... 669
Figure 20.2
Information Item represented as a classifier.......................................................................... 669
Figure 20.3
Figure 20.4
Examples of «representation» notation................................................................................. 669
InformationItems attached to Connectors.............................................................................. 669
Figure 20.5
Figure 20.6
InformationItems attached to Associations............................................................................ 670
Figure  21.1 Primitive Types.......................................................................................................................... 675
Figure  21.2  An Integer used as a type for an attribute, with a default value................................................675
A Boolean used as a type for an attribute, with a default value.............................................676
Figure 21.3
A String used as a type for an attribute, with a default value................................................. 676
Figure 21.4
An UnlimitedNatural used as an upper bound for a multiplicity..............................................676
Figure 21.5
Figure 21.6
Two attributes with type Real................................................................................................. 676
Figure 22.1 Model of StandardProfile....................................................................................................... 677
UML Diagram......................................................................................................................... 681
Figure A.1
Class diagram of package P.................................................................................................. 681
Figure A.2
Figure A.3
Two diagrams of packages.................................................................................................... 682
A class diagram and a composite structure diagram............................................................. 682
Figure A.4
The taxonomy of structure and behavior diagrams................................................................ 683
Figure A.5
UML Diagram Interchange Architecture................................................................................. 685
Figure B.1
Figure B.2
UML Diagrams and Diagram Elements..................................................................................686
UML Shapes and Edges........................................................................................................ 687
Figure B.3
Labels.................................................................................................................................... 687
Figure B.4
UML Compartmentable Shapes............................................................................................. 689
Figure B.5
Figure B.6
Stereotype Application Labels................................................................................................689
UML Styles............................................................................................................................ 691
Figure B.7
Structure Diagrams................................................................................................................ 691
Figure B.8
Figure B.9
Classifier Shapes................................................................................................................... 693
Figure B.10 Multiplicity and Association End Labels................................................................................. 694
Figure B.11
Association, Connector, and Link Shapes............................................................................. 695
Figure B.12 Behavior Diagrams................................................................................................................ 695
Figure B.13 State Shapes......................................................................................................................... 700
Figure B.14
Interaction Shapes................................................................................................................. 701
Sequence diagram enhanced with identification of the Event occurrences...........................748
Figure D.1
Figure D.2
Sequence diagram with guards, parallel composition and alternatives..................................749

xl

Unified Modeling Language 2.5

Table of Tables

Table 7.1
Table 9.1
Table 17.1
Table 17.2
Table 17.3
Table 17.4
Table 17.5

Table 17.6
Table 21.1
Table 22.1
Table B.1
Table B.2
Table C.1
Table D.1
Table D.2

Collection types for MultiplicityElements.................................................................................. 34
GeneralizationSet constraints................................................................................................ 119
Graphic Nodes Included in Sequence Diagrams................................................................... 594
Graphic Paths Included in Sequence Diagrams.................................................................... 596
Graphic Nodes Included in Communication Diagrams.......................................................... 598
Graphic Paths Included in Communications Diagrams.......................................................... 598
Graphic nodes included in Interaction Overview Diagrams in addition to those borrowed
from Activity Diagrams........................................................................................................... 600
Graphic nodes and paths included in timing diagrams.......................................................... 602
PrimitiveType domains........................................................................................................... 675
Description of the Stereotypes in the UML StandardProfile................................................... 678
UML Shapes.......................................................................................................................... 702
UML Edges............................................................................................................................ 716
Keywords............................................................................................................................... 744
Interaction Table describing Figure D.1................................................................................. 748
Interaction Table for Figure D.2.............................................................................................. 749

Unified Modeling Language 2.5

xli

Scope

1
This specification defines the Unified Modeling Language (UML), revision 2. The objective of UML is to provide 
system architects, software engineers, and software developers with tools for analysis, design, and implementation of 
software-based systems as well as for modeling business and similar processes.
The initial versions of UML (UML 1) originated with three leading object-oriented methods (Booch, OMT, and OOSE), 
and incorporated a number of best practices from modeling language design, object-oriented programming, and 
architectural description languages. Relative to UML 1, this revision of UML has been enhanced with significantly 
more precise definitions of its abstract syntax rules and semantics, a more modular language structure, and a greatly 
improved capability for modeling large-scale systems.
One of the primary goals of UML is to advance the state of the industry by enabling object visual modeling tool 
interoperability. However, to enable meaningful exchange of model information between tools, agreement on semantics 
and syntax is required. UML meets the following requirements:

• A formal definition of a common MOF-based metamodel that specifies the abstract syntax of the UML. The 

abstract syntax defines the set of UML modeling concepts, their attributes and their relationships, as well as the 
rules for combining these concepts to construct partial or complete UML models.

• A detailed explanation of the semantics of each UML modeling concept. The semantics define, in a 

technology-independent manner, how the UML concepts are to be realized by computers.

• A specification of the human-readable notation elements for representing the individual UML modeling 
concepts as well as rules for combining them into a variety of different diagram types corresponding to 
different aspects of modeled systems.

Unified Modeling Language 2.5

1

Conformance

2
There are five distinct types of conformance. These are listed below. Unless otherwise stated these types of 
conformance are independent.

1

Abstract syntax conformance. A tool demonstrating abstract syntax conformance provides a user interface 
and/or API that enables instances of concrete UML metaclasses to be created, read, updated, and deleted. The 
tool must also provide a way to validate the well-formedness of models that corresponds to the constraints 
defined in the UML metamodel.

2 Concrete syntax conformance. A tool demonstrating concrete syntax conformance provides a user interface 

and/or API that enables instances of UML notation to be created, read, updated, and deleted. Note that a 
conforming tool may provide the ability to create, read, update and delete additional diagrams and notational 
elements that are not defined in UML.

3 Model interchange conformance. A tool demonstrating model interchange conformance can import and export 

conformant XMI for all valid UML models, including models with profiles defined and/or applied. Model 
interchange conformance implies abstract syntax conformance. A conforming UML 2.5 tool shall be able to 
load and save XMI in UML 2.4.1 format as well as UML 2.5 format (see Annex E).

4 Diagram interchange conformance. A tool demonstrating diagram interchange conformance can import and 

export conformant DI (see Annex B) for all valid UML models with diagrams, including models with profiles 
defined and/or applied. Diagram interchange conformance implies both concrete syntax conformance and 
model interchange conformance.

5

Semantic conformance. A tool demonstrating semantic conformance provides a demonstrable way to interpret 
UML semantics, e.g., code generation, model execution, or semantic model analysis. The normative 
specification for UML semantics includes clause 6.3 in addition to the Semantics subdivisions of clauses 7-22. 
Semantic conformance implies Abstract Syntax conformance.

Where the UML specification provides options for a conforming tool, these are explicitly stated in the specification. In a 
number of other cases, certain aspects of the semantics are listed as "undefined" or “intentionally not specified” or “not 
specified”, allowing for domain- or application-specific customizations. Only customizations that do not contradict the 
provisions of this specification will be deemed to conform to it. However, models whose meaning is based on such 
customizations can only be interchanged without loss with tools that support the same or compatible customizations.
This specification comprises this document together with XMI serialization contained in machine-consumable files as 
listed on the cover page. If there are any conflicts between this document and the machine-consumable files, the 
machine-consumable files take precedence.

Unified Modeling Language 2.5

3

Normative References

3
The following normative documents contain provisions which, through reference in this text, constitute provisions of 
this specification. For dated references, subsequent amendments to, or revisions of, any of these publications do not 
apply.
•

ISO/IEC Directives, Part 2, Rules for the structure and drafting of International Standards, Sixth Edition 2011

• OMG Object Constraint Language (OCL) 2.3.1 Specification: http://www.omg.org/spec/OCL/2.3.1

• OMG Meta Object Facility (MOF) Core 2.5 Specification: http://www.omg.org/spec/MOF/2.5

• OMG XML Metadata Interchange (XMI) 2.5 Specification: http://www.omg.org/spec/XMI/2.5

• OMG Diagram Definition (DD) 1.1 Specification: http://www.omg.org/spec/DD/1.1

Unified Modeling Language 2.5

5

Terms and Definitions

4
There are no formal definitions in this specification that are taken from other documents.

Unified Modeling Language 2.5

7

Notational Conventions
Key words for Requirement Statements

5
5.1
The words SHALL, SHALL NOT, SHOULD, SHOULD NOT, MAY, NEED NOT, CAN and CANNOT in this 
specification shall be interpreted according to Annex H of ISO/IEC Directives, Part 2, Rules for the structure and 
drafting of International Standards, Sixth Edition 2011.

Annotations on Example Diagrams

5.2
Some of the diagram examples in this specification include explanatory annotations, which should not be confused as 
being part of the formal UML graphical notation.
In these cases, the explanatory text originates outside the UML diagram boundary, and has an arrow pointing at the 
feature of the diagram which is being explained by the annotation. The color rendition of this spec shows these 
annotations in red.

Unified Modeling Language 2.5

9

Additional Information
Specification Simplification

6
6.1
This specification has been extensively re-written from its previous version to make it easier to read by removing 
redundancy and increasing clarity. In particular, the following major changes have been made since UML 2.4.1:

•

•

•

•

•

The UML Infrastructure no longer forms part of the UML specification. The entire UML specification is 
constituted in this document.

Package Merge is not used within the specification. Every metaclass is specified completely in one clause.

The specification is organized to reduce forward references as much as possible. This means that topics such as 
Templates which are pervasive in their effects appear early in the specification.

Every clause has a section of documentation generated from the metamodel that contains all of the metaclasses 
with their properties, and all of the metaassociations with their properties. All cross-references in this generated 
documentation include hyperlinks to their targets.

The compliance levels L0, L1, L2, and L3 have been eliminated, because they were not found to be useful in 
practice. A tool either complies with the whole of UML or it does not. A tool may partially comply with UML 
by implementing a subset of its metamodel, notation, and semantics, in which case the vendor should declare 
which subset it implements.

However, the metamodel itself remains unchanged from UML 2.4.1 superstructure, with a few exceptions:

•

The metamodel has been partitioned into packages, corresponding to the clause structure of this specification. 
All of these packages are owned by a top-level package named UML; they are also imported into UML so that 
metaclasses may be referred to by their unqualified name in UML.

• Many OCL constraints have been corrected or added where they were absent. In order to do this, some names 

of association-owned properties and the corresponding associations have been changed in order to avoid 
ambiguity in OCL expressions.

• A small number of lower multiplicities have been relaxed from 1 to 0, in order to represent default values that 

cannot be formally represented using MOF. In these cases the absence of a value signifies the presence of a 
default value. These cases could not be represented at all in earlier versions of UML. They all occur in Clause 
15: Activities and are made explicit in the text there.

•

The property LoopNode::loopVariable has been made composite, in order to enable interchange of loop variables, 
which was not possible in a standard way in UML 2.4.1.

• NamedElement::clientDependency has been made derived.

•

{ordered} has been added to or removed from some properties in order to make the semantics consistent.

Unified Modeling Language 2.5

11

Architectural Alignment

6.2
The OMG’s Model Driven Architecture (MDA) initiative is a conceptual architecture for a set of industry-wide 
technology specifications that support a model-driven approach to software development. Although MDA is not itself a 
technology specification, it represents an important approach and a plan to achieve a cohesive set of model-driven 
technology specifications. UML, MOF, and related specifications play important roles in MDA by providing the 
languages for creating and transforming models.
The abstract syntax of UML is specified using a UML model called the UML metamodel. This metamodel uses 
constructs from a constrained subset of UML that is identified in the MOF 2 specification and used for constructing 
metamodels. Classes in a metamodel are called metaclasses. So, for example, the UML metaclass Element is an abstract 
class in the UML metamodel: which also means that it can be viewed from the MOF perspective as an instance of the 
metaclass Class, whose isAbstract property has the value true. Another such instance is the UML metaclass Comment, 
which has an attribute named body, which can in turn be viewed from the MOF perspective as an instance of the 
metaclass Property whose name property has the value “body”.
The fact that UML is defined using itself is no more surprising than the fact that many programming languages have 
compilers written in the language itself, or that recursive functions (such as the factorial function) can be defined using 
themselves. Certain conditions are required to ensure that the resulting definition is well-formed and unique; there is no 
formal proof that UML satisfies these conditions, but the existence of numerous interoperable implementations of UML 
offer substantial confidence that it does.
Defining UML using this constrained subset of itself ensures that UML models can be held in a MOF 2 repository 
where they can be manipulated using MOF features, and interchanged using XMI in accordance with the MOF 2 XMI 
Mapping Specification.
Since version 2.4.1 a MOF 2.x metamodel, including the UML 2.x metamodel, is a valid UML 2.x model. This was a 
substantial simplification and alignment compared to earlier versions. It is expected that future versions of MOF and 
UML will continue to be aligned in this manner.
Further discussion of metamodels and the relationship between UML and MOF may be found in the MOF 2 Core 
specification.

On the Semantics of UML
Models and What They Model

6.3
6.3.1
A model is always a model of something. The thing being modeled can generically be considered a system within some 
domain of discourse. The model then makes some statements of interest about that system, abstracting from all the 
details of the system that could possibly be described, from a certain point of view and for a certain purpose. For an 
existing system, the model may represent an analysis of the properties and behavior of the system. For a planned 
system, the model may represent a specification of how the system is to be constructed and behave.
A UML model consists of three major categories of model elements, each of which may be used to make statements 
about different kinds of individual things within the system being modeled (termed simply “individuals” in the 
following). These categories are:

•

•

•

12

Classifiers. A classifier describes a set of objects. An object is an individual with a state and relationships to 
other objects. The state of an object identifies the values for that object of properties of the classifier of the 
object. (In some cases, a classifier itself may also be considered an individual; for example, see the discussion 
of static structural features in sub clause 9.4.3.)

Events. An event describes a set of possible occurrences. An occurrence is something that happens that has 
some consequence with regard to the system.

Behaviors. A behavior describes a set of possible executions. An execution is a performance of a set of actions 
(potentially over some period of time) that may generate and respond to occurrences of events, including 

Unified Modeling Language 2.5

accessing and changing the state of objects. (As described in sub clause 13.2, behaviors are themselves 
modeled in UML as kinds of classifiers, so that executions are essentially modeled as objects. However, for 
the purposes of the present discussion, it is clearer to consider behaviors and executions to be in a separate 
semantic category than classifiers and objects.)

UML models do not contain objects, occurrences, or executions, because such individuals are part of the domain being 
modeled, not the content of the models themselves. UML does have modeling constructs for directly modeling 
individuals: instance specifications, occurrence specifications, and execution specifications for modeling objects, 
occurrences, and executions, respectively, within a particular context. However, these are again just model elements, 
making statements about the individuals being modeled. As for any model, such statements can be incomplete, 
imprecise, and abstract, according to the purpose of the model, and may turn out to be wrong (or even be asserted as 
counterfactual). The individuals being modeled, on the other hand, are always complete, precise, and concrete within 
their domain.
The execution of behaviors within a modeled system may result in the creation and destruction of objects within that 
system. The system may also reference other objects in the domain of discourse that are external to the system. 
Generally, the distinction of whether an object is internal or external is not important to the formal semantics of 
behaviors that access those objects. However, in certain cases – in particular, static properties (see sub clause 9.5) and 
classifier extents (see sub clause 16.4 on read extent actions) – the system may be considered to provide an execution 
scope that explicitly delineates those objects existing within the system (“within the execution scope”) from those 
outside. The concept of an execution scope is not further defined within UML semantics, because exactly to what it 
corresponds varies depending on the domain of discourse. For example, for a model of factory processes, the execution 
scope may encompass the execution of those processes within a single factory, while, for a model of a software 
program, the execution scope will correspond to a single execution of that program.

Semantic Areas

6.3.2
Clause 2 makes the distinction of the conformance of a tool to the (concrete and abstract) syntax of UML from 
conformance to its semantics.
The syntax of UML has to do with how UML models may be constructed, represented and interchanged. The UML 
specification defines the syntax of UML, both abstractly and concretely. However, the syntax of UML is specified 
within the framework of MOF, and the meaning of syntactic models for the purposes of tool conformance are given in 
the MOF Core specification and related XMI and Diagram Interchange specifications.
In contrast, the semantics of UML itself have to do with the standard meaning of the statements made by a UML model 
about the system being modeled. This is sometimes referred to as the “run-time” semantics of UML, especially in the 
context of UML models of executable software or other enactable processes. However, not all UML models are 
executable in this sense and not all UML semantics relate to “running” software or other processes.

Instead, consider the general division of UML modeling constructs into two semantic categories:

•

•

Structural Semantics defines the meaning of UML structural model elements about individuals in the domain 
being modeled, which may be true at some specific point in time. (Note that this category is sometimes called 
“static semantics”. However, in programming language definition, the term “static semantics” is generally used 
to mean context-sensitive name resolution and type constraints beyond the base context-free syntax of the 
language, which corresponds to well-formedness constraints in the UML abstract syntax specification. In order 
to avoid confusion, the term “structural semantics” is used here instead.)

Behavioral Semantics defines the meaning of UML behavioral model elements that make statements about 
how individuals in the domain being modeled change over time. (This is sometimes also called “dynamic 
semantics.”)

Figure 6.1 shows a more detailed delineation of the semantic areas of UML within these categories and the notional 
layering of these areas.

Unified Modeling Language 2.5

13

Figure 6.1  Semantic Areas of UML

The structural semantics of UML provides the foundation for the behavioral semantics of UML. This reflects the 
conception of behavioral semantics in terms of changes in the system state specified through structural modeling. 
Structural modeling constructs in UML are built on a common base of fundamental concepts such as type, namespace, 
relationship and dependency (see Clause 7). Specific modeling constructs then include a number of different kinds of 
classifiers: data types, classes, signals, interfaces, and components (see Clauses 9 through 11), corresponding constructs 
for modeling values and instances (see Clause 8), and constructs for packaging and profiling (see Clause 12).
The base behavioral semantics of UML builds on this structural foundation to provide a basic framework for the 
execution of behaviors (see Clause 13). This common behavioral semantics also addresses the communication that may 
result between structural objects with associated behavior. Note that this framework only deals with event-driven, or 
discrete, behaviors. However, UML semantics do not dictate the amount of time between events (unless this is 
specifically modeled using timing constraints, see sub clause 8.5). Thus, the intervals between certain events can be 
considered to be as small as needed by the application; for example, when simulating continuous behaviors.
Actions are the fundamental units of behavior in UML, used to define fine-grained behaviors (see Clause 16). Their 
resolution and expressive power are comparable to the executable instructions in traditional programming languages. 
Actions are available for use with any of the higher-level formalisms to be used for describing detailed behaviors. Such 
higher-level behavioral constructs in UML are state machines, activities and interactions (see Clauses 14, 15 and 17, 
respectively).
In addition, there are some supplemental modeling constructs that have both structural and behavioral aspects. These 
include use cases, deployments and information flows (see Clauses 18, 19 and 20, respectively).

14

Unified Modeling Language 2.5

Stable and Transient Behavioral Semantics

6.3.3
Though structural semantics, as defined in sub clause 6.3.2, has to do with modeling things at a specific point in time, 
the structural modeling constructs in UML still include the ability to model certain behavioral aspects of otherwise 
primarily structural elements. For example, a classifier may have behavioral features that can be invoked to request 
some behavior from the classifier. Or a class may be modeled as being active, meaning that an instance of the class has 
some autonomous behavior.
The behavioral characteristics of primarily structural modeling constructs make high-level statements about the 
behavior of a system that may generally be verified when the system is in a stable state at some specific point in time. 
However, they do not define how the system actually got into that state from a previous state, just that some behavior 
must have happened to cause this change. The detailed definition of transient behavior over time requires the use of 
behavioral modeling constructs.
In many cases, a structural element in a UML model will have related behavioral elements that define the detailed 
behavior to realize the high-level behavior identified for the structural element. For example, an operation owned by a 
class may have a related method that defines its detailed behavior. Or an active class may have a classifier behavior that 
details its autonomous behavior. In these cases, it is the responsibility of the modeler to ensure that the detailed transient 
behavior specified using the behavioral modeling elements actually results in the high-level stable behavior specified 
for the corresponding structural elements. (A tool may assist the modeler in this responsibility, but a conforming UML 
tool is not required to do so.)
The following are some areas in which this semantic distinction is particularly important in UML.

• Operation behaviors. An operation is a behavioral feature of a class that may be directly invoked on instances 

of that class (see sub clause 9.6). The definition of an operation includes the types of input and output 
parameters of the operation and may also include pre- and postconditions on the state of the system being 
modeled before and after invocation of the operation. The semantics of such a model are that, if the operation 
is invoked with inputs of the given types and in a state in which the precondition holds, then, when the invoked 
behavior of the operation completes, it will have produced outputs of the given types and the postcondition will 
hold in the resulting system state. An operation may also have a method, which is a detailed definition of its 
required behavior (see sub clause 13.2). It is a modeler responsibility to ensure that the detailed behavior 
modeled by the method of the operation meets the behavioral requirements given by the pre- and 
postconditions of the operation. Note, however, that the postcondition is not required to hold during the 
transient execution of the method behavior, but only at the stable point of the completion of execution of that 
behavior. A class may also have invariant conditions that must be true before and after the execution of the 
operation but may be violated during the course of the execution of the operation method.

•

•

Property default values. The semantics of properties specify that, when a property with a default value is 
instantiated, in the absence of some specific setting for the property, the default value is evaluated to provide 
the initial values of the property (see sub clause 9.5). Thus, when instantiating a classifier, all its attributes (i.e., 
properties of the classifier) with default values should be properly initialized once any behavior required to 
instantiate the classifier completes. However, a create object action is specified to create an object with its 
attributes initially having no initial values, whether or not those attributes have default values in the classifier 
of the object (see sub clause 16.4.3). Therefore, when modeling the detailed behavior of the instantiation of a 
classifier, it is a modeler responsibility to ensure that the modeled behavior carries out the proper initialization 
of any attributes with default values once the object is created. (This is often done by encapsulating the 
instantiation behavior for a class in a constructor operation – see sub clause 11.4 – in which case the 
initialization of the attributes becomes an implicit postcondition for the constructor.)

Active class behaviors. The semantics of active classes specify that, when such a class is instantiated, the new 
object commences execution of its behavior as a direct consequence of its creation (see sub clause 11.4). 
However, a create object action is specified to create an object without commencing the execution of any 
associated behaviors (see sub clause 16.4.3). Instead, it is necessary to use a start object behavior action to 
execute those behaviors (see sub clause 16.3.3). Therefore, when modeling the detailed behavior of the 
instantiation of a classifier, it is a modeler responsibility to ensure that the modeled behavior properly starts the 

Unified Modeling Language 2.5

15

classifier behavior of an instance of an active class, after that instance is created. (This behavior may also be 
encapsulated in a constructor operation for the class.)

How to Read this Specification
Specification Format

6.4
6.4.1
The rest of this document contains the technical content of this specification.
The concepts of UML are grouped into clauses. A clause typically covers a specific modeling formalism. For instance, 
all concepts related to state machine modeling are gathered in the State Machines clause and all concepts related to 
activities modeling are in the Activities clause.
The clauses in the specification as a whole are presented in an order that minimizes forward references. Clauses  7 – 12 
are primarily concerned with the modeling of structure. Clauses 13 – 17 are primarily concerned with the modeling of 
behavior. Clauses 18 – 20 cover supplementary concepts including UseCases, Deployments, and InformationFlows. 
Clauses 21 and 22 specify primitive types and the standard profile.
Annex A discusses UML Diagrams. Annex B specifies a model for the interchange of UML diagrams: this is a new part 
of the specification that was absent from earlier versions of UML. Annex C specifies keywords; Annex D specifies 
some alternative tabular notations; Annex E specifies the format for XMI serialization.
Although the clauses are organized in a logical manner and can be read sequentially, this is a reference specification and 
is intended to be read in a non-sequential manner. Consequently, extensive cross-references are provided to facilitate 
browsing and search.
Within each clause, there is first a brief informal description of the concepts described in that clause. The clause is then 
split into sub clauses, each describing a coherent set of concepts that constitute a portion of the formalism specified by 
the clause. Each sub clause is then split into Abstract Syntax, Semantics, Notation, and Examples.
The Abstract Syntax subdivision contains one or more diagrams that define that capability in terms of a MOF model 
(i.e., the UML metamodel) with each modeling concept represented by an instance of a metaclass or association. These 
diagrams are designed to provide information about a related set of concepts. Within such a diagram, all of the 
metaclasses described in that clause are depicted with their attribute compartments, while metaclasses whose definition 
appears in another clause are depicted with just their headers and no compartments.
The following stylistic conventions are applied in the Semantics, Notation, and Examples subdivisions:

• Headings without numbers are used to break up the sections into meaningful chunks. These headings are 

organized by coherent chunks of tightly-coupled semantics. Often these headings will turn out to be pluralized 
metaclass names (e.g., Comments); they might equally represent particular semantic themes (e.g., Run-to-
Completion).

•

Italics are used for emphasis.

• Names of metaclasses in the text are capitalized but otherwise used as if they are nouns in English, e.g., “Every 

Element has the inherent capability of owning other Elements,” pluralizing where necessary.

• Names of properties in the text are styled as 8-point Arial, and used as if they are English nouns pluralizing 

where necessary, e.g., “the ownedAttributes of the Classifier.”

The Semantics subdivision specifies the semantics of all of the concepts described in the sub clause.
The Notation subdivision specifies the notation corresponding to all of the concepts defined in the sub clause. Only 
concepts that can appear in diagrams will have a notation specified. For textual notations a variant of the Backus-Naur 
Form (BNF) is often used to specify the legal formats. The conventions of this BNF are:

16

Unified Modeling Language 2.5

• All non-terminals are in italics and enclosed between angle brackets (e.g., <non-terminal>).

• All terminals (keywords, strings, etc.), are enclosed between single quotes (e.g., ‘or’).

• Non-terminal production rule definitions are signified with the ‘::=’ operator.

•

Repetition of an item is signified by an asterisk placed after that item: ‘*’.

• Alternative choices in a production are separated by the ‘|’ symbol (e.g., <alternative-A> | <alternative-B>).

•

Items that are optional are enclosed in square brackets (e.g., [<item-x>]).

• Where items need to be grouped they are enclosed in simple parenthesis; for example:

(<item-1> | <item-2>) * 

signifies a sequence of one or more items, each of which is <item-1> or <item-2>.

NOTE. As for all UML surface syntax, UML textual notations are generally for presentation. There is no requirement 
that such notations be unambiguously parsable — for example, a modeler may use arbitrary characters like “/” and “:” 
in a property name, even though these are used as special punctuation in the BNF for property textual notation. This 
may be confusing to some readers, since BNF is commonly used to specify parsable programming language text.
The Examples subdivision gives examples intended to illustrate the concepts in the sub clause.
NOTE. All examples in this specification are provided for the purposes of illustrating syntax and semantics of UML 
modeling constructs and do not assert or claim facts about the world.
Diagrams appearing in the Notation and Examples subdivisions have been produced by a variety of tools, and may 
differ in stylistic details such as fonts, line thicknesses, size of arrowheads, etc. Such differences are not material to the 
specification.
Statements in the Notation subdivision assume that diagrams are to be rendered in black on a white background. 
Conforming tools may adopt other color schemes, in which case the word “black” shall be interpreted as “solid”, 
“white” shall be interpreted as “un-filled”, and “gray” shall be interpreted as “a distinguishable color between solid and 
un-filled”.
Finally in each clause are machine-generated sub clauses called Classifier Descriptions and Association Descriptions, 
containing a complete description for all of the classifiers and associations in the metamodel. In Classifier Descriptions, 
each classifier (Class, Abstract Class, or Enumeration) is documented under the following headings:

• Name [Type]

• Description: a summary of the role played by the classifier in the metamodel.

• Diagrams: a list of links to diagrams in which the classifier appears.

• Generalizations: a list of links to generalizing classifiers, if any.

•

Specializations: a list of links to specializing classifiers, if any.

• Attributes: each specified by its name, type, and multiplicity, and any additional properties such as {readOnly}. 

If no multiplicity is listed, it defaults to 1..1. This is followed by a textual description of the purpose and 
meaning of the attribute. If an attribute is derived, the name will be preceded by a forward slash. Where an 
attribute is derived, the logic of the derivation is in most cases shown using OCL.

Unified Modeling Language 2.5

17

• Association Ends: each specified by its name, type, and multiplicity, any additional properties such as {union}, 
and a link to its opposite end. If the association end subsets or redefines others, this is shown in the additional 
properties as {subsets <end>} or {redefines <end>}, where <end> is a link to the applicable end. This is 
followed by a textual description of the purpose and meaning of the association end. If an association end is 
derived, the name will be preceded by a forward slash. If the association end is a composition, this is indicated 
by a small black diamond adjacent to the name of the end.

• Derivation: where an Attribute or Association End is marked as derived and is not a derived union, the 

derivation is specified by an Operation with the same name and type as the derived Attribute or Association 
End.

• Operations: each specified by its signature, a textual description of the logic of the operation, and a 

specification of the logic of the operation in OCL. Note that in some cases the OCL is absent. Note also that 
the body: of each operation is shown as an expression <expr> having the result type of the Operation. In the 
XMI, this is serialized as a bodyCondition of the form result = (<expr>).

•

Constraints: each specified by its name, a textual description of the logic of the constraint, and a specification 
of the logic of the constraint in OCL. Note that in some cases the OCL is absent.

In Association Descriptions , each association is documented under the following headings:

• Name [Type].

• Diagrams: a list of links to diagrams in which the association appears.

• Generalizations: a list of links to generalizing associations, if any.

•

Specializations: a list of links to specializing associations, if any.

• Member Ends: links to each end of the association; this appears if neither of the ends is owned by the 

association itself.

• Owned Ends: documentation for each association end owned by the association itself, each specified by its 
name, type and multiplicity, any additional properties such as {union}, and a link to its opposite end. If the 
association end subsets or redefines others, this is shown in the additional properties as {subsets <end>} or 
{redefines <end>}, where <end> is a link to the applicable end. If an association end is derived, the name will 
be preceded by a forward slash.

Diagram Format

6.4.2
The following conventions are adopted for all metamodel diagrams throughout this specification.
• A metaclass may appear on many diagrams, but takes a primary role on only one diagram, which is the diagram 
adjacent to where the semantics of the metaclass are described. A metaclass in a primary role is shown with its 
attribute compartment expanded; a metaclass in a secondary role is shown as just its header rectangle.

• Dot notation is used to denote association end ownership, where the dot shows that the Class at the other end of the 

line owns the Property whose type is the Class touched by the dot. See 11.5.4 for details of Association notation 
and 11.5.5 for examples.

• Arrow notation is used to denote association end navigability. By definition, all class-owned association ends are 

navigable. By convention, all association-owned ends in the metamodel are not navigable.

18

Unified Modeling Language 2.5

• An association with neither end marked by navigability arrows means that the association is navigable in both 

directions.

• Association specialization and redefinition are indicated by appropriate constraints situated in the proximity of the 

association ends to which they apply. Thus:

•

•

The constraint {subsets endA} means that the association end to which this constraint is applied subsets 
the association end endA.

The constraint {redefines endA} means that the association end to which this constraint is applied 
redefines the association end endA.

•

•

If no multiplicity is shown on an association end, it implies a multiplicity of exactly 1.

If an association end is unlabeled, the default name for that end is the name of the class to which the end is 
attached, modified such that the first letter is a lowercase letter. Note that, by convention, non-navigable association 
ends are often left unlabeled although all association ends have a name which is documented in the Association 
Description section of each clause.

• Associations that are not explicitly named, are given names that are constructed according to the following 

production rule:

"A_" <association-end-name1> "_" <association-end-name2>

where <association-end-name1> is the name of the first association end and <association-end-name2> is the name 
of the second association end.

Acknowledgements
Primary Authors

6.5
6.5.1
The following people wrote this specification, incorporating the work of authors of earlier versions of UML:
Conrad Bock, Steve Cook (lead), Pete Rivett, Tom Rutt, Ed Seidewitz, Bran Selic, Doug Tolbert

Technical Support

6.5.2
The following people provided technical support for this specification, including writing tools to generate portions of 
the document and to validate the OCL:
Peter Denno, Maged Elaasar, Nicolas Rouquette, Ed Willink

Reviewers

6.5.3
In addition to the authors and technical supporters, the following people provided invaluable contributions by reviewing 
some or all of the specification in detail:
Omar Bahy Badreddin, Neil Capey, Michael Jesse Chonoles (lead), Adriano Comai, Lenny Delligatti, Sanford 
Friedenthal, Dave Hawkins, Darren Kumasawa, Jim Logan, Sam Mancarella, Milagros Nguyen, Axel Scheithauer, John 
Watson, Marc-Florian Wendland, Ed Willink.

Unified Modeling Language 2.5

19

Submitters

6.5.4
The following companies were submitters of this specification: 88solutions, Adaptive, Deere&Company, Fujitsu, 
International Business Machines, Microsoft Corporation, Model Driven Solutions, No Magic Inc, Sparx Systems and 
Unisys.

20

Unified Modeling Language 2.5

Common Structure
Summary

7
7.1
This clause specifies the basic modeling concepts underlying all structural modeling in UML. Many of the metaclasses 
defined here are abstract, providing the base for specialized, concrete classes defined in subsequent clauses. However, 
in order to provide examples of how these basic concepts are applied in UML, it is necessary to use these concrete 
modeling constructs, even though they are specified in later clauses. Appropriate forward references are provided as 
necessary.

Root
Summary

7.2
7.2.1
The root concepts of Element and Relationship provide the basis for all other modeling concepts in UML.

7.2.2

Abstract Syntax

{readOnly, union, subsets
relatedElement}

+ /source
1..*
{readOnly, union, subsets
relatedElement}

+ /target
1..*

{readOnly, union}
+ /relatedElement
1..*

Element

+ annotatedElement
*

{subsets owner}
+ owningElement
0..1

{readOnly, union}
+ /owner
0..1

*

+ /ownedElement
{readOnly, union}

{readOnly, union}
+ /relationship
*

Relationship

{subsets ownedElement}

* + ownedComment

Comment

+ body : String [0..1]

+ comment
*

{readOnly, union, subsets relationship}

+ /directedRelationship

*

DirectedRelationship

{readOnly, union, subsets relationship}
+ /directedRelationship
*

Figure 7.1  Root

Unified Modeling Language 2.5

21

7.2.3

7.2.3.1

Semantics

Elements

An Element is a constituent of a model. Descendants of Element provide semantics appropriate to the concept they 
represent.
Every Element has the inherent capability of owning other Elements. When an Element is removed from a model, all its
ownedElements are also necessarily removed from the model. The abstract syntax for each kind of Element specifies 
what other kind of Elements it may own. Every Element in a model must be owned by exactly one other Element of that 
model, with the exception of the top-level Packages of the model (see also Clause 12 on Packages).

7.2.3.2

Comments

Every kind of Element may own Comments. The ownedComments for an Element add no semantics but may represent 
information useful to the reader of the model.

7.2.3.3

Relationships

A Relationship is an Element that specifies some kind of relationship between other Elements. Descendants of 
Relationship provide semantics appropriate to the concept they represent.
A DirectedRelationship represents a Relationship between a collection of source model elements and a collection of 
target model elements. A DirectedRelationship is said to be directed from the source elements to the target elements.

Notation

7.2.4
There is no general notation for Element, Relationships, and DirectedRelationships. The descendants of these classes 
define their own notation. For Relationships, in most cases the notation is a variation on a line drawn between the 
relatedElements. For DirectedRelationships, the line is usually directed in some way from the source(s) to the target(s).
A Comment is shown as a rectangle with the upper right corner bent (this is also known as a “note symbol”). The 
rectangle contains the body of the Comment. The connection to each annotatedElement is shown by a separate dashed 
line. The dashed line connecting the note symbol to the annotatedElement(s) may be suppressed if it is clear from the 
context, or not important in this diagram.

7.2.5

Examples

Figure 7.2  Comment notation

Templates
Summary

7.3
7.3.1
Templates are model Elements that are parameterized by other model Elements. This sub clause specifies the general 
concepts applicable to all kinds of templates. Further details of specific kinds of templates allowed in UML are 
discussed in later sub clauses, including Classifier templates (see sub clause 9.3), Operation templates (see sub clause 
9.6) and Package templates (see sub clause 12.2).

22

Unified Modeling Language 2.5

7.3.2

Abstract Syntax

Element

TemplateSignature

{subsets ownedElement}
+ ownedTemplateSignature

{subsets templateSignature,
subsets owner}

+ signature

1

{ordered, subsets ownedElement,
subsets parameter}

+ ownedParameter

*

0..1

* + templateSignature

{ordered}

1..* + parameter

{subsets owner}
+ template
1

TemplateableElement

TemplateParameter

{subsets templateParameter,
subsets owner}

+ owningTemplateParameter

0..1

{subsets ownedElement,
subsets parameteredElement}
+ ownedParameteredElement
0..1

+ templateParameter

+ parameteredElement

ParameterableElement

0..1

+ templateParameter

*

{subsets owner, redefines
templateParameter}
+ templateParameter

0..1

1

+ default

0..1
{subsets ownedElement,
subsets default}

+ ownedDefault

0..1

Figure 7.3  Templates

Element

Element

TemplateParameter

ParameterableElement

+ formal

1

+ actual
1

+ templateParameterSubstitution
*

TemplateParameterSubstitution

+ templateParameterSubstitution
*

{subsets ownedElement,
subsets actual}
+ ownedActual

*

0..1

+ owningTemplateParameterSubstitution

{subsets owner, redefines
templateParameterSubstitution}

{subsets ownedElement}
* + parameterSubstitution

TemplateableElement

TemplateSignature

{subsets source,
subsets owner}
+ boundElement

1
{subsets target}
+ signature

1

{subsets ownedElement, subsets
directedRelationship}

1

{subsets owner}
+ templateBinding

+ templateBinding

TemplateBinding

*

{subsets directedRelationship}

+ templateBinding

*

Figure 7.4  Template bindings

Unified Modeling Language 2.5

DirectedRelationship

23

7.3.3

7.3.3.1

Semantics

Templates

A TemplateableElement is an Element that can optionally be defined as a template and bound to other templates. A 
template is a TemplateableElement that is parameterized using a TemplateSignature. Such a template can be used to 
generate other model Elements using TemplateBinding relationships.
A template cannot be used in the same manner as a non-template Element of the same kind (e.g., a template Class 
cannot be used as the type of a TypedElement). The template Element can only be used to generate bound Elements or 
as part of the specification of another template (e.g., a template Class may specialize another template Class).
The TemplateSignature of a template defines a set of TemplateParameters that may be bound to actual model Elements 
in a bound element for the template. A bound element is a TemplateableElement that has one or more such 
TemplateBindings.
A completely bound element is a bound element all of whose TemplateBindings bind all the TemplateParameter of the 
template being bound. A completely bound element is an ordinary element and can be used in the same manner as a 
non-bound (and non-template) element of the same kind. For example, a completely bound element of a Class template 
may be used as the type of a Typed Element.
A partially bound element is a bound element at least one of whose TemplateBindings does not bind a 
TemplateParameter of the template being bound. A partially bound element is still considered to be a template, 
parameterized by the remaining TemplateParameters left unbound by its TemplateBindings.

7.3.3.2

Template Signatures

The TemplateParameters for a TemplateSignature specify the formal parameters that will be substituted by actual 
parameters (or the default) in a binding. A TemplateParameter is defined in terms of a ParameterableElement contained 
within the template that owns the TemplateSignature of which the TemplateParameter is a part. Such an element is said 
to be exposed by the TemplateParameter.
An exposed ParameterableElement may be owned, directly or indirectly, by the template or it may be owned by the 
TemplateParameter itself, in situations in which the element does not otherwise have an ownership association within 
the template model. In either case, the ParameterableElement is meaningful only within the context of the template—it 
will be effectively replaced by an actual Element in the context of a binding. Thus, a ParameterableElement exposed by 
a TemplateParameter cannot be referenced outside its owning template or other templates that have access to the 
internals of the original template (e.g., if the template is specialized). Subclasses of TemplateSignature can also add 
additional rules that constrain what sort of ParameterableElement can be used for a TemplateParameter in the context of 
a particular kind of template.
A TemplateParameter may also reference a ParameterableElement as the default for this formal parameter in any 
TemplateBinding that does not provide an explicit TemplateParameterSubstitution for the parameter. Similarly to an 
exposed ParameterableElement, a default ParameterableElement may be owned either directly by the template or by the 
TemplateParameter itself. The TemplateParameter may own this default ParameterableElement even in situations where 
the exposed ParameterableElement is not owned by the TemplateParameter.

7.3.3.3

Template Bindings

A TemplateBinding is a relationship between a TemplateableElement and a template that specifies the substitutions of 
actual ParameterableElements for the formal TemplateParameters of the template. A TemplateParameterSubstitution 
specifies the actual parameter to be substituted for a formal TemplateParameter within the context of a TemplateBinding. 
If no actual parameter is specified in this binding for a formal parameter, then the default ParameterableElement for that 
formal TemplateParameter (if specified) is used.
A bound element may have multiple bindings, possibly to the same template. In addition, the bound element may 
contain elements other than the bindings. The details of how the expansions of multiple bindings, and any other 
Elements owned by the bound element, are combined together to fully specify the bound element are specific to the 
subclasses of TemplateableElement. The general principle is that one evaluates the bindings in isolation to produce 

24

Unified Modeling Language 2.5

intermediate results (one for each binding), which are then merged to produce the final result. It is the way the merging 
is done that is specific to each kind of TemplateableElement.
A TemplateableElement may contain both a TemplateSignature and TemplateBindings. Thus a TemplateableElement 
may be both a template and a bound element.
A conforming tool may require that all formal TemplateParameters must be bound as part of a TemplateBinding 
(complete binding) or may allow just a subset of the formal TemplateParameters to be bound (partial binding). In the 
case of complete binding, the bound element may have its own TemplateSignature, and the TemplateParameters from 
this can be provided as actual parameters of the TemplateBinding. In the case of partial binding, the unbound formal 
TemplateParameters act as formal TemplateParameters of the bound element, which is thus still a template.
NOTE. A TemplateParameter with a default can never be unbound, as it has an implicit binding to the default, even if an 
explicit TemplateParameterSubstitution is not given for it.

7.3.3.4

Bound Element Semantics

ATemplateBinding implies that the bound element has the same well-formedness constraints and semantics as if the 
contents of the template owning the target TemplateSignature were copied into the bound element, substituting any 
ParameterableElements exposed as formal TemplateParameters by the corresponding ParameterableElements specified 
as actual template parameters in the TemplateBinding. However, a bound element does not explicitly contain the model 
Elements implied by expanding the templates to which it binds. Nevertheless, it is possible to define an expanded 
bound element that results from actually applying the TemplateParameterSubstitution for a bound element to the target 
templates.
Formally, an expanded bound element for a bound element with a single TemplateBinding and no Elements other than 
from that binding is constructed as follows:

1 Copy the template associated with the TemplateSignature that is the target of the TemplateBinding. For the 

present purposes, a copy of a model Element is an instance of the same metaclass as the original model 
Element, with:

a Values for all composite properties (owned attributes and owned association ends) that are copies (in 

the same sense) of the corresponding values from the original Element.

b Values for all non-composite properties that are the same as the corresponding values from the 

original Element, except that references to Elements owned (directly or indirectly) by the original 
Element are replaced with references to the copies of those Elements created as specified above and 
references to the original Element itself are replaced by references to the copy.

2

3

If the copy specializes any Elements that are templates, then redirect the Generalization relationships to 
equivalent bound elements for the general elements, using the same TemplateBinding. If the copy is an 
Operation that has an associated method that is also a template, then replace that method with an equivalent 
bound element using the same template binding.
NOTE. It is necessary for the method of a template Operation to also be a template, presumably with 
TemplateParameters corresponding to those of the Operation. In particular, Operation TemplateParameters are 
typically used to parameterize the types of Operation Parameters, but the method of an Operation does not 
directly reference the Parameters of the Operation that specifies it. Rather, the method has its own 
ownedParameter list, which should match that of the Operation (see sub clause 13.2). The types of the method 
Parameters thus need to be separately templated to match the template parameterization of the Operation.
For each Element owned directly or indirectly by the copy, replace any reference to the parameteredElement of 
a TemplateParameter of the copy with a reference to the actual Element associated with the parameter in the 
TemplateBinding. If an actual Element has a TemplateBinding itself, then reference the equivalent bound 
element.

4 Remove all TemplateParameters that are referenced in the TemplateBinding from the TemplateSignature of the 

copy. If this would remove all TemplateParameters from the TemplateSignature, then remove the 
TemplateSignature entirely.

Unified Modeling Language 2.5

25

If a bound element has more than one TemplateBinding, then a specific expanded bound element can be defined based 
on each TemplateBinding. The overall expanded bound element is then constructed by merging all the 
TemplateBinding-specific expanded bound elements with any other Elements contained by the original bound element. 
As noted previously, how this merging is performed depends on the kind of TemplateableElement being bound.
Including a bound element in a model does not automatically require that the corresponding expanded bound element be 
included in the model. However, if the expanded bound element constructed as given above violates any well-
formedness constraints, then the original bound element is also considered to not be well formed.
On the other hand, if the bound element is for a Namespace template, then it may be necessary to be able to refer to 
members of the bound element considered as a Namespace itself. For example, for a bound element of a Class template, 
it may be necessary to reference Operations of that Class, e.g., from a CallOperationAction.
NOTE. Referencing the Operation from the template is not sufficient, as each bound element of the template Class is to 
be considered to have its own effective copy of the Operations of the template.
In order to accommodate a situation like this, it is allowable to include in a model the expanded bound element for a 
bound element in addition to the bound element itself. In this case, the expanded bound element must have a realization 
dependency (see sub clause 7.7) to the bound element that it is expanding. The expanded bound element must be 
constructed (either manually by the modeler or automatically by a tool) according to the rules given above. References 
then made as usual from other model elements to visible members of the expanded bound element are considered to be 
semantically equivalent to effective references made to the corresponding implicit members of the original bound 
element. Any relationships made directly to the expanded bound element are semantically equivalent to relationships 
made to the bound element itself.

Notation

7.3.4
If a TemplateableElement has TemplateParameters, a small dashed rectangle is superimposed on the symbol for the 
TemplateableElement, typically on the upper right-hand corner of the notation (if possible). The dashed rectangle 
contains a list of the formal TemplateParameters. The parameter list must not be empty, although it may be suppressed 
in the presentation. Any other compartments in the notation of the TemplateableElement appear as normal.
The formal TemplateParameter list may be shown as a comma-separated list, or it may be one formal 
TemplateParameter per line. The general notation for a TemplateParameter is a string displayed within the 
TemplateParameter list for the template:
<template-parameter> ::= <template-param-name> [‘:’ <parameter-kind> ] [‘=’ <default>]
where <parameter-kind> is the name of the metaclass for the exposed element. The syntax of <template-param-name> 
and <default> depend on the kind of ParameteredElement for this TemplateParameter.
A bound element has the same graphical notation as other Elements of that kind. A TemplateBinding is shown as a 
dashed arrow with the tail on the bound element and the arrowhead on the template and the keyword «bind». The 
binding information may be displayed as a comma-separated list of template parameter substitutions:
<template-param-substitution> ::= <template-param-name> ‘->’ <actual-template-parameter>
where the syntax of <template-param-name> is the name or qualifiedName of the parameteredElement of the formal 
TemplateParameter and the kind of <actual-template-parameter> depends upon the kind of ParameteredElement for 
that TemplateParameter.
An alternative presentation for the bindings for a bound element is to include the binding information within the 
notation for the bound element. The name of the bound element is extended to contain binding expressions with the 
following syntax:
[<element-name> ‘:’] <binding-expression> [‘,’ <binding-expression>]*
<binding-expression> ::= <template-element-name> ‘<‘ <template-param-substitution> [‘,’<template-param-
substitution]*‘>’

26

Unified Modeling Language 2.5

and <template-param-substitution> is defined as above.

Namespaces
Summary

7.4
7.4.1
A Namespace is an Element in a model that contains a set of NamedElements that can be identified by name. Packages 
(see Clause 12) are Namespaces whose specific purpose is to contain other NamedElements in order to organize a 
model, but many other kinds of model Elements are also Namespaces, including Classifiers (see sub clause 9.2), which 
contain named Features and nested Classifiers, and BehavioralFeatures (see sub clause 9.4), which contain named 
Parameters.

7.4.2

Abstract Syntax

{readOnly, union, subsets member,
subsets ownedElement}

Element

+ /ownedMember
*

*

NamedElement

+ name : String [0..1]
+ /qualifiedName : String [0..1] {readOnly}
+ visibility : VisibilityKind [0..1]

{subsets owner}
+ namedElement

{subsets ownedElement}
+ nameExpression

0..1

0..1

«enumeration»
VisibilityKind

public
private
protected
package

StringExpression

ParameterableElement

{subsets namespace}

+ context

{subsets ownedMember}

+ ownedRule

Constraint

Package

0..1

*

Figure 7.5  Namespaces

7.4.3

7.4.3.1

Semantics

Namespaces

A Namespace provides a container for NamedElements, which are called its ownedMembers. A Namespace may also 
import NamedElements from other Namespaces, in which case these, along with the ownedMembers, are members of the 
importing Namespace. If a member of a Namespace with the name N is a NamedElement with the name x, then the 
member can be referred to by a qualified name of the form N::x.

Unified Modeling Language 2.5

27

+ /member
{readOnly, union}

+ /memberNamespace
*

{readOnly, union}

0..1

+ /namespace

{readOnly, union, subsets
memberNamespace,
subsets owner}

Namespace

{readOnly, subsets member}

+ /importedMember

*
+ namespace
{subsets memberNamespace}

*

PackageableElement

+ visibility : VisibilityKind [0..1] = public {redefines visibility}

1

+ importedElement
{subsets target}

1

+ importingNamespace
{subsets source,
subsets owner}

{subsets source,
subsets owner}

+ importingNamespace

1

{subsets ownedElement, subsets
directedRelationship}

{subsets directedRelationship}

* + import

ElementImport

+ elementImport

*

+ alias : String [0..1]
+ visibility : VisibilityKind = public

DirectedRelationship

{subsets ownedElement, subsets
directedRelationship}

+ packageImport

PackageImport

*

+ visibility : VisibilityKind = public

*

1

+ packageImport
{subsets directedRelationship}

{subsets target}
+ importedPackage

When a distinction is necessary, a simple name that is not qualified with Namespace names may be referred to as an 
unqualified name. Within a Namespace, unqualified names may be used to refer to the members of that Namespace and 
to outer names that are not hidden. An outer name is the name of a NamedElement that may be referenced using an 
unqualified name in an immediately enclosing Namespace. An outer name is hidden unless it is distinguishable from all 
members of the inner Namespace. (See the discussion on distinguishability below under “Named Elements”.)
As a Namespace is itself a NamedElement, the fully qualified name of a NamedElement may include multiple 
Namespace names, such as N1::N2::x.
The ownedRule Constraints for a Namespace represent well-formedness rules for the constrained elements (see sub 
clause 7.6 on Constraints). These constraints are evaluated when determining if the constrained elements are well-
formed.

7.4.3.2

Named Elements

A NamedElement is an Element in a model that may have a name. The name may be used for identification of the 
NamedElement within Namespaces where its name is accessible.
NOTE. The name of a NamedElement is optional, which provides for the possibility of the absence of a name (which is 
different from the empty name).
NamedElements may appear within a Namespace according to rules that specify how one NamedElement is 
distinguishable from another. The default rule is that two members are distinguishable if they have different names or if 
they have the same names, but their metaclasses are different and neither is a (direct or indirect) subclass of the other. 
This rule may be overridden for particular cases, such as Operations that are distinguished by their signature (see sub 
clause 9.6).
The visibility of a NamedElement provides a means to constrain the usage of the Element, either in Namespaces or in 
access to the Element. It is intended for use in conjunction with import, generalization, and access mechanisms.
A NamedElement may, in addition to having an explicit name, be associated with a StringExpression (see sub clause 
8.3) that may be used to specify a calculated name for the NamedElement. In a template (see sub clause 7.3), a 
NamedElement may have an associated StringExpression whose subexpressions may be ParameteredElements exposed 
by TemplateParameters. When the template is bound, the exposed subexpressions are substituted with the actuals 
substituted for the TemplateParameters. The value of the StringExpression is then a string resulting from concatenating 
the values of the subexpression, which then provides the name of the NamedElement.
A NamedElement may have both a name and a nameExpression associated with it. In this case, the name can be used as an 
alias for the NamedElement, which may be used, for example, in referencing the element in a Constraint expression. 
(This avoids the need to use StringExpressions in textual surface notation, which is often cumbersome, although it does 
not preclude it.)

7.4.3.3

Packageable Elements and Imports

A PackageableElement is a NamedElement that may be owned directly by a Package (see Clause 12 on Packages). Any 
such element may serve as a TemplateParameter (see sub clause 7.3 on Templates).
An ElementImport is a DirectedRelationship between an importing Namespace and a PackageableElement. It adds the 
name of the PackageableElement to the importing Namespace. The visibility of the ElementImport may be either the 
same or more restricted than that of the imported element.
In case of a name clash with an outer name (an element that is defined in an enclosing Namespace that is available using 
its unqualified name in enclosed Namespaces) in the importing Namespace, the outer name is hidden by an 
ElementImport, and the unqualified name refers to the imported element. The outer name can be accessed using its 
qualified name.
A PackageImport is a DirectedRelationship between an importing Namespace and a Package, indicating that the 
importing Namespace adds the names of the members of the Package to its own Namespace. Conceptually, a Package 
import is equivalent to having an ElementImport to each individual member of the imported Namespace, unless there is 

28

Unified Modeling Language 2.5

a separately-defined ElementImport. If there is an ElementImport for an Element, then this takes precedence over a 
potential import of the same Element via a PackageImport.
If indistinguishable Elements would be imported into a Namespace as a consequence of ElementImports or 
PackageImports, the Elements are not added to the importing Namespace and the names of those Elements must be 
qualified in order to be used in that Namespace. If the name of an imported Element is indistinguishable from an 
Element owned by the importing Namespace, that Element is not added to the importing Namespace and the name of 
that Element must be qualified in order to be used.
An Element that is publicly imported is a public member of the importing Namespace. This means that, if the 
Namespace is a Package, a PackageImport of it by another Namespace will result in the further import of those publicly 
imported members into the other Namespace, in addition to the public ownedMembers of the Package.
NOTE. A Namespace may not import itself, nor may it import any of its own ownedMembers. This means that it is not 
possible for a NamedElement to acquire an alias in its owning Namespace.

7.4.4

7.4.4.1

Notation

Namespaces

There is no general notation for Namespaces. Specific kinds of Namespace have their own specific notation.
Conforming tools may optionally allow the “circle-plus” notation defined in sub clause 12.2.4 to show Package 
membership to also be used to show membership in other kinds of Namespaces (for example, to show nestedClassifiers 
and ownedBehaviors of Classes).

7.4.4.2

Name Expressions

The nameExpression associated with a NamedElement can be shown in two ways, depending on whether an alias is 
required or not. Both notations are illustrated in Figure 7.6.

No alias: The StringExpression appears as the name of the model Element.

•
• With alias: Both the StringExpression and the alias are shown wherever the name usually appears. The alias is 

given first and the StringExpression underneath.

In both cases the StringExpression appears between “$” signs. The specification of Expressions in UML supports the 
use of alternative string expression languages in the abstract syntax—they have to have String as their type and can be 
some structure of operator Expressions with operands. The notation for this is discussed in sub clause 8.3 on Expressions. 
In the context of templates, subexpressions of a StringExpression (usually LiteralStrings) that are parametered in a 
template are shown between angle brackets.

7.4.4.3

Imports

A PackageImport or ElementImport is shown using a dashed arrow with an open arrowhead from the importing 
Namespace to the imported Package or Element. The keyword «import» is shown near the dashed arrow if the visibility 
is public; otherwise, the keyword «access» is shown to indicate private visibility. The alias may be shown after or below 
the keyword «import». If the imported element for an ElementImport is a Package, the keyword may optionally be 
preceded by “element”, i.e., «element import».
As an alternative to the dashed arrow, it is possible to show a PackageImport or ElementImport by having a text that 
uniquely identifies the imported Package or Element within curly brackets either below or after the name of the 
Namespace. The textual syntax for a PackageImport is:
‘{import ’ <qualified-name> ‘}’ | ‘{access ’ <qualified-name> ‘}’
The textual syntax for an ElementImport is:
 ‘{element import’ <qualified-name> ‘}’ | ‘{element access ’ <qualified-name> ‘}’

Unified Modeling Language 2.5

29

Optionally, the alias, if any, may be shown as well:
‘{element import ’ <qualified-name> ‘ as ’ <alias> ‘}’ | ‘{element access ’ <qualified-name> ‘as’ <alias> ‘}’

7.4.5

7.4.5.1

 Examples

Name Expressions

Figure 7.6 shows a ResourceAllocation Package template where the first two formal TemplateParameters are 
StringExpression parameters. These formal TemplateParameters are used within the Package template to name some of 
the Classes and Association ends. The figure also shows a bound Package (named TrainingAdmin) that has two 
bindings to this ResourceAllocation template. The first binding substitutes the string “Instructor” for Resource, the 
string “Qualification” for ResourceKind, and the Class TrainingAdminSystem for System. The second binding 
substitutes the string “Facility” for Resource, the string “FacilitySpecification” for ResourceKind, and the Class 
TrainingAdminSystem is again substituted for System.
The result of the binding includes Classes Instructor, Qualification, and InstructorAllocation as well as Classes Facility, 
FacilitySpecification, and FacilityAllocation. The associations are similarly replicated.
NOTE. Request will have two attributes derived from the single “the<ResourceKind>” attribute (shown here by an 
arrow), namely theQualification and theFacilitySpecification.

30

Unified Modeling Language 2.5

ResourceAllocation

$a<Resource>$

*

Resource: StringExpression, 
ResourceKind: StringExpression,  
System

$<Resource>$

resource

1

Allocation 

$<Resource>Allocation$

allocation 

$a<Resource>Allocation$

*

resource

*

kind

1

TimeSlot

timeSlot

1

System

1

request

$<ResourceKind>$

$the<ResourceKind>$

1

Request

request

*

$a<ResourceKind>$

*

«bind» 
Resource -> "Instructor", 
ResourceKind -> "Qualification", 
System -> TrainingAdminSystem

«bind» 
Resource -> "Facility", 
ResourceKind -> "FacilitySpecification", 
System -> TrainingAdminSystem

TrainingAdmin

Figure 7.6  Template package with string parameters

7.4.5.2

Imports

The ElementImport shown in Figure 7.7 allows Elements in the Package Program to refer by name to the DataType 
Time in Types without qualification. However, they still need to refer explicitly to Types::Integer, as this Element is not 
imported. The DataType String is imported into the Program Package but it is not publicly visible as a member of 
Program outside of that Package, and it cannot be further imported from the Program Package by other Namespaces.

Figure 7.7  Example of element import

Unified Modeling Language 2.5

31

In Figure 7.8, the ElementImport is combined with aliasing, meaning that the DataType Types::Real will be referred to 
by name as Double in the package Shapes.

Figure 7.8  Example of element import with aliasing

In Figure 7.9, a number of PackageImports are shown. The public members of Types are imported into ShoppingCart 
and then further imported into WebShop. However, the members of Auxiliary are only privately imported by 
ShoppingCart and cannot be referenced using unqualified names from WebShop.

Figure 7.9  Examples of public and private package imports

Types and Multiplicity
Summary

7.5
7.5.1
Types and multiplicity are used in the declaration of Elements that contain values, in order to constrain the kind and 
number of values that may be contained.

32

Unified Modeling Language 2.5

7.5.2

Abstract Syntax

NamedElement

PackageableElement

TypedElement

+ typedElement

*

+ type

0..1

Type

Element

MultiplicityElement

+ isOrdered : Boolean = false
+ isUnique : Boolean = true
+ /lower : Integer
+ /upper : UnlimitedNatural

{subsets owner}
+ owningLower
0..1

{subsets owner}
+ owningUpper

0..1

{subsets ownedElement}

+ lowerValue
0..1

{subsets ownedElement}

+ upperValue
0..1

ValueSpecification

Figure 7.10  Abstract syntax of types and multiplicity elements

7.5.3

7.5.3.1

Semantics

Types and Typed Elements

A Type specifies a set of allowed values known as the instances of the Type. Depending on the kind of Type, instances 
of the Type may be created or destroyed over time. However, the rules for what constitutes an instance of the Type 
remain fixed by the definition of that Type. All Types in UML are Classifiers (see Clause 9).
A TypedElement is a NamedElement that, in some way, represents particular values. Depending on the kind of 
TypedElement, the actual values that it represents may change over time. Examples of kinds of TypedElement include 
ValueSpecification, which directly specifies a collection of values (see Clause 8), and StructuralFeature, which 
represents values held as part of the structure of the instances of the Classifier that owns it (see sub clause 9.4).
If a TypedElement has an associated Type, then any value represented by the TypedElement (at any point in time) shall 
be an instance of the given Type. A TypeElement with no associated Type may represent any value.

7.5.3.2

Multiplicities

A MultiplicityElement is an Element that may be instantiated in some way to represent a collection of values. 
Depending on the kind of MultiplicityElement, the values in the collection may change over time. Examples of kinds of 
MultiplicityElement include StructuralFeature, which has values in the context of an instance of the Classifier that owns 
it (see sub clause 9.4) and Variable, which has values in the context of the execution of an Activity (see sub clause 15.2).
The cardinality of a collection is the number of values contained in that collection. The multiplicity of a 
MultiplicityElement specifies valid cardinalities of the collection it represents. The multiplicity is a constraint on the 
cardinality, which shall not be less than the lower bound and not greater than the upper bound specified for the 
multiplicity (unless the multiplicity is unlimited, in which case there is no constraint on the upper bound).
The lower and upper bounds for the multiplicity of a MultiplicityElement are specified by ValueSpecifications (see 
Clause 8), which must evaluate to an Integer value for the lowerBound and an UnlimitedNatural value for the 

Unified Modeling Language 2.5

33

upperBound (see Clause 21 on Primitive Types). A MultiplicityElement is unlimited if its upperBound has the 
UnlimitedNatural value of unlimited (“*”). A MultiplicityElement is multivalued if it has an upperBound greater than 1 
(including unbounded). A MultiplicityElement that is not multivalued can represent at most a single value.
A MultiplicityElement can define a multiplicity both of whose bounds are zero. This restricts the allowed cardinality to 
be 0; that is, it requires that an instantiation of this element contain no values. This is useful in the context of 
Generalizations (see sub clause 9.2) to constrain the cardinalities of a more general Classifier. It applies to (but is not 
limited to) redefining properties existing in more general Classifiers.
If the MultiplicityElement is specified as ordered (i.e., isOrdered is true), then the collection of values in an instantiation 
of this Element is ordered. This ordering implies that there is a mapping from positive integers to the elements of the 
collection of values. If a MultiplicityElement is not multivalued, then the value for isOrdered has no semantic effect.
If the MultiplicityElement is specified as unordered (i.e., isOrdered is false), then no assumptions can be made about the 
order of the values in an instantiation of this Element.
If the MultiplicityElement is specified as unique (i.e., isUnique is true), then the collection of values in an instantiation of 
this Element must be unique. That is, no two values in the collection may be equal, where equality of objects (instances 
of Classes) is based on object identity while equality of data values (instances of DataTypes) and Signal instances is 
based on value (see also sub clauses 10.2, 10.3, and 11.4 on DataTypes, Signals and Classes, respectively ). If a 
MultiplicityElement is not multivalued, then the value for isUnique has no semantic effect.
Taken together, the isOrdered and isUnique properties can be used to specify that the collection of values in an 
instantiation of a MultiplicityElement is of one of four types. Table 7.1shows the traditional names given to each of 
these collection types.
Table 7.1  Collection types for MultiplicityElements

isOrdered

isUnique

Collection Type

false

true

false

true

7.5.4

7.5.4.1

Notation

Multiplicity Element

true

true

false

false

Set

OrderedSet

Bag

Sequence

The specific notation for a MultiplicityElement is defined for each concrete kind of MultiplicityElement. In general, the 
notation will include a multiplicity specification, which is shown as a text string containing the bounds of the 
multiplicity and a notation for showing the optional ordering and uniqueness specifications.
The multiplicity bounds may be shown in the format:
<lower-bound> ‘..’ <upper-bound>
where <lower-bound> is a ValueSpecification of type Integer and <upper-bound> is a ValueSpecification of type 
UnlimitedNatural. The star character (*) is used as part of a multiplicity specification to represent an unlimited upper 
bound.
If the multiplicity is associated with a MultiplicityElement whose notation is a text string (such as an attribute), the 
multiplicity string is placed within square brackets ([ ]) as part of that text string.
If the multiplicity is associated with a MultiplicityElement that appears as a symbol (such as an Association end), the 
multiplicity string is displayed without square brackets and may be placed near the symbol for the element.

34

Unified Modeling Language 2.5

If the lower bound is equal to the upper bound, then an alternate notation is to use a string containing just the upper 
bound. For example, “1” is semantically equivalent to “1..1” multiplicity. A multiplicity with zero as the lower bound 
and an unspecified upper bound may use the alternative notation containing a single star “*” instead of “0..*” 
multiplicity.
The specific notation for the ordering and uniqueness specifications may vary depending on the specific kind of 
MultiplicityElement. A general notation is to use a textual annotation containing “ordered” or “unordered” to define the 
ordering, and “unique” or “nonunique” to define the uniqueness.
The following BNF defines the general syntax for a multiplicity string, including support order and uniqueness 
designators:
<multiplicity> ::= <multiplicity-range> [ [ ‘{‘ <order-designator> [‘,’ <uniqueness-designator> ] ‘}’ ] | 
[ ‘{‘ <uniqueness-designator> [‘,’ <order-designator> ] ‘}’ ] ]
<multiplicity-range> ::= [ <lower> ‘..’ ] <upper>
<lower> ::= <value-specification>
<upper> ::= <value-specification>
<order-designator> ::= ‘ordered’ | ‘unordered’
<uniqueness-designator> ::= ‘unique’ | ‘nonunique’
See also Clause 8 on the textual notation for ValueSpecifications.

Examples

7.5.5
Figure 7.11 shows two multiplicity strings as part of attribute specifications within a class symbol.

Figure 7.11  Multiplicity within a textual specification

Figure 7.12 shows two multiplicity strings as part of the specification of two association ends.

Figure 7.12  Multiplicity as an adornment to a symbol

Constraints
Summary

7.6
7.6.1
A Constraint is an assertion that indicates a restriction that must be satisfied by any valid realization of the model 
containing the Constraint. A Constraint is attached to a set of constrainedElements, and it represents additional semantic 
information about those Elements.

Unified Modeling Language 2.5

35

7.6.2

Abstract Syntax

PackageableElement

Constraint

+ constraint

{ordered}
+ constrainedElement

*

Element

*

{subsets ownedMember}
+ ownedRule

0..1

*

{subsets owner}
+ owningConstraint

{subsets ownedElement}

+ specification

0..1

ValueSpecification

1

{subsets namespace}
+ context

Namespace

Figure 7.13  Abstract Syntax of Constraints

Semantics

7.6.3
The specification of a Constraint is given by a ValueSpecification (see Clause 8) of type Boolean. The computation of 
the specification may reference the constrainedElements of the Constraint and also the context of the Constraint. In 
addition, the context of the Constraint may be used as the Namespace for interpreting names used in the specification 
(for example, in OCL “self” is used to refer to the context element).
In general there are many possible kinds of owners for a Constraint. The only restriction is that the owning Element must 
have access to the constrainedElements. The owner of the Constraint determines when the Constraint specification is 
evaluated. For example, a Constraint that is a precondition of an Operation is evaluated at the start of the invocation of 
the Operation, while a Constraint that is a postcondition is evaluated at the conclusion of the invocation (see sub clause 
9.6 on Operations).
A Constraint is evaluated by evaluating its specification. If the specification evaluates to true, then the Constraint is 
satisfied at that time. If the specification evaluates to false, then the Constraint is not satisfied, and the realization of the 
model in which the evaluation occurs is not valid.

Notation

7.6.4
Certain kinds of Constraints are predefined in UML, others may be user-defined. The specification of a user-defined 
Constraint is often expressed as a text string in some language, whose syntax and interpretation is as defined by that 
language. In some situations, a formal language (such as OCL) or a programming language (such as Java) may be 
appropriate, in other situations natural language may be used. Such a specification may be represented as an 
OpaqueExpression with the appropriate language and body (see sub clause 8.3). The Constraint may then be notated 
textually within braces ({}) according to the following BNF:
<constraint> ::= ‘{‘ [ <name> ‘:’ ] <boolean-expression> ‘ }’
where <name> is the name of the Constraint and <boolean-expression> is the appropriate textual notation for the 
Constraint specification.
Most generally, the constraint string is placed in a note symbol and attached to each of the symbols for the 
constrainedElements by dashed lines. (See Figure 7.14 for an example.)
For a Constraint that applies to a single constrainedElement (such as a single Class or Association), the constraint string 
may be directly placed near the symbol for the constrainedElement, preferably near the name, if any. A tool shall make it 
possible to determine the constrainedElement.
For an Element whose notation is a text string (such as an attribute, etc.), the constraint string may follow the Element 
text string. The Element so annotated is then the single constrainedElement of the Constraint. (Figure 7.15 shows a 
Constraint string that follows an attribute within a Class symbol.)

36

Unified Modeling Language 2.5

For a Constraint that applies to two Elements (such as two Classes or two Associations), the Constraint may be shown 
as a dashed line between the Elements labeled by the constraint string. (See Figure 7.16 for an example.)
If the Constraint is shown as a dashed line between two Elements, then an arrowhead may be placed on one end. The 
direction of the arrow is relevant information within the Constraint. The Element at the tail of the arrow is mapped to 
the first position and the element at the head of the arrow is mapped to the second position in the constrainedElement 
collection.
For three or more paths of the same kind (such as Generalization paths or Association paths), the constraint string may 
be attached to a dashed line crossing all of the paths.

Examples

7.6.5
Figure 7.14 shows an example of a Constraint in a note symbol.

Figure 7.14  Constraint in a note symbol

Figure 7.15 shows a constraint string attached to an attribute.

Figure 7.15  Constraint attached to an attribute

Figure 7.16 shows an {xor} constraint between two associations.

Figure 7.16  {xor} constraint

Unified Modeling Language 2.5

37

Dependencies
Summary

7.7
7.7.1
A Dependency signifies a supplier/client relationship between model elements where the modification of a supplier may 
impact the client model elements.

7.7.2

Abstract Syntax

DirectedRelationship

PackageableElement

NamedElement

{subsets target}

+ supplier
1..*
1 ..*
+ client

{subsets source}

{subsets directedRelationship}

+ supplierDependency
*

*
+ /clientDependency

{subsets directedRelationship}

Dependency

OpaqueExpression

{subsets ownedElement}

+ mapping
0..1

{subsets owner}
+ abstraction

0..1

A b s tra c tio n

Usage

Realization

Figure 7.17  Abstract syntax of dependencies

7.7.3

7.7.3.1

Semantics

Dependency

A Dependency implies that the semantics of the clients are not complete without the suppliers. The presence of 
Dependency relationships in a model does not have any runtime semantic implications. The semantics are all given in 
terms of the NamedElements that participate in the relationship, not in terms of their instances.

7.7.3.2

Usage

A Usage is a Dependency in which one NamedElement requires another NamedElement (or set of NamedElements) for 
its full implementation or operation. The Usage does not specify how the client uses the supplier other than the fact that 
the supplier is used by the definition or implementation of the client.

7.7.3.3

Abstraction

An Abstraction is a Dependency that relates two NamedElements or sets of NamedElements that represent the same 
concept at different levels of abstraction or from different viewpoints. The relationship may be defined as a mapping 
between the suppliers and the clients. Depending on the specific stereotype of Abstraction, the mapping may be formal or 
informal, and it may be unidirectional or bidirectional. Abstraction has predefined stereotypes (such as «Derive», 
«Refine», and «Trace») that are defined in the Standard Profile (see Clause 22). If an Abstraction has more than one 
client, the supplier maps into the set of clients as a group. For example, an analysis-level Class might be split into several 
design-level Classes. The situation is similar if there is more than one supplier.

38

Unified Modeling Language 2.5

7.7.3.4

Realization

Realization is a specialized Abstraction dependency between two sets of NamedElements, one representing a 
specification (the supplier) and the other representing an implementation of that specification (the client). Realization can 
be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework 
composition, etc. A Realization signifies that the set of clients is an implementation of the set of suppliers, which serves 
as the specification. The meaning of “implementation” is not strictly defined, but rather implies a more refined or 
elaborate form in respect to a certain modeling context. It is possible to specify a mapping between the specification and 
implementation elements, although this is not necessarily computable.

Notation

7.7.4
A Dependency is shown as a dashed arrow between two model Elements. The model Element at the tail of the arrow 
(the client) depends on the model Element at the arrowhead (the supplier). The arrow may be labeled with an optional 
keyword or stereotype and an optional name (see Figure 7.18).

NamedElement-1

«keywordOrStereotypeName»  

dependencyName

NamedElement-2

Figure 7.18  Notation for a Dependency between two elements

It is possible to have a set of Elements for the client or supplier. In this case, one or more arrows with their tails on the 
clients are connected to the tails of one or more arrows with their heads on the suppliers. A small dot can be placed on the 
junction if desired. A note on the Dependency should be attached at the junction point.
A Usage is shown as a Dependency with a «use» keyword attached to it.
An Abstraction is shown as a Dependency with an «abstraction» keyword or the specific predefined stereotype attached 
to it.
A Realization is shown as a dashed line with a triangular arrowhead at the end that corresponds to the realized Element.

Examples

7.7.5
In Figure 7.19, the CarFactory Class has a Dependency on the Car Class. In this case, the Dependency is a Usage with 
the standard stereotype «Instantiate» applied, indicating that an instance of the CarFactory Class creates instances of the 
Car Class.

CarFactory

«Instantiate» 

Car

Figure 7.19  An example of an «Instantiate» Dependency

In Figure 7.20, an Order Class requires the Line Item Class for its full implementation.

Figure 7.20  An example of a «use» Dependency

Unified Modeling Language 2.5

39

Figure 7.21 illustrates an example in which the Business class is realized by a combination of Owner and Employee 
classes.

Figure 7.21  An example of a realization Dependency

7.8
7.8.1

7.8.1.1

Classifier Descriptions
Abstraction [Class]

Description

An Abstraction is a Relationship that relates two Elements or sets of Elements that represent the same concept at 
different levels of abstraction or from different viewpoints.

7.8.1.2

Diagrams

Dependencies, Artifacts

7.8.1.3

Generalizations

Dependency

7.8.1.4

Specializations

7.8.1.5
•

Realization, Manifestation

Association Ends

♦ mapping : OpaqueExpression [0..1]{subsets Element::ownedElement} (opposite 
A_mapping_abstraction::abstraction)
An OpaqueExpression that states the abstraction relationship between the supplier(s) and the client(s). In some 
cases, such as derivation, it is usually formal and unidirectional; in other cases, such as trace, it is usually 
informal and bidirectional. The mapping expression is optional and may be omitted if the precise relationship 
between the Elements is not specified.

7.8.2

7.8.2.1

Comment [Class]

Description

A Comment is a textual annotation that can be attached to a set of Elements.

7.8.2.2

Diagrams

Root

40

Unified Modeling Language 2.5

7.8.2.3

Generalizations

Element

Attributes

body : String [0..1]
Specifies a string that is the comment.

Association Ends

annotatedElement : Element [0..*] (opposite A_annotatedElement_comment::comment)
References the Element(s) being commented.

Constraint [Class]

Description

7.8.2.4
•

7.8.2.5
•

7.8.3

7.8.3.1

A Constraint is a condition or restriction expressed in natural language text or in a machine readable language for the 
purpose of declaring some of the semantics of an Element or set of Elements.

7.8.3.2

Diagrams

Namespaces, Constraints, Intervals, Use Cases, Behavior State Machines, Protocol State Machines, 
Interactions, Fragments, Behaviors, Features, Operations, Actions

7.8.3.3

Generalizations

PackageableElement

7.8.3.4

Specializations

7.8.3.5
•

•

•

IntervalConstraint, InteractionConstraint

Association Ends

constrainedElement : Element [0..*]{ordered} (opposite A_constrainedElement_constraint::constraint)
The ordered set of Elements referenced by this Constraint.

context : Namespace [0..1]{subsets NamedElement::namespace} (opposite Namespace::ownedRule)
Specifies the Namespace that owns the Constraint.

♦ specification : ValueSpecification [1..1]{subsets Element::ownedElement} (opposite 
A_specification_owningConstraint::owningConstraint)
A condition that must be true when evaluated in order for the Constraint to be satisfied.

7.8.3.6

Constraints

•

boolean_value
The ValueSpecification for a Constraint must evaluate to a Boolean value.

Cannot be expressed in OCL

Unified Modeling Language 2.5

41

•

•

no_side_effects
Evaluating the ValueSpecification for a Constraint must not have side effects.

Cannot be expressed in OCL

not_apply_to_self
A Constraint cannot be applied to itself.

inv: not constrainedElement->includes(self)

7.8.4

7.8.4.1

Dependency [Class]

Description

A Dependency is a Relationship that signifies that a single model Element or a set of model Elements requires other 
model Elements for their specification or implementation. This means that the complete semantics of the client 
Element(s) are either semantically or structurally dependent on the definition of the supplier Element(s).

7.8.4.2

Diagrams

Dependencies, Collaborations, Deployments

7.8.4.3

Generalizations

DirectedRelationship, PackageableElement

7.8.4.4

Specializations

Abstraction, Usage, Deployment

Association Ends

client : NamedElement [1..*]{subsets DirectedRelationship::source} (opposite 
NamedElement::clientDependency)
The Element(s) dependent on the supplier Element(s). In some cases (such as a trace Abstraction) the 
assignment of direction (that is, the designation of the client Element) is at the discretion of the modeler and is 
a stipulation.

supplier : NamedElement [1..*]{subsets DirectedRelationship::target} (opposite 
A_supplier_supplierDependency::supplierDependency)
The Element(s) on which the client Element(s) depend in some respect. The modeler may stipulate a sense of 
Dependency direction suitable for their domain.

DirectedRelationship [Abstract Class]

Description

7.8.4.5
•

•

7.8.5

7.8.5.1

A DirectedRelationship represents a relationship between a collection of source model Elements and a collection of 
target model Elements.

7.8.5.2

Diagrams

Root, Template Bindings, Namespaces, Dependencies, Use Cases, Packages, Profiles, Information Flows, 
Classifiers

42

Unified Modeling Language 2.5

7.8.5.3

Generalizations

Relationship

7.8.5.4

Specializations

Dependency, ElementImport, PackageImport, TemplateBinding, Extend, Include, ProtocolConformance, 
PackageMerge, ProfileApplication, InformationFlow, Generalization

7.8.5.5
•

•

7.8.6

7.8.6.1

Association Ends

/source : Element [1..*]{union, subsets Relationship::relatedElement} (opposite 
A_source_directedRelationship::directedRelationship)
Specifies the source Element(s) of the DirectedRelationship.

/target : Element [1..*]{union, subsets Relationship::relatedElement} (opposite 
A_target_directedRelationship::directedRelationship)
Specifies the target Element(s) of the DirectedRelationship.

Element [Abstract Class]

Description

An Element is a constituent of a model. As such, it has the capability of owning other Elements.

7.8.6.2

Diagrams

Root, Template Bindings, Templates, Namespaces, Types, Constraints, Activity Groups, Executable Nodes, 
Profiles, Instances, Link End Data, Structured Actions

7.8.6.3

Specializations

Comment, MultiplicityElement, NamedElement, ParameterableElement, Relationship, TemplateableElement, 
TemplateParameter, TemplateParameterSubstitution, TemplateSignature, ExceptionHandler, Image, Slot, 
Clause, LinkEndData, QualifierValue

7.8.6.4
•

•

•

7.8.6.5
•

Association Ends

♦ ownedComment : Comment [0..*]{subsets Element::ownedElement} (opposite 
A_ownedComment_owningElement::owningElement)
The Comments owned by this Element.

♦ /ownedElement : Element [0..*]{union} (opposite Element::owner)
The Elements owned by this Element.

/owner : Element [0..1]{union} (opposite Element::ownedElement)
The Element that owns this Element.

Operations

allOwnedElements() : Element [0..*]
The query allOwnedElements() gives all of the direct and indirect ownedElements of an Element.

body: ownedElement->union(ownedElement->collect(e | e.allOwnedElements()))->asSet()

Unified Modeling Language 2.5

43

• mustBeOwned() : Boolean

The query mustBeOwned() indicates whether Elements of this type must have an owner. Subclasses of 
Element that do not require an owner must override this operation.

body: true

7.8.6.6

Constraints

•

•

has_owner
Elements that must be owned must have an owner.

inv: mustBeOwned() implies owner->notEmpty()

not_own_self
An element may not directly or indirectly own itself.

inv: not allOwnedElements()->includes(self)

7.8.7

7.8.7.1

ElementImport [Class]

Description

An ElementImport identifies a NamedElement in a Namespace other than the one that owns that NamedElement and 
allows the NamedElement to be referenced using an unqualified name in the Namespace owning the ElementImport.

7.8.7.2

Diagrams

Namespaces, Profiles

7.8.7.3

Generalizations

DirectedRelationship

Attributes

alias : String [0..1]
Specifies the name that should be added to the importing Namespace in lieu of the name of the imported 
PackagableElement. The alias must not clash with any other member in the importing Namespace. By default, 
no alias is used.

visibility : VisibilityKind [1..1] = public
Specifies the visibility of the imported PackageableElement within the importingNamespace, i.e., whether the 
importedElement will in turn be visible to other Namespaces. If the ElementImport is public, the 
importedElement will be visible outside the importingNamespace while, if the ElementImport is private, it will 
not.

Association Ends

importedElement : PackageableElement [1..1]{subsets DirectedRelationship::target} (opposite 
A_importedElement_import::import)
Specifies the PackageableElement whose name is to be added to a Namespace.

importingNamespace : Namespace [1..1]{subsets DirectedRelationship::source, subsets Element::owner} 
(opposite Namespace::elementImport)
Specifies the Namespace that imports a PackageableElement from another Namespace.

Unified Modeling Language 2.5

7.8.7.4
•

•

7.8.7.5
•

•

44

7.8.7.6
•

Operations

getName() : String
The query getName() returns the name under which the imported PackageableElement will be known in the 
importing namespace.

body: if alias->notEmpty() then
  alias
else
  importedElement.name
endif

7.8.7.7

Constraints

•

•

7.8.8

7.8.8.1

imported_element_is_public
An importedElement has either public visibility or no visibility at all.

inv: importedElement.visibility <> null implies importedElement.visibility = 
VisibilityKind::public

visibility_public_or_private
The visibility of an ElementImport is either public or private.

inv: visibility = VisibilityKind::public or visibility = VisibilityKind::private

MultiplicityElement [Abstract Class]

Description

A multiplicity is a definition of an inclusive interval of non-negative integers beginning with a lower bound and ending 
with a (possibly infinite) upper bound. A MultiplicityElement embeds this information to specify the allowable 
cardinalities for an instantiation of the Element.

7.8.8.2

Diagrams

Types, Activities, Structured Classifiers, Features, Actions

7.8.8.3

Generalizations

Element

7.8.8.4

Specializations

7.8.8.5
•

•

•

Variable, ConnectorEnd, Parameter, StructuralFeature, Pin

Attributes

isOrdered : Boolean [1..1] = false
For a multivalued multiplicity, this attribute specifies whether the values in an instantiation of this 
MultiplicityElement are sequentially ordered.

isUnique : Boolean [1..1] = true
For a multivalued multiplicity, this attribute specifies whether the values in an instantiation of this 
MultiplicityElement are unique.

/lower : Integer [1..1]
The lower bound of the multiplicity interval.

Unified Modeling Language 2.5

45

•

7.8.8.6
•

•

7.8.8.7
•

•

•

•

•

•

•

/upper : UnlimitedNatural [1..1]
The upper bound of the multiplicity interval.

Association Ends

♦ lowerValue : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_lowerValue_owningLower::owningLower)
The specification of the lower bound for this multiplicity.

♦ upperValue : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_upperValue_owningUpper::owningUpper)
The specification of the upper bound for this multiplicity.

Operations

compatibleWith(other : MultiplicityElement) : Boolean
The operation compatibleWith takes another multiplicity as input. It returns true if the other multiplicity is 
wider than, or the same as, self.

body: (other.lowerBound() <= self.lowerBound()) and ((other.upperBound() = *) or 
(self.upperBound() <= other.upperBound()))

includesMultiplicity(M : MultiplicityElement) : Boolean
The query includesMultiplicity() checks whether this multiplicity includes all the cardinalities allowed by the 
specified multiplicity.

pre: self.upperBound()->notEmpty() and self.lowerBound()->notEmpty() and M.upperBound()-
>notEmpty() and M.lowerBound()->notEmpty()
body: (self.lowerBound() <= M.lowerBound()) and (self.upperBound() >= M.upperBound())

is(lowerbound : Integer, upperbound : UnlimitedNatural) : Boolean
The operation is determines if the upper and lower bound of the ranges are the ones given.

body: lowerbound = self.lowerBound() and upperbound = self.upperBound()

isMultivalued() : Boolean
The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.

pre: upperBound()->notEmpty()
body: upperBound() > 1

lower() : Integer [0..1]
The derived lower attribute must equal the lowerBound.

body: lowerBound()

lowerBound() : Integer [1..1]
The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the integerValue of 
lowerValue, if this is given, and 1 otherwise.

body: if (lowerValue=null or lowerValue.integerValue()=null) then 1 else 
lowerValue.integerValue() endif

upper() : UnlimitedNatural [0..1]
The derived upper attribute must equal the upperBound.

46

Unified Modeling Language 2.5

body: upperBound()

•

upperBound() : UnlimitedNatural [1..1]
The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an unlimited 
natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.

body: if (upperValue=null or upperValue.unlimitedValue()=null) then 1 else 
upperValue.unlimitedValue() endif

7.8.8.8

Constraints

•

•

•

•

•

•

upper_ge_lower
The upper bound must be greater than or equal to the lower bound.

inv: upperBound() >= lowerBound()

lower_ge_0
The lower bound must be a non-negative integer literal.

inv: lowerBound() >= 0

value_specification_no_side_effects
If a non-literal ValueSpecification is used for lowerValue or upperValue, then evaluating that specification 
must not have side effects.

Cannot be expressed in OCL

value_specification_constant
If a non-literal ValueSpecification is used for lowerValue or upperValue, then that specification must be a 
constant expression.

Cannot be expressed in OCL

lower_is_integer
If it is not empty, then lowerValue must have an Integer value.

inv: lowerValue <> null implies lowerValue.integerValue() <> null

upper_is_unlimitedNatural
If it is not empty, then upperValue must have an UnlimitedNatural value.

inv: upperValue <> null implies upperValue.unlimitedValue() <> null

7.8.9

7.8.9.1

NamedElement [Abstract Class]

Description

A NamedElement is an Element in a model that may have a name. The name may be given directly and/or via the use of 
a StringExpression.

7.8.9.2

Diagrams

Namespaces, Types, Dependencies, Activity Groups, Time, Use Cases, Collaborations, Behavior State 
Machines, Interactions, Messages, Lifelines, Occurrences, Fragments, Information Flows, Deployments, 
Events, Classifiers

Unified Modeling Language 2.5

47

7.8.9.3

Generalizations

Element

7.8.9.4

Specializations

7.8.9.5
•

•

•

7.8.9.6
•

•

•

7.8.9.7
•

Namespace, PackageableElement, TypedElement, ActivityGroup, Trigger, Extend, Include, CollaborationUse, 
Vertex, GeneralOrdering, InteractionFragment, Lifeline, Message, MessageEnd, DeployedArtifact, 
DeploymentTarget, ParameterSet, RedefinableElement

Attributes

name : String [0..1]
The name of the NamedElement.

/qualifiedName : String [0..1]
A name that allows the NamedElement to be identified within a hierarchy of nested Namespaces. It is 
constructed from the names of the containing Namespaces starting at the root of the hierarchy and ending with 
the name of the NamedElement itself.

visibility : VisibilityKind [0..1]
Determines whether and how the NamedElement is visible outside its owning Namespace.

Association Ends

/clientDependency : Dependency [0..*]{subsets A_source_directedRelationship::directedRelationship} 
(opposite Dependency::client)
Indicates the Dependencies that reference this NamedElement as a client.

♦ nameExpression : StringExpression [0..1]{subsets Element::ownedElement} (opposite 
A_nameExpression_namedElement::namedElement)
The StringExpression used to define the name of this NamedElement.

/namespace : Namespace [0..1]{union, subsets A_member_memberNamespace::memberNamespace, subsets 
Element::owner} (opposite Namespace::ownedMember)
Specifies the Namespace that owns the NamedElement.

Operations

allNamespaces() : Namespace [0..*]{ordered}
The query allNamespaces() gives the sequence of Namespaces in which the NamedElement is nested, working 
outwards.

body: if owner.oclIsKindOf(TemplateParameter) and
  owner.oclAsType(TemplateParameter).signature.template.oclIsKindOf(Namespace) then
    let enclosingNamespace : Namespace =
      owner.oclAsType(TemplateParameter).signature.template.oclAsType(Namespace) in
        enclosingNamespace.allNamespaces()->prepend(enclosingNamespace)
else
  if namespace->isEmpty()
    then OrderedSet{}
  else
    namespace.allNamespaces()->prepend(namespace)
  endif
endif

48

Unified Modeling Language 2.5

•

•

•

•

•

allOwningPackages() : Package [0..*]
The query allOwningPackages() returns the set of all the enclosing Namespaces of this NamedElement, 
working outwards, that are Packages, up to but not including the first such Namespace that is not a Package.

body: if namespace.oclIsKindOf(Package)
then
  let owningPackage : Package = namespace.oclAsType(Package) in
    owningPackage->union(owningPackage.allOwningPackages())
else
  null
endif

isDistinguishableFrom(n : NamedElement, ns : Namespace) : Boolean
The query isDistinguishableFrom() determines whether two NamedElements may logically co-exist within a 
Namespace. By default, two named elements are distinguishable if (a) they have types neither of which is a 
kind of the other or (b) they have different names.

body: (self.oclIsKindOf(n.oclType()) or n.oclIsKindOf(self.oclType())) implies
    ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->isEmpty()

qualifiedName() : String
When a NamedElement has a name, and all of its containing Namespaces have a name, the qualifiedName is 
constructed from the name of the NamedElement and the names of the containing Namespaces.

body: if self.name <> null and self.allNamespaces()->select( ns | ns.name=null )->isEmpty()
then
    self.allNamespaces()->iterate( ns : Namespace; agg: String = self.name | 
ns.name.concat(self.separator()).concat(agg))
else
   null
endif

separator() : String
The query separator() gives the string that is used to separate names when constructing a qualifiedName.

body: '::'

clientDependency() : Dependency [0..*]

body: Dependency.allInstances()->select(d | d.client->includes(self))

7.8.9.8

Constraints

•

•

visibility_needs_ownership
If a NamedElement is owned by something other than a Namespace, it does not have a visibility. One that is 
not owned by anything (and hence must be a Package, as this is the only kind of NamedElement that overrides 
mustBeOwned()) may have a visibility.

inv: (namespace = null and owner <> null) implies visibility = null

has_qualified_name
When there is a name, and all of the containing Namespaces have a name, the qualifiedName is constructed 
from the name of the NamedElement and the names of the containing Namespaces.

inv: (name <> null and allNamespaces()->select(ns | ns.name = null)->isEmpty()) implies
  qualifiedName = allNamespaces()->iterate( ns : Namespace; agg: String = name | 
ns.name.concat(self.separator()).concat(agg))

Unified Modeling Language 2.5

49

•

has_no_qualified_name
If there is no name, or one of the containing Namespaces has no name, there is no qualifiedName.

inv: name=null or allNamespaces()->select( ns | ns.name=null )->notEmpty() implies 
qualifiedName = null

7.8.10

7.8.10.1

Namespace [Abstract Class]

Description

A Namespace is an Element in a model that owns and/or imports a set of NamedElements that can be identified by 
name.

7.8.10.2

Diagrams

Namespaces, Constraints, Behavior State Machines, Packages, Fragments, Classifiers, Features, Structured 
Actions

7.8.10.3

Generalizations

NamedElement

7.8.10.4

Specializations

Region, State, Transition, Package, InteractionOperand, BehavioralFeature, Classifier, StructuredActivityNode

7.8.10.5

Association Ends

•

•

•

•

•

•

♦ elementImport : ElementImport [0..*]{subsets Element::ownedElement, subsets 
A_source_directedRelationship::directedRelationship} (opposite ElementImport::importingNamespace)
References the ElementImports owned by the Namespace.

/importedMember : PackageableElement [0..*]{subsets Namespace::member} (opposite 
A_importedMember_namespace::namespace)
References the PackageableElements that are members of this Namespace as a result of either PackageImports 
or ElementImports.

/member : NamedElement [0..*]{union} (opposite A_member_memberNamespace::memberNamespace)
A collection of NamedElements identifiable within the Namespace, either by being owned or by being 
introduced by importing or inheritance.

♦ /ownedMember : NamedElement [0..*]{union, subsets Namespace::member, subsets 
Element::ownedElement} (opposite NamedElement::namespace)
A collection of NamedElements owned by the Namespace.

♦ ownedRule : Constraint [0..*]{subsets Namespace::ownedMember} (opposite Constraint::context)
Specifies a set of Constraints owned by this Namespace.

♦ packageImport : PackageImport [0..*]{subsets Element::ownedElement, subsets 
A_source_directedRelationship::directedRelationship} (opposite PackageImport::importingNamespace)
References the PackageImports owned by the Namespace.

50

Unified Modeling Language 2.5

7.8.10.6

Operations

•

•

•

•

excludeCollisions(imps : PackageableElement [0..*]) : PackageableElement [0..*]
The query excludeCollisions() excludes from a set of PackageableElements any that would not be 
distinguishable from each other in this Namespace.

body: imps->reject(imp1  | imps->exists(imp2 | not imp1.isDistinguishableFrom(imp2, self)))

getNamesOfMember(element : NamedElement) : String [0..*]
The query getNamesOfMember() gives a set of all of the names that a member would have in a Namespace, 
taking importing into account. In general a member can have multiple names in a Namespace if it is imported 
more than once with different aliases.

body: if self.ownedMember ->includes(element)
then Set{element.name}
else let elementImports : Set(ElementImport) = self.elementImport->select(ei | 
ei.importedElement = element) in
  if elementImports->notEmpty()
  then
     elementImports->collect(el | el.getName())->asSet()
  else
     self.packageImport->select(pi | 
pi.importedPackage.visibleMembers().oclAsType(NamedElement)->includes(element))-> collect(pi 
| pi.importedPackage.getNamesOfMember(element))->asSet()
  endif
endif

importMembers(imps : PackageableElement [0..*]) : PackageableElement [0..*]
The query importMembers() defines which of a set of PackageableElements are actually imported into the 
Namespace. This excludes hidden ones, i.e., those which have names that conflict with names of 
ownedMembers, and it also excludes PackageableElements that would have the indistinguishable names when 
imported.

body: self.excludeCollisions(imps)->select(imp | self.ownedMember->forAll(mem | 
imp.isDistinguishableFrom(mem, self)))

importedMember() : PackageableElement [0..*]
The importedMember property is derived as the PackageableElements that are members of this Namespace as 
a result of either PackageImports or ElementImports.

body: self.importMembers(elementImport.importedElement->asSet()-
>union(packageImport.importedPackage->collect(p | p.visibleMembers()))->asSet())

• membersAreDistinguishable() : Boolean

The Boolean query membersAreDistinguishable() determines whether all of the Namespace's members are 
distinguishable within it.

body: member->forAll( memb |
   member->excluding(memb)->forAll(other |
       memb.isDistinguishableFrom(other, self)))

7.8.10.7

Constraints

• members_distinguishable

All the members of a Namespace are distinguishable within it.

inv: membersAreDistinguishable()

Unified Modeling Language 2.5

51

•

•

cannot_import_self
A Namespace cannot have a PackageImport to itself.

inv: packageImport.importedPackage.oclAsType(Namespace)->excludes(self)

cannot_import_ownedMembers
A Namespace cannot have an ElementImport to one of its ownedMembers.

inv: elementImport.importedElement.oclAsType(Element)->excludesAll(ownedMember)

7.8.11

7.8.11.1

PackageImport [Class]

Description

A PackageImport is a Relationship that imports all the non-private members of a Package into the Namespace owning 
the PackageImport, so that those Elements may be referred to by their unqualified names in the importingNamespace.

7.8.11.2

Diagrams

Namespaces, Profiles

7.8.11.3

Generalizations

DirectedRelationship

7.8.11.4

Attributes

•

visibility : VisibilityKind [1..1] = public
Specifies the visibility of the imported PackageableElements within the importingNamespace, i.e., whether 
imported Elements will in turn be visible to other Namespaces. If the PackageImport is public, the imported 
Elements will be visible outside the importingNamespace, while, if the PackageImport is private, they will not.

7.8.11.5

Association Ends

•

•

importedPackage : Package [1..1]{subsets DirectedRelationship::target} (opposite 
A_importedPackage_packageImport::packageImport)
Specifies the Package whose members are imported into a Namespace.

importingNamespace : Namespace [1..1]{subsets DirectedRelationship::source, subsets Element::owner} 
(opposite Namespace::packageImport)
Specifies the Namespace that imports the members from a Package.

7.8.11.6

Constraints

•

public_or_private
The visibility of a PackageImport is either public or private.

inv: visibility = VisibilityKind::public or visibility = VisibilityKind::private

7.8.12

7.8.12.1

PackageableElement [Abstract Class]

Description

A PackageableElement is a NamedElement that may be owned directly by a Package. A PackageableElement is also 
able to serve as the parameteredElement of a TemplateParameter.

52

Unified Modeling Language 2.5

7.8.12.2

Diagrams

Namespaces, Types, Constraints, Dependencies, Literals, Time, Components, Packages, Information Flows, 
Deployments, Artifacts, Events, Instances, Generalization Sets

7.8.12.3

Generalizations

ParameterableElement, NamedElement

7.8.12.4

Specializations

Constraint, Dependency, Type, Event, Observation, ValueSpecification, Package, InformationFlow, 
GeneralizationSet, InstanceSpecification

7.8.12.5

Attributes

•

visibility : VisibilityKind [0..1] = public
A PackageableElement must have a visibility specified if it is owned by a Namespace. The default visibility is 
public.

7.8.12.6

Constraints

•

namespace_needs_visibility
A PackageableElement owned by a Namespace must have a visibility.

inv: visibility = null implies namespace = null

7.8.13

7.8.13.1

ParameterableElement [Abstract Class]

Description

A ParameterableElement is an Element that can be exposed as a formal TemplateParameter for a template, or specified 
as an actual parameter in a binding of a template.

7.8.13.2

Diagrams

Template Bindings, Templates, Namespaces, Structured Classifiers, Properties, Operations

7.8.13.3

Generalizations

Element

7.8.13.4

Specializations

PackageableElement, ConnectableElement, Operation

7.8.13.5

Association Ends

•

•

owningTemplateParameter : TemplateParameter [0..1]{subsets ParameterableElement::templateParameter, 
subsets Element::owner} (opposite TemplateParameter::ownedParameteredElement)
The formal TemplateParameter that owns this ParameterableElement.

templateParameter : TemplateParameter [0..1] (opposite TemplateParameter::parameteredElement)
The TemplateParameter that exposes this ParameterableElement as a formal parameter.

Unified Modeling Language 2.5

53

7.8.13.6

Operations

•

•

isCompatibleWith(p : ParameterableElement) : Boolean
The query isCompatibleWith() determines if this ParameterableElement is compatible with the specified 
ParameterableElement. By default, this ParameterableElement is compatible with another 
ParameterableElement p if the kind of this ParameterableElement is the same as or a subtype of the kind of p. 
Subclasses of ParameterableElement should override this operation to specify different compatibility 
constraints.

body: self.oclIsKindOf(p.oclType())

isTemplateParameter() : Boolean
The query isTemplateParameter() determines if this ParameterableElement is exposed as a formal 
TemplateParameter.

body: templateParameter->notEmpty()

7.8.14

7.8.14.1

Realization [Class]

Description

Realization is a specialized Abstraction relationship between two sets of model Elements, one representing a 
specification (the supplier) and the other represents an implementation of the latter (the client). Realization can be used 
to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.

7.8.14.2

Diagrams

Dependencies, Components, Interfaces, Classifiers

7.8.14.3

Generalizations

Abstraction

7.8.14.4

Specializations

ComponentRealization, InterfaceRealization, Substitution

7.8.15

7.8.15.1

Relationship [Abstract Class]

Description

Relationship is an abstract concept that specifies some kind of relationship between Elements.

7.8.15.2

Diagrams

Root, Associations, Information Flows

7.8.15.3

Generalizations

Element

7.8.15.4

Specializations

DirectedRelationship, Association

54

Unified Modeling Language 2.5

7.8.15.5

Association Ends

•

/relatedElement : Element [1..*]{union} (opposite A_relatedElement_relationship::relationship)
Specifies the elements related by the Relationship.

7.8.16

7.8.16.1

TemplateBinding [Class]

Description

A TemplateBinding is a DirectedRelationship between a TemplateableElement and a template. A TemplateBinding 
specifies the TemplateParameterSubstitutions of actual parameters for the formal parameters of the template.

7.8.16.2

Diagrams

Template Bindings

7.8.16.3

Generalizations

DirectedRelationship

7.8.16.4

Association Ends

•

•

•

boundElement : TemplateableElement [1..1]{subsets DirectedRelationship::source, subsets Element::owner} 
(opposite TemplateableElement::templateBinding)
The TemplateableElement that is bound by this TemplateBinding.

♦ parameterSubstitution : TemplateParameterSubstitution [0..*]{subsets Element::ownedElement} (opposite 
TemplateParameterSubstitution::templateBinding)
The TemplateParameterSubstitutions owned by this TemplateBinding.

signature : TemplateSignature [1..1]{subsets DirectedRelationship::target} (opposite 
A_signature_templateBinding::templateBinding)
The TemplateSignature for the template that is the target of this TemplateBinding.

7.8.16.5

Constraints

•

•

parameter_substitution_formal
Each parameterSubstitution must refer to a formal TemplateParameter of the target TemplateSignature.

inv: parameterSubstitution->forAll(b | signature.parameter->includes(b.formal))

one_parameter_substitution
A TemplateBiinding contains at most one TemplateParameterSubstitution for each formal TemplateParameter 
of the target TemplateSignature.

inv: signature.parameter->forAll(p | parameterSubstitution->select(b | b.formal = p)->size() 
<= 1)

7.8.17

7.8.17.1

TemplateParameter [Class]

Description

A TemplateParameter exposes a ParameterableElement as a formal parameter of a template.

Unified Modeling Language 2.5

55

7.8.17.2

Diagrams

Template Bindings, Templates, Structured Classifiers, Classifier Templates, Operations

7.8.17.3

Generalizations

Element

7.8.17.4

Specializations

ConnectableElementTemplateParameter, ClassifierTemplateParameter, OperationTemplateParameter

7.8.17.5

Association Ends

•

•

•

•

•

default : ParameterableElement [0..1] (opposite A_default_templateParameter::templateParameter)
The ParameterableElement that is the default for this formal TemplateParameter.

♦ ownedDefault : ParameterableElement [0..1]{subsets Element::ownedElement, subsets 
TemplateParameter::default} (opposite A_ownedDefault_templateParameter::templateParameter)
The ParameterableElement that is owned by this TemplateParameter for the purpose of providing a default.

♦ ownedParameteredElement : ParameterableElement [0..1]{subsets Element::ownedElement, subsets 
TemplateParameter::parameteredElement} (opposite ParameterableElement::owningTemplateParameter)
The ParameterableElement that is owned by this TemplateParameter for the purpose of exposing it as the 
parameteredElement.

parameteredElement : ParameterableElement [1..1] (opposite ParameterableElement::templateParameter)
The ParameterableElement exposed by this TemplateParameter.

signature : TemplateSignature [1..1]{subsets A_parameter_templateSignature::templateSignature, subsets 
Element::owner} (opposite TemplateSignature::ownedParameter)
The TemplateSignature that owns this TemplateParameter.

7.8.17.6

Constraints

• must_be_compatible

The default must be compatible with the formal TemplateParameter.

inv: default <> null implies default.isCompatibleWith(parameteredElement)

7.8.18

7.8.18.1

TemplateParameterSubstitution [Class]

Description

A TemplateParameterSubstitution relates the actual parameter to a formal TemplateParameter as part of a template 
binding.

7.8.18.2

Diagrams

Template Bindings

7.8.18.3

Generalizations

Element

56

Unified Modeling Language 2.5

7.8.18.4

Association Ends

•

•

•

•

actual : ParameterableElement [1..1] (opposite 
A_actual_templateParameterSubstitution::templateParameterSubstitution)
The ParameterableElement that is the actual parameter for this TemplateParameterSubstitution.

formal : TemplateParameter [1..1] (opposite 
A_formal_templateParameterSubstitution::templateParameterSubstitution)
The formal TemplateParameter that is associated with this TemplateParameterSubstitution.

♦ ownedActual : ParameterableElement [0..1]{subsets Element::ownedElement, subsets 
TemplateParameterSubstitution::actual} (opposite 
A_ownedActual_owningTemplateParameterSubstitution::owningTemplateParameterSubstitution)
The ParameterableElement that is owned by this TemplateParameterSubstitution as its actual parameter.

templateBinding : TemplateBinding [1..1]{subsets Element::owner} (opposite 
TemplateBinding::parameterSubstitution)
The TemplateBinding that owns this TemplateParameterSubstitution.

7.8.18.5

Constraints

• must_be_compatible

The actual ParameterableElement must be compatible with the formal TemplateParameter, e.g., the actual 
ParameterableElement for a Class TemplateParameter must be a Class.

inv: actual->forAll(a | a.isCompatibleWith(formal.parameteredElement))

7.8.19

7.8.19.1

TemplateSignature [Class]

Description

A Template Signature bundles the set of formal TemplateParameters for a template.

7.8.19.2

Diagrams

Template Bindings, Templates, Classifier Templates

7.8.19.3

Generalizations

Element

7.8.19.4

Specializations

RedefinableTemplateSignature

7.8.19.5

Association Ends

•

•

♦ ownedParameter : TemplateParameter [0..*]{ordered, subsets Element::ownedElement, subsets 
TemplateSignature::parameter} (opposite TemplateParameter::signature)
The formal parameters that are owned by this TemplateSignature.

parameter : TemplateParameter [1..*]{ordered} (opposite A_parameter_templateSignature::templateSignature)
The ordered set of all formal TemplateParameters for this TemplateSignature.

Unified Modeling Language 2.5

57

•

template : TemplateableElement [1..1]{subsets Element::owner} (opposite 
TemplateableElement::ownedTemplateSignature)
The TemplateableElement that owns this TemplateSignature.

7.8.19.6

Constraints

•

•

own_elements
Parameters must own the ParameterableElements they parameter or those ParameterableElements must be 
owned by the TemplateableElement being templated.

inv: template.ownedElement->includesAll(parameter.parameteredElement->asSet() - 
parameter.ownedParameteredElement->asSet())

unique_parameters
The names of the parameters of a TemplateSignature are unique.

inv: parameter->forAll( p1, p2 | (p1 <> p2 and 
p1.parameteredElement.oclIsKindOf(NamedElement) and 
p2.parameteredElement.oclIsKindOf(NamedElement) ) implies
   p1.parameteredElement.oclAsType(NamedElement).name <> 
p2.parameteredElement.oclAsType(NamedElement).name)

7.8.20

7.8.20.1

TemplateableElement [Abstract Class]

Description

A TemplateableElement is an Element that can optionally be defined as a template and bound to other templates.

7.8.20.2

Diagrams

Template Bindings, Templates, Expressions, Packages, Classifiers, Classifier Templates, Operations

7.8.20.3

Generalizations

Element

7.8.20.4

Specializations

StringExpression, Package, Classifier, Operation

7.8.20.5

Association Ends

•

•

♦ ownedTemplateSignature : TemplateSignature [0..1]{subsets Element::ownedElement} (opposite 
TemplateSignature::template)
The optional TemplateSignature specifying the formal TemplateParameters for this TemplateableElement. If a 
TemplateableElement has a TemplateSignature, then it is a template.

♦ templateBinding : TemplateBinding [0..*]{subsets Element::ownedElement, subsets 
A_source_directedRelationship::directedRelationship} (opposite TemplateBinding::boundElement)
The optional TemplateBindings from this TemplateableElement to one or more templates.

7.8.20.6

Operations

•

58

isTemplate() : Boolean
The query isTemplate() returns whether this TemplateableElement is actually a template.

body: ownedTemplateSignature <> null

Unified Modeling Language 2.5

•

parameterableElements() : ParameterableElement [0..*]
The query parameterableElements() returns the set of ParameterableElements that may be used as the 
parameteredElements for a TemplateParameter of this TemplateableElement. By default, this set includes all 
the ownedElements. Subclasses may override this operation if they choose to restrict the set of 
ParameterableElements.

body: self.allOwnedElements()-
>select(oclIsKindOf(ParameterableElement)).oclAsType(ParameterableElement)->asSet()

7.8.21

7.8.21.1

Type [Abstract Class]

Description

A Type constrains the values represented by a TypedElement.

7.8.21.2

Diagrams

Types, Associations, Packages, Classifiers, Features, Operations

7.8.21.3

Generalizations

PackageableElement

7.8.21.4

Specializations

Classifier

7.8.21.5

7.8.21.6

Attributes

Association Ends

•

package : Package [0..1]{subsets A_packagedElement_owningPackage::owningPackage} (opposite 
Package::ownedType)
Specifies the owning Package of this Type, if any.

7.8.21.7

Operations

•

conformsTo(other : Type) : Boolean
The query conformsTo() gives true for a Type that conforms to another. By default, two Types do not conform 
to each other. This query is intended to be redefined for specific conformance situations.

body: false

7.8.22

7.8.22.1

TypedElement [Abstract Class]

Description

A TypedElement is a NamedElement that may have a Type specified for it.

7.8.22.2

Diagrams

Types, Object Nodes, Literals, Structured Classifiers, Features

7.8.22.3

Generalizations

NamedElement

Unified Modeling Language 2.5

59

7.8.22.4

Specializations

ObjectNode, ValueSpecification, ConnectableElement, StructuralFeature

7.8.22.5

Association Ends

•

type : Type [0..1] (opposite A_type_typedElement::typedElement)
The type of the TypedElement.

7.8.23

7.8.23.1

Usage [Class]

Description

A Usage is a Dependency in which the client Element requires the supplier Element (or set of Elements) for its full 
implementation or operation.

7.8.23.2

Diagrams

Dependencies

7.8.23.3

Generalizations

Dependency

7.8.24

7.8.24.1

VisibilityKind [Enumeration]

Description

VisibilityKind is an enumeration type that defines literals to determine the visibility of Elements in a model.

7.8.24.2

Diagrams

• Namespaces

 

 

7.8.24.3

Literals

•

•

•

•

public
A Named Element with public visibility is visible to all elements that can access the contents of the Namespace 
that owns it.

private
A NamedElement with private visibility is only visible inside the Namespace that owns it.

protected
A NamedElement with protected visibility is visible to Elements that have a generalization relationship to the 
Namespace that owns it.

package
A NamedElement with package visibility is visible to all Elements within the nearest enclosing Package (given 
that other owning Elements have proper visibility). Outside the nearest enclosing Package, a NamedElement 
marked as having package visibility is not visible. Only NamedElements that are not owned by Packages can 
be marked as having package visibility.

60

Unified Modeling Language 2.5

7.9
7.9.1

7.9.1.1

Association Descriptions
A_actual_templateParameterSubstitution [Association]

Diagrams

Template Bindings

7.9.1.2

Specializations

A_ownedActual_owningTemplateParameterSubstitution

7.9.1.3
•

7.9.2

7.9.2.1

7.9.2.2
•

7.9.3

7.9.3.1

Owned Ends

templateParameterSubstitution : TemplateParameterSubstitution [0..*] (opposite 
TemplateParameterSubstitution::actual)

A_annotatedElement_comment [Association]

Diagrams

Root

Owned Ends

comment : Comment [0..*] (opposite Comment::annotatedElement)

A_clientDependency_client [Association]

Diagrams

Dependencies

7.9.3.2

Member Ends

 

• NamedElement::clientDependency
• Dependency::client

 

 

 

7.9.4

7.9.4.1

7.9.4.2
•

7.9.5

7.9.5.1

A_constrainedElement_constraint [Association]

Diagrams

Constraints

Owned Ends

constraint : Constraint [0..*] (opposite Constraint::constrainedElement)

A_default_templateParameter [Association]

Diagrams

Templates

Unified Modeling Language 2.5

61

7.9.5.2

Specializations

7.9.5.3
•

7.9.6

7.9.6.1

A_ownedDefault_templateParameter

Owned Ends

templateParameter : TemplateParameter [0..*] (opposite TemplateParameter::default)

A_elementImport_importingNamespace [Association]

Diagrams

Namespaces

7.9.6.2

Member Ends

 

• Namespace::elementImport
•

 

ElementImport::importingNamespace
 

 

7.9.7

7.9.7.1

7.9.7.2
•

7.9.8

7.9.8.1

7.9.8.2
•

7.9.9

7.9.9.1

7.9.9.2
•

62

A_formal_templateParameterSubstitution [Association]

Diagrams

Template Bindings

Owned Ends

templateParameterSubstitution : TemplateParameterSubstitution [0..*] (opposite 
TemplateParameterSubstitution::formal)

A_importedElement_import [Association]

Diagrams

Namespaces

Owned Ends

import : ElementImport [0..*]{subsets A_target_directedRelationship::directedRelationship} (opposite 
ElementImport::importedElement)

A_importedMember_namespace [Association]

Diagrams

Namespaces

Owned Ends

namespace : Namespace [0..*]{subsets A_member_memberNamespace::memberNamespace} (opposite 
Namespace::importedMember)

Unified Modeling Language 2.5

7.9.10

7.9.10.1

A_importedPackage_packageImport [Association]

Diagrams

Namespaces

7.9.10.2

Owned Ends

•

7.9.11

7.9.11.1

packageImport : PackageImport [0..*]{subsets A_target_directedRelationship::directedRelationship} (opposite
PackageImport::importedPackage)

A_lowerValue_owningLower [Association]

Diagrams

Types

7.9.11.2

Owned Ends

•

owningLower : MultiplicityElement [0..1]{subsets Element::owner} (opposite 
MultiplicityElement::lowerValue)

7.9.12

7.9.12.1

A_mapping_abstraction [Association]

Diagrams

Dependencies

7.9.12.2

Owned Ends

•

abstraction : Abstraction [0..1]{subsets Element::owner} (opposite Abstraction::mapping)

7.9.13

7.9.13.1

A_member_memberNamespace [Association]

Diagrams

Namespaces

7.9.13.2

Owned Ends

•

/memberNamespace : Namespace [0..*]{union} (opposite Namespace::member)

7.9.14

7.9.14.1

A_nameExpression_namedElement [Association]

Diagrams

Namespaces

7.9.14.2

Owned Ends

•

namedElement : NamedElement [0..1]{subsets Element::owner} (opposite NamedElement::nameExpression)

Unified Modeling Language 2.5

63

7.9.15

7.9.15.1

A_ownedActual_owningTemplateParameterSubstitution [Association]

Diagrams

Template Bindings

7.9.15.2

Generalizations

A_actual_templateParameterSubstitution

7.9.15.3

Owned Ends

•

owningTemplateParameterSubstitution : TemplateParameterSubstitution [0..1]{subsets Element::owner, 
redefines A_actual_templateParameterSubstitution::templateParameterSubstitution} (opposite 
TemplateParameterSubstitution::ownedActual)

A_ownedComment_owningElement [Association]

Diagrams

7.9.16

7.9.16.1

Root

7.9.16.2

Owned Ends

•

owningElement : Element [0..1]{subsets Element::owner} (opposite Element::ownedComment)

7.9.17

7.9.17.1

A_ownedDefault_templateParameter [Association]

Diagrams

Templates

7.9.17.2

Generalizations

A_default_templateParameter

7.9.17.3

Owned Ends

•

templateParameter : TemplateParameter [0..1]{subsets Element::owner, redefines 
A_default_templateParameter::templateParameter} (opposite TemplateParameter::ownedDefault)

A_ownedElement_owner [Association]

Diagrams

7.9.18

7.9.18.1

Root

7.9.18.2

Member Ends

•

•

Element::ownedElement
 

 

Element::owner
 

 

64

Unified Modeling Language 2.5

7.9.19

7.9.19.1

A_ownedMember_namespace [Association]

Diagrams

Namespaces

7.9.19.2

Member Ends

 

• Namespace::ownedMember
• NamedElement::namespace

 

 

 

7.9.20

7.9.20.1

A_ownedParameter_signature [Association]

Diagrams

Templates

7.9.20.2

Member Ends

•

•

TemplateSignature::ownedParameter
 

 

TemplateParameter::signature
 

 

7.9.21

7.9.21.1

A_ownedParameteredElement_owningTemplateParameter [Association]

Diagrams

Templates

7.9.21.2

Member Ends

•

•

TemplateParameter::ownedParameteredElement
 

 

ParameterableElement::owningTemplateParameter
 

 

7.9.22

7.9.22.1

A_ownedRule_context [Association]

Diagrams

Namespaces, Constraints

7.9.22.2

Member Ends
• Namespace::ownedRule
• Constraint::context
 

 

 

 

7.9.23

7.9.23.1

A_ownedTemplateSignature_template [Association]

Diagrams

Templates

Unified Modeling Language 2.5

65

7.9.23.2

Member Ends

•

•

TemplateableElement::ownedTemplateSignature
 

 

TemplateSignature::template
 

 

7.9.24

7.9.24.1

A_packageImport_importingNamespace [Association]

Diagrams

Namespaces

7.9.24.2

Member Ends

 

• Namespace::packageImport
•

 

PackageImport::importingNamespace
 

 

7.9.25

7.9.25.1

A_parameterSubstitution_templateBinding [Association]

Diagrams

Template Bindings

7.9.25.2

Member Ends

•

•

TemplateBinding::parameterSubstitution
 

 

TemplateParameterSubstitution::templateBinding
 

 

7.9.26

7.9.26.1

A_parameter_templateSignature [Association]

Diagrams

Templates

7.9.26.2

Owned Ends

•

templateSignature : TemplateSignature [0..*] (opposite TemplateSignature::parameter)

7.9.27

7.9.27.1

A_parameteredElement_templateParameter [Association]

Diagrams

Templates

7.9.27.2

Member Ends

TemplateParameter::parameteredElement
 

 

ParameterableElement::templateParameter
 

 

•

•

66

Unified Modeling Language 2.5

A_relatedElement_relationship [Association]

Diagrams

7.9.28

7.9.28.1

Root

7.9.28.2

Owned Ends

•

/relationship : Relationship [0..*]{union} (opposite Relationship::relatedElement)

7.9.29

7.9.29.1

A_signature_templateBinding [Association]

Diagrams

Template Bindings

7.9.29.2

Owned Ends

•

templateBinding : TemplateBinding [0..*]{subsets A_target_directedRelationship::directedRelationship} 
(opposite TemplateBinding::signature)

A_source_directedRelationship [Association]

Diagrams

7.9.30

7.9.30.1

Root

7.9.30.2

Owned Ends

•

/directedRelationship : DirectedRelationship [0..*]{union, subsets 
A_relatedElement_relationship::relationship} (opposite DirectedRelationship::source)

7.9.31

7.9.31.1

A_specification_owningConstraint [Association]

Diagrams

Constraints

7.9.31.2

Specializations

A_specification_intervalConstraint

7.9.31.3

Owned Ends

•

owningConstraint : Constraint [0..1]{subsets Element::owner} (opposite Constraint::specification)

7.9.32

7.9.32.1

A_supplier_supplierDependency [Association]

Diagrams

Dependencies

Unified Modeling Language 2.5

67

7.9.32.2

Owned Ends

•

supplierDependency : Dependency [0..*]{subsets A_target_directedRelationship::directedRelationship} 
(opposite Dependency::supplier)
Indicates the dependencies that reference the supplier.

A_target_directedRelationship [Association]

Diagrams

7.9.33

7.9.33.1

Root

7.9.33.2

Owned Ends

•

/directedRelationship : DirectedRelationship [0..*]{union, subsets 
A_relatedElement_relationship::relationship} (opposite DirectedRelationship::target)

7.9.34

7.9.34.1

A_templateBinding_boundElement [Association]

Diagrams

Template Bindings

7.9.34.2

Member Ends

•

•

TemplateableElement::templateBinding
 

 

TemplateBinding::boundElement
 

 

7.9.35

7.9.35.1

A_type_typedElement [Association]

Diagrams

Types

7.9.35.2

Owned Ends

•

typedElement : TypedElement [0..*] (opposite TypedElement::type)

7.9.36

7.9.36.1

A_upperValue_owningUpper [Association]

Diagrams

Types

7.9.36.2

Owned Ends

•

owningUpper : MultiplicityElement [0..1]{subsets Element::owner} (opposite 
MultiplicityElement::upperValue)

68

Unified Modeling Language 2.5

Values
Summary

8
8.1
This clause describes the specification of values. In general, a ValueSpecification is a model element that is considered 
semantically to yield zero or more values. The type and number of values shall be suitable for the context in which the 
ValueSpecification is used (as determined by the constraints given in that context).
The following sub clauses describe the various kinds of ValueSpecifications available in UML.

Literals
Summary

8.2
8.2.1
A LiteralSpecification is a ValueSpecification that specifies a literal value. There is a different kind of 
LiteralSpecification for each of the UML standard PrimitiveTypes, with a corresponding textual literal notation, plus a 
“null” literal that represents the “lack of a value.”

8.2.2

Abstract Syntax

TypedElement

PackageableElement

ValueSpecification

LiteralSpecification

LiteralNull

LiteralInteger

+ value : Integer = 0

LiteralUnlimitedNatural

+ value : UnlimitedNatural = 0

LiteralString

+ value : String [0..1]

LiteralBoolean

+ value : Boolean = false

LiteralReal
+ value : Real

Figure 8.1  Literals

Semantics

8.2.3
There are six kinds of LiteralSpecifications:

1 A LiteralNull is intended to be used to explicitly model the lack of a value. In the context of a 

MultiplicityElement with a multiplicity lower bound of 0, this corresponds to the empty set (i.e., a set of no 
values). It is equivalent to specifying no values for the Element.

2 A LiteralString specifies a constant value of the PrimitiveType String. Though a String is specified as a 

sequence of characters, String values are considered to be primitive in UML, so their internal structure is not 
specified as part of UML semantics.

Unified Modeling Language 2.5

69

3 A LiteralInteger specifies a constant value of the PrimitiveType Integer.

4 A LiteralBoolean specifies a constant value of the PrimitiveType Boolean.

5 A LiteralUnlimitedNatural specifies a constant value of the PrimitiveType UnlimitedNatural.

6 A LiteralReal specifies a constant value of the PrimitiveType Real.

See also Clause 21 for further discussion of the standard UML primitive types.

Notation

8.2.4
LiteralSpecifications are notated textually.

•

The notation for a LiteralNull varies depending on where it is used. It often appears as the word “null.” Other 
notations are described elsewhere for specific uses.

• A LiteralString is shown as a sequence of characters within double quotes. The String value is the sequence of 

characters, not including the quotes. The character set used is unspecified.

• A LiteralInteger is shown as a sequence of digits representing the decimal numeral for the Integer value.

• A LiteralBoolean is shown as either the word “true” or the word “false,” corresponding to its value.

• A LiteralUnlimitedNatural is shown either as a sequence of digits or as an asterisk (*), where an asterisk 

denotes unlimited. Note that “unlimited” denotes the lack of a limit on the value of some element (such as a 
multiplicity upper bound), not a value of “infinity.”

• A LiteralReal is shown in decimal notation or scientific notation. Decimal notation consists of an optional sign 
character (+/-) followed by zero or more digits followed optionally by a dot (.) followed by one or more digits. 
Scientific notation consists of decimal notation followed by either the letter “e” or “E” and an exponent 
consisting of an optional sign character followed by one or more digits. The scientific notation expresses a real 
number equal to that given by the decimal notation before the exponent, times 10 raised to the power of the 
exponent.

This notation is specified by the following EBNF rules:
<natural-literal> ::= ('0'..'9')+
<decimal-literal> ::= ['+' | '-' ] <natural-literal> | ['+' | '-' ] [<natural-literal>] '.' <natural-literal>
<real-literal> ::= <decimal-literal> [ ('e' | 'E') ['+' | '-' ] <natural-literal> ]

Expressions
Summary

8.3
8.3.1
Expressions are ValueSpecifications that specify values resulting from a computation.

70

Unified Modeling Language 2.5

8.3.2

Abstract Syntax

{ordered, subsets ownedElement}
+ operand

*

ValueSpecification

0..1

+ expression
{subsets owner}

Expression

+ symbol : String [0..1]

OpaqueExpression

+ body : String [*] {ordered, nonunique}
+ language : String [*] {ordered}

+ opaqueExpression

*

* + opaqueExpression

+ behavior

0..1

0..1 + /result

{readOnly}

Behavior

Parameter

{subsets owner}
+ owningExpression
0..1

*
+ subExpression

StringExpression

{ordered, subsets ownedElement}

TemplateableElement

Figure 8.2  Expressions

8.3.3

8.3.3.1

Semantics

Expressions

An Expression is specified as a tree structure. Each node in this tree structure consists of a symbol and an optional set of 
operands. If there are no operands, the Expression represents a terminal node. If there are operands, the Expression 
represents the operator given by the symbol applied to those operands.
An Expression is evaluated by first evaluating each of its operands and then performing the operation denoted by the 
Expression symbol to the resulting operand values. However, the actual interpretation of the symbol depends on the 
context of use of the Expression and this specification does not provide any standard symbol definitions. A conforming 
tool may define a specific set of symbols for which it provides interpretations or it may simply treat all Expressions as 
uninterpreted.

8.3.3.2

String Expressions

A StringExpression is an Expression that specifies a String value that is derived by concatenating a list of substrings. 
The substrings are given as either a list of LiteralString operands or as a list of StringExpression subExpressions (but it is 
not allowed to mix the two). The String value of a StringExpression is obtained by concatenating, in order, the String 
values of either the operands or the subExpressions, depending on which is given.
StringExpressions are intended to be used to specify the names of NamedElements in the context of Templates. Either 
the entire StringExpression or one or more of its subExpressions may be used as the ParameterableElements of 
TemplateParameters, allowing the name of a NamedElement to be parameterized within a template. See the semantics 
of NamedElements in sub clause 7.4.3 for further discussion of this.

8.3.3.3

Opaque Expressions

An OpaqueExpression specifies the computation of a set of values either in terms of a UML Behavior or based on a 
textual statement in a language other than UML.

Unified Modeling Language 2.5

71

An OpaqueExpression may have a body that consists of a sequence of text Strings representing alternative means of 
computing the values of the OpaqueExpression. A corresponding sequence of language Strings may be used to specify 
the languages in which each of the body Strings is to be interpreted. Languages are matched to body Strings by order. 
The UML specification does not define how body Strings are interpreted relative to any language, though other 
specifications may define specific language Strings to be used to indicate interpretation with respect to those 
specifications (e.g., “OCL” for expressions to be interpreted according to the OCL specification). Note also that it is not 
required to specify the languages. If they are unspecified, then the interpretation of any body Strings must be determined 
implicitly from the form of the bodies or the context of use of the OpaqueExpression.
An OpaqueExpression may also be defined by a UML Behavior (see sub clause 13.2) that is restricted to have no 
Parameters other than a return Parameter. The values of the OpaqueExpression are given by invoking the Behavior and 
returning the values on the return Parameter. Note that the behavior of an OpaqueExpression does not have Parameters 
other than its return and thus cannot be passed data upon invocation. It must therefore access any input data through 
elements of its behavioral description.
If an OpaqueExpression has more than one body String, or a behavior in addition to one or more body Strings, then any 
one of the bodies or the behavior may be used to evaluate the OpaqueExpression. The UML specification does not 
determine how this choice is made.

8.3.4

8.3.4.1

Notation

Expressions

An Expression with no operands is notated simply by its symbol (unlike a StringLiteral, the symbol is not enclosed in 
quotes). An Expression with operands may be notated by its symbol, followed by round parentheses containing its 
operands in order, separated by commas. However, in particular contexts, a conforming tool may permit special 
notations, including infix operators.
See sub clause 7.4.4 for the notation of the use of StringExpressions with NamedElements.

8.3.4.2

Opaque Expressions

If an OpaqueExpression has one or more body Strings, then these are used to display the OpaqueExpression in the 
context of its containing element. The UML Specification does not define the syntax of such Strings, but, if a 
corresponding language is given for a body String, a conforming tool may enforce the syntax of that language. A 
conforming tool may also restrict the languages allowed or assume a particular default language.
If languages are specified for an OpaqueExpression, then a language name may be displayed in braces ({}) before the 
body String to which it corresponds. It is not required, however, that the languages of an OpaqueExpression be displayed.
If a language has a specification that defines its language name, then the language name used in an OpaqueExpression 
should be spelled and capitalized exactly as it appears in the specification for the language. For example, use “OCL,” 
not “ocl.”

Examples

Expressions

Opaque Expressions

8.3.5

8.3.5.1

xor
else
plus(x,1)
x+1

8.3.5.2

a > 0

72

Unified Modeling Language 2.5

{OCL} i > j and self.size > i
average hours worked per week

Time
Summary

8.4
8.4.1
This sub clause defines TimeExpressions and Durations that produce values based on a simple model of time. This 
simple model of time is intended as an approximation for situations in which the more complex aspects of time and time 
measurement can safely be ignored. For example, in many distributed systems there is no global notion of time, only the 
notion of local time relative to each distributed element of the system. This relativity of time is not accounted for in the 
simple time model, nor are the effects resulting from imperfect clocks with finite resolution, overflows, drift, skew, etc. 
It is assumed that applications for which such characteristics are relevant will use a more sophisticated model of time 
provided by an appropriate profile.

8.4.2

Abstract Syntax

{subsets ownedElement}
+ expr

ValueSpecification

{subsets ownedElement}
+ expr

0..1

0..1

{subsets owner}
+ timeExpression

0..1

TimeExpression

+ timeExpression

0..1

{subsets owner}

0..1 + duration

Duration

0..1 + duration

PackageableElement

+ observation

Observation

+ observation

*

*

TimeObservation

+ firstEvent : Boolean = true

+ timeObservation

*

DurationObservation

+ firstEvent : Boolean [0..2]

* + durationObservation

+ event
1

NamedElement

+ event
{ordered}

1..2

Figure 8.3  Time and Duration

Unified Modeling Language 2.5

73

8.4.3

8.4.3.1

Semantics

Time

The structural modeling constructs of UML are used to model the properties of entities at specific points in time. In 
contrast, behavioral modeling constructs are used to model how these properties change over time. An event is a 
specification of something that may occur at a specific point in time when something of interest happens relative to the 
properties and behaviors being modeled, such as the change in value of a Property or the beginning of execution of an 
Activity.
Time in this conception is simply a coordinate that orders the occurrence of events. Every event occurrence can be given 
a time coordinate value and, based on this, can be said to be before, after or at the same time as another event 
occurrence.
A duration is the period of time between two event occurrences, computed as the difference of the time coordinates of 
those events. If a model Element has a behavioral effect, then this effect may occur over some duration. The starting 
event of this duration is known as entering the element and the ending event is known as exiting the Element.

8.4.3.2

Observations

An Observation denotes the observation of events that may occur relative to some other part of a model. An 
Observation is made on a NamedElement within the model. The events of interest are when the reference 
NamedElement is entered and exited. If the referenced NamedElement is not a behavioral element, then the duration 
between entering and exiting the NamedElement is considered to be zero, but this specification does not otherwise 
define what specific events are observed on the Element.
There are two kinds of Observations, TimeObservations and DurationObservations.
A TimeObservation observes either entering or exiting a specific NamedElement. If firstEvent is true, then it is the entry 
event that is observed, otherwise the exit event is observed. The result of a TimeObservation is the time at which the 
observed event occurs.
A DurationObservation observes a duration relative to either one or two NamedElements. If a single element is 
observed, then the observed duration is between sequential occurrences of the entry and exit events of the element. If 
two elements are observed, then the duration is between either the entry or the exit event of the first element and a 
subsequent entry or exit event of the second element. In the latter case, two corresponding firstEvent values must also be 
given for the DurationObservation, such that, if firstEvent=true for an observed element, then it is the entry event that is 
observed, otherwise it is the exit event that is observed.

8.4.3.3

TimeExpression

A TimeExpression is a ValueSpecification that evaluates to the time coordinate for an instant in time, possibly relative 
to some given set of observations.
If the TimeExpression has an expr, then this is evaluated to produce the result of the TimeExpression. The expr must 
evaluate to a single value, but UML does not define any specific type or units that the value must have. The expr may 
reference the observations associated with the TimeExpression but no standard notation is defined for such references. If 
the TimeExpression has an expr but no observations, then the expr evaluates to a time constant.
If the TimeExpression does not have an expr, then it must have a single TimeObservation and the result of that 
observation is the value of the TimeExpression.

8.4.3.4

Duration

A Duration is a ValueSpecification that evaluates to some duration in time, possibly relative to some given set of 
observations.
If the Duration has an expr, then this is evaluated to produce the result of the DurationExpression. The expr must 
evaluate to a single value, but UML does not define any specific type or units that the value must have. The expr may 

74

Unified Modeling Language 2.5

reference the observations associated with the Duration but no standard notation is defined for such references. If the 
Duration has an expr but no observations, then the expr evaluates to a duration constant.
If the Duration does not have an expr, then it must have a single DurationObservation and the result of that observation is 
the value of the Duration.

8.4.4

8.4.4.1

Notation

Observations

An Observation may be denoted by a straight line attached to the NamedElement it references. The Observation is given 
a name that is shown close to the unattached end of the line. Additional notation conventions on Observations are given 
elsewhere relative to the modeling constructs in which they are typically used (such as Interactions, see sub clause 
17.2).

8.4.4.2

Time Expressions and Durations

A TimeExpression or Duration is denoted by the textual representation of its expr, if it has one (see sub clause 8.3.5). 
The representation is of a formula for computing the time or duration value, which may include the names of related 
Observations and constants. If a TimeExpression or Duration does not have an expr, then it is simply represented by its 
single associated Observation.
A Duration is a value of relative time given in an implementation specific textual format. Often a Duration is a non-
negative integer expression representing the number of “time ticks” which may elapse during this duration.

Examples

8.4.5
Time is often represented using a numeric coordinate, in which case the expr of a TimeExpression should evaluate to a 
numeric value, the units of which may be assumed by convention in a model (e.g., times are always in seconds). 
Alternatively, DataTypes may be used to model time values with specific units (e.g., Second, Day, etc.) and the expr of a 
TimeExpression should then have the appropriate one of those types.
A Duration is a value of relative time and, as such, is often represented as a non-negative number, such as an Integer 
count of the number of “time ticks” on a reference clock that elapsed during the duration. In this case, the expr of a 
DurationExpression should evaluate to a non-negative numeric value. A Duration value may also be used to represent a 
time coordinate value as a Duration since some fixed “origin” of time.
See also Figure 8.5 in sub clause 8.5.5.

Intervals
Summary

8.5
8.5.1
An Interval is a range between two values, primarily for use in Constraints that assert that some other Element has a 
value in the given range. Intervals can be defined for any type of value, but they are especially useful for time and 
duration values as part of corresponding TimeConstraints and DurationConstraints.

Unified Modeling Language 2.5

75

8.5.2

Abstract Syntax

ValueSpecification

+ min

1

1 + max

Constraint

+ interval

*

* + interval

{redefines owningConstraint}

Interval

1
+ specification

+ intervalConstraint
0..1

{redefines specification}

IntervalConstraint

TimeInterval

{redefines specification}

+ specification
1

{redefines interval}
+ timeInterval

{redefines min}
+ min

*

1

{redefines interval}

* + timeInterval

{redefines max}

1 + max

{redefines intervalConstraint}
+ timeConstraint

TimeConstraint

0..1

+ firstEvent : Boolean [0..1] = true

{redefines intervalConstraint}

+ durationConstraint

0..1

DurationConstraint

+ firstEvent : Boolean [0..2]

DurationInterval

TimeExpression

{redefines specification}

+ specification
1

{redefines interval}
+ durationInterval

{redefines min}
+ min

*

1

{redefines interval}
* + durationInterval

{redefines max}

1 + max

Duration

Figure 8.4  Intervals

8.5.3

8.5.3.1

Semantics

Intervals

An Interval is a ValueSpecification specified using two other ValueSpecifications, the min and the max. An Interval is 
evaluated by first evaluating each of its constituent ValueSpecifications, which must each evaluate to a single value. The 
value of the Interval is then the range from the min value to the max value—that is, the set of all values greater than or 
equal to the min value and less than or equal to the max value (which may be the empty set). Note that, while 
syntactically any ValueSpecifications of any type are allowed for the min and max of an Interval, a standard semantic 
interpretation is only given for Intervals for which the min and max ValueSpecifications have the same type and that type 
has a total ordering defined on it.
There are two specializations of Interval for use with timing constraints. A TimeInterval specifies the range between two 
time values given by TimeExpressions. A DurationInterval specifies the range between two duration values given by 
Durations.

8.5.3.2

IntervalConstraint

An IntervalConstraint defines a Constraint whose specification is given by an Interval (see also sub clause 7.6 on 
Constraints). The constrainedElements of an IntervalConstraint are asserted to have values that are within the range 
specified by the Interval of the IntervalConstraint. If a constrainedElement has a value outside this range, then the 
IntervalConstraint is violated. If any constrainedElement cannot be interpreted to have a value, or its value is not the same 
type as the range given by the IntervalConstraint, then the IntervalConstraint has no standard semantic interpretation.
There are two specializations of IntervalConstraint for use in specifying timing constraints. A TimeConstraint defines an 
IntervalConstraint on a single constrainedElement in which the constraining Interval is a TimeInterval. A 
DurationConstraint defines an IntervalConstraint on either one or two constrainedElements in which the constraining 

76

Unified Modeling Language 2.5

Interval is a DurationInterval. If there are two constrainedElements, then the start of the duration being observed may be 
between an event in the first constrainedElement and an event in the second.

8.5.4

8.5.4.1

Notation

Intervals

An Interval is denoted textually by the textual representation of its two ValueSpecifications separated by “..”:
<interval> ::= <min-value> ‘ ..’ <max-value>
A TimeInterval is shown with the notation of Interval where each ValueSpecification element is a TimeExpression. A 
DurationInterval is shown using the notation of Interval where each ValueSpecification element is a Duration. (See sub 
clause 8.4.4 on the notation for TimeExpressions and Durations.)

8.5.4.2

Interval Constraints

An IntervalConstraint is shown as an annotation of its constrainedElement. The general notation for Constraints (see sub 
clause 7.6.4) may be used for an IntervalConstraint, with the specification Interval denoted textually as above. Special 
notational constructs are defined for TimeConstraints and DurationConstraints, as given below.
A TimeConstraint of a single constrainedElement may be shown as a small line between the graphical representation of 
the constrainedElement and the textual representation of the TimeInterval of TimeConstraint. A DurationConstraint may 
also be shown using a graphical notation relating its constrainedElements. However, the notation used is specific to the 
diagram type on which the DurationConstraint appears (see sub clause 17.8 for the notation on Sequence Diagrams and 
sub clause 17.11 for the notation on Timing Diagrams).

Examples

8.5.5
Figure 8.5 shows a DurationConstraints associated with the duration of a Message and with the duration between two 
OccurrenceSpecifications. It also shows a TimeConstraint associated with the reception of a Message. (See also sub 
clause 17.2.5.)

Figure 8.5  Example of DurationConstraints and TimeConstraints

Unified Modeling Language 2.5

77

8.6
8.6.1

8.6.1.1

Classifier Descriptions
Duration [Class]

Description

A Duration is a ValueSpecification that specifies the temporal distance between two time instants.

8.6.1.2

Diagrams

Time, Intervals

8.6.1.3

Generalizations

8.6.1.4
•

•

ValueSpecification

Association Ends

♦ expr : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite A_expr_duration::duration)
A ValueSpecification that evaluates to the value of the Duration.

observation : Observation [0..*] (opposite A_observation_duration::duration)
Refers to the Observations that are involved in the computation of the Duration value.

8.6.1.5

Constraints

•

no_expr_requires_observation
If a Duration has no expr, then it must have a single observation that is a DurationObservation.

inv: expr = null implies (observation->size() = 1 and observation-
>forAll(oclIsKindOf(DurationObservation)))

8.6.2

8.6.2.1

DurationConstraint [Class]

Description

A DurationConstraint is a Constraint that refers to a DurationInterval.

8.6.2.2

Diagrams

Intervals

8.6.2.3

Generalizations

IntervalConstraint

Attributes

firstEvent : Boolean [0..2]
The value of firstEvent[i] is related to constrainedElement[i] (where i is 1 or 2). If firstEvent[i] is true, then the 
corresponding observation event is the first time instant the execution enters constrainedElement[i]. If 
firstEvent[i] is false, then the corresponding observation event is the last time instant the execution is within 
constrainedElement[i].

Unified Modeling Language 2.5

8.6.2.4
•

78

8.6.2.5
•

Association Ends

♦ specification : DurationInterval [1..1]{redefines IntervalConstraint::specification} (opposite 
A_specification_durationConstraint::durationConstraint)
The DurationInterval constraining the duration.

8.6.2.6

Constraints

•

•

first_event_multiplicity
The multiplicity of firstEvent must be 2 if the multiplicity of constrainedElement is 2. Otherwise the 
multiplicity of firstEvent is 0.

inv: if (constrainedElement->size() = 2)
  then (firstEvent->size() = 2) else (firstEvent->size() = 0)
endif

has_one_or_two_constrainedElements
A DurationConstraint has either one or two constrainedElements.

inv: constrainedElement->size() = 1 or constrainedElement->size()=2

8.6.3

8.6.3.1

DurationInterval [Class]

Description

A DurationInterval defines the range between two Durations.

8.6.3.2

Diagrams

Intervals

8.6.3.3

Generalizations

Interval

8.6.3.4

Association Ends

• max : Duration [1..1]{redefines Interval::max} (opposite A_max_durationInterval::durationInterval)

Refers to the Duration denoting the maximum value of the range.

• min : Duration [1..1]{redefines Interval::min} (opposite A_min_durationInterval::durationInterval)

Refers to the Duration denoting the minimum value of the range.

8.6.4

8.6.4.1

DurationObservation [Class]

Description

A DurationObservation is a reference to a duration during an execution. It points out the NamedElement(s) in the model 
to observe and whether the observations are when this NamedElement is entered or when it is exited.

8.6.4.2

Diagrams

Time

Unified Modeling Language 2.5

79

8.6.4.3

Generalizations

8.6.4.4
•

8.6.4.5
•

Observation

Attributes

firstEvent : Boolean [0..2]
The value of firstEvent[i] is related to event[i] (where i is 1 or 2). If firstEvent[i] is true, then the corresponding 
observation event is the first time instant the execution enters event[i]. If firstEvent[i] is false, then the 
corresponding observation event is the time instant the execution exits event[i].

Association Ends

event : NamedElement [1..2]{ordered} (opposite A_event_durationObservation::durationObservation)
The DurationObservation is determined as the duration between the entering or exiting of a single event 
Element during execution, or the entering/exiting of one event Element and the entering/exiting of a second.

8.6.4.6

Constraints

•

first_event_multiplicity
The multiplicity of firstEvent must be 2 if the multiplicity of event is 2. Otherwise the multiplicity of firstEvent 
is 0.

inv: if (event->size() = 2)
  then (firstEvent->size() = 2) else (firstEvent->size() = 0)
endif

8.6.5

8.6.5.1

Expression [Class]

Description

An Expression represents a node in an expression tree, which may be non-terminal or terminal. It defines a symbol, and 
has a possibly empty sequence of operands that are ValueSpecifications. It denotes a (possibly empty) set of values 
when evaluated in a context.

8.6.5.2

Diagrams

Expressions

8.6.5.3

Generalizations

ValueSpecification

8.6.5.4

Specializations

StringExpression

Attributes

symbol : String [0..1]
The symbol associated with this node in the expression tree.

8.6.5.5
•

80

Unified Modeling Language 2.5

8.6.5.6
•

8.6.6

8.6.6.1

Association Ends

♦ operand : ValueSpecification [0..*]{ordered, subsets Element::ownedElement} (opposite 
A_operand_expression::expression)
Specifies a sequence of operand ValueSpecifications.

Interval [Class]

Description

An Interval defines the range between two ValueSpecifications.

8.6.6.2

Diagrams

Intervals

8.6.6.3

Generalizations

ValueSpecification

8.6.6.4

Specializations

DurationInterval, TimeInterval

8.6.6.5

Association Ends

• max : ValueSpecification [1..1] (opposite A_max_interval::interval)

Refers to the ValueSpecification denoting the maximum value of the range.

• min : ValueSpecification [1..1] (opposite A_min_interval::interval)

Refers to the ValueSpecification denoting the minimum value of the range.

8.6.7

8.6.7.1

IntervalConstraint [Class]

Description

An IntervalConstraint is a Constraint that is specified by an Interval.

8.6.7.2

Diagrams

Intervals

8.6.7.3

Generalizations

Constraint

8.6.7.4

Specializations

8.6.7.5
•

DurationConstraint, TimeConstraint

Association Ends

♦ specification : Interval [1..1]{redefines Constraint::specification} (opposite 
A_specification_intervalConstraint::intervalConstraint)
The Interval that specifies the condition of the IntervalConstraint.

Unified Modeling Language 2.5

81

8.6.8

8.6.8.1

LiteralBoolean [Class]

Description

A LiteralBoolean is a specification of a Boolean value.

8.6.8.2

Diagrams

Literals

8.6.8.3

Generalizations

LiteralSpecification

Attributes

value : Boolean [1..1] = false
The specified Boolean value.

Operations

booleanValue() : Boolean {redefines ValueSpecification::booleanValue()}
The query booleanValue() gives the value.

body: value

isComputable() : Boolean {redefines ValueSpecification::isComputable()}
The query isComputable() is redefined to be true.

body: true

LiteralInteger [Class]

Description

8.6.8.4
•

8.6.8.5
•

•

8.6.9

8.6.9.1

A LiteralInteger is a specification of an Integer value.

8.6.9.2

Diagrams

Literals

8.6.9.3

Generalizations

LiteralSpecification

Attributes

value : Integer [1..1] = 0
The specified Integer value.

Operations

integerValue() : Integer {redefines ValueSpecification::integerValue()}
The query integerValue() gives the value.

8.6.9.4
•

8.6.9.5
•

82

Unified Modeling Language 2.5

body: value

•

isComputable() : Boolean {redefines ValueSpecification::isComputable()}
The query isComputable() is redefined to be true.

body: true

8.6.10

8.6.10.1

LiteralNull [Class]

Description

A LiteralNull specifies the lack of a value.

8.6.10.2

Diagrams

Literals

8.6.10.3

Generalizations

LiteralSpecification

8.6.10.4

Operations

•

•

isComputable() : Boolean {redefines ValueSpecification::isComputable()}
The query isComputable() is redefined to be true.

body: true

isNull() : Boolean {redefines ValueSpecification::isNull()}
The query isNull() returns true.

body: true

8.6.11

8.6.11.1

LiteralReal [Class]

Description

A LiteralReal is a specification of a Real value.

8.6.11.2

Diagrams

Literals

8.6.11.3

Generalizations

LiteralSpecification

8.6.11.4

Attributes

•

value : Real [1..1]
The specified Real value.

8.6.11.5

Operations

•

isComputable() : Boolean {redefines ValueSpecification::isComputable()}
The query isComputable() is redefined to be true.

Unified Modeling Language 2.5

83

body: true

•

realValue() : Real {redefines ValueSpecification::realValue()}
The query realValue() gives the value.

body: value

8.6.12

8.6.12.1

LiteralSpecification [Abstract Class]

Description

A LiteralSpecification identifies a literal constant being modeled.

8.6.12.2

Diagrams

Literals

8.6.12.3

Generalizations

ValueSpecification

8.6.12.4

Specializations

LiteralBoolean, LiteralInteger, LiteralNull, LiteralReal, LiteralString, LiteralUnlimitedNatural

8.6.13

8.6.13.1

LiteralString [Class]

Description

A LiteralString is a specification of a String value.

8.6.13.2

Diagrams

Literals

8.6.13.3

Generalizations

LiteralSpecification

8.6.13.4

Attributes

•

value : String [0..1]
The specified String value.

8.6.13.5

Operations

isComputable() : Boolean {redefines ValueSpecification::isComputable()}
The query isComputable() is redefined to be true.

body: true

stringValue() : String {redefines ValueSpecification::stringValue()}
The query stringValue() gives the value.

body: value

•

•

84

Unified Modeling Language 2.5

8.6.14

8.6.14.1

LiteralUnlimitedNatural [Class]

Description

A LiteralUnlimitedNatural is a specification of an UnlimitedNatural number.

8.6.14.2

Diagrams

Literals

8.6.14.3

Generalizations

LiteralSpecification

8.6.14.4

Attributes

•

value : UnlimitedNatural [1..1] = 0
The specified UnlimitedNatural value.

8.6.14.5

Operations

•

•

isComputable() : Boolean {redefines ValueSpecification::isComputable()}
The query isComputable() is redefined to be true.

body: true

unlimitedValue() : UnlimitedNatural {redefines ValueSpecification::unlimitedValue()}
The query unlimitedValue() gives the value.

body: value

8.6.15

8.6.15.1

Observation [Abstract Class]

Description

Observation specifies a value determined by observing an event or events that occur relative to other model Elements.

8.6.15.2

Diagrams

Time

8.6.15.3

Generalizations

PackageableElement

8.6.15.4

Specializations

DurationObservation, TimeObservation

8.6.16

8.6.16.1

OpaqueExpression [Class]

Description

An OpaqueExpression is a ValueSpecification that specifies the computation of a collection of values either in terms of 
a UML Behavior or based on a textual statement in a language other than UML

Unified Modeling Language 2.5

85

8.6.16.2

Diagrams

Expressions, Dependencies

8.6.16.3

Generalizations

ValueSpecification

8.6.16.4

Attributes

•

•

body : String [0..*]
A textual definition of the behavior of the OpaqueExpression, possibly in multiple languages.

language : String [0..*]
Specifies the languages used to express the textual bodies of the OpaqueExpression. Languages are matched to 
body Strings by order. The interpretation of the body depends on the languages. If the languages are 
unspecified, they may be implicit from the expression body or the context.

8.6.16.5

Association Ends

•

•

behavior : Behavior [0..1] (opposite A_behavior_opaqueExpression::opaqueExpression)
Specifies the behavior of the OpaqueExpression as a UML Behavior.

/result : Parameter [0..1]{} (opposite A_result_opaqueExpression::opaqueExpression)
If an OpaqueExpression is specified using a UML Behavior, then this refers to the single required return 
Parameter of that Behavior. When the Behavior completes execution, the values on this Parameter give the 
result of evaluating the OpaqueExpression.

8.6.16.6

Operations

•

•

•

•

isIntegral() : Boolean
The query isIntegral() tells whether an expression is intended to produce an Integer.

body: false

isNonNegative() : Boolean
The query isNonNegative() tells whether an integer expression has a non-negative value.

pre: self.isIntegral()
body: false

isPositive() : Boolean
The query isPositive() tells whether an integer expression has a positive value.

pre: self.isIntegral()
body: false

result() : Parameter [0..1]
Derivation for OpaqueExpression::/result

body: if behavior = null then

null

else

behavior.ownedParameter->first()

endif

86

Unified Modeling Language 2.5

•

value() : Integer
The query value() gives an integer value for an expression intended to produce one.

pre: self.isIntegral()
body: 0

8.6.16.7

Constraints

•

•

•

language_body_size
If the language attribute is not empty, then the size of the body and language arrays must be the same.

inv: language->notEmpty() implies (_'body'->size() = language->size())

one_return_result_parameter
The behavior must have exactly one return result parameter.

inv: behavior <> null implies
   behavior.ownedParameter->select(direction=ParameterDirectionKind::return)->size() = 1

only_return_result_parameters
The behavior may only have return result parameters.

inv: behavior <> null implies behavior.ownedParameter-
>select(direction<>ParameterDirectionKind::return)->isEmpty()

8.6.17

8.6.17.1

StringExpression [Class]

Description

A StringExpression is an Expression that specifies a String value that is derived by concatenating a sequence of 
operands with String values or a sequence of subExpressions, some of which might be template parameters.

8.6.17.2

Diagrams

Expressions, Namespaces

8.6.17.3

Generalizations

TemplateableElement, Expression

8.6.17.4

Association Ends

•

•

owningExpression : StringExpression [0..1]{subsets Element::owner} (opposite 
StringExpression::subExpression)
The StringExpression of which this StringExpression is a subExpression.

♦ subExpression : StringExpression [0..*]{ordered, subsets Element::ownedElement} (opposite 
StringExpression::owningExpression)
The StringExpressions that constitute this StringExpression.

8.6.17.5

Operations

•

stringValue() : String {redefines ValueSpecification::stringValue()}
The query stringValue() returns the String resulting from concatenating, in order, all the component String 
values of all the operands or subExpressions that are part of the StringExpression.

Unified Modeling Language 2.5

87

body: if subExpression->notEmpty()
then subExpression->iterate(se; stringValue: String = '' | 
stringValue.concat(se.stringValue()))
else operand->iterate(op; stringValue: String = '' | stringValue.concat(op.stringValue()))
endif

8.6.17.6

Constraints

•

•

operands
All the operands of a StringExpression must be LiteralStrings

inv: operand->forAll (oclIsKindOf (LiteralString))

subexpressions
If a StringExpression has sub-expressions, it cannot have operands and vice versa (this avoids the problem of 
having to define a collating sequence between operands and subexpressions).

inv: if subExpression->notEmpty() then operand->isEmpty() else operand->notEmpty() endif

8.6.18

8.6.18.1

TimeConstraint [Class]

Description

A TimeConstraint is a Constraint that refers to a TimeInterval.

8.6.18.2

Diagrams

Intervals

8.6.18.3

Generalizations

IntervalConstraint

8.6.18.4

Attributes

•

firstEvent : Boolean [0..1] = true
The value of firstEvent is related to the constrainedElement. If firstEvent is true, then the corresponding 
observation event is the first time instant the execution enters the constrainedElement. If firstEvent is false, 
then the corresponding observation event is the last time instant the execution is within the 
constrainedElement.

8.6.18.5

Association Ends

•

♦ specification : TimeInterval [1..1]{redefines IntervalConstraint::specification} (opposite 
A_specification_timeConstraint::timeConstraint)
TheTimeInterval constraining the duration.

8.6.18.6

Constraints

•

has_one_constrainedElement
A TimeConstraint has one constrainedElement.

inv: constrainedElement->size() = 1

88

Unified Modeling Language 2.5

8.6.19

8.6.19.1

TimeExpression [Class]

Description

A TimeExpression is a ValueSpecification that represents a time value.

8.6.19.2

Diagrams

Time, Intervals, Events

8.6.19.3

Generalizations

ValueSpecification

8.6.19.4

Association Ends

•

•

♦ expr : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_expr_timeExpression::timeExpression)
A ValueSpecification that evaluates to the value of the TimeExpression.

observation : Observation [0..*] (opposite A_observation_timeExpression::timeExpression)
Refers to the Observations that are involved in the computation of the TimeExpression value.

8.6.19.5

Constraints

•

no_expr_requires_observation
If a TimeExpression has no expr, then it must have a single observation that is a TimeObservation.

inv: expr = null implies (observation->size() = 1 and observation-
>forAll(oclIsKindOf(TimeObservation)))

8.6.20

8.6.20.1

TimeInterval [Class]

Description

A TimeInterval defines the range between two TimeExpressions.

8.6.20.2

Diagrams

Intervals

8.6.20.3

Generalizations

Interval

8.6.20.4

Association Ends

• max : TimeExpression [1..1]{redefines Interval::max} (opposite A_max_timeInterval::timeInterval)

Refers to the TimeExpression denoting the maximum value of the range.

• min : TimeExpression [1..1]{redefines Interval::min} (opposite A_min_timeInterval::timeInterval)

Refers to the TimeExpression denoting the minimum value of the range.

Unified Modeling Language 2.5

89

8.6.21

8.6.21.1

TimeObservation [Class]

Description

A TimeObservation is a reference to a time instant during an execution. It points out the NamedElement in the model to 
observe and whether the observation is when this NamedElement is entered or when it is exited.

8.6.21.2

Diagrams

Time

8.6.21.3

Generalizations

Observation

8.6.21.4

Attributes

•

firstEvent : Boolean [1..1] = true
The value of firstEvent is related to the event. If firstEvent is true, then the corresponding observation event is 
the first time instant the execution enters the event Element. If firstEvent is false, then the corresponding 
observation event is the time instant the execution exits the event Element.

8.6.21.5

Association Ends

•

event : NamedElement [1..1] (opposite A_event_timeObservation::timeObservation)
The TimeObservation is determined by the entering or exiting of the event Element during execution.

8.6.22

8.6.22.1

ValueSpecification [Abstract Class]

Description

A ValueSpecification is the specification of a (possibly empty) set of values. A ValueSpecification is a 
ParameterableElement that may be exposed as a formal TemplateParameter and provided as the actual parameter in the 
binding of a template.

8.6.22.2

Diagrams

Expressions, Literals, Time, Intervals, Object Nodes, Activities, Control Nodes, Messages, Lifelines, 
Fragments, Interaction Uses, Types, Constraints, Events, Features, Properties, Instances, Actions, Object 
Actions

8.6.22.3

Generalizations

TypedElement, PackageableElement

8.6.22.4

Specializations

Duration, Expression, Interval, LiteralSpecification, OpaqueExpression, TimeExpression, InstanceValue

8.6.22.5

Operations

•

booleanValue() : Boolean [0..1]
The query booleanValue() gives a single Boolean value when one can be computed.

body: null

90

Unified Modeling Language 2.5

•

•

•

•

•

•

•

integerValue() : Integer [0..1]
The query integerValue() gives a single Integer value when one can be computed.

body: null

isCompatibleWith(p : ParameterableElement) : Boolean {redefines 
ParameterableElement::isCompatibleWith()}
The query isCompatibleWith() determines if this ValueSpecification is compatible with the specified 
ParameterableElement. This ValueSpecification is compatible with ParameterableElement p if the kind of this 
ValueSpecification is the same as or a subtype of the kind of p. Further, if p is a TypedElement, then the type of 
this ValueSpecification must be conformant with the type of p.

body: self.oclIsKindOf(p.oclType()) and (p.oclIsKindOf(TypedElement) implies
self.type.conformsTo(p.oclAsType(TypedElement).type))

isComputable() : Boolean
The query isComputable() determines whether a value specification can be computed in a model. This 
operation cannot be fully defined in OCL. A conforming implementation is expected to deliver true for this 
operation for all ValueSpecifications that it can compute, and to compute all of those for which the operation is 
true. A conforming implementation is expected to be able to compute at least the value of all 
LiteralSpecifications.

body: false

isNull() : Boolean
The query isNull() returns true when it can be computed that the value is null.

body: false

realValue() : Real [0..1]
The query realValue() gives a single Real value when one can be computed.

body: null

stringValue() : String [0..1]
The query stringValue() gives a single String value when one can be computed.

body: null

unlimitedValue() : UnlimitedNatural [0..1]
The query unlimitedValue() gives a single UnlimitedNatural value when one can be computed.

8.7
8.7.1

8.7.1.1

body: null

Association Descriptions
A_behavior_opaqueExpression [Association]

Diagrams

Expressions

Unified Modeling Language 2.5

91

8.7.1.2
•

8.7.2

8.7.2.1

8.7.2.2
•

8.7.3

8.7.3.1

8.7.3.2
•

8.7.4

8.7.4.1

8.7.4.2
•

8.7.5

8.7.5.1

8.7.5.2
•

8.7.6

8.7.6.1

Owned Ends

opaqueExpression : OpaqueExpression [0..*] (opposite OpaqueExpression::behavior)

A_event_durationObservation [Association]

Diagrams

Time

Owned Ends

durationObservation : DurationObservation [0..*] (opposite DurationObservation::event)

A_event_timeObservation [Association]

Diagrams

Time

Owned Ends

timeObservation : TimeObservation [0..*] (opposite TimeObservation::event)

A_expr_duration [Association]

Diagrams

Time

Owned Ends

duration : Duration [0..1]{subsets Element::owner} (opposite Duration::expr)

A_expr_timeExpression [Association]

Diagrams

Time

Owned Ends

timeExpression : TimeExpression [0..1]{subsets Element::owner} (opposite TimeExpression::expr)

A_max_durationInterval [Association]

Diagrams

Intervals

8.7.6.2

Generalizations

A_max_interval

92

Unified Modeling Language 2.5

8.7.6.3
•

8.7.7

8.7.7.1

Owned Ends

durationInterval : DurationInterval [0..*]{redefines A_max_interval::interval} (opposite 
DurationInterval::max)

A_max_interval [Association]

Diagrams

Intervals

8.7.7.2

Specializations

8.7.7.3
•

8.7.8

8.7.8.1

A_max_timeInterval, A_max_durationInterval

Owned Ends

interval : Interval [0..*] (opposite Interval::max)

A_max_timeInterval [Association]

Diagrams

Intervals

8.7.8.2

Generalizations

8.7.8.3
•

8.7.9

8.7.9.1

A_max_interval

Owned Ends

timeInterval : TimeInterval [0..*]{redefines A_max_interval::interval} (opposite TimeInterval::max)

A_min_durationInterval [Association]

Diagrams

Intervals

8.7.9.2

Generalizations

A_min_interval

Owned Ends

durationInterval : DurationInterval [0..*]{redefines A_min_interval::interval} (opposite DurationInterval::min)

8.7.9.3
•

8.7.10

8.7.10.1

A_min_interval [Association]

Diagrams

Intervals

Unified Modeling Language 2.5

93

8.7.10.2

Specializations

A_min_timeInterval, A_min_durationInterval

8.7.10.3

Owned Ends

•

8.7.11

8.7.11.1

interval : Interval [0..*] (opposite Interval::min)

A_min_timeInterval [Association]

Diagrams

Intervals

8.7.11.2

Generalizations

A_min_interval

8.7.11.3

Owned Ends

•

timeInterval : TimeInterval [0..*]{redefines A_min_interval::interval} (opposite TimeInterval::min)

A_observation_duration [Association]

Diagrams

8.7.12

8.7.12.1

Time

8.7.12.2

Owned Ends

•

duration : Duration [0..1] (opposite Duration::observation)

A_observation_timeExpression [Association]

Diagrams

8.7.13

8.7.13.1

Time

8.7.13.2

Owned Ends

•

timeExpression : TimeExpression [0..1] (opposite TimeExpression::observation)

8.7.14

8.7.14.1

A_operand_expression [Association]

Diagrams

Expressions

8.7.14.2

Owned Ends

•

expression : Expression [0..1]{subsets Element::owner} (opposite Expression::operand)

94

Unified Modeling Language 2.5

8.7.15

8.7.15.1

A_result_opaqueExpression [Association]

Diagrams

Expressions

8.7.15.2

Owned Ends

•

opaqueExpression : OpaqueExpression [0..*] (opposite OpaqueExpression::result)

8.7.16

8.7.16.1

A_specification_durationConstraint [Association]

Diagrams

Intervals

8.7.16.2

Generalizations

A_specification_intervalConstraint

8.7.16.3

Owned Ends

•

durationConstraint : DurationConstraint [0..1]{redefines 
A_specification_intervalConstraint::intervalConstraint} (opposite DurationConstraint::specification)

8.7.17

8.7.17.1

A_specification_intervalConstraint [Association]

Diagrams

Intervals

8.7.17.2

Generalizations

A_specification_owningConstraint

8.7.17.3

Specializations

A_specification_timeConstraint, A_specification_durationConstraint

8.7.17.4

Owned Ends

•

intervalConstraint : IntervalConstraint [0..1]{redefines A_specification_owningConstraint::owningConstraint} 
(opposite IntervalConstraint::specification)

8.7.18

8.7.18.1

A_specification_timeConstraint [Association]

Diagrams

Intervals

8.7.18.2

Generalizations

A_specification_intervalConstraint

Unified Modeling Language 2.5

95

8.7.18.3

Owned Ends

•

timeConstraint : TimeConstraint [0..1]{redefines A_specification_intervalConstraint::intervalConstraint} 
(opposite TimeConstraint::specification)

8.7.19

8.7.19.1

A_subExpression_owningExpression [Association]

Diagrams

Expressions

8.7.19.2

Member Ends

•

•

StringExpression::subExpression
 

 

StringExpression::owningExpression
 

 

96

Unified Modeling Language 2.5

Classification
Summary

9
9.1
Classification is an important technique for organization. This clause specifies concepts relating to classification. The 
core concept is Classifier, an abstract metaclass whose concrete subclasses are used to classify different kinds of values.  
The other metaclasses in this clause represent the constituents of Classifiers, models of how Classifiers are instantiated 
using InstanceSpecifications, and various relationships between all of these concepts.

Classifiers
Summary

9.2
9.2.1
A Classifier represents a classification of instances according to their Features. Classifiers are organized in hierarchies 
by Generalizations. RedefinableElements may be redefined in the context of Generalization hierarchies.

9.2.2

Abstract Syntax

Namespace

Type

TemplateableElement

DirectedRelationship

{subsets ownedElement}
+ collaborationUse

*

{subsets collaborationUse}
+ representation

0..1

{readOnly, subsets member}
+ /inheritedMember

*

CollaborationUse

NamedElement

Figure 9.1  Classifiers

9.2.3

9.2.3.1

Semantics

Classifiers

A Classifier has a set of Features, some of which are Properties called the attributes of the Classifier. Each of the Features 
is a member of the Classifier (see sub clause 7.4 Namespaces).
The values that are classified by a Classifier are called instances of the Classifier.
A Classifier may be redefined (see below).

Unified Modeling Language 2.5

97

*

NamedElement

+ /inheritedMember

{readOnly, subsets member}

RedefinableElement

+ isLeaf : Boolean = false

+ inheritingClassifier

{subsets memberNamespace}
*

Classifier

+ isAbstract : Boolean
+ isFinalSpecialization : Boolean

{readOnly, union}

+ /redefinableElement

*

*

+ /redefinedElement
{readOnly, union}

{subsets redefinedElement}
+ redefinedClassifier

*
*

+ classifier
{subsets redefinableElement}

{readOnly, union}
+ /redefinableElement

{readOnly, union}
+ /redefinitionContext

*

*

Feature

+ /feature

{readOnly, union, subsets member}

*

0..1

+ /featuringClassifier
{readOnly, union, subsets memberNamespace}

{readOnly, union, subsets featuringClassifier,
subsets redefinitionContext}

Property

*
+ /attribute

{ordered, readOnly, union, subsets
feature, subsets redefinableElement}

+ /classifier
0..1

{subsets owner}
+ classifier

0..1

{subsets source,
subsets owner}
+ specific

1

{subsets target}
+ general

1

+ classifier
*
*

+ /general

+ powertype

0..1

+ subject
*

+ classifier
{subsets namespace}

{subsets ownedElement, subsets
directedRelationship}

+ generalization

Generalization

+ isSubstitutable : Boolean [0..1] = true

*
{subsets
directedRelationship}
+ generalization
*

*

*

+ generalization

+ generalizationSet

+ powertypeExtent

*

GeneralizationSet

+ useCase
*
+ ownedUseCase
{subsets ownedMember}

UseCase

0..1
+ contract
{subsets supplier}
1
+ substitutingClassifier
{subsets client, subsets owner}
1

*
+ substitution
{subsets supplierDependency}

*

*
+ substitution
{subsets ownedElement,
subsets clientDependency}

{subsets memberNamespace}
+ inheritingClassifier

*

{redefines classifier}

0..1 + classifier

Substitution

Realization

A Classifier may own CollaborationUses that relate the Classifier to Collaborations. The Collaborations describes 
aspects of this Classifier. See 11.7 Collaborations.
A Classifier may own UseCases. See 18.1 Use Cases.

9.2.3.2

Generalization

Generalizations define generalization/specialization relationships between Classifiers. Each Generalization relates a 
specific Classifier to a more general Classifier. Given a Classifier, the transitive closure of its general Classifiers is often 
called its generalizations, and the transitive closure of its specific Classifiers is called its specializations. The immediate 
generalizations are also called the Classifier’s parents, and where the Classifier is a Class, its superClasses (see 11.4).
NOTE. The concept of parent (a generalization relationship between Classifiers) is unrelated to the concept of owner (a 
composition relationship between instances).
An instance of a Classifier is also an (indirect) instance of each of its generalizations. Any Constraints applying to 
instances of the generalizations also apply to instances of the Classifier.
When a Classifier is generalized, certain members of its generalizations are inherited, that is they behave as though they 
were defined in the inheriting Classifier itself. For example, an inherited member that is an attribute may have a value or 
collection of values in any instance of the inheriting Classifier, and an inherited member that is an Operation may be 
invoked on an instance of the inheriting Classifier.
The set of members that are inherited is called the inheritedMembers. Unless specified differently for a particular kind of 
Classifier, the inheritedMembers are members that do not have private visibility.
Type conformance means that if one Type conforms to another, then any instance of the first Type may be used as the 
value of a TypedElement whose type is declared to be the second Type. A Classifier is a Type, and conforms to itself and 
to all of its generalizations.
The isAbstract property of Classifier, when true, specifies that the Classifier is abstract, i.e., has no direct instances: every 
instance of the abstract Classifier shall be an instance of one of its specializations.
If one Classifier (the parent) generalizes another (the child) it is not necessarily the case that instances of the child are 
substitutable for instances of the parent under every possible circumstance. For example, Circle may be defined as a 
specialization of Ellipse, and its instances would be substitutable in every circumstance involving accessing the 
properties of an Ellipse. However, if Ellipse were to define a stretch behavior that modifies the length of its major axis 
only, then a Circle object would be unable to implement such a behavior. The isSubstitutable property may be used to 
indicate whether the specific Classifier can be used in every circumstance that the general Classifier can be used.

9.2.3.3

Redefinition

Any member (that is a kind of RedefinableElement) of a generalization of a specializing Classifier may be redefined 
instead of being inherited. Redefinition is done in order to augment, constrain, or override the redefined member(s) in 
the context of instances of the specializing Classifier. When this occurs, the redefining member contributes to the 
structure or behavior of the specializing Classifier in place of the redefined member(s); specifically, any reference to a 
redefined member in the context of an instance of the specializing Classifier shall resolve to the redefining member (note 
that to avoid circularity “any reference” here excludes the redefinedElement reference itself).
The Classifier from which the member may be redefined is called the redefinitionContext. Although in the metamodel 
redefinitionContext has the multiplicity ‘*’, there are no cases in the UML specification where there is more than one 
redefinitionContext. The redefinitionContext is defined for each kind of RedefinableElement; it is often, but not always, the 
owner of the member.
A redefining element shall be consistent with the RedefinableElement it redefines, but it may add specific constraints or 
other details that are particular to instances of the specializing redefinitionContext that do not contradict constraints in the 
general context.
One redefining element may redefine multiple RedefinableElements. Furthermore, a RedefinableElement may be 
redefined multiple times, as long as it is unambiguous which definition applies for a particular instance.

98

Unified Modeling Language 2.5

The isLeaf property, when true for a particular RedefinableElement, specifies that it shall have no redefinitions.
The detailed semantics of redefinition vary for each specialization of RedefinableElement. There are various kinds of 
compatibility between a redefined element and its redefining element, such as name compatibility (the redefining 
element has the same name as the redefined element), structural compatibility (the client visible properties of the 
redefined element are also properties of the redefining element), or behavioral compatibility (the redefining element is 
substitutable for the redefined element). Any kind of compatibility involves a constraint on redefinitions.
Classifier is itself a RedefinableElement. This can come into play when a Classifier is nested in a Class or Interface, 
which becomes the redefinitionContext. Redefining a Classifier in the context of a specializing Class or Interface has the 
effect of making any references to the redefined Classifier from an instance of the specializing Class or Interface resolve 
to the redefining Classifier.

9.2.3.4

Substitution

A Substitution is a relationship between two Classifiers which signifies that the substitutingClassifier complies with the 
contract specified by the contract Classifier. This implies that instances of the substitutingClassifier are runtime 
substitutable where instances of the contract Classifier are expected. The Substitution dependency denotes runtime 
substitutability that is not based on specialization. Substitution, unlike specialization, does not imply inheritance of 
structure, but only compliance of publicly available contracts. It requires that:

•

Interfaces implemented by the contract Classifier are also implemented by the substitutingClassifier or else the 
substitutingClassifier implements a more specialized Interface type.

• Any Port owned by the contract Classifier has a matching Port (see 11.3.3) owned by the substitutingClassifier.

9.2.4

9.2.4.1

Notation

Classifiers

Classifier is an abstract metaclass. It is nevertheless convenient to define in one place a default notation available for 
any concrete subclass of Classifier.  Some specializations of Classifier have their own distinct notations.
The default notation for a Classifier is a solid-outline rectangle containing the Classifier’s name, and with compartments 
separated by horizontal lines below the name. The name of the Classifier should be centered in boldface. For those 
languages that distinguish between uppercase and lowercase characters, Classifier names should begin with an 
uppercase character.
If the default notation is used for a Classifier, a keyword corresponding to the metaclass of the Classifier shall be shown 
in guillemets above the name. The keywords for each metaclass are listed in Annex C and are specified in the notation 
for each subclass of Classifier. No keyword is needed to indicate that the metaclass is Class.
Any keywords (including stereotype names) should also be centered in plain face within guillemets above the Classifier 
name. If multiple keywords and/or stereotype names apply to the same model element, each may be enclosed in a 
separate pair of guillemets and listed one after the other. Alternatively they may all appear between the same pair of 
guillemets, separated by commas.
The name of an abstract Classifier is shown in italics, where permitted by the font in use.  Alternatively or in addition, 
an abstract Classifier may be shown using the textual annotation {abstract} after or below its name.
Some compartments in Classifier shapes are mandatory and shall be supported by tools that exhibit concrete syntax 
conformance. Others are optional, in the sense that a conforming tool may not support such compartments.
Any compartment may be suppressed. A separator line is not drawn for a suppressed compartment. If a compartment is 
suppressed, no inference may be drawn about the presence or absence of elements in it.
The compartment named “attributes” contains notation for the Properties that are reached via the attribute property. The 
attributes compartment is mandatory and always appears above other compartments, if it is not suppressed.

Unified Modeling Language 2.5

99

The compartment named “operations” contains notation for Operations. The operations compartment is mandatory and 
always appears below the attributes compartment, if it is not suppressed. The operations compartment is used for 
Classifiers that own Operations, including Class (see 11.4), DataType (see 10.2) and Interface (see 10.4).
The compartment named “receptions” contains notation for Receptions. The receptions compartment is mandatory and 
always appears below the operations compartment, if it is not suppressed. The receptions compartment is used for 
Classifiers that own Receptions, including Class (see 11.4).
Any compartment which contains notation for Features may show those Features grouped under the literals public, 
private and protected, representing their visibility. The visibility literals are left-justified in the compartment with the 
Features’ notation appearing indented beneath them. The groups may appear in any order. Visibility grouping is 
optional: a conforming tool need not support it.
A conforming tool may provide the option to suppress individual Features in a compartment containing notation for 
Features.
A conforming tool may optionally support compartment naming. A compartment’s name may be shown to remove 
ambiguity, or it may be hidden. Compartment names should be centered and start with lower-case letters. Compartment 
names may contain spaces and should not contain punctuation (including guillemets).
If a Classifier has ownedMembers that are Classifiers (including Behaviors – see 13.2), a conforming tool may provide 
the option to show the owned Classifiers, and relationships between them, diagrammatically nested within a separate 
compartment of the owning Classifier’s rectangle. Unless otherwise specified, the name of such a compartment shall be 
derived from the corresponding metamodel property, pluralized if that property has multiplicity greater than 1. So, for 
example, a compartment showing the contents of the property nestedClassifier for a Class (see 11.4.2) shall be called 
“nested classifiers;” a compartment showing the contents of the property ownedBehavior for a BehavioredClassifier shall 
be called “owned behaviors.”
If a Classifier owns Constraints, a conforming tool may implement a compartment to show the owned Constraints listed 
within a separate compartment of the owning Classifier’s rectangle. The name of this optional compartment is 
“constraints.”

9.2.4.2

Other elements

A Generalization is shown as a line with a hollow triangle as an arrowhead between the symbols representing the 
involved Classifiers. The arrowhead points to the symbol representing the general Classifier.
Multiple Generalization relationships that reference the same general Classifier may be shown as separate lines with 
separate arrowheads. This notation is referred to as the “separate target style.” Alternatively they may be connected to 
the same arrowhead in the “shared target style.”
There is no general notation for RedefinableElement. See the subclasses of RedefinableElement for specific notations.
A Substitution is shown as a Dependency with the keyword «substitute» attached to it.
Members that are inherited by a Classifier may be shown on a diagram of that Classifier by prepending a caret ’^’ symbol 
to the textual representation that would be shown if the member were not inherited. Thus the notation for an inherited 
Property is defined like this:
<inherited-property> ::= ’^’ <property>
where <property> is specified in 9.5.4.
Similarly, the notation for an inherited Connector is defined like this:
<inherited-connector> ::= ’^’ <connector>
where <connector> is specified in 11.2.4.
Analogous notations may be used for all NamedElements that are inheritedMembers of a Classifier to indicate that they 
are inherited.

100

Unified Modeling Language 2.5

Inherited members may also be shown in a lighter color to help distinguish them from non-inherited members. A 
conforming implementation does not need to provide this option.

Examples

9.2.5
Examples for Classifier notation are shown under its various concrete subclasses, especially Class (see 11.4.4).
Figure 9.2 illustrates Generalization notation with different target styles.

Shape

Separate target style

Polygon

Ellipse

Spline

Shape

Shared target style

Polygon

Ellipse

Spline

Figure 9.2  Generalization notation showing different target styles

In Figure 9.3, a generic Window class is substitutable in a particular environment by the Resizable Window class.

Window

ResizableWindow

«substitute»

Figure 9.3  Example of Substitution notation

Classifier Templates
Summary

9.3
9.3.1
Classifier is a kind of TemplateableElement signifying that a Classifier may be parameterized. It is also (via 
PackageableElement) a kind of ParameterableElement so that a Classifier may be a formal TemplateParameter and may 
be specified as an actual parameter in a binding of a template. Sub clause 7.3 describes the general semantics of 
templates and their parameters.

Unified Modeling Language 2.5

101

9.3.2

Abstract Syntax

RedefinableElement

TemplateSignature

TemplateableElement

RedefinableTemplateSignature

{subsets redefinableElement,
redefines ownedTemplateSignature}

+ ownedTemplateSignature
0..1

{subsets redefinableElement}
+ redefinableTemplateSignature

{subsets redefinitionContext,
redefines template}
+ classifier

Classifier

1

{redefines parameteredElement}
+ parameteredElement

1

* + constrainingClassifier

*

*

+ extendedSignature
{subsets redefinedElement}

{subsets templateSignature}
+ redefinableTemplateSignature

{readOnly, subsets parameter}
+ /inheritedParameter

*

*

TemplateParameter

Figure 9.4  Classifier Templates

9.3.3

9.3.3.1

Semantics

Template and Bound Classifiers

{redefines templateParameter}
+ templateParameter

0..1

* + classifierTemplateParameter

ClassifierTemplateParameter
+ allowSubstitutable : Boolean = true

The meanings of the terms template and bound element are defined in 7.3 – Templates.
A Classifier that is parameterized using a RedefinableTemplateSignature is called a template Classifier, while a 
Classifier with one or more TemplateBindings is called a bound Classifier.
The general semantics of templates as defined in sub clause 7.3.3. There the details of how the contents are merged into 
a bound element are left open. In the case of Classifier the semantics are equivalent to inserting an anonymous general 
bound Classifier representing the intermediate result for each binding, and specializing all these intermediate results by 
the bound Classifier.
Members of the expanded bound Classifier may be used as actual parameters in a binding.
A bound Classifier may have contents in addition to those resulting from its bindings.
The parameters of a template Classifier can be any kind of TemplateParameter. Semantics and notation are only defined 
when the parameter is a Classifier, a LiteralSpecification, a Property or an Operation.
When the parameter is a Classifier, represented by a ClassifierTemplateParameter, the semantics and notation are 
defined in this clause.
When the parameter is a LiteralSpecification, the semantics and notation are as specified in 7.3.
When the parameter is an Operation, the semantics and notation are as specified in 9.6.
When the parameter is a Property, the semantics and notation are as specified in 9.5.

9.3.3.2

Template Classifier specialization

RedefinableTemplateSignature specializes both TemplateSignature and RedefinableElement in order to allow the 
addition of new formal TemplateParameters in the context of a specializing template Classifier.
A RedefinableTemplateSignature redefines the RedefinableTemplateSignatures of all parent Classifiers that are 
templates. All the formal TemplateParameters of the extended (redefined) signatures are included as formal 
TemplateParameters of the extending signature, along with any TemplateParameters locally specified for the extending 
signature.

102

Unified Modeling Language 2.5

9.3.3.3

Classifier Template Parameters

ClassifierTemplateParameter is a TemplateParameter where the parameteredElement is a Classifier in its capacity of being 
a kind of ParameterableElement.
All subclasses of Classifier (such as Class, Collaboration, Component, Datatype, Interface, Signal, and UseCases) may 
be parameterized, bound, and used as TemplateParameters. The same holds for Behavior as a subclass of Class, and 
thereby all subclasses of Behavior (such as Activity, Interaction, StateMachine).
The constrainingClassifier property of ClassifierTemplateParameter specifies a set of Classifiers that constrain the 
argument that can be used for the parameter. If there are any Classifiers in this set, then the argument shall be 
compatible with all of them, in the following sense:

•

•

If allowSubstitutable is false, then compatibility means being the same as or a specialization of all of the 
constrainingClassifiers.
If allowSubstitutable is true, then compatibility additionally allows a Substitution whose contract is a 
constrainingClassifier.

Furthermore, if there are any constrainingClassifiers, the parameteredElement shall be constrained as follows:

•

•

If allowSubstitutable is false, then compatibility means being the same as or a direct specialization of all of the 
constrainingClassifiers, with no additional features.
If allowSubstitutable is true, then compatibility additionally allows a Substitution whose contract is a 
constrainingClassifier.

In all cases, if the parameteredElement is not abstract then the Classifier used as an argument shall not be abstract. Apart 
from this, if the constrainingClassifier property is empty, there are no constraints on the Classifier that can be used as an 
argument. In this case the parameteredElement shall have no generalizations and no features, and allowSubstitutable shall be 
false.

Notation

9.3.4
See TemplateableElement for the general notation for displaying a template and a bound element.
When a bound Classifier is used directly as the type of a Property, then <template-param-name> acts as the prop-type of 
the Property in its notation (see Property).
The general notation for template parameters specified in 7.3.4 is extended for the parameters of a template Classifier to 
include the following:
<template-parameter> ::= <classifier-template-parameter> | <operation-template-parameter>| <connectable-
element-template-parameter>
A ClassifierTemplateParameter extends the notation for a TemplateParameter to include an optional type constraint:
<classifier-template-parameter> ::= <parameter-name> [ ‘:‘ <parameter-kind> ] [‘>’ <constraint>] [‘=’ <default>]
<constraint> ::= [‘{contract }’] <classifier-name>*
<default> ::= <classifier-name>
The parameter-kind indicates the metaclass of the parameteredElement. It may be suppressed if it is ‘Class.’
The classifier-name of constraint designates a constrainingClassifier, of which there may be zero or more, with the 
meaning specified in the semantics above. The ‘contract’ option indicates that allowSubstitutable is true.

Unified Modeling Language 2.5

103

Examples

9.3.5
The example shows a Class template (named FArray) with two formal TemplateParameters. The first formal 
TemplateParameter (named T) is an unconstrained class TemplateParameter: the metaclass Class has been suppressed 
from the diagram. The second formal TemplateParameter (named k) is a LiteralInteger that has a default of 10. There is 
also a bound Class (named AddressList) that substitutes Address for T and 3 for k.

T, k : LiteralInteger = 10

FArray

contents: T[0..k]

«bind» T -> Address, k -> 3

AddressList

Figure 9.5  Template Class and Bound Class

The following figure shows an anonymous bound Class that substitutes the Point class for T. As there is no substitution 
for k, the default (10) will be used.

FArray<T -> Point>

Figure 9.6  Anonymous Bound Class

The following figure shows a template Class (named Car) with two formal TemplateParameters. The first formal 
TemplateParameter (named CarEngine) is a Class that is constrained to conform to the Class called Engine. The second 
formal TemplateParameter (named n) is a LiteralInteger.

CarEngine->Engine,  
n:LiteralInteger

Car

e : CarEngine

dw : Wheel [n+1]

Figure 9.7  Template Class with constrained Class parameter

104

Unified Modeling Language 2.5

The following figure shows a bound Class (named DieselCar) that binds CarEngine to DieselEngine and n to 2: thus 
defining a class of 3-wheeled diesel cars.

DieselCar : Car<CarEngine -> DieselEngine, n -> 2>

Figure 9.8  Bound Class

Features
Summary

9.4
9.4.1
Features represent structural and behavioral characteristics of Classifiers.

9.4.2

Abstract Syntax

RedefinableElement

{readOnly, union, subsets
memberNamespace}

{readOnly, union, subsets
member}

Classifier

+ /featuringClassifier

+ /feature

Feature

0..1

*

+ isStatic : Boolean = false

CallConcurrencyKind
sequential
guarded
concurrent

ParameterDirectionKind
in
inout
out
return

ParameterEffectKind
create
read
update
delete

TypedElement

MultiplicityElement

TypedElement

Namespace

MultiplicityElement

ConnectableElement

StructuralFeature

+ isReadOnly : Boolean = false

BehavioralFeature

+ concurrency : CallConcurrencyKind = sequential
+ isAbstract : Boolean = false

{subsets namespace}
+ ownerFormalParam
0..1

{ordered, subsets
ownedMember}
+ ownedParameter

*

+ behavioralFeature

*

+ specification

0..1

0..1

{subsets namespace}
+ behavioralFeature

Parameter
+ /default : String [0..1]
+ direction : ParameterDirectionKind = in
+ effect : ParameterEffectKind [0..1]
+ isException : Boolean = false
+ isStream : Boolean = false

+ raisedException

*

+ method

*

Type

Behavior

{subsets ownedMember}
+ ownedParameterSet

*

ParameterSet

*
+ parameterSet

{subsets owner}
+ parameterSet

0..1

{subsets ownedElement}
+ condition

*

Constraint

+ parameter

1..*

{subsets owner}
+ owningParameter

0..1

{subsets ownedElement}

0..1 + defaultValue

ValueSpecification

Figure 9.9  Features

9.4.3

9.4.3.1

Semantics

Features

Each Feature is associated with a Classifier called its featuringClassifier. The Feature represents some structural or 
behavioral characteristic for its featuringClassifier, except for Properties acting as qualifiers (see 9.5.3).
The isStatic property specifies whether the characteristic relates to the Classifier’s instances considered individually 
(isStatic=false), or to the Classifier itself (isStatic=true). All semantics relating to Features that do not explicitly state 
whether the feature is static shall be assumed to refer to non-static Features. Where semantics are not explicitly 
specified for static Features, those semantics are undefined.

9.4.3.2

Structural Features

A StructuralFeature is a typed Feature of a Classifier that specifies the structure of instances of the Classifier.

Unified Modeling Language 2.5

105

The StructuralFeatures of a Classifier that are Properties are called the attributes of the Classifier (see 9.2.3). In UML, 
Property is the only kind of StructuralFeature so all of the StructuralFeatures of a Classifier are Properties, and hence 
attributes.
For each instance of a Classifier there is a value or collection of values for each direct or inherited non-static  attribute of 
the Classifier, as follows:

•

•

•

•

If the attribute’s multiplicity is 0..1, there shall either be no value or a single value whose Type conforms to the 
Type of the attribute
If the attribute’s multiplicity is 1..1, there shall be a single value whose Type conforms to the Type of the 
attribute.
If the attribute’s multiplicity is j..k where k is not 1, there shall be a collection of values whose size is not less 
than j and not greater than k, each of whose Types conforms to the Type of the attribute.
If the attribute’s multiplicity is 0..0, there shall be no value or values.

If a StructuralFeature is marked with isStatic = true, then the bullet points above are relative to the Classifier itself 
considered as an identifiable individual within some execution scope, rather than to individual instances. (See sub 
clause 6.3.1 for a discussion of execution scope.)
In a semantically conforming tool, each inherited static StructuralFeature shall have one of two alternative semantics:

1. Within an execution scope, the value or collection of values of the StructuralFeature is always the same for any 

inheriting Classifier as its value or collection of values for the owning Classifier. These semantics correspond 
to those for static members in Java and C#.

2. Within an execution scope, the StructuralFeature has a separate and independent value or collection of values 
for its owning Classifier and for each Classifier that inherits it. These semantics correspond to those for class 
instance variables in Ruby and Smalltalk.

If a StructuralFeature is marked with isReadOnly true, then it may not be updated once it has been assigned an initial 
value. Conversely, when isReadOnly is false (the default), the value may be modified.

9.4.3.3

Behavioral Features

A non-static BehavioralFeature specifies that an instance of its featuringClassifier will react to an invocation of the 
BehavioralFeature by carrying out a specific behavioral response. Subclasses of BehavioralFeature model different 
behavioral aspects of a Classifier.
The list of ownedParameters describes the order, type, and direction of arguments that may be given when the 
BehavioralFeature is invoked, or which are output and returned when the invocation completes.
The ownedParameters with direction in or inout define the arguments that shall be provided when invoking the 
BehavioralFeature. The ownedParameters with direction out, inout, or return define the arguments that will be output and 
returned from a successful invocation.
A BehavioralFeature may raise an exception during its invocation. Possible exception types may be specified by 
attaching them to the BehavioralFeature using the raisedException association.
One way to define the behavioral response of a BehavioralFeature is to specify one or more Behaviors as  methods that 
implement the BehavioralFeature. An invocation of the BehavioralFeature then results in the execution of one of the 
associated methods (as further discussed in sub clause 13.2 on Behaviors). The isAbstract property, when true, specifies 
that the BehavioralFeature does not have any methods implementing it, with the expectation that an implementation will 
be supplied by a more specific element.
The concurrency property specifies the semantics of concurrent calls to the same instance. Its type is 
CallConcurrencyKind, an enumeration with the following literals:

106

Unified Modeling Language 2.5

sequential

guarded

No concurrency management mechanism is associated with the BehavioralFeature and, therefore, 
concurrency conflicts may occur. Instances that invoke a BehavioralFeature need to coordinate so 
that only one invocation to a target on any BehavioralFeature occurs at once.
Multiple invocations of a BehavioralFeature that overlap in time may occur to one instance, but only 
one is allowed to commence. The others are blocked until the performance of the currently executing 
BehavioralFeature is complete. It is the responsibility of the system designer to ensure that deadlocks 
do not occur due to simultaneous blocking.

concurrent Multiple invocations of a BehavioralFeature that overlap in time may occur to one instance and all of 

them may proceed concurrently.

9.4.3.4

Parameters

A Parameter is a specification of an argument used to pass information into or out of an invocation of a 
BehavioralFeature. The Type and Multiplicity of a Parameter restrict what values may be passed, how many, and 
whether the values are ordered. The Multiplicity defines a lower and upper bound on the values passed to the Parameter 
at runtime. A lower bound of zero means the Parameter is optional. Actions using the Parameter may execute without 
having a value for optional Parameters. A lower bound greater than zero means values for the Parameter are required to 
arrive sometime during the execution of the action.
If a defaultValue is specified for a Parameter, then it is evaluated at invocation time and used as the argument for this 
Parameter if and only if no argument is supplied at invocation of the BehavioralFeature.
A Parameter may be given a name, which then identifies the Parameter uniquely within the Parameters of the same 
BehavioralFeature. If it is unnamed, it is distinguished only by its position in the ordered list of Parameters.
The direction property specifies whether a value is passed into, out of, or both into and out of the owning 
BehavioralFeature. Its type is ParameterDirectionKind, an enumeration of the following literal values:

in
inout

out
return

Indicates that Parameter values are passed in by the caller.
Indicates that Parameter values are passed in by the caller and (possibly different) values passed out 
to the caller.
Indicates that Parameter values are passed out to the caller.
Indicates that Parameter values are passed as return values back to the caller.

No more than one Parameter for a BehavioralFeature may be marked as a return Parameter by setting its direction to 
return.
The effect property may be used to specify what happens to objects passed in or out of a Parameter. It does not apply to 
parameters typed by data types, because these do not have identity with which to detect changes. It is a declaration of 
modeler intent that must be consistent with the behaviors having the effect. Multiple effects might occur during 
execution, whether or not an effect is specified. For example, an update effect does not preclude reading from occurring 
during execution, and a lack of value for effect does not prevent effects from occurring during execution. The effect is 
specified using an enumerated value typed by ParameterEffectKind, an enumeration of the following literals:

create

read

update

delete

Objects passed out of executions of the behavior as values of the parameter do not exist before those 
executions start.
Objects that are values of the parameter have values of their properties, or links in which they 
participate, or their classifiers retrieved during executions of the behavior.
Objects that are values of the parameter have values of their properties, or links in which they 
participate, or their classification changed during executions of the behavior.
Objects that are values of the parameter do not exist after executions of the behavior are finished.

Only in and inout Parameters may have a delete effect. Only out, inout, and return Parameters may have a create effect.
The isException property applies to output Parameters. An output posted to a Parameter with isException true during an 
invocation of a BehavioralFeature excludes outputs from being posted to any other outputs of the BehavioralFeature 
during the same invocation. The type of such an exception Parameter may be included in the raisedException set, but does 
not have to be included.

Unified Modeling Language 2.5

107

The isStream property, when true, designates a streaming Parameter. A streaming Parameter expresses the expectation 
that any Behavior implementing this feature will exhibit streaming behavior on this Parameter – see sub clause 13.2. 
The semantics for a Parameter designated as streaming when the implementing Behavior does not exhibit streaming 
behavior are undefined.
A ParameterSet owned by a BehavioralFeature is an element that provides alternative sets of inputs or outputs that the 
Behaviors that implements that BehavioralFeature may use. The Parameters in a ParameterSet shall all be inputs or all 
outputs of the same BehavioralFeature: a ParameterSet with all inputs is called an input ParameterSet, and one with all 
outputs is called an output ParameterSet.
A BehavioralFeature with input ParameterSets may only accept inputs from Parameters in one of the sets per 
invocation. A BehavioralFeature with output ParameterSets may only return outputs to the Parameters in one of the sets 
per invocation. The semantics of conditions on input and output ParameterSets of BehavioralFeatures is the same as 
Operation preconditions and postconditions, respectively, but apply to only to invocations that accept inputs to or return 
outputs from Parameters in the ParameterSet having the condition.
More detailed semantics and examples of ParameterSets may be found in sub clause 16.3.

Notation

9.4.4
There is no general notation for Feature. Subclasses define their specific notation.
Static Features are underlined.
Where Features are shown in lists, an ellipsis (...) as the final element of a list of Features may be used to indicate that 
additional Features exist but are not shown in that list.
A read only StructuralFeature is shown using {readOnly} as part of the notation for the StructuralFeature. This 
annotation may be suppressed, in which case it is not possible to determine its value from the diagram. Alternatively a 
conforming tool may only allow suppression of the {readOnly} annotation when isReadOnly=false (the default). In this 
case it is possible to assume this value in all cases where {readOnly} is not shown.
Feature redefinitions may either be explicitly notated with the use of a {redefines <x>} property string on the Feature or 
implicitly by having a Feature which cannot be distinguished using isDistinguishableFrom() from another Feature in 
one of the owning Classifier’s more general Classifiers. In both cases, the redefined Feature shall conform to the 
compatibility constraint on the redefinitions.
A Parameter is shown as a text string of the form:
<parameter> ::= [<direction>] <parameter-name> ’:’ <type-expression> [’[’<multiplicity-range>’]’] [’=’ <default>]

[’{’ <parm-property> [’,’ <parm-property>]* ’}’]   where:
<direction> ::= ’in’ | ’out’ | ’inout’ (defaults to ’in’ if omitted).
<parameter-name> is the name of the Parameter.
<type-expression> is an expression that specifies the type of the Parameter.
<multiplicity-range> is the multiplicity of the Parameter. (See MultiplicityElement — sub clause 7.5).
<default> is an expression that defines the value specification for the default value of the Parameter.
<parm-property> indicates additional property values that apply to the Parameter.

•

•

•

•

•

•

<parm-property> ::= ’ordered’ | ’unordered’ | ’unique’ | ’nonunique’ | ’seq’ | ’sequence’ where

•

•

•

108

’ordered’ applies when there is a multi-valued Parameter and means that its values are ordered.

’unordered’ applies when there is a multi-valued Parameter and means that its values are not ordered.

’unique’ applies when there is a multi-valued Parameter and means that its values have no duplicates.

Unified Modeling Language 2.5

•

•

’nonunique’ applies when there is a multi-valued Parameter and means that its values may have duplicates.

’seq’ or ’sequence’ applies when there is a multi-valued Parameter and means that its values constitute an 
ordered bag, i.e., isUnique = false and isOrdered = true.

Notation for ParameterSets in activity diagrams may be found in sub clause 16.3.4. There is no notation for 
ParameterSets in other diagrams.

Properties
Summary

9.5
9.5.1
Properties are StructuralFeatures that represent the attributes of Classifiers, the memberEnds of Associations, and the parts 
of StructuredClassifiers.

9.5.2

Abstract Syntax

ParameterableElement

ConnectableElement

StructuralFeature

DeploymentTarget

«enumeration»
AggregationKind
none
shared
composite

Interface

DataType

{subsets namespace,
subsets classifier}
+ interface

0..1

{ordered, subsets attribute, subsets
ownedMember}

+ ownedAttribute

*

Property

+ aggregation : AggregationKind = none
+ /isComposite : Boolean = false
+ isDerived : Boolean = false
+ isDerivedUnion : Boolean = false
+ isID : Boolean = false

{subsets namespace,
subsets classifier}
+ datatype

0..1

{ordered, subsets attribute, subsets
ownedMember}

+ ownedAttribute

*

{subsets namespace, subsets
structuredClassifier, subsets classifier}

Class

+ class

0..1

{ordered, subsets attribute, subsets
ownedMember, redefines
ownedAttribute}

+ ownedAttribute

*

{ordered, subsets feature, subsets
redefinableElement, subsets
memberEnd, subsets ownedMember}

+ ownedEnd

*

{subsets featuringClassifier, subsets
namespace, subsets association,
subsets redefinitionContext}
+ owningAssociation
0..1

Association

{ordered, subsets member}
+ memberEnd

{subsets memberNamespace}
+ association

2..*

0..1

+ qualifier

{ordered, subsets ownedElement}

*
0..1

+ associationEnd

{subsets owner}

0..1
+ /opposite

0..1
+ property

{subsets owner}
+ owningProperty
0..1

{subsets ownedElement}

+ defaultValue
0..1

ValueSpecification

+ property

*

*

+ subsettedProperty

{subsets redefinedElement}
+ redefinedProperty

*

* + property
{subsets
redefinableElement}

Figure 9.10  Properties

Semantics

9.5.3
A Property may represent an attribute of a Classifier, a memberEnd of an Association, or in some cases both 
simultaneously.
A useful convention for general modeling scenarios is that a Property whose type is a kind of Class is an Association 
end, while a property whose type is a kind of DataType is not. This convention is not enforced by UML.
A Property represents a declared state of one or more instances in terms of a named relationship to a value or values. 
When a Property is a non-static attribute of a Classifier, the value or values are related to the instance of the Classifier 
by being held in slots of the instance. When a Property is an Association’s memberEnd, the value or values are related to 
the instance or instances at the other end(s) of the association (see 11.5 Associations). When a Property is a static 
attribute of a Classifier, the value or values are related to the Classifier itself within some execution scope.
A Property that is a memberEnd may itself have other Properties that serve as qualifiers.

Unified Modeling Language 2.5

109

When a Property is owned by a Classifier other than an Association via ownedAttribute, then it represents an attribute of 
the Classifier. When related to an Association via memberEnd it represents an end of the Association. For a binary 
Association, it may be both at once. In either case, when instantiated a Property represents a value or collection of 
values associated with an instance of one (or in the case of a ternary or higher-order association, more than one) 
Classifier. This set of Classifiers is called the context for the Property; in the case of an attribute the context is the owning 
Classifier, and in the case of an association end the context is the set of Classifiers at the other end or ends of the 
Association.
If there is a defaultValue specified for a Property, this default is evaluated when an instance of the Property is created in 
the absence of a specific setting for the Property or a constraint in the model that requires the Property to have a specific 
value. The evaluated default then becomes the initial value (or values) of the Property.
If a Property has isDerived = true, it is derived and its value or values may be computed from other information. Actions 
involving a derived Property behave the same as for a nonderived Property. Derived Properties are often specified to be 
read-only (i.e., clients may not directly change values). But where a derived Property is changeable, an implementation 
is expected to make appropriate changes to the model in order for all the constraints to be met, in particular the 
derivation constraint for the derived Property. The derivation for a derived Property may be specified by a constraint.
Property is indirectly a kind of RedefinableElement, so Properties may be redefined. The name and visibility of a Property 
are not required to match those of any Property it redefines.
A derived Property may redefine one which is not derived. An implementation shall ensure that the constraints implied 
by the derivation are maintained if the Property is updated.
If a Property has a specified default, and the Property redefines another Property with a specified default, then the 
redefining Property’s default is used in place of the more general default from the redefined Property.
Sometimes a Property is used to model circumstances in which one instance is used to group together a set of instances; 
this is called aggregation. To represent such circumstances, a Property has an aggregation property, of type 
AggregationKind; the instance representing the whole group is classified by the owner of the Property, and the instances 
representing the grouped individuals are classified by the type of the Property. AggregationKind is an enumeration with 
the following literal values:

none
shared

composite

Indicates that the Property has no aggregation semantics.
Indicates that the Property has shared aggregation semantics. Precise semantics of shared aggregation 
varies by application area and modeler.
Indicates that the Property is aggregated compositely, i.e., the composite object has responsibility for 
the existence and storage of the composed objects (see the definition of parts in 11.2.3).

Composite aggregation is a strong form of aggregation that requires a part object be included in at most one composite 
object at a time. If a composite object is deleted, all of its part instances that are objects are deleted with it.
NOTE. A part object may (where otherwise allowed) be removed from a composite object before the composite object 
is deleted, and thus not be deleted as part of the composite object.
Compositions may be linked in a directed acyclic graph with transitive deletion characteristics; that is, deleting an 
object in one part of the graph will also result in the deletion of all objects of the subgraph below that object. The 
precise lifecycle semantics of composite aggregation is intentionally not specified. The order and way in which 
composed objects are created is intentionally not defined. The semantics of composite aggregation when the container 
or part is typed by a DataType are intentionally not specified.
A Property may be marked as the subset of another subsettedProperty. In this case, calculate a set by eliminating 
duplicates from the collection of values denoted by the subsetting property in some context. Then that set shall be 
included in (or the same as) a set calculated by eliminating duplicates from the collection of values denoted by the 
subsettedProperty in the same context.
A Property may be marked as being a derived union, by setting isDerivedUnion to true. This means that the collection of 
values denoted by the Property in some context is derived by being the strict union of all of the values denoted, in the 

110

Unified Modeling Language 2.5

same context, by Properties defined to subset it. If the Property has a multiplicity upper bound of 1, then this means that 
the values of all the subsets shall be null or the same.
When an attribute marked as a derived union is marked with isOrdered = true, and in a particular context all of its 
subsetting properties are attributes marked as ordered or with upper bound 1, and the value in that context of the 
Classifier::allAttributes() operation gives a well-defined ordering, then the ordering of the union is defined by 
evaluating the subsetting properties in the order in which they appear in the result of allAttributes() and concatenating 
the results. In all other cases the ordering of a property marked as an ordered derived union is undefined.
A Property may be marked, via the property isID, as being (part of) the identifier (if any) for Classifiers of which it is a 
member. The interpretation of this is left open but this could be mapped to implementations such as primary keys for 
relational database tables or ID attributes in XML. If multiple Properties are marked as isID (possibly in generalizing 
Classifiers) then it is the combination of the (Property, value) tuples that will logically provide the uniqueness for any 
instance. Hence there is no need for any specification of order and it is possible for some of the Property values to be 
empty. If the Property is multivalued then all values are included.
Property specializes ParameterableElement to specify that a Property may be exposed as a formal 
ConnectableElementTemplateParameter (see 11.2.3), and provided as an actual parameter in a binding of a template. 
Within a template a Property TemplateParameter may be used like any other accessible Property. Any references to the 
Property TemplateParameter within the template will end up being a reference to the actual Property in the bound 
element.

Notation

9.5.4
The following general notation is defined for Properties.
NOTE. Some specializations of Property may also have additional notational forms. These are covered in the 
appropriate Notation sub clauses of those classes.
<property> ::= [<visibility>] [‘/’] <name> [‘:’ <prop-type>] [‘[‘ <multiplicity-range> ‘]’] [‘=’ <default>] [‘{‘ 
<prop-modifier > [‘,’ <prop-modifier >]* ’}’]
where:

• <visibility> is the visibility of the Property. (See VisibilityKind - sub clause 7.4.)

<visibility> ::= ‘+’ | ‘-‘ | ‘#’ | ‘~’
‘/’ signifies that the Property is derived.

•
• <name> is the name of the Property, or the empty string if the Property has no name.
• <prop-type> is the name of the Classifier that is the type of the Property.
• <multiplicity-range> is the multiplicity range of the Property. If this term is omitted, it implies a multiplicity 

of 1 (exactly one). (See MultiplicityElement – sub clause 7.5.)

• <default> is an expression that evaluates to the default value or values of the Property.
• <prop-modifier> indicates a modifier that applies to the Property.

<prop-modifier> ::= ‘readOnly’ | ‘union’ | ‘subsets’ <property-name> | 
‘redefines’ <property-name> | ‘ordered’ | ‘unordered’ | ‘unique’ | ‘nonunique’ | ‘seq’ | ‘sequence’ |
‘id’ | <prop-constraint>
where:
•

‘readOnly’ means that the Property is read only.
‘union’ means that the Property is a derived union of its subsets.
‘subsets’ <property-name> means that the Property is a proper subset of the Property identified by 
<property-name>, where <property-name> may be qualified.

•

•

Unified Modeling Language 2.5

111

‘redefines’ <property-name> means that the Property redefines an inherited Property identified by 
<property-name>, where <property-name> may be qualified.
‘ordered’ means that the Property is ordered, i.e., isOrdered = true.

‘unordered’ means that the Property is not ordered, i.e., isOrdered = false.
‘unique’ means that there are no duplicates in a multi-valued Property, i.e., isUnique = true.

•

•

•

•

•

•

‘nonunique’ means that there may be duplicates in a multi-valued Property, i.e., isUnique = false.
‘seq’ or ‘sequence’ means that the property represents an ordered bag, i.e., isUnique = false and 
isOrdered = true
‘id’ means that the Property is part of the identifier for the class.

•
• <prop-constraint> is an expression that specifies a constraint that applies to the Property.

The notation for qualifiers is defined in 11.5 Associations.
The notation for the aggregation of a Property is defined in 11.5 Associations.
In a Classifier, the type, visibility, default, multiplicity, property string may be suppressed from being displayed, even if 
there are values in the model.
In a Classifier, the individual properties of an attribute may be shown in columns rather than as a continuous string.
In a Classifier, an attribute may also be shown using association notation, where only an aggregation adornment (hollow 
or filled diamond) may be shown at the tail of the arrow.
The notation for a ConnectableElementTemplateParameter used to parameterize a template Classifier by a Property is 
this:
<connectable-element-template-parameter> ::= <property-name> ‘: Property’

112

Unified Modeling Language 2.5

9.5.5

Examples

ClassA

name: String 
shape: Rectangle 
+size: Integer[0..1] 
/area: Integer {readOnly} 
height: Integer = 5 
width: Integer

ClassB

id {redefines name} 
shape: Square 
^+size: Integer[0..1] 
Integer = 7 
/width

Figure 9.11  Examples of attributes

The attributes in Figure 9.11 are explained below.

•

•

•

•

•

•

•

•

•

•

•

ClassA::name is an attribute with type String.

ClassA::shape is an attribute with type Rectangle.

ClassA::size is a public attribute of type Integer with multiplicity 0..1.

ClassA::area is a derived attribute with type Integer. It is marked as read-only.

ClassA::height is an attribute of type Integer with a default initial value of 5.

ClassA::width is an attribute of type Integer.

ClassB::id is an attribute that redefines ClassA::name.

ClassB::shape is an attribute that redefines ClassA::shape. It has type Square, a specialization of Rectangle.

ClassB shows size as an attribute inherited from ClassA, as signified by the prepended caret symbol (see
9.2.4).
ClassB::height is an attribute that redefines ClassA::height. It has a default of 7 for ClassB instances that 
overrides the ClassA default of 5.
ClassB::width is a derived attribute that redefines ClassA::width, which is not derived.

Figure 9.12 shows how an attribute may be shown using association notation.

Unified Modeling Language 2.5

113

Figure 9.12  Association-like notation for attributes

Operations
Summary

9.6
9.6.1
An Operation is a BehavioralFeature that may be owned by an Interface, DataType or Class. Operations may also be 
templated and used as template parameters.

9.6.2

Abstract Syntax

TemplateableElement

BehavioralFeature

ParameterableElement

{subsets ownerFormalParam}

+ operation
0..1

{ordered, redefines ownedParameter}
+ ownedParameter
*

Parameter

Constraint

{subsets context}

+ preContext

{subsets ownedRule}
+ precondition

0..1

*

{subsets context}
+ postContext

{subsets ownedRule}
+ postcondition

0..1

*

{subsets context}
+ bodyContext

{subsets ownedRule}
+ bodyCondition

0..1

0..1
+ /type

{readOnly}

Type

*
+ raisedException

{redefines raisedException}

0..1

+ operation

*
{subsets behavioralFeature}
+ operation

*

{subsets redefinableElement}
+ operation
*

*
+ redefinedOperation
{subsets redefinedElement}

{subsets featuringClassifier,
subsets namespace, subsets
redefinitionContext}

Interface

+ interface

0..1

{ordered, subsets feature,
subsets redefinableElement,
subsets ownedMember}

+ ownedOperation

Operation

+ /isOrdered : Boolean {readOnly}
+ isQuery : Boolean = false
+ /isUnique : Boolean {readOnly}
+ /lower : Integer [0..1] {readOnly}
+ /upper : UnlimitedNatural [0..1] {readOnly}

*

{subsets featuringClassifier,
subsets namespace, subsets
redefinitionContext}
+ datatype

{ordered, subsets feature,
subsets redefinableElement,
subsets ownedMember}

+ ownedOperation

DataType

0..1

{subsets featuringClassifier,
subsets namespace, subsets
redefinitionContext}
+ class

Class

0..1

*

{ordered, subsets
feature, subsets
redefinableElement,
subsets ownedMember}

+ ownedOperation

*

{redefines parameteredElement}
+ parameteredElement

1

{redefines templateParameter}
+ templateParameter

0..1

OperationTemplateParameter

TemplateParameter

Figure 9.13  Operations

9.6.3

9.6.3.1

Semantics

Operations

An Operation is a BehaviorialFeature of an Interface, DataType, or Class. An Operation may be directly invoked on 
instances of its featuringClassifiers. The Operation specifies the name, type, Parameters, and Constraints for such 
invocations.
If there is a return Parameter, the type of the Operation is the same as the type of this Parameter. Otherwise the 
Operation has no type.

114

Unified Modeling Language 2.5

The preconditions for an Operation define conditions that shall be true when the Operation is invoked. These preconditions 
may be assumed by an implementation of this Operation. The behavior of an invocation of an Operation when a 
precondition is not satisfied is not defined in UML.
The postconditions for an Operation define conditions that will be true when the invocation of the Operation completes 
successfully, assuming the preconditions were satisfied. These postconditions shall be satisfied by any implementation of 
the Operation.
The bodyCondition for an Operation constrains the return result to a value calculated by the specification of the 
bodyCondition. This value should satisfy the postconditions, if any. The bodyCondition differs from postconditions in that the 
bodyCondition may be overridden when an Operation is redefined, whereas postconditions may only be added during 
redefinition.
An Operation may raise an exception during its invocation. When an exception is raised, it should not be assumed that 
the postconditions or bodyCondition of the Operation are satisfied.
An Operation may be redefined in a specialization of the featuringClassifier. This redefinition may add new preconditions or
postconditions, add new raisedExceptions, or otherwise refine the specification of the Operation.
Different type-conformance systems adopt different schemes for how the types of parameters and results may vary 
when an Operation is redefined in a specialization. When the type may not vary, it is called invariance. When the 
parameter type may be specialized in a specialized type, it is called covariance. When the parameter type may be 
generalized in a specialized type, it is called contravariance. In UML, such rules for type conformance are intentionally 
not specified. Redefined parameters shall have compatible multiplicity, and the same direction, ordering and uniqueness 
as the redefined parameters.
If the isQuery property is true, an invocation of the Operation shall not modify the state of the instance or any other 
element in the model.
An Operation may be owned by and in the namespace of a Class, DataType or Interface that provides the context for its 
possible redefinition. The owning classifier of the Operation provides its redefinitionContext.

9.6.3.2

Template Operations

Operation specializes TemplateableElement in order to support specification of template Operations and bound 
Operations. Bound Operations must be owned by a Classifier.  If the original operation was defined with a Behavior, 
then the bound element has to be owned by a Classifier that is consistent with that Behavior.  This means one of three 
things: (a) the bound operation appears in the same Classifier as the template; (b) the bound operation appears in a 
subtype of the template’s owner; (c) the template was defined without side-effects in a static class and the bound one 
can then appear anywhere.

9.6.3.3

Operation Template Parameters

An Operation may be exposed by a template as a formal template parameter via an OperationTemplateParameter. 
OperationTemplateParameter is a kind of TemplateParameter where the parametered element is an Operation. Within a 
template Classifier an OperationTemplateParameter may be used like any other accessible Operation. Any references to 
the OperationTemplateParameter within the template will end up being a reference to the actual Operation in the bound 
Classifier. For example, a call to the OperationTemplateParameter will be a call to the actual Operation.
A default for an OperationTemplateParameter must be an Operation with the same parameter types, directions, and 
multiplicities as the exposed Operation.

Notation

9.6.4
If shown in a diagram, an Operation is shown as a text string of the form:
[<visibility>] <name> ‘(‘ [<parameter-list>] ‘)’ [‘:’ [<return-type>] [‘[‘ <multiplicity-range> ‘]’] 
                 [‘{‘ <oper-property> [‘,’ <oper-property>]* ‘}’]]

Unified Modeling Language 2.5

115

where:
•

<visibility> is the visibility of the Operation (see 7.4).
<visibility> ::= ‘+’ | ‘-‘ | ‘#’ | ‘~’
•

•

<name> is the name of the Operation.
<parameter-list> is a list of Parameters of the Operation in the following format:
<parameter-list> ::= <parameter> [‘,’<parameter>]*

•

•

•

where <parameter> is defined in 9.4.4.
<return-type> is the type of the return result Parameter if the Operation has one defined.
<multiplicity-range> is the multiplicity of the return type (see 7.5).
<oper-property> indicates the properties of the Operation.
<oper-property> ::= ‘redefines’ <oper-name> | ‘query’ | ‘ordered’ | ‘unordered’ | ‘unique’ | ‘nonunique’ | ‘seq’ | 
‘sequence’ | <oper-constraint>

where:
•

•

•

•

•

•

•

•

‘redefines’ <oper-name> means that the Operation redefines an inherited Operation identified by <oper-
name>, where <oper-name> may be qualified.
‘query’ means that the Operation does not change the state of the system.

‘ordered’ applies when there is a multi-valued return Parameter and means that its values are ordered.

‘unordered’ applies when there is a multi-valued return Parameter and means that its values are not 
ordered.
‘unique’ applies when there is a multi-valued return Parameter and means that its values have no 
duplicates.
‘nonunique’ applies when there is a multi-valued return Parameter and means that its values may have 
duplicates.
‘seq’ or ‘sequence’ applies when there is a multi-valued return Parameter and means that its values 
constitute an ordered bag, i.e., isUnique = false and isOrdered = true.
<oper-constraint> is a constraint that applies to the Operation. The parameter list may be suppressed.

The TemplateParameters of a template Operation are in a list between the name of the Operation and the Parameters of 
the Operation.
[<visibility>] <name> ‘<‘ <template-parameter-list> ‘>’ ‘(‘ [<parameter-list>] ‘)’ [‘:’ [<return-type>] [‘[‘ <multiplicity> 
‘]’] [‘{‘ <oper-property> [‘,’ <oper-property>]* ‘}’]]
The TemplateParameter bindings of a bound template Operation are in a list between the name of the Operation and the 
Parameters of the Operation.
[<visibility>] <name> ‘<<‘ <binding-expression-list> ‘>>’ ‘(‘ [<parameter-list>] ‘)’ [‘:’ [<return-type>] [‘[‘ 
<multiplicity> ‘]’] [‘{‘ <oper-property> [‘,’ <oper-property>]* ‘}’]]
where < binding-expression-list> ::= <binding-expression> [‘,’ <binding-expression>]*, and <binding-expression> is 
defined in 7.3.4.
Within the notation for formal TemplateParameters and TemplateParameter bindings, an Operation is shown as 
<operation-name> ‘(‘<parameter-list> ‘)’.
An OperationTemplateParameter extends the notation for a TemplateParameter to include the Parameters for the 
Operation:

116

Unified Modeling Language 2.5

<operation-template-parameter> ::= <parameter> [ ‘: Operation’] [‘=’ <default>]
<parameter> ::= <operation-name> ‘(‘<parameter-list> ‘)’
<default> ::= <operation-name ‘(‘<parameter-list> ‘)’
The notation in class diagrams for exceptions and streaming Parameters on Operations has the keywords “exception” or 
“stream” in the property string.

Examples

9.6.5
Normal Operations:
display ()
-hide ()
+createWindow (location: Coordinates, container: Container [0..1]): Window
+toString (): String

A template Operation:

f <T:Class>(x : T)

A binding of that template Operation.

f << T -> Window >>(x : Window)

NOTE. Parameters may be suppressed; they are calculated by the binding.

Generalization Sets
Summary

9.7
9.7.1
GeneralizationSet provides a way to group Generalizations into orthogonal dimensions. A GeneralizationSet may be 
associated with a Classifier called its powertype. These techniques provide additional expressive power for organizing 
classification hierarchies.

9.7.2

Abstract Syntax

PackageableElement

Classifier

+ powertype

+ powertypeExtent

0..1

*

GeneralizationSet
+ isCovering : Boolean
+ isDisjoint : Boolean

+ generalizationSet

+ generalization

*

*

Generalization

Figure 9.14  Generalization Sets

Semantics

9.7.3
Generalizations may be grouped to represent orthogonal dimensions of generalization.  Each group is represented by a 
GeneralizationSet.  The generalizationSet property designates the GeneralizationSets to which the Generalization belongs. 
All of the Generalizations in a particular GeneralizationSet shall have the same general Classifier.
The isCovering property of GeneralizationSet specifies whether the specific Classifiers of the Generalizations in that set 
are complete, in the following sense: if isCovering is true, then every instance of the general Classifier is an instance of 

Unified Modeling Language 2.5

117

(at least) one of the specific Classifiers.  The isDisjoint property specifies whether the specific Classifiers of the 
Generalizations in that set may overlap, in the following sense: if isDisjoint is true, then no instance of any of the specific 
Classifiers may also be an instance of any other of the specific Classifiers.  By default, both properties are false.
A GeneralizationSet may optionally be associated with a Classifier called its powertype. This means that for every 
Generalization in the GeneralizationSet, the specializing Classifier is uniquely associated with an instance of the 
powertype, i.e., there is a 1-1 correspondence between instances of the powertype and specializations in the 
GeneralizationSet, so that the powertype instances and the corresponding Classifiers may be treated as semantically 
equivalent. How this semantic equivalence is implemented and how its integrity is maintained is not defined within the 
scope of UML.

Notation

9.7.4
When Generalization relationship lines are named, that name designates a GeneralizationSet to which the 
Generalization belongs. All Generalization relationships with the same GeneralizationSet name are part of the same 
GeneralizationSet. This notation form is depicted in Figure 9.15.

Figure 9.15  GeneralizationSets designated by name

When two or more lines are drawn to the same arrowhead and labeled by a single GeneralizationSet name, i.e., “shared 
target” style as illustrated in Figure 9.16, the specific Classifiers are part of the same GeneralizationSet.

Figure 9.16  GeneralizationSets designated by shared target

With either of the notation forms above, if there are no labels on the Generalization arrows it cannot be determined from 
the diagram whether there are any GeneralizationSets in the model.
Lastly in Figure 9.17, a GeneralizationSet may be designated by drawing a dashed line across those lines with separate 
arrowheads that are meant to be part of the same set. Here, as in Figure 9.16, the GeneralizationSet is labeled with a 
single name, instead of each line labeled separately. This label may be elided.

118

Unified Modeling Language 2.5

Figure 9.17  GeneralizationSet designated by dashed line spanning Generalization arrows

To indicate whether or not a generalization set is covering and disjoint, each set may be labeled with a constraint 
consisting of one of the textual annotations indicated below.
Table 9.1  GeneralizationSet constraints

{complete, disjoint}

Indicates the generalization set is covering and its specific Classifiers have no common 
instances.

{incomplete, disjoint}

Indicates the generalization set is not covering and its specific Classifiers have no common 
instances.

{complete, 
overlapping}

{incomplete, 
overlapping}

Indicates the generalization set is covering and its specific Classifiers do share common 
instances.

Indicates the generalization set is not covering and its specific Classifiers do share common 
instances.

The constraints may appear in either order: {complete, disjoint} is equivalent to {disjoint, complete}.  The default 
values are {incomplete, overlapping}. If only one constraint is shown, the other takes its default value.
Graphically, the GeneralizationSet constraints are placed next to the sets, whether the common arrowhead notation is 
employed as illustrated in Figure 9.18 below, or the dashed line notation as shown in Figure 9.19.

Figure 9.18  GeneralizationSet constraint notation with shared target style

Unified Modeling Language 2.5

119

Figure 9.19  GeneralizationSet constraint notation with dashed line style

Power type specification is indicated by placing the name of the powertype Classifier—preceded by a colon—next to 
the corresponding GeneralizationSet. Figure 9.20 below indicates how this would appear for the shared arrowhead 
notation, and Figure 9.21 shows it for the dashed-line notation.

Figure 9.20  Power type notation with shared target style

Figure 9.21  Power type notation with dashed line style

The labels for GeneralizationSet name, GeneralizationSet constraint and powertype may appear together in any 
combination on a diagram.

Examples

9.7.5
In Figure 9.22, Person (an abstract class) is specialized as Woman and Man. Separately, Person is specialized as 
Employee. Here, the specializations to Woman and Man constitute one GeneralizationSet and that to Employee another. 
This example employs the various notation forms.

120

Unified Modeling Language 2.5

Figure 9.22  GeneralizationSet notation options

In Figure 9.23 below, Person (an abstract class) is specialized as Woman and Man. Because this GeneralizationSet is 
partitioned (i.e., is constrained to be complete and disjoint), each instance of Person shall either be a Woman or a Man; 
that is, it shall be one or the other and not both. Person is also specialized as Employee, and this single specialization is 
expressed as {incomplete}, which means that a Person may either be an Employee or not. Taken together, the diagram 
indicates that a Person may be 1) either a Man or Woman, and 2) an Employee or not (a total of four options).

Figure 9.23  GeneralizationSets and constraints

One of the ways botanists organize trees is by species. Each tree we see may be classified as an American elm, sugar 
maple, apricot, saguaro—or some other species of tree. The class diagram below expresses that each Tree Species 
classifies zero or more instances of Tree, and each Tree is classified as exactly one Tree Species. For example, one of 
the instances of Tree could be the tree in your front yard, the tree in your neighbor’s backyard, or trees at your local 
nursery. Furthermore, this figure indicates the relationships that exist between these two sets of objects. For instance, 
the tree in your front yard might be classified as a sugar maple, your neighbor’s tree as an apricot, and so on. This class 

Unified Modeling Language 2.5

121

diagram indicates that each Tree Species is identified with a Leaf Pattern and has a general location in any number of 
Geographic Locations. For example, the saguaro cactus has leaves reduced to large spines and is generally found in 
southern Arizona and northern Sonora. Additionally, this figure indicates each Tree has an actual location at a particular 
Geographic Location. In this way, a particular tree could be classified as a saguaro and be located in Phoenix, Arizona.

Figure 9.24  Power type example

This diagram also illustrates that Tree is subtyped as American Elm, Sugar Maple, Apricot, or Saguaro—or something 
else. Each subtype, then, may have its own specialized Properties. For instance, each Sugar Maple could have a yearly 
maple sugar yield of some given quantity, each Saguaro could be inhabited by zero or more instances of a Gila 
Woodpecker, and so on.
The powertype designation on the Tree GeneralizationSet specifies that the instances of TreeSpecies are in one-to-one 
correspondence to the subclasses of Tree.
This concept applies to many situations within many lines of business. Figure 9.25 depicts other examples of power 
types. The name on the GeneralizationSet beginning with a colon indicates the power type.

122

Unified Modeling Language 2.5

Figure 9.25  More power type examples

In diagram (a), each instance of Checking Account could have its own attributes (including those inherited from 
Account), such as account number and balance. Additionally, the equivalent instance for Checking Account may have 
attributes, such as interest rate and maximum delay for withdrawal.
The example (b) depicts a vehicle-modeling example. Here, each Vehicle may be classified as either a Truck or a Car or 
something else. Furthermore, Truck and Car are equivalent to instances of Vehicle Type. In (c), Disease Occurrence 
classifies each occurrence of disease (e.g., my chicken pox and your measles). Disease Classification is the power type 
whose instances are equivalent to classes such as Chicken Pox and Measles.
Labeling collections of subtypes with powertypes becomes increasingly important when a type has more than one 
powertype. Figure 9.26 illustrates one such example, showing which subtype collection contains Policy Coverage Types 
and which Insurance Lines. For instance, a Policy may be classified as Life, Health, Property/Casualty, or some other 
Insurance Line. The same Policy may be classified with its Policy Coverage Type as Group or Individual.

Unified Modeling Language 2.5

123

Figure 9.26  More than one powertype

Instances
Summary

9.8
9.8.1
InstanceSpecifications represent instances of Classifiers in a modeled system. They are often used to model example 
configurations of instances. They may be partial or complete representations of the instances that they correspond to.

9.8.2

Abstract Syntax

PackageableElement

DeploymentTarget

DeployedArtifact

Element

InstanceSpecification

{subsets owner}
+ owningInstance
1

{subsets ownedElement}
+ slot

*

Slot

+ slot
*

+ definingFeature
1

StructuralFeature

0..1

+ owningSlot

{subsets owner}

0..1
+ owningInstanceSpec
{subsets owner}

{subsets ownedElement}
+ specification
0..1

+ value

{ordered, subsets ownedElement}

*

ValueSpecification

+ instance

1

+ instanceValue

InstanceValue

*

+ instanceSpecification

*

+ classifier

*

Classifier

Figure 9.27  Instances

124

Unified Modeling Language 2.5

Semantics

9.8.3
An InstanceSpecification represents the possible or actual existence of instances in a modeled system and completely or 
partially describes those instances.
A Slot specifies that an instance modeled by an InstanceSpecification has a value or values for a specific 
StructuralFeature, which shall be a StructuralFeature that is related to a classifier of the InstanceSpecification owning 
the Slot by being a direct attribute, inherited attribute, private attribute in a generalization, or a memberEnd if the 
classifier is an Association, but excluding redefined StructuralFeatures. The values in a Slot shall conform to the 
defining StructuralFeature of the Slot (in type, multiplicity, etc.). The values in a Slot are specified using 
ValueSpecifications (see Clause 8).
The InstanceSpecification may represent:

•

•

•

Classification of the instance by one or more Classifiers, any of which may be abstract.

The kind of instance, based on its classifiers. For example, an InstanceSpecification whose classifier is a Class 
describes an instance of that Class, while an InstanceSpecification whose classifier is an Association describes a 
link of that Association. If no classifiers are given, then the InstanceSpecification does not constrain the kind of 
instance represented. If classifiers of different kinds are given, then the semantics are not defined.
Specification of values of StructuralFeatures of the instance, where the values are contained in Slots. Not all 
StructuralFeatures of all Classifiers of the InstanceSpecification need be represented by Slots, in which case 
the InstanceSpecification is a partial description.

• An optional specification, by a ValueSpecification, of how to compute, derive, or construct the instance. If 

such a ValueSpecification is given, then the represented instance is equal to the value resulting from the 
evaluation of the ValueSpecification. If the InstanceSpecification has one or more classifiers, then the type of 
the ValueSpecification must conform to at least one of those classifiers.

An InstanceSpecification may specify the actual existence of an instance in a modeled system. Or, an 
InstanceSpecification may provide an illustration or example of a possible instance in a modeled system. The purpose of 
an InstanceSpecification is to show what is of interest about the instance. The instance conforms to each classifier of the 
InstanceSpecification, and has properties with values indicated by each slot of the InstanceSpecification. Having no slot 
in an InstanceSpecification for some properties does not mean that the represented instance does not have the property, 
but merely that the property is not of interest in the model. Similarly, the actual instance might conform to a 
specialization of a modeled classifier of the InstanceSpecification, but this fact may not be of interest in the model.
An InstanceSpecification may represent an instance at a point in time (a snapshot). Changes to the instance may be 
modeled using multiple InstanceSpecification, one for each snapshot.
It is important to keep in mind that InstanceSpecification is a model element and should not be confused with the 
instance that it is modeling. As an InstanceSpecification may only partially determine the properties of an instance, 
there may actually be multiple instances in the modeled system that satisfy the requirements of the 
InstanceSpecification. On the other hand, an InstanceSpecification may model a situation which is not actually 
supposed to occur in the modeled system, in which case no instance meeting the requirements of the 
InstanceSpecification may ever actually occur in the system.
An InstanceValue is a kind of ValueSpecification whose value is specified using an InstanceSpecification. Each 
evaluation of the InstanceValue is considered to result in a distinct instance conforming to the InstanceSpecification. If 
the InstanceSpecification has a specification, then that ValueSpecification is evaluated to give the value of the 
InstanceValue. Otherwise, an InstanceValue is evaluated by creating a value that is an instance of each of the classifiers 
identified in the InstanceSpecification. Any slots in the InstanceSpecification then provide values for the corresponding 
StructuralFeatures of the instance by evaluating the ValueSpecifications associated with those slots. A StructuralFeature 
for which no slot is given either has the value obtained by evaluating its defaultValue, if it is a Property with a 
defaultValue, or no value, otherwise.
NOTE. An InstanceValue does not own the InstanceSpecification to which it refers; multiple InstanceValues may refer 
to the same InstanceSpecification.

Unified Modeling Language 2.5

125

Notation

9.8.4
An InstanceSpecification is depicted using similar notation to its classifiers, but in place of the Classifier name appears 
an underlined concatenation of the instance name (if any), a colon (‘:’) and the Classifier name or names. The 
convention for showing multiple classifiers is to separate their names by commas.
An InstanceSpecification whose classifier is an Association represents a link and is shown using the same notation as for 
an Association, but the solid path or paths connect InstanceSpecifications rather than Classifiers. It is not necessary to 
show an underlined name where it is clear from its connection to instance specifications that it represents a link and not 
an Association. End names may adorn the ends. Navigation arrows may be shown, but if shown, they shall agree with 
the navigation of the Association’s ends.
NOTE. Names are optional for Classifiers and InstanceSpecifications. The absence of a name in a diagram does not 
necessarily reflect its absence in the underlying model.
The standard notation for an anonymous InstanceSpecification of an unnamed Classifier is an underlined colon (‘:’).
If an InstanceSpecification has a ValueSpecification as its specification, the ValueSpecification is shown either after an 
equal sign (“=”) following the name, or without an equal sign below the name. If the InstanceSpecification is shown 
using an enclosing shape (such as a rectangle) that contains the name, the ValueSpecification is shown within the 
enclosing shape.
Slots are shown using similar notation to that of the corresponding StructuralFeatures. Where a StructuralFeature would 
be shown textually in a compartment, a Slot for that StructuralFeature may be shown textually as a StructuralFeature 
name or qualifiedName followed by an equal sign (‘=’) and a value specification. Other properties of the 
StructuralFeature, such as its type, may optionally be shown.
An InstanceValue may appear using textual or graphical notation. When textual, as may appear for the value of a Slot, 
the name of the InstanceSpecification is shown. This may be displayed as a qualified name. When graphical, an 
InstanceValue is represented using the notation for its InstanceSpecification.
A Slot value that is an InstanceValue may alternatively be shown using a graphical notation similar to that for a link. A 
solid path runs from the owning InstanceSpecification to the symbol representing the InstanceValue that is the Slot’s 
value, and the name of the attribute adorns the target end of the path. Navigability, if shown, shall be only in the 
direction of the target. This notation can give rise to visual ambiguity with the link notation when the only adornments 
are at the target end; in such cases the model should be inspected to determine the presence or absence of an actual 
Association instance.
Where an InstanceSpecification is classified by a StructuredClassifier (see 11.2.3) it may contain nested rectangles 
representing the instances playing its roles. The namestring of such a nested InstanceSpecification obeys the following 
syntax:

{<name> [‘/’ <rolename>] | ‘/’ <rolename>} [‘:’ <classifiername> [‘,’ <classifiername>]*]

The name of the InstanceSpecification may be followed by the name of the role which the instance plays. The role name 
may only be present if the instance plays a role.
Where an InstanceSpecification contains both Slot values and nested rectangles depicting roles, it is divided into 
compartments analogous to the attributes and internal structure compartments of its corresponding StructuredClassifier.
Examples of InstanceSpecifications for StructuredClassifiers are shown in 11.4.5.

Examples

9.8.5
The example in Figure 9.28 below shows an InstanceSpecification called “streetName,” classified as String, and with a 
specification that is a LiteralString whose value is “S.Crown Street.”

126

Unified Modeling Language 2.5

Figure 9.28  Specification of an Instance of String

The example in Figure 9.29 below shows an InstanceSpecification with Slots.

Figure 9.29  Slots with values

The example in Figure 9.30 below shows a link between two InstanceSpecifications.

Figure 9.30  InstanceSpecifications representing two objects connected by a link

The example in Figure 9.31 below shows an InstanceValue as the value of a Slot represented using textual notation.

Figure 9.31  InstanceValue represented textually

The example in Figure 9.32 below shows the same model represented using graphical notation.

Figure 9.32  InstanceValue represented graphically

9.9
9.9.1

9.9.1.1

Classifier Descriptions
AggregationKind [Enumeration]

Description

AggregationKind is an Enumeration for specifying the kind of aggregation of a Property.

9.9.1.2
•

Diagrams

Properties
 
 

Unified Modeling Language 2.5

127

9.9.1.3

Literals

•

•

•

9.9.2

9.9.2.1

none
Indicates that the Property has no aggregation.

shared
Indicates that the Property has shared aggregation.

composite
Indicates that the Property is aggregated compositely, i.e., the composite object has responsibility for the 
existence and storage of the composed objects (parts).

BehavioralFeature [Abstract Class]

Description

A BehavioralFeature is a feature of a Classifier that specifies an aspect of the behavior of its instances. A 
BehavioralFeature is implemented (realized) by a Behavior. A BehavioralFeature specifies that a Classifier will respond 
to a designated request by invoking its implementing method.

9.9.2.2

Diagrams

Features, Operations, Signals, Behaviors

9.9.2.3

Generalizations

Feature, Namespace

9.9.2.4

Specializations

9.9.2.5
•

•

Operation, Reception

Attributes

concurrency : CallConcurrencyKind [1..1] = sequential
Specifies the semantics of concurrent calls to the same passive instance (i.e., an instance originating from a 
Class with isActive being false). Active instances control access to their own BehavioralFeatures.

isAbstract : Boolean [1..1] = false
If true, then the BehavioralFeature does not have an implementation, and one must be supplied by a more 
specific Classifier. If false, the BehavioralFeature must have an implementation in the Classifier or one must be 
inherited.

9.9.2.6

Association Ends

• method : Behavior [0..*] (opposite Behavior::specification)

A Behavior that implements the BehavioralFeature. There may be at most one Behavior for a particular pairing 
of a Classifier (as owner of the Behavior) and a BehavioralFeature (as specification of the Behavior).

•

128

♦ ownedParameter : Parameter [0..*]{ordered, subsets Namespace::ownedMember} (opposite 
A_ownedParameter_ownerFormalParam::ownerFormalParam)
The ordered set of formal Parameters of this BehavioralFeature.

Unified Modeling Language 2.5

•

•

9.9.2.7
•

•

•

♦ ownedParameterSet : ParameterSet [0..*]{subsets Namespace::ownedMember} (opposite 
A_ownedParameterSet_behavioralFeature::behavioralFeature)
The ParameterSets owned by this BehavioralFeature.

raisedException : Type [0..*] (opposite A_raisedException_behavioralFeature::behavioralFeature)
The Types representing exceptions that may be raised during an invocation of this BehavioralFeature.

Operations

isDistinguishableFrom(n : NamedElement, ns : Namespace) : Boolean {redefines 
NamedElement::isDistinguishableFrom()}
The query isDistinguishableFrom() determines whether two BehavioralFeatures may coexist in the same 
Namespace. It specifies that they must have different signatures.

body: (n.oclIsKindOf(BehavioralFeature) and ns.getNamesOfMember(self)-
>intersection(ns.getNamesOfMember(n))->notEmpty()) implies
  Set{self}->including(n.oclAsType(BehavioralFeature))->isUnique(ownedParameter->collect(p|
  Tuple { name=p.name, 
type=p.type,effect=p.effect,direction=p.direction,isException=p.isException,
              isStream=p.isStream,isOrdered=p.isOrdered,isUnique=p.isUnique,lower=p.lower, 
upper=p.upper }))

inputParameters() : Parameter [0..*]{ordered}
The ownedParameters with direction in and inout.

body: ownedParameter->select(direction=ParameterDirectionKind::_'in' or 
direction=ParameterDirectionKind::inout)

outputParameters() : Parameter [0..*]{ordered}
The ownedParameters with direction out, inout, or return.

body: ownedParameter->select(direction=ParameterDirectionKind::out or 
direction=ParameterDirectionKind::inout or direction=ParameterDirectionKind::return)

9.9.2.8

Constraints

•

abstract_no_method
When isAbstract is true there are no methods.

inv: isAbstract implies method->isEmpty()

CallConcurrencyKind [Enumeration]

Description

9.9.3

9.9.3.1

CallConcurrencyKind is an Enumeration used to specify the semantics of concurrent calls to a BehavioralFeature.

9.9.3.2
•

9.9.3.3

•

Diagrams

Features
 

 

Literals

sequential
No concurrency management mechanism is associated with the BehavioralFeature and, therefore, concurrency 

Unified Modeling Language 2.5

129

conflicts may occur. Instances that invoke a BehavioralFeature need to coordinate so that only one invocation 
to a target on any BehavioralFeature occurs at once.

•

•

guarded
Multiple invocations of a BehavioralFeature that overlap in time may occur to one instance, but only one is 
allowed to commence. The others are blocked until the performance of the currently executing 
BehavioralFeature is complete. It is the responsibility of the system designer to ensure that deadlocks do not 
occur due to simultaneous blocking.

concurrent
Multiple invocations of a BehavioralFeature that overlap in time may occur to one instance and all of them 
may proceed concurrently.

9.9.4

9.9.4.1

Classifier [Abstract Class]

Description

A Classifier represents a classification of instances according to their Features.

9.9.4.2

Diagrams

Classifiers, Classifier Templates, Features, Instances, Generalization Sets, Executable Nodes, Use Cases, 
Structured Classifiers, Classes, Associations, Components, Collaborations, State Machine Redefinition, 
DataTypes, Signals, Interfaces, Information Flows, Artifacts, Actions, Accept Event Actions, Object Actions

9.9.4.3

Generalizations

Namespace, Type, TemplateableElement, RedefinableElement

9.9.4.4

Specializations

Association, StructuredClassifier, BehavioredClassifier, DataType, Interface, Signal, InformationItem, Artifact

Attributes

isAbstract : Boolean [1..1] = false
If true, the Classifier can only be instantiated by instantiating one of its specializations. An abstract Classifier is 
intended to be used by other Classifiers e.g., as the target of Associations or Generalizations.

isFinalSpecialization : Boolean [1..1] = false
If true, the Classifier cannot be specialized.

Association Ends

/attribute : Property [0..*]{ordered, union, subsets Classifier::feature, subsets 
A_redefinitionContext_redefinableElement::redefinableElement} (opposite A_attribute_classifier::classifier)
All of the Properties that are direct (i.e., not inherited or imported) attributes of the Classifier.

♦ collaborationUse : CollaborationUse [0..*]{subsets Element::ownedElement} (opposite 
A_collaborationUse_classifier::classifier)
The CollaborationUses owned by the Classifier.

Unified Modeling Language 2.5

9.9.4.5
•

•

9.9.4.6
•

•

130

•

•

•

•

•

•

•

•

•

•

•

•

9.9.4.7
•

/feature : Feature [0..*]{union, subsets Namespace::member} (opposite Feature::featuringClassifier)
Specifies each Feature directly defined in the classifier. Note that there may be members of the Classifier that 
are of the type Feature but are not included, e.g., inherited features.

/general : Classifier [0..*] (opposite A_general_classifier::classifier)
The generalizing Classifiers for this Classifier.

♦ generalization : Generalization [0..*]{subsets Element::ownedElement, subsets 
A_source_directedRelationship::directedRelationship} (opposite Generalization::specific)
The Generalization relationships for this Classifier. These Generalizations navigate to more general Classifiers 
in the generalization hierarchy.

/inheritedMember : NamedElement [0..*]{subsets Namespace::member} (opposite 
A_inheritedMember_inheritingClassifier::inheritingClassifier)
All elements inherited by this Classifier from its general Classifiers.

♦ ownedTemplateSignature : RedefinableTemplateSignature [0..1]{subsets 
A_redefinitionContext_redefinableElement::redefinableElement, redefines 
TemplateableElement::ownedTemplateSignature} (opposite RedefinableTemplateSignature::classifier)
The optional RedefinableTemplateSignature specifying the formal template parameters.

♦ ownedUseCase : UseCase [0..*]{subsets Namespace::ownedMember} (opposite 
A_ownedUseCase_classifier::classifier)
The UseCases owned by this classifier.

powertypeExtent : GeneralizationSet [0..*] (opposite GeneralizationSet::powertype)
The GeneralizationSet of which this Classifier is a power type.

redefinedClassifier : Classifier [0..*]{subsets RedefinableElement::redefinedElement} (opposite 
A_redefinedClassifier_classifier::classifier)
The Classifiers redefined by this Classifier.

representation : CollaborationUse [0..1]{subsets Classifier::collaborationUse} (opposite 
A_representation_classifier::classifier)
A CollaborationUse which indicates the Collaboration that represents this Classifier.

♦ substitution : Substitution [0..*]{subsets Element::ownedElement, subsets 
NamedElement::clientDependency} (opposite Substitution::substitutingClassifier)
The Substitutions owned by this Classifier.

templateParameter : ClassifierTemplateParameter [0..1]{redefines ParameterableElement::templateParameter} 
(opposite ClassifierTemplateParameter::parameteredElement)
TheClassifierTemplateParameter that exposes this element as a formal parameter.

useCase : UseCase [0..*] (opposite UseCase::subject)
The set of UseCases for which this Classifier is the subject.

Operations

allFeatures() : Feature [0..*]
The query allFeatures() gives all of the Features in the namespace of the Classifier. In general, through 
mechanisms such as inheritance, this will be a larger set than feature.

Unified Modeling Language 2.5

131

•

•

•

•

•

•

•

•

body: member->select(oclIsKindOf(Feature))->collect(oclAsType(Feature))->asSet()

allParents() : Classifier [0..*]
The query allParents() gives all of the direct and indirect ancestors of a generalized Classifier.

body: parents()->union(parents()->collect(allParents())->asSet())

conformsTo(other : Type) : Boolean {redefines Type::conformsTo()}
The query conformsTo() gives true for a Classifier that defines a type that conforms to another. This is used, 
for example, in the specification of signature conformance for operations.

body: if other.oclIsKindOf(Classifier) then
  let otherClassifier : Classifier = other.oclAsType(Classifier) in
    self = otherClassifier or allParents()->includes(otherClassifier)
else
  false
endif

general() : Classifier [0..*]
The general Classifiers are the ones referenced by the Generalization relationships.

body: parents()

hasVisibilityOf(n : NamedElement) : Boolean
The query hasVisibilityOf() determines whether a NamedElement is visible in the classifier. Non-private 
members are visible. It is only called when the argument is something owned by a parent.

pre: allParents()->including(self)->collect(member)->includes(n)
body: n.visibility <> VisibilityKind::private

inherit(inhs : NamedElement [0..*]) : NamedElement [0..*]
The query inherit() defines how to inherit a set of elements passed as its argument. It excludes redefined 
elements from the result.

body: inhs->reject(inh |
  inh.oclIsKindOf(RedefinableElement) and
  ownedMember->select(oclIsKindOf(RedefinableElement))->
    select(redefinedElement->includes(inh.oclAsType(RedefinableElement)))
       ->notEmpty())

inheritableMembers(c : Classifier) : NamedElement [0..*]
The query inheritableMembers() gives all of the members of a Classifier that may be inherited in one of its 
descendants, subject to whatever visibility restrictions apply.

pre: c.allParents()->includes(self)
body: member->select(m | c.hasVisibilityOf(m))

inheritedMember() : NamedElement [0..*]
The inheritedMember association is derived by inheriting the inheritable members of the parents.

body: inherit(parents()->collect(inheritableMembers(self))->asSet())

isTemplate() : Boolean {redefines TemplateableElement::isTemplate()}
The query isTemplate() returns whether this Classifier is actually a template.

body: ownedTemplateSignature <> null or general->exists(g | g.isTemplate())

132

Unified Modeling Language 2.5

• maySpecializeType(c : Classifier) : Boolean

The query maySpecializeType() determines whether this classifier may have a generalization relationship to 
classifiers of the specified type. By default a classifier may specialize classifiers of the same or a more general 
type. It is intended to be redefined by classifiers that have different specialization constraints.

•

•

•

•

•

•

•

•

body: self.oclIsKindOf(c.oclType())

parents() : Classifier [0..*]
The query parents() gives all of the immediate ancestors of a generalized Classifier.

body: generalization.general->asSet()

directlyRealizedInterfaces() : Interface [0..*]
The Interfaces directly realized by this Classifier

body: (clientDependency->
  select(oclIsKindOf(Realization) and supplier->forAll(oclIsKindOf(Interface))))->
      collect(supplier.oclAsType(Interface))->asSet()

directlyUsedInterfaces() : Interface [0..*]
The Interfaces directly used by this Classifier

body: (supplierDependency->
  select(oclIsKindOf(Usage) and client->forAll(oclIsKindOf(Interface))))->
    collect(client.oclAsType(Interface))->asSet()

allRealizedInterfaces() : Interface [0..*]
The Interfaces realized by this Classifier and all of its generalizations

body: directlyRealizedInterfaces()->union(self.allParents()-
>collect(directlyRealizedInterfaces()))->asSet()

allUsedInterfaces() : Interface [0..*]
The Interfaces used by this Classifier and all of its generalizations

body: directlyUsedInterfaces()->union(self.allParents()->collect(directlyUsedInterfaces()))-
>asSet()

isSubstitutableFor(contract : Classifier) : Boolean

body: substitution.contract->includes(contract)

allAttributes() : Property [0..*]{ordered}
The query allAttributes gives an ordered set of all owned and inherited attributes of the Classifier. All owned 
attributes appear before any inherited attributes, and the attributes inherited from any more specific parent 
Classifier appear before those of any more general parent Classifier. However, if the Classifier has multiple 
immediate parents, then the relative ordering of the sets of attributes from those parents is not defined.

body: attribute->asSequence()->union(parents()->asSequence().allAttributes())->select(p | 
member->includes(p))->asOrderedSet()

allSlottableFeatures() : StructuralFeature [0..*]
All StructuralFeatures related to the Classifier that may have Slots, including direct attributes, inherited 
attributes, private attributes in generalizations, and memberEnds of Associations, but excluding redefined 
StructuralFeatures.

body: member->select(oclIsKindOf(StructuralFeature))->

Unified Modeling Language 2.5

133

  collect(oclAsType(StructuralFeature))->
   union(self.inherit(self.allParents()->collect(p | p.attribute)->asSet())->
     collect(oclAsType(StructuralFeature)))->asSet()

9.9.4.8

Constraints

•

specialize_type
A Classifier may only specialize Classifiers of a valid type.

inv: parents()->forAll(c | self.maySpecializeType(c))

• maps_to_generalization_set

The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the 
Generalization relationships defined for that GeneralizationSet. In other words, a power type may not be an 
instance of itself nor may its instances also be its subclasses.

inv: powertypeExtent->forAll( gs |
  gs.generalization->forAll( gen |
    not (gen.general = self) and not gen.general.allParents()->includes(self) and not 
(gen.specific = self) and not self.allParents()->includes(gen.specific)
  ))

•

•

9.9.5

9.9.5.1

non_final_parents
The parents of a Classifier must be non-final.

inv: parents()->forAll(not isFinalSpecialization)

no_cycles_in_generalization
Generalization hierarchies must be directed and acyclical. A Classifier can not be both a transitively general 
and transitively specific Classifier of the same Classifier.

inv: not allParents()->includes(self)

ClassifierTemplateParameter [Class]

Description

A ClassifierTemplateParameter exposes a Classifier as a formal template parameter.

9.9.5.2

Diagrams

Classifier Templates

9.9.5.3

Generalizations

TemplateParameter

Attributes

allowSubstitutable : Boolean [1..1] = true
Constrains the required relationship between an actual parameter and the parameteredElement for this formal 
parameter.

Association Ends

constrainingClassifier : Classifier [0..*] (opposite 
A_constrainingClassifier_classifierTemplateParameter::classifierTemplateParameter)

Unified Modeling Language 2.5

9.9.5.4
•

9.9.5.5
•

134

The classifiers that constrain the argument that can be used for the parameter. If the allowSubstitutable 
attribute is true, then any Classifier that is compatible with this constraining Classifier can be substituted; 
otherwise, it must be either this Classifier or one of its specializations. If this property is empty, there are no 
constraints on the Classifier that can be used as an argument.

•

parameteredElement : Classifier [1..1]{redefines TemplateParameter::parameteredElement} (opposite 
Classifier::templateParameter)
The Classifier exposed by this ClassifierTemplateParameter.

9.9.5.6

Constraints

•

•

has_constraining_classifier
If allowSubstitutable is true, then there must be a constrainingClassifier.

inv: allowSubstitutable implies constrainingClassifier->notEmpty()

parametered_element_no_features
The parameteredElement has no direct features, and if constrainedElement is empty it has no generalizations.

inv: parameteredElement.feature->isEmpty() and (constrainingClassifier->isEmpty() implies  
parameteredElement.allParents()->isEmpty())

• matching_abstract

If the parameteredElement is not abstract, then the Classifier used as an argument shall not be abstract.

inv: (not parameteredElement.isAbstract) implies templateParameterSubstitution.actual-
>forAll(a | not a.oclAsType(Classifier).isAbstract)

•

•

•

actual_is_classifier
The argument to a ClassifierTemplateParameter is a Classifier.

inv:  templateParameterSubstitution.actual->forAll(a | a.oclIsKindOf(Classifier))

constraining_classifiers_constrain_args
If there are any constrainingClassifiers, then every argument must be the same as or a specialization of them, 
or if allowSubstitutable is true, then it can also be substitutable.

inv: templateParameterSubstitution.actual->forAll( a |
  let arg : Classifier = a.oclAsType(Classifier) in
    constrainingClassifier->forAll(
      cc |
         arg = cc or arg.conformsTo(cc) or (allowSubstitutable and 
arg.isSubstitutableFor(cc))
      )
)

constraining_classifiers_constrain_parametered_element
If there are any constrainingClassifiers, then the parameteredElement must be the same as or a specialization of 
them, or if allowSubstitutable is true, then it can also be substitutable.

inv: constrainingClassifier->forAll(
     cc |  parameteredElement = cc or parameteredElement.conformsTo(cc) or 
(allowSubstitutable and parameteredElement.isSubstitutableFor(cc))
)

Unified Modeling Language 2.5

135

9.9.6

9.9.6.1

Feature [Abstract Class]

Description

A Feature declares a behavioral or structural characteristic of Classifiers.

9.9.6.2

Diagrams

Classifiers, Features, Structured Classifiers

9.9.6.3

Generalizations

RedefinableElement

9.9.6.4

Specializations

BehavioralFeature, StructuralFeature, Connector

Attributes

isStatic : Boolean [1..1] = false
Specifies whether this Feature characterizes individual instances classified by the Classifier (false) or the 
Classifier itself (true).

Association Ends

/featuringClassifier : Classifier [0..1]{union, subsets A_member_memberNamespace::memberNamespace} 
(opposite Classifier::feature)
The Classifiers that have this Feature as a feature.

Generalization [Class]

Description

9.9.6.5
•

9.9.6.6
•

9.9.7

9.9.7.1

A Generalization is a taxonomic relationship between a more general Classifier and a more specific Classifier. Each 
instance of the specific Classifier is also an instance of the general Classifier. The specific Classifier inherits the features 
of the more general Classifier. A Generalization is owned by the specific Classifier.

9.9.7.2

Diagrams

Classifiers, Generalization Sets

9.9.7.3

Generalizations

DirectedRelationship

Attributes

isSubstitutable : Boolean [0..1] = true
Indicates whether the specific Classifier can be used wherever the general Classifier can be used. If true, the 
execution traces of the specific Classifier shall be a superset of the execution traces of the general Classifier. If 
false, there is no such constraint on execution traces. If unset, the modeler has not stated whether there is such 
a constraint or not.

Unified Modeling Language 2.5

9.9.7.4
•

136

9.9.7.5
•

•

•

9.9.8

9.9.8.1

Association Ends

general : Classifier [1..1]{subsets DirectedRelationship::target} (opposite 
A_general_generalization::generalization)
The general classifier in the Generalization relationship.

generalizationSet : GeneralizationSet [0..*] (opposite GeneralizationSet::generalization)
Represents a set of instances of Generalization. A Generalization may appear in many GeneralizationSets.

specific : Classifier [1..1]{subsets DirectedRelationship::source, subsets Element::owner} (opposite 
Classifier::generalization)
The specializing Classifier in the Generalization relationship.

GeneralizationSet [Class]

Description

A GeneralizationSet is a PackageableElement whose instances represent sets of Generalization relationships.

9.9.8.2

Diagrams

Classifiers, Generalization Sets

9.9.8.3

Generalizations

9.9.8.4
•

•

9.9.8.5
•

•

PackageableElement

Attributes

isCovering : Boolean [1..1] = false
Indicates (via the associated Generalizations) whether or not the set of specific Classifiers are covering for a 
particular general classifier. When isCovering is true, every instance of a particular general Classifier is also an 
instance of at least one of its specific Classifiers for the GeneralizationSet. When isCovering is false, there are 
one or more instances of the particular general Classifier that are not instances of at least one of its specific 
Classifiers defined for the GeneralizationSet.

isDisjoint : Boolean [1..1] = false
Indicates whether or not the set of specific Classifiers in a Generalization relationship have instance in 
common. If isDisjoint is true, the specific Classifiers for a particular GeneralizationSet have no members in 
common; that is, their intersection is empty. If isDisjoint is false, the specific Classifiers in a particular 
GeneralizationSet have one or more members in common; that is, their intersection is not empty.

Association Ends

generalization : Generalization [0..*] (opposite Generalization::generalizationSet)
Designates the instances of Generalization that are members of this GeneralizationSet.

powertype : Classifier [0..1] (opposite Classifier::powertypeExtent)
Designates the Classifier that is defined as the power type for the associated GeneralizationSet, if there is one.

9.9.8.6

Constraints

•

generalization_same_classifier
Every Generalization associated with a particular GeneralizationSet must have the same general Classifier.

Unified Modeling Language 2.5

137

inv: generalization->collect(general)->asSet()->size() <= 1

• maps_to_generalization_set

The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the 
Generalization relationships defined for that GeneralizationSet. In other words, a power type may not be an 
instance of itself nor may its instances be its subclasses.

inv: powertype <> null implies generalization->forAll( gen |
    not (gen.general = powertype) and not gen.general.allParents()->includes(powertype) and 
not (gen.specific = powertype) and not powertype.allParents()->includes(gen.specific)
  )

9.9.9

9.9.9.1

InstanceSpecification [Class]

Description

An InstanceSpecification is a model element that represents an instance in a modeled system. An InstanceSpecification 
can act as a DeploymentTarget in a Deployment relationship, in the case that it represents an instance of a Node. It can 
also act as a DeployedArtifact, if it represents an instance of an Artifact.

9.9.9.2

Diagrams

Instances, DataTypes, Deployments

9.9.9.3

Generalizations

DeploymentTarget, PackageableElement, DeployedArtifact

9.9.9.4

Specializations

EnumerationLiteral

9.9.9.5
•

•

•

Association Ends

classifier : Classifier [0..*] (opposite A_classifier_instanceSpecification::instanceSpecification)
The Classifier or Classifiers of the represented instance. If multiple Classifiers are specified, the instance is 
classified by all of them.

♦ slot : Slot [0..*]{subsets Element::ownedElement} (opposite Slot::owningInstance)
A Slot giving the value or values of a StructuralFeature of the instance. An InstanceSpecification can have one 
Slot per StructuralFeature of its Classifiers, including inherited features. It is not necessary to model a Slot for 
every StructuralFeature, in which case the InstanceSpecification is a partial description.

♦ specification : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_specification_owningInstanceSpec::owningInstanceSpec)
A specification of how to compute, derive, or construct the instance.

9.9.9.6

Constraints

•

•

138

deployment_artifact
An InstanceSpecification can act as a DeployedArtifact if it represents an instance of an Artifact.

inv: deploymentForArtifact->notEmpty() implies classifier->exists(oclIsKindOf(Artifact))

structural_feature
No more than one slot in an InstanceSpecification may have the same definingFeature.

Unified Modeling Language 2.5

•

•

inv: classifier->forAll(c | (c.allSlottableFeatures()->forAll(f | slot->select(s | 
s.definingFeature = f)->size() <= 1)))

defining_feature
The definingFeature of each slot is a StructuralFeature related to a classifier of the InstanceSpecification, 
including direct attributes, inherited attributes, private attributes in generalizations, and memberEnds of 
Associations, but excluding redefined StructuralFeatures.

inv: slot->forAll(s | classifier->exists (c | c.allSlottableFeatures()->includes 
(s.definingFeature)))

deployment_target
An InstanceSpecification can act as a DeploymentTarget if it represents an instance of a Node and functions as 
a part in the internal structure of an encompassing Node.

inv: deployment->notEmpty() implies classifier->exists(node | node.oclIsKindOf(Node) and 
Node.allInstances()->exists(n | n.part->exists(p | p.type = node)))

9.9.10

9.9.10.1

InstanceValue [Class]

Description

An InstanceValue is a ValueSpecification that identifies an instance.

9.9.10.2

Diagrams

Instances

9.9.10.3

Generalizations

ValueSpecification

9.9.10.4

Association Ends

•

9.9.11

9.9.11.1

instance : InstanceSpecification [1..1] (opposite A_instance_instanceValue::instanceValue)
The InstanceSpecification that represents the specified value.

Operation [Class]

Description

An Operation is a BehavioralFeature of a Classifier that specifies the name, type, parameters, and constraints for 
invoking an associated Behavior. An Operation may invoke both the execution of method behaviors as well as other 
behavioral responses. Operation specializes TemplateableElement in order to support specification of template 
operations and bound operations. Operation specializes ParameterableElement to specify that an operation can be 
exposed as a formal template parameter, and provided as an actual parameter in a binding of a template.

9.9.11.2

Diagrams

Operations, Classes, Protocol State Machines, DataTypes, Interfaces, Artifacts, Events, Invocation Actions

9.9.11.3

Generalizations

TemplateableElement, ParameterableElement, BehavioralFeature

Unified Modeling Language 2.5

139

9.9.11.4

Attributes

•

•

•

•

•

/isOrdered : Boolean [1..1]
Specifies whether the return parameter is ordered or not, if present. This information is derived from the return 
result for this Operation.

isQuery : Boolean [1..1] = false
Specifies whether an execution of the BehavioralFeature leaves the state of the system unchanged 
(isQuery=true) or whether side effects may occur (isQuery=false).

/isUnique : Boolean [1..1]
Specifies whether the return parameter is unique or not, if present. This information is derived from the return 
result for this Operation.

/lower : Integer [0..1]
Specifies the lower multiplicity of the return parameter, if present. This information is derived from the return 
result for this Operation.

/upper : UnlimitedNatural [0..1]
The upper multiplicity of the return parameter, if present. This information is derived from the return result for 
this Operation.

9.9.11.5

Association Ends

•

•

•

•

•

•

•

♦ bodyCondition : Constraint [0..1]{subsets Namespace::ownedRule} (opposite 
A_bodyCondition_bodyContext::bodyContext)
An optional Constraint on the result values of an invocation of this Operation.

class : Class [0..1]{subsets Feature::featuringClassifier, subsets NamedElement::namespace, subsets 
RedefinableElement::redefinitionContext} (opposite Class::ownedOperation)
The Class that owns this operation, if any.

datatype : DataType [0..1]{subsets Feature::featuringClassifier, subsets NamedElement::namespace, subsets 
RedefinableElement::redefinitionContext} (opposite DataType::ownedOperation)
The DataType that owns this Operation, if any.

interface : Interface [0..1]{subsets Feature::featuringClassifier, subsets NamedElement::namespace, subsets 
RedefinableElement::redefinitionContext} (opposite Interface::ownedOperation)
The Interface that owns this Operation, if any.

♦ ownedParameter : Parameter [0..*]{ordered, redefines BehavioralFeature::ownedParameter} (opposite 
Parameter::operation)
The parameters owned by this Operation.

♦ postcondition : Constraint [0..*]{subsets Namespace::ownedRule} (opposite 
A_postcondition_postContext::postContext)
An optional set of Constraints specifying the state of the system when the Operation is completed.

♦ precondition : Constraint [0..*]{subsets Namespace::ownedRule} (opposite 
A_precondition_preContext::preContext)
An optional set of Constraints on the state of the system when the Operation is invoked.

140

Unified Modeling Language 2.5

•

•

•

•

raisedException : Type [0..*]{redefines BehavioralFeature::raisedException} (opposite 
A_raisedException_operation::operation)
The Types representing exceptions that may be raised during an invocation of this operation.

redefinedOperation : Operation [0..*]{subsets RedefinableElement::redefinedElement} (opposite 
A_redefinedOperation_operation::operation)
The Operations that are redefined by this Operation.

templateParameter : OperationTemplateParameter [0..1]{redefines ParameterableElement::templateParameter} 
(opposite OperationTemplateParameter::parameteredElement)
The OperationTemplateParameter that exposes this element as a formal parameter.

/type : Type [0..1]{} (opposite A_type_operation::operation)
The return type of the operation, if present. This information is derived from the return result for this 
Operation.

9.9.11.6

Operations

•

•

•

isConsistentWith(redefiningElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isConsistentWith()}
The query isConsistentWith() specifies, for any two Operations in a context in which redefinition is possible, 
whether redefinition would be consistent. A redefining operation is consistent with a redefined operation if it 
has the same number of owned parameters, and for each parameter the following holds: - Direction, ordering 
and uniqueness are the same. - The corresponding types are covariant, contravariant or invariant. - The 
multiplicities are compatible, depending on the parameter direction.

pre: redefiningElement.isRedefinitionContextValid(self)
body: redefiningElement.oclIsKindOf(Operation) and
let op : Operation = redefiningElement.oclAsType(Operation) in

self.ownedParameter->size() = op.ownedParameter->size() and
Sequence{1..self.ownedParameter->size()}->

forAll(i |
  let redefiningParam : Parameter = op.ownedParameter->at(i),
               redefinedParam : Parameter = self.ownedParameter->at(i) in
                 (redefiningParam.isUnique = redefinedParam.isUnique) and
                 (redefiningParam.isOrdered = redefinedParam. isOrdered) and
                 (redefiningParam.direction = redefinedParam.direction) and
                 (redefiningParam.type.conformsTo(redefinedParam.type) or
                     redefinedParam.type.conformsTo(redefiningParam.type)) and
                 (redefiningParam.direction = ParameterDirectionKind::inout implies
                         (redefinedParam.compatibleWith(redefiningParam) and
                         redefiningParam.compatibleWith(redefinedParam))) and
                 (redefiningParam.direction = ParameterDirectionKind::_'in' implies
                         redefinedParam.compatibleWith(redefiningParam)) and
                 ((redefiningParam.direction = ParameterDirectionKind::out or
                      redefiningParam.direction = ParameterDirectionKind::return) implies
                         redefiningParam.compatibleWith(redefinedParam))

)

isOrdered() : Boolean
If this operation has a return parameter, isOrdered equals the value of isOrdered for that parameter. Otherwise 
isOrdered is false.

body: if returnResult()->notEmpty() then returnResult()-> exists(isOrdered) else false endif

isUnique() : Boolean
If this operation has a return parameter, isUnique equals the value of isUnique for that parameter. Otherwise 
isUnique is true.

body: if returnResult()->notEmpty() then returnResult()->exists(isUnique) else true endif

Unified Modeling Language 2.5

141

•

•

•

•

lower() : Integer
If this operation has a return parameter, lower equals the value of lower for that parameter. Otherwise lower 
has no value.

body: if returnResult()->notEmpty() then returnResult()->any(true).lower else null endif

returnResult() : Parameter [0..*]
The query returnResult() returns the set containing the return parameter of the Operation if one exists, 
otherwise, it returns an empty set

body: ownedParameter->select (direction = ParameterDirectionKind::return)

type() : Type
If this operation has a return parameter, type equals the value of type for that parameter. Otherwise type has no 
value.

body: if returnResult()->notEmpty() then returnResult()->any(true).type else null endif

upper() : UnlimitedNatural
If this operation has a return parameter, upper equals the value of upper for that parameter. Otherwise upper 
has no value.

body: if returnResult()->notEmpty() then returnResult()->any(true).upper else null endif

9.9.11.7

Constraints

•

•

at_most_one_return
An Operation can have at most one return parameter; i.e., an owned parameter with the direction set to 'return.'

inv: self.ownedParameter->select(direction = ParameterDirectionKind::return)->size() <= 1

only_body_for_query
A bodyCondition can only be specified for a query Operation.

inv: bodyCondition <> null implies isQuery

9.9.12

9.9.12.1

OperationTemplateParameter [Class]

Description

An OperationTemplateParameter exposes an Operation as a formal parameter for a template.

9.9.12.2

Diagrams

Operations

9.9.12.3

Generalizations

TemplateParameter

9.9.12.4

Association Ends

•

142

parameteredElement : Operation [1..1]{redefines TemplateParameter::parameteredElement} (opposite 
Operation::templateParameter)
The Operation exposed by this OperationTemplateParameter.

Unified Modeling Language 2.5

9.9.12.5

Constraints

• match_default_signature

inv: default->notEmpty() implies (default.oclIsKindOf(Operation) and (let defaultOp : 
Operation = default.oclAsType(Operation) in
    defaultOp.ownedParameter->size() = parameteredElement.ownedParameter->size() and
    Sequence{1.. defaultOp.ownedParameter->size()}->forAll( ix |
        let p1: Parameter = defaultOp.ownedParameter->at(ix), p2 : Parameter = 
parameteredElement.ownedParameter->at(ix) in
          p1.type = p2.type and p1.upper = p2.upper and p1.lower = p2.lower and p1.direction 
= p2.direction and p1.isOrdered = p2.isOrdered and p1.isUnique = p2.isUnique)))

9.9.13

9.9.13.1

Parameter [Class]

Description

A Parameter is a specification of an argument used to pass information into or out of an invocation of a 
BehavioralFeature. Parameters can be treated as ConnectableElements within Collaborations.

9.9.13.2

Diagrams

Features, Operations, Object Nodes, Expressions, Behaviors

9.9.13.3

Generalizations

MultiplicityElement, ConnectableElement

9.9.13.4

Attributes

•

•

•

•

•

/default : String [0..1]
A String that represents a value to be used when no argument is supplied for the Parameter.

direction : ParameterDirectionKind [1..1] = in
Indicates whether a parameter is being sent into or out of a behavioral element.

effect : ParameterEffectKind [0..1]
Specifies the effect that executions of the owner of the Parameter have on objects passed in or out of the 
parameter.

isException : Boolean [1..1] = false
Tells whether an output parameter may emit a value to the exclusion of the other outputs.

isStream : Boolean [1..1] = false
Tells whether an input parameter may accept values while its behavior is executing, or whether an output 
parameter may post values while the behavior is executing.

9.9.13.5

Association Ends

•

♦ defaultValue : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_defaultValue_owningParameter::owningParameter)
Specifies a ValueSpecification that represents a value to be used when no argument is supplied for the 
Parameter.

Unified Modeling Language 2.5

143

•

•

operation : Operation [0..1]{subsets A_ownedParameter_ownerFormalParam::ownerFormalParam} (opposite 
Operation::ownedParameter)
The Operation owning this parameter.

parameterSet : ParameterSet [0..*] (opposite ParameterSet::parameter)
The ParameterSets containing the parameter. See ParameterSet.

9.9.13.6

Operations

•

default() : String [0..1]
Derivation for Parameter::/default

body: if self.type = String then defaultValue.stringValue() else null endif

9.9.13.7

Constraints

•

•

•

•

•

•

in_and_out
Only in and inout Parameters may have a delete effect. Only out, inout, and return Parameters may have a 
create effect.

inv: (effect = ParameterEffectKind::delete implies (direction = 
ParameterDirectionKind::_'in' or direction = ParameterDirectionKind::inout))
and
(effect = ParameterEffectKind::create implies (direction = ParameterDirectionKind::out or 
direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::return))

not_exception
An input Parameter cannot be an exception.

inv: isException implies (direction <> ParameterDirectionKind::_'in' and direction <> 
ParameterDirectionKind::inout)

connector_end
A Parameter may only be associated with a Connector end within the context of a Collaboration.

inv: end->notEmpty() implies collaboration->notEmpty()

reentrant_behaviors
Reentrant behaviors cannot have stream Parameters.

inv: (isStream and behavior <> null) implies not behavior.isReentrant

stream_and_exception
A Parameter cannot be a stream and exception at the same time.

inv: not (isException and isStream)

object_effect
Parameters typed by DataTypes cannot have an effect.

inv: (type.oclIsKindOf(DataType)) implies (effect = null)

144

Unified Modeling Language 2.5

9.9.14

9.9.14.1

ParameterDirectionKind [Enumeration]

Description

ParameterDirectionKind is an Enumeration that defines literals used to specify direction of parameters.

9.9.14.2

Diagrams

•

Features
 

 

9.9.14.3

Literals

•

•

•

•

in
Indicates that Parameter values are passed in by the caller.

inout
Indicates that Parameter values are passed in by the caller and (possibly different) values passed out to the 
caller.

out
Indicates that Parameter values are passed out to the caller.

return
Indicates that Parameter values are passed as return values back to the caller.

9.9.15

9.9.15.1

ParameterEffectKind [Enumeration]

Description

ParameterEffectKind is an Enumeration that indicates the effect of a Behavior on values passed in or out of its 
parameters.

9.9.15.2

Diagrams

•

Features
 

 

9.9.15.3

Literals

•

•

•

•

create
Indicates that the behavior creates values.

read
Indicates objects that are values of the parameter have values of their properties, or links in which they 
participate, or their classifiers retrieved during executions of the behavior.

update
Indicates objects that are values of the parameter have values of their properties, or links in which they 
participate, or their classification changed during executions of the behavior.

delete
Indicates objects that are values of the parameter do not exist after executions of the behavior are finished.

Unified Modeling Language 2.5

145

9.9.16

9.9.16.1

ParameterSet [Class]

Description

A ParameterSet designates alternative sets of inputs or outputs that a Behavior may use.

9.9.16.2

Diagrams

Features, Behaviors

9.9.16.3

Generalizations

NamedElement

9.9.16.4

Association Ends

•

•

♦ condition : Constraint [0..*]{subsets Element::ownedElement} (opposite 
A_condition_parameterSet::parameterSet)
A constraint that should be satisfied for the owner of the Parameters in an input ParameterSet to start execution 
using the values provided for those Parameters, or the owner of the Parameters in an output ParameterSet to 
end execution providing the values for those Parameters, if all preconditions and conditions on input 
ParameterSets were satisfied.

parameter : Parameter [1..*] (opposite Parameter::parameterSet)
Parameters in the ParameterSet.

9.9.16.5

Constraints

•

•

•

same_parameterized_entity
The Parameters in a ParameterSet must all be inputs or all be outputs of the same parameterized entity, and the 
ParameterSet is owned by that entity.

inv: parameter->forAll(p1, p2 | self.owner = p1.owner and self.owner = p2.owner and 
p1.direction = p2.direction)

input
If a parameterized entity has input Parameters that are in a ParameterSet, then any inputs that are not in a 
ParameterSet must be streaming. Same for output Parameters.

inv: ((parameter->exists(direction = ParameterDirectionKind::_'in')) implies
    behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::_'in' 
and p.parameterSet->isEmpty())->forAll(isStream))
    and
((parameter->exists(direction = ParameterDirectionKind::out)) implies
    behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::out 
and p.parameterSet->isEmpty())->forAll(isStream))

two_parameter_sets
Two ParameterSets cannot have exactly the same set of Parameters.

inv: parameter->forAll(parameterSet->forAll(s1, s2 | s1->size() = s2->size() implies 
s1.parameter->exists(p | not s2.parameter->includes(p))))

146

Unified Modeling Language 2.5

9.9.17

9.9.17.1

Property [Class]

Description

A Property is a StructuralFeature. A Property related by ownedAttribute to a Classifier (other than an association) 
represents an attribute and might also represent an association end. It relates an instance of the Classifier to a value or 
set of values of the type of the attribute. A Property related by memberEnd to an Association represents an end of the 
Association. The type of the Property is the type of the end of the Association. A Property has the capability of being a 
DeploymentTarget in a Deployment relationship. This enables modeling the deployment to hierarchical nodes that have 
Properties functioning as internal parts. Property specializes ParameterableElement to specify that a Property can be 
exposed as a formal template parameter, and provided as an actual parameter in a binding of a template.

9.9.17.2

Diagrams

Classifiers, Properties, Encapsulated Classifiers, Structured Classifiers, Classes, Associations, DataTypes, 
Signals, Interfaces, Profiles, Deployments, Artifacts, Link End Data, Link Object Actions

9.9.17.3

Generalizations

ConnectableElement, DeploymentTarget, StructuralFeature

9.9.17.4

Specializations

Port, ExtensionEnd

9.9.17.5

Attributes

•

•

•

•

•

aggregation : AggregationKind [1..1] = none
Specifies the kind of aggregation that applies to the Property.

/isComposite : Boolean [1..1] = false
If isComposite is true, the object containing the attribute is a container for the object or value contained in the 
attribute. This is a derived value, indicating whether the aggregation of the Property is composite or not.

isDerived : Boolean [1..1] = false
Specifies whether the Property is derived, i.e., whether its value or values can be computed from other 
information.

isDerivedUnion : Boolean [1..1] = false
Specifies whether the property is derived as the union of all of the Properties that are constrained to subset it.

isID : Boolean [1..1] = false
True indicates this property can be used to uniquely identify an instance of the containing Class.

9.9.17.6

Association Ends

•

•

association : Association [0..1]{subsets A_member_memberNamespace::memberNamespace} (opposite 
Association::memberEnd)
The Association of which this Property is a member, if any.

associationEnd : Property [0..1]{subsets Element::owner} (opposite Property::qualifier)
Designates the optional association end that owns a qualifier attribute.

Unified Modeling Language 2.5

147

•

•

•

•

•

•

•

•

•

class : Class [0..1]{subsets NamedElement::namespace, subsets 
A_ownedAttribute_structuredClassifier::structuredClassifier, subsets A_attribute_classifier::classifier} 
(opposite Class::ownedAttribute)
The Class that owns this Property, if any.

datatype : DataType [0..1]{subsets NamedElement::namespace, subsets A_attribute_classifier::classifier} 
(opposite DataType::ownedAttribute)
The DataType that owns this Property, if any.

♦ defaultValue : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_defaultValue_owningProperty::owningProperty)
A ValueSpecification that is evaluated to give a default value for the Property when an instance of the owning 
Classifier is instantiated.

interface : Interface [0..1]{subsets NamedElement::namespace, subsets A_attribute_classifier::classifier} 
(opposite Interface::ownedAttribute)
The Interface that owns this Property, if any.

/opposite : Property [0..1] (opposite A_opposite_property::property)
In the case where the Property is one end of a binary association this gives the other end.

owningAssociation : Association [0..1]{subsets Feature::featuringClassifier, subsets 
NamedElement::namespace, subsets Property::association, subsets RedefinableElement::redefinitionContext} 
(opposite Association::ownedEnd)
The owning association of this property, if any.

♦ qualifier : Property [0..*]{ordered, subsets Element::ownedElement} (opposite Property::associationEnd)
An optional list of ordered qualifier attributes for the end.

redefinedProperty : Property [0..*]{subsets RedefinableElement::redefinedElement} (opposite 
A_redefinedProperty_property::property)
The properties that are redefined by this property, if any.

subsettedProperty : Property [0..*] (opposite A_subsettedProperty_property::property)
The properties of which this Property is constrained to be a subset, if any.

9.9.17.7

Operations

•

•

148

isAttribute() : Boolean
The query isAttribute() is true if the Property is defined as an attribute of some Classifier.

body: not classifier->isEmpty()

isCompatibleWith(p : ParameterableElement) : Boolean {redefines 
ParameterableElement::isCompatibleWith()}
The query isCompatibleWith() determines if this Property is compatible with the specified 
ParameterableElement. This Property is compatible with ParameterableElement p if the kind of this Property is 
thesame as or a subtype of the kind of p. Further, if p is a TypedElement, then the type of this Property must be 
conformant with the type of p.

body: self.oclIsKindOf(p.oclType()) and (p.oclIsKindOf(TypeElement) implies
self.type.conformsTo(p.oclAsType(TypedElement).type))

Unified Modeling Language 2.5

•

•

•

•

•

isComposite() : Boolean
The value of isComposite is true only if aggregation is composite.

body: aggregation = AggregationKind::composite

isConsistentWith(redefiningElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isConsistentWith()}
The query isConsistentWith() specifies, for any two Properties in a context in which redefinition is possible, 
whether redefinition would be logically consistent. A redefining Property is consistent with a redefined 
Property if the type of the redefining Property conforms to the type of the redefined Property, and the 
multiplicity of the redefining Property (if specified) is contained in the multiplicity of the redefined Property.

pre: redefiningElement.isRedefinitionContextValid(self)
body: redefiningElement.oclIsKindOf(Property) and
  let prop : Property = redefiningElement.oclAsType(Property) in
  (prop.type.conformsTo(self.type) and
  ((prop.lowerBound()->notEmpty() and self.lowerBound()->notEmpty()) implies 
prop.lowerBound() >= self.lowerBound()) and
  ((prop.upperBound()->notEmpty() and self.upperBound()->notEmpty()) implies 
prop.lowerBound() <= self.lowerBound()) and
  (self.isComposite implies prop.isComposite))

isNavigable() : Boolean
The query isNavigable() indicates whether it is possible to navigate across the property.

body: not classifier->isEmpty() or association.navigableOwnedEnd->includes(self)

opposite() : Property
If this property is a memberEnd of a binary association, then opposite gives the other end.

body: if association <> null and association.memberEnd->size() = 2
then
    association.memberEnd->any(e | e <> self)
else
    null
endif

subsettingContext() : Type [0..*]
The query subsettingContext() gives the context for subsetting a Property. It consists, in the case of an 
attribute, of the corresponding Classifier, and in the case of an association end, all of the Classifiers at the other 
ends.

body: if association <> null
then association.memberEnd->excluding(self)->collect(type)->asSet()
else
  if classifier<>null
  then classifier->asSet()
  else Set{}
  endif
endif

9.9.17.8

Constraints

•

subsetting_context_conforms
Subsetting may only occur when the context of the subsetting property conforms to the context of the subsetted 
property.

inv: subsettedProperty->notEmpty() implies
  (subsettingContext()->notEmpty() and subsettingContext()->forAll (sc |
    subsettedProperty->forAll(sp |
      sp.subsettingContext()->exists(c | sc.conformsTo(c)))))

Unified Modeling Language 2.5

149

•

derived_union_is_read_only
A derived union is read only.

inv: isDerivedUnion implies isReadOnly

• multiplicity_of_composite

A multiplicity on the composing end of a composite aggregation must not have an upper bound greater than 1.

•

•

•

•

•

•

•

inv: isComposite and association <> null implies opposite.upperBound() <= 1

redefined_property_inherited
A redefined Property must be inherited from a more general Classifier.

inv: (redefinedProperty->notEmpty()) implies
  (redefinitionContext->notEmpty() and
      redefinedProperty->forAll(rp|
        ((redefinitionContext->collect(fc|
          fc.allParents()))->asSet())->collect(c| c.allFeatures())->asSet()->includes(rp)))

subsetting_rules
A subsetting Property may strengthen the type of the subsetted Property, and its upper bound may be less.

inv: subsettedProperty->forAll(sp |
  self.type.conformsTo(sp.type) and
    ((self.upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies
      self.upperBound() <= sp.upperBound() ))

binding_to_attribute
A binding of a PropertyTemplateParameter representing an attribute must be to an attribute.

inv: (self.isAttribute()
and (templateParameterSubstitution->notEmpty())
implies (templateParameterSubstitution->forAll(ts |
    ts.formal.oclIsKindOf(Property)
    and ts.formal.oclAsType(Property).isAttribute())))

derived_union_is_derived
A derived union is derived.

inv: isDerivedUnion implies isDerived

deployment_target
A Property can be a DeploymentTarget if it is a kind of Node and functions as a part in the internal structure of 
an encompassing Node.

inv: deployment->notEmpty() implies owner.oclIsKindOf(Node) and Node.allInstances()-
>exists(n | n.part->exists(p | p = self))

subsetted_property_names
A Property may not subset a Property with the same name.

inv: subsettedProperty->forAll(sp | sp.name <> name)

type_of_opposite_end
If a Property is a classifier-owned end of a binary Association, its owner must be the type of the opposite end.

inv: (opposite->notEmpty() and owningAssociation->isEmpty()) implies classifier = 
opposite.type

150

Unified Modeling Language 2.5

•

qualified_is_association_end
All qualified Properties must be Association ends

inv: qualifier->notEmpty() implies association->notEmpty()

9.9.18

9.9.18.1

RedefinableElement [Abstract Class]

Description

A RedefinableElement is an element that, when defined in the context of a Classifier, can be redefined more specifically 
or differently in the context of another Classifier that specializes (directly or indirectly) the context Classifier.

9.9.18.2

Diagrams

Classifiers, Classifier Templates, Features, Activities, Use Cases, State Machine Redefinition

9.9.18.3

Generalizations

NamedElement

9.9.18.4

Specializations

Classifier, Feature, RedefinableTemplateSignature, ActivityEdge, ActivityNode, ExtensionPoint, Region, 
State, Transition

9.9.18.5

Attributes

•

isLeaf : Boolean [1..1] = false
Indicates whether it is possible to further redefine a RedefinableElement. If the value is true, then it is not 
possible to further redefine the RedefinableElement.

9.9.18.6

Association Ends

•

•

/redefinedElement : RedefinableElement [0..*]{union} (opposite 
A_redefinedElement_redefinableElement::redefinableElement)
The RedefinableElement that is being redefined by this element.

/redefinitionContext : Classifier [0..*]{union} (opposite 
A_redefinitionContext_redefinableElement::redefinableElement)
The contexts that this element may be redefined from.

9.9.18.7

Operations

•

•

isConsistentWith(redefiningElement : RedefinableElement) : Boolean
The query isConsistentWith() specifies, for any two RedefinableElements in a context in which redefinition is 
possible, whether redefinition would be logically consistent. By default, this is false; this operation must be 
overridden for subclasses of RedefinableElement to define the consistency conditions.

pre: redefiningElement.isRedefinitionContextValid(self)
body: false

isRedefinitionContextValid(redefinedElement : RedefinableElement) : Boolean
The query isRedefinitionContextValid() specifies whether the redefinition contexts of this RedefinableElement 
are properly related to the redefinition contexts of the specified RedefinableElement to allow this element to 

Unified Modeling Language 2.5

151

redefine the other. By default at least one of the redefinition contexts of this element must be a specialization of 
at least one of the redefinition contexts of the specified element.

body: redefinitionContext->exists(c | c.allParents()-
>includesAll(redefinedElement.redefinitionContext))

9.9.18.8

Constraints

•

•

•

redefinition_consistent
A redefining element must be consistent with each redefined element.

inv: redefinedElement->forAll(re | re.isConsistentWith(self))

non_leaf_redefinition
A RedefinableElement can only redefine non-leaf RedefinableElements.

inv: redefinedElement->forAll(re | not re.isLeaf)

redefinition_context_valid
At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the 
redefinition contexts for each redefined element.

inv: redefinedElement->forAll(re | self.isRedefinitionContextValid(re))

9.9.19

9.9.19.1

RedefinableTemplateSignature [Class]

Description

A RedefinableTemplateSignature supports the addition of formal template parameters in a specialization of a template 
classifier.

9.9.19.2

Diagrams

Classifier Templates

9.9.19.3

Generalizations

RedefinableElement, TemplateSignature

9.9.19.4

Association Ends

•

•

•

152

classifier : Classifier [1..1]{subsets RedefinableElement::redefinitionContext, redefines 
TemplateSignature::template} (opposite Classifier::ownedTemplateSignature)
The Classifier that owns this RedefinableTemplateSignature.

extendedSignature : RedefinableTemplateSignature [0..*]{subsets RedefinableElement::redefinedElement} 
(opposite A_extendedSignature_redefinableTemplateSignature::redefinableTemplateSignature)
The signatures extended by this RedefinableTemplateSignature.

/inheritedParameter : TemplateParameter [0..*]{subsets TemplateSignature::parameter} (opposite 
A_inheritedParameter_redefinableTemplateSignature::redefinableTemplateSignature)
The formal template parameters of the extended signatures.

Unified Modeling Language 2.5

9.9.19.5

Operations

•

•

inheritedParameter() : TemplateParameter [0..*]
Derivation for RedefinableTemplateSignature::/inheritedParameter

body: if extendedSignature->isEmpty() then Set{} else extendedSignature.parameter->asSet() 
endif

isConsistentWith(redefiningElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isConsistentWith()}
The query isConsistentWith() specifies, for any two RedefinableTemplateSignatures in a context in which 
redefinition is possible, whether redefinition would be logically consistent. A redefining template signature is 
always consistent with a redefined template signature, as redefinition only adds new formal parameters.

pre: redefiningElement.isRedefinitionContextValid(self)
body: redefiningElement.oclIsKindOf(RedefinableTemplateSignature)

9.9.19.6

Constraints

•

redefines_parents
If any of the parent Classifiers are a template, then the extendedSignature must include the signature of that 
Classifier.

inv: classifier.allParents()->forAll(c | c.ownedTemplateSignature->notEmpty() implies self-
>closure(extendedSignature)->includes(c.ownedTemplateSignature))

9.9.20

9.9.20.1

Slot [Class]

Description

A Slot designates that an entity modeled by an InstanceSpecification has a value or values for a specific 
StructuralFeature.

9.9.20.2

Diagrams

Instances

9.9.20.3

Generalizations

Element

9.9.20.4

Association Ends

•

•

•

definingFeature : StructuralFeature [1..1] (opposite A_definingFeature_slot::slot)
The StructuralFeature that specifies the values that may be held by the Slot.

owningInstance : InstanceSpecification [1..1]{subsets Element::owner} (opposite InstanceSpecification::slot)
The InstanceSpecification that owns this Slot.

♦ value : ValueSpecification [0..*]{ordered, subsets Element::ownedElement} (opposite 
A_value_owningSlot::owningSlot)
The value or values held by the Slot.

Unified Modeling Language 2.5

153

9.9.21

9.9.21.1

StructuralFeature [Abstract Class]

Description

A StructuralFeature is a typed feature of a Classifier that specifies the structure of instances of the Classifier.

9.9.21.2

Diagrams

Features, Properties, Instances, Structural Feature Actions

9.9.21.3

Generalizations

MultiplicityElement, TypedElement, Feature

9.9.21.4

Specializations

Property

9.9.21.5

Attributes

•

isReadOnly : Boolean [1..1] = false
If isReadOnly is true, the StructuralFeature may not be written to after initialization.

9.9.22

9.9.22.1

Substitution [Class]

Description

A substitution is a relationship between two classifiers signifying that the substituting classifier complies with the 
contract specified by the contract classifier. This implies that instances of the substituting classifier are runtime 
substitutable where instances of the contract classifier are expected.

9.9.22.2

Diagrams

Classifiers

9.9.22.3

Generalizations

Realization

9.9.22.4

Association Ends

•

•

154

contract : Classifier [1..1]{subsets Dependency::supplier} (opposite A_contract_substitution::substitution)
The contract with which the substituting classifier complies.

substitutingClassifier : Classifier [1..1]{subsets Dependency::client, subsets Element::owner} (opposite 
Classifier::substitution)
Instances of the substituting classifier are runtime substitutable where instances of the contract classifier are 
expected.

Unified Modeling Language 2.5

9.10
9.10.1

Association Descriptions
A_attribute_classifier [Association]

9.10.1.1

Diagrams

Classifiers

9.10.1.2

Owned Ends

•

/classifier : Classifier [0..1]{union, subsets Feature::featuringClassifier, subsets 
RedefinableElement::redefinitionContext} (opposite Classifier::attribute)

9.10.2

9.10.2.1

A_bodyCondition_bodyContext [Association]

Diagrams

Operations

9.10.2.2

Owned Ends

•

bodyContext : Operation [0..1]{subsets Constraint::context} (opposite Operation::bodyCondition)

9.10.3

9.10.3.1

A_classifier_instanceSpecification [Association]

Diagrams

Instances

9.10.3.2

Specializations

A_classifier_enumerationLiteral

9.10.3.3

Owned Ends

•

instanceSpecification : InstanceSpecification [0..*] (opposite InstanceSpecification::classifier)

9.10.4

9.10.4.1

A_classifier_templateParameter_parameteredElement [Association]

Diagrams

Classifier Templates

9.10.4.2

Member Ends

 

• Classifier::templateParameter
• ClassifierTemplateParameter::parameteredElement

 

 

 

9.10.5

9.10.5.1

A_collaborationUse_classifier [Association]

Diagrams

Classifiers, Collaborations

Unified Modeling Language 2.5

155

9.10.5.2

Specializations

A_representation_classifier

9.10.5.3

Owned Ends

•

classifier : Classifier [0..1]{subsets Element::owner} (opposite Classifier::collaborationUse)

9.10.6

9.10.6.1

A_condition_parameterSet [Association]

Diagrams

Features

9.10.6.2

Owned Ends

•

parameterSet : ParameterSet [0..1]{subsets Element::owner} (opposite ParameterSet::condition)

9.10.7

9.10.7.1

A_constrainingClassifier_classifierTemplateParameter [Association]

Diagrams

Classifier Templates

9.10.7.2

Owned Ends

•

classifierTemplateParameter : ClassifierTemplateParameter [0..*] (opposite 
ClassifierTemplateParameter::constrainingClassifier)

9.10.8

9.10.8.1

A_contract_substitution [Association]

Diagrams

Classifiers

9.10.8.2

Owned Ends

•

substitution : Substitution [0..*]{subsets A_supplier_supplierDependency::supplierDependency} (opposite 
Substitution::contract)

9.10.9

9.10.9.1

A_defaultValue_owningParameter [Association]

Diagrams

Features

9.10.9.2

Owned Ends

•

owningParameter : Parameter [0..1]{subsets Element::owner} (opposite Parameter::defaultValue)

156

Unified Modeling Language 2.5

9.10.10

A_defaultValue_owningProperty [Association]

9.10.10.1

Diagrams

Properties

9.10.10.2

Owned Ends

•

owningProperty : Property [0..1]{subsets Element::owner} (opposite Property::defaultValue)

9.10.11

A_definingFeature_slot [Association]

9.10.11.1

Diagrams

Instances

9.10.11.2

Owned Ends

•

slot : Slot [0..*] (opposite Slot::definingFeature)

9.10.12

A_extendedSignature_redefinableTemplateSignature [Association]

9.10.12.1

Diagrams

Classifier Templates

9.10.12.2

Owned Ends

•

redefinableTemplateSignature : RedefinableTemplateSignature [0..*]{subsets 
A_redefinedElement_redefinableElement::redefinableElement} (opposite 
RedefinableTemplateSignature::extendedSignature)

9.10.13

A_feature_featuringClassifier [Association]

9.10.13.1

Diagrams

Classifiers, Features

9.10.13.2

Member Ends

 

• Classifier::feature
•

 

Feature::featuringClassifier
 

 

9.10.14

A_general_classifier [Association]

9.10.14.1

Diagrams

Classifiers

9.10.14.2

Owned Ends

•

classifier : Classifier [0..*] (opposite Classifier::general)

Unified Modeling Language 2.5

157

9.10.15

A_general_generalization [Association]

9.10.15.1

Diagrams

Classifiers

9.10.15.2

Owned Ends

•

generalization : Generalization [0..*]{subsets A_target_directedRelationship::directedRelationship} (opposite 
Generalization::general)

9.10.16

A_generalizationSet_generalization [Association]

9.10.16.1

Diagrams

Classifiers, Generalization Sets

9.10.16.2

Member Ends

 

• Generalization::generalizationSet
• GeneralizationSet::generalization

 

 

 

9.10.17

A_generalization_specific [Association]

9.10.17.1

Diagrams

Classifiers

9.10.17.2

Member Ends
• Classifier::generalization
• Generalization::specific

 

 

 

 

9.10.18

A_inheritedMember_inheritingClassifier [Association]

9.10.18.1

Diagrams

Classifiers

9.10.18.2

Owned Ends

•

inheritingClassifier : Classifier [0..*]{subsets A_member_memberNamespace::memberNamespace} (opposite 
Classifier::inheritedMember)

9.10.19

A_inheritedParameter_redefinableTemplateSignature [Association]

9.10.19.1

Diagrams

Classifier Templates

158

Unified Modeling Language 2.5

9.10.19.2

Owned Ends

•

redefinableTemplateSignature : RedefinableTemplateSignature [0..*]{subsets 
A_parameter_templateSignature::templateSignature} (opposite 
RedefinableTemplateSignature::inheritedParameter)

9.10.20

A_instance_instanceValue [Association]

9.10.20.1

Diagrams

Instances

9.10.20.2

Owned Ends

•

instanceValue : InstanceValue [0..*] (opposite InstanceValue::instance)

9.10.21

A_method_specification [Association]

9.10.21.1

Diagrams

Features, Behaviors

9.10.21.2

Member Ends

 

• BehavioralFeature::method
• Behavior::specification

 

 

 

9.10.22

A_operation_templateParameter_parameteredElement [Association]

9.10.22.1

Diagrams

Operations

9.10.22.2

Member Ends

 

• Operation::templateParameter
• OperationTemplateParameter::parameteredElement

 

 

 

9.10.23

A_opposite_property [Association]

9.10.23.1

Diagrams

Properties

9.10.23.2

Owned Ends

•

property : Property [0..1] (opposite Property::opposite)

Unified Modeling Language 2.5

159

9.10.24

A_ownedParameterSet_behavioralFeature [Association]

9.10.24.1

Diagrams

Features

9.10.24.2

Owned Ends

•

behavioralFeature : BehavioralFeature [0..1]{subsets NamedElement::namespace} (opposite 
BehavioralFeature::ownedParameterSet)

9.10.25

A_ownedParameter_operation [Association]

9.10.25.1

Diagrams

Operations

9.10.25.2

Member Ends

 

• Operation::ownedParameter
•

Parameter::operation
 

 

 

9.10.26

A_ownedParameter_ownerFormalParam [Association]

9.10.26.1

Diagrams

Features

9.10.26.2

Owned Ends

•

ownerFormalParam : BehavioralFeature [0..1]{subsets NamedElement::namespace} (opposite 
BehavioralFeature::ownedParameter)

9.10.27

A_ownedTemplateSignature_classifier [Association]

9.10.27.1

Diagrams

Classifier Templates

9.10.27.2

Member Ends

 

• Classifier::ownedTemplateSignature
• RedefinableTemplateSignature::classifier

 

 

 

9.10.28

A_ownedUseCase_classifier [Association]

9.10.28.1

Diagrams

Classifiers, Use Cases

160

Unified Modeling Language 2.5

9.10.28.2

Owned Ends

•

classifier : Classifier [0..1]{subsets NamedElement::namespace} (opposite Classifier::ownedUseCase)

9.10.29

A_parameterSet_parameter [Association]

9.10.29.1

Diagrams

Features

9.10.29.2

Member Ends

•

•

Parameter::parameterSet
 

 

ParameterSet::parameter
 

 

9.10.30

A_postcondition_postContext [Association]

9.10.30.1

Diagrams

Operations

9.10.30.2

Owned Ends

•

postContext : Operation [0..1]{subsets Constraint::context} (opposite Operation::postcondition)

9.10.31

A_powertypeExtent_powertype [Association]

9.10.31.1

Diagrams

Classifiers, Generalization Sets

9.10.31.2

Member Ends

 

• Classifier::powertypeExtent
 
• GeneralizationSet::powertype

 

 

9.10.32

A_precondition_preContext [Association]

9.10.32.1

Diagrams

Operations

9.10.32.2

Owned Ends

•

preContext : Operation [0..1]{subsets Constraint::context} (opposite Operation::precondition)

9.10.33

A_qualifier_associationEnd [Association]

9.10.33.1

Diagrams

Properties, Associations

Unified Modeling Language 2.5

161

9.10.33.2

Member Ends

•

•

Property::qualifier
 

 

Property::associationEnd
 
 

9.10.34

A_raisedException_behavioralFeature [Association]

9.10.34.1

Diagrams

Features

9.10.34.2

Owned Ends

•

behavioralFeature : BehavioralFeature [0..*] (opposite BehavioralFeature::raisedException)

9.10.35

A_raisedException_operation [Association]

9.10.35.1

Diagrams

Operations

9.10.35.2

Owned Ends

•

operation : Operation [0..*]{subsets A_raisedException_behavioralFeature::behavioralFeature} (opposite 
Operation::raisedException)

9.10.36

A_redefinedClassifier_classifier [Association]

9.10.36.1

Diagrams

Classifiers

9.10.36.2

Owned Ends

•

classifier : Classifier [0..*]{subsets A_redefinedElement_redefinableElement::redefinableElement} (opposite 
Classifier::redefinedClassifier)

9.10.37

A_redefinedElement_redefinableElement [Association]

9.10.37.1

Diagrams

Classifiers

9.10.37.2

Owned Ends

•

/redefinableElement : RedefinableElement [0..*]{union} (opposite RedefinableElement::redefinedElement)

9.10.38

A_redefinedOperation_operation [Association]

9.10.38.1

Diagrams

Operations

162

Unified Modeling Language 2.5

9.10.38.2

Owned Ends

•

operation : Operation [0..*]{subsets A_redefinedElement_redefinableElement::redefinableElement} (opposite 
Operation::redefinedOperation)

9.10.39

A_redefinedProperty_property [Association]

9.10.39.1

Diagrams

Properties

9.10.39.2

Owned Ends

•

property : Property [0..*]{subsets A_redefinedElement_redefinableElement::redefinableElement} (opposite 
Property::redefinedProperty)

9.10.40

A_redefinitionContext_redefinableElement [Association]

9.10.40.1

Diagrams

Classifiers

9.10.40.2

Specializations

A_redefinitionContext_transition, A_redefinitionContext_state, A_redefinitionContext_region

9.10.40.3

Owned Ends

•

/redefinableElement : RedefinableElement [0..*]{union} (opposite RedefinableElement::redefinitionContext)

9.10.41

A_representation_classifier [Association]

9.10.41.1

Diagrams

Classifiers, Collaborations

9.10.41.2

Generalizations

A_collaborationUse_classifier

9.10.41.3

Owned Ends

•

classifier : Classifier [0..1]{redefines A_collaborationUse_classifier::classifier} (opposite 
Classifier::representation)

9.10.42

A_slot_owningInstance [Association]

9.10.42.1

Diagrams

Instances

9.10.42.2

Member Ends

•

InstanceSpecification::slot
 

 

Unified Modeling Language 2.5

163

•

Slot::owningInstance
 
 

9.10.43

A_specification_owningInstanceSpec [Association]

9.10.43.1

Diagrams

Instances

9.10.43.2

Owned Ends

•

owningInstanceSpec : InstanceSpecification [0..1]{subsets Element::owner} (opposite 
InstanceSpecification::specification)

9.10.44

A_subsettedProperty_property [Association]

9.10.44.1

Diagrams

Properties

9.10.44.2

Owned Ends

•

property : Property [0..*] (opposite Property::subsettedProperty)

9.10.45

A_substitution_substitutingClassifier [Association]

9.10.45.1

Diagrams

Classifiers

9.10.45.2

Member Ends
• Classifier::substitution
 
•

 

Substitution::substitutingClassifier
 
 

9.10.46

A_type_operation [Association]

9.10.46.1

Diagrams

Operations

9.10.46.2

Owned Ends

•

operation : Operation [0..*] (opposite Operation::type)

9.10.47

A_value_owningSlot [Association]

9.10.47.1

Diagrams

Instances

9.10.47.2

Owned Ends

owningSlot : Slot [0..1]{subsets Element::owner} (opposite Slot::value)

•

164

Unified Modeling Language 2.5

10 Simple Classifiers
10.1
This clause specifies various kinds of Classifier that do not have complex internal structure.

Summary

DataTypes
Summary

10.2
10.2.1
DataTypes model Types whose instances are distinguished only by their value.

10.2.2

Abstract Syntax

Classifier

{subsets namespace,
subsets classifier}
+ datatype

DataType

0..1

{ordered, subsets attribute,
subsets ownedMember}

+ ownedAttribute

Property

*

{subsets featuringClassifier,
subsets namespace, subsets
redefinitionContext}
+ datatype

0..1

{ordered, subsets feature, subsets
redefinableElement, subsets
ownedMember}

+ ownedOperation

Operation

*

InstanceSpecification

PrimitiveType

{subsets namespace}

Enumeration

+ enumeration

{ordered, subsets
ownedMember}
+ ownedLiteral

EnumerationLiteral

1
1

*

*

+ /classifier

+ enumerationLiteral

{readOnly, redefines classifier}

{redefines instanceSpecification}

Figure 10.1  DataTypes

10.2.3

10.2.3.1

Semantics

DataTypes

A DataType is a kind of Classifier. DataType differs from Class in that instances of a DataType are identified only by 
their value. All instances of a DataType with the same value are considered to be equal instances.
If a DataType has attributes (i.e., Properties owned by it and in its namespace) it is called a structured DataType. 
Instances of a structured DataType contain attribute values matching its attributes. Instances of a structured DataType are 
considered to be equal if and only if the structure is the same and the values of the corresponding attributes are equal.

Unified Modeling Language 2.5

165

A DataType may be parameterized, bound, and used as TemplateParameters.

10.2.3.2

Primitive Types

A PrimitiveType defines a predefined DataType, without any substructure. A PrimitiveType may have algebra and 
operations defined outside of UML, for example, mathematically. The run-time instances of a PrimitiveType are values 
that correspond to mathematical elements defined outside of UML (for example, the Integers).

10.2.3.3

Enumerations

Enumeration is a kind of DataType. Each value of an Enumeration corresponds to one of its user-defined 
EnumerationLiterals.
As a specialization of Classifier, Enumerations can participate in generalization relationships. An Enumeration that 
specializes another may define new EnumerationLiterals that are not defined in the generalizing Enumeration; in such a 
case the set of applicable literals comprises inherited literals plus locally-defined ones.
An EnumerationLiteral defines an element of the run-time extension of an Enumeration. Values corresponding to 
EnumerationLiterals are immutable and may be compared for equality. EnumerationLiterals may not change during 
their existence, so any attributes on an Enumeration shall be read-only.
An EnumerationLiteral has a name that shall be used to identify it within its Enumeration. The EnumerationLiteral 
name is scoped within and shall be unique within its Enumeration. EnumerationLiteral names shall be qualified for 
general use.

Notation

10.2.4
A DataType is designated using the Classifier notation (a rectangle) with keyword «dataType» or, when it is referenced 
(e.g., by an attribute), by the name of the DataType. A compartment listing the attributes is placed below the name 
compartment. A compartment listing the Operations is placed below the attribute compartment.
A PrimitiveType is similarly designated with the keyword «primitive» above or before the name of the PrimitiveType.
An Enumeration is similarly designated. The name of the Enumeration is placed in the upper compartment with the 
keyword «enumeration» above or before the name. A list of EnumerationLiterals may be placed, one to a line, in a 
compartment named “literals” below the operations compartment. The attributes and operations compartments may be 
suppressed, and typically are suppressed and empty.

Examples

10.2.5
Figure 10.2 illustrates the notation for defining a PrimitiveType.

«primitive»
Integer

Figure 10.2  PrimitiveType Notation

Figure 10.3 illustrates the notation for defining DataTypes. The FullName type defined on the left is used as the type of 
the fullName attribute in the Person type defined on the right.

«dataType»
FullName

firstName : String
secondName : String
initial : String

«dataType»

Person

fullName : FullName

Figure 10.3  DataType Notation

166

Unified Modeling Language 2.5

Figure 10.4 illustrates the notation for defining Enumerations.

«enumeration»
VisibilityKind
public
private
protected
package

Figure 10.4  Enumeration Notation

Signals
Summary

10.3
10.3.1
Signals and Receptions are used to model asynchronous communication between objects.

10.3.2

Abstract Syntax

Classifier

BehavioralFeature

Signal

+ signal

+ reception

Reception

1

*

{subsets namespace,
subsets classifier}

0..1 + owningSignal

{ordered, subsets attribute,
subsets ownedMember}

*

+ ownedAttribute

Property

Figure 10.5  Signals

10.3.3

10.3.3.1

Semantics

Signals

A Signal is a specification of a kind of communication between objects in which a reaction is asynchronously triggered 
in the receiver without a reply. The receiving object handles Signals as specified by clause 13.3. The data carried by the 
communication are represented as attributes of the Signal. A Signal is defined independently of the Classifiers handling 
it.
The sender of a Signal will not block waiting for a reply but continue execution immediately. By declaring a Reception 
associated to a given Signal, a Classifier specifies that its instances will be able to receive that Signal, or a subtype 
thereof, and will respond to it with the designated Behavior.
A Signal may be parameterized, bound, and used as TemplateParameters.

10.3.3.2

Receptions

A Reception specifies that its owning Class or Interface is prepared to react to the receipt of a Signal. A Reception 
matches a Signal if the received Signal is a specialization of the Reception’s signal. The details of how the object 

Unified Modeling Language 2.5

167

responds to the received Signal depend on the kind of Behavior associated with the Reception and its owning Class or 
Interface. See 13.2. The name of the Reception is the same as the name of the Signal. A Reception may only have in 
Parameters (see 9.4.3) that match the attributes of the Signal by name, type, and multiplicity.

Notation

10.3.4
A Signal is depicted by a Classifier symbol with the keyword «signal».
Receptions are shown in the receptions compartment using the same notation as for Operations with the keyword 
«signal».

Examples

10.3.5
Figure 10.6 shows an interface IAlarm that defines two Receptions, each referring to a Signal also shown in the 
example.
NOTE. The name of the Reception matches the name of the Signal, and the parameter of the Reception matches the 
attribute of the Signal.

«interface»

IAlarm

«signal» Notify()
«signal» Activate()

Figure 10.6  Reception Notation

«signal»
Notify

«signal»
Activate

Interfaces
Summary

10.4
10.4.1
Interfaces declare coherent services that are implemented by BehavioredClassifiers that implement the Interfaces via 
InterfaceRealizations.

168

Unified Modeling Language 2.5

10.4.2

Abstract Syntax

Property

Operation

Reception

{ordered, subsets attribute, subsets
ownedMember}
+ ownedAttribute
*

{ordered, subsets feature, subsets
redefinableElement, subsets
ownedMember}
+ ownedOperation
*

{subsets feature, subsets
ownedMember}
+ ownedReception
*

{subsets namespace,
subsets classifier}

+ interface
0..1

{subsets featuringClassifier,
subsets namespace, subsets
redefinitionContext}

+ interface

0..1

{subsets featuringClassifier,
subsets namespace}

+ interface

0..1

BehavioredClassifier

{subsets client, subsets owner}
+ implementingClassifier
1

{subsets supplierDependency}

+ interfaceRealization

*

{redefines behavioredClassifier}
+ behavioredClassifier

{subsets ownedBehavior}
+ classifierBehavior

0..1

0..1

{subsets namespace}
0..1 + behavioredClassifier

{subsets ownedMember}

* + ownedBehavior

Behavior

Figure 10.7  Interfaces

10.4.3

10.4.3.1

Semantics

Interfaces

Classifier

Interface

{ordered, subsets redefinableElement,
subsets ownedMember}
+ nestedClassifier

*

{subsets namespace, subsets
redefinitionContext}
+ interface

0..1

{subsets ownedMember}

+ protocol

0..1
+ interface
{subsets namespace}

ProtocolStateMachine

0..1

{subsets redefinedClassifier}

+ redefinedInterface
*
{subsets classifier}
+ interface
*

{subsets supplier}

1 + contract

{subsets ownedElement,
subsets clientDependency}

* + interfaceRealization

InterfaceRealization

Realization

An Interface is a kind of Classifier that represents a declaration of a set of public Features and obligations that together 
constitute a coherent service. An Interface specifies a contract; any instance of a Classifier that realizes the Interface 
shall fulfill that contract. The obligations associated with an Interface are in the form of constraints (such as pre- and 
postconditions) or protocol specifications, which may impose ordering restrictions on interactions through the Interface.
Interfaces may not be instantiated. Instead, an Interface specification is implemented or realized by a 
BehavioredClassifier, which means that the BehavioredClassifier presents a public facade that conforms to the Interface 
specification.
NOTE. A given BehavioredClassifier may implement more than one Interface and that an Interface may be 
implemented by a number of different BehavioredClassifiers.
Interfaces provide a way to partition and characterize groups of public Features and obligations that realizing 
BehavioredClassifiers shall possess. An Interface does not specify how it is to be implemented, but merely what needs 
to be supported by realizing BehavioredClassifiers. That is, such BehavioredClassifiers shall provide a public façade 
consisting of attributes, Operations, and externally observable Behavior that conforms to the Interface.
NOTE. If an Interface declares an attribute, this does not necessarily mean that the realizing BehavioredClassifier will 
necessarily have such an attribute in its implementation, but only that it will appear so to external observers.
The set of Interfaces realized by a BehavioredClassifier are its provided Interfaces, which represent the services and 
obligations that instances of that BehavioredClassifier offer to their clients. Interfaces may also be used to specify 
required Interfaces, which are specified by a Usage dependency between the BehavioredClassifier and the 
corresponding Interfaces. Required Interfaces specify services that a BehavioredClassifier needs in order to perform its 
function and fulfill its own obligations to its clients.

Unified Modeling Language 2.5

169

Properties owned by Interfaces (including Association ends) imply that the realizing BehavioredClassifier should 
maintain information corresponding to the type and multiplicity of the Property and facilitate retrieval and modification 
of that information. A Property declared on an Interface does not necessarily imply that there will be such a Property on 
a realizing BehavioredClassifier (e.g., it may be realized by equivalent get and set Operations). Interfaces may also own 
constraints that impose constraints on the Features of the implementing BehavioredClassifier.
Interfaces may own a ProtocolStateMachine that specifies event sequences and pre/post conditions for the Operations 
and Receptions described by the Interface. A BehavioredClassifier realizing an Interface shall comply with the 
ProtocolStateMachine owned by the Interface.
An Interface may be parameterized, bound, and used as TemplateParameters.
An InterfaceRealization relationship between a BehavioredClassifier and an Interface implies that the 
BehavioredClassifier conforms to the contract specified by the Interface by supporting the set of Features owned by the 
Interface, and any of its parent Interfaces. For BehavioralFeatures, the implementing BehavioredClassifier will have an 
Operation or Reception for every Operation or Reception, respectively, defined by the Interface. For Properties, the 
realizing BehavioredClassifier will provide functionality that maintains the state represented by the Property. While 
such may be done by direct mapping to a Property of the realizing BehavioredClassifier, it may also be supported by the 
StateMachine of the BehavioredClassifier or by a pair of Operations that support the retrieval of the state information 
and an Operation that changes the state information.

Notation

10.4.4
An Interface may be designated using the default notation for Classifier (see 9.2.4) with the keyword «interface».
Alternatively an InterfaceRealization dependency from a BehavioredClassifier to an Interface may be shown by 
representing the Interface by a circle or ball, often also called lollipop, labeled with the name of the Interface, attached 
by a solid line to the BehavioredClassifier that realizes this Interface.
The Usage dependency from a Classifier to an Interface is shown by representing the Interface by a half-circle or  socket,
labeled with the name of the Interface, attached by a solid line to the Classifier that requires this Interface.
Interfaces inherited from a generalization of the BehavioredClassifier may be notated on a diagram through a lollipop. 
These Interfaces are indicated on the diagram by preceding the name of the Interface by a caret symbol. Earlier versions 
of UML permitted a forward slash preceding the name to indicate inherited Interfaces; this notation is permitted but 
discouraged.
If a Dependency is wired from a Usage to an InterfaceRealization that are represented using a socket and a lollipop, the 
dependency arrow may be shown joining the socket to the lollipop

Examples

10.4.5
The InterfaceRealization dependency from ProximitySensor to ISensor is shown using ball (lollipop) notation (see
Figure 10.8).

ProximitySensor

ISensor

Figure 10.8  ISensor is a provided Interface of ProximitySensor

Figure 10.9 shows the lollipop notation for an inherited provided interface.

170

Unified Modeling Language 2.5

ProximitySensor

CapacitiveSensor

^ ISensor

Figure 10.9  ISensor, a provided Interface of ProximitySensor, is shown as inherited by CapacitiveSensor

The Usage dependency from TheftAlarm to ISensor is shown using socket notation (see Figure 10.10).

TheftAlarm

Text

...

Text

Figure 10.10  ISensor is a required Interface of TheftAlarm

Alternatively, in cases where Interfaces are represented using the rectangle notation, InterfaceRealization and Usage 
dependencies are denoted with appropriate dependency arrows (see Figure 10.11). The Classifier at the tail of the arrow 
implements the Interface at the head of the arrow or uses that Interface, respectively.

TheftAlarm

«use»

«interface»
ISensor
activate ( )
read ( )

ProximitySensor

Figure 10.11  Alternative notation for required and provided Interface

It is often the case in practice that two or more Interfaces are mutually coupled through application-specific 
dependencies. In such situations, each Interface represents a specific role in a multi-party “protocol.” These types of 
protocol role couplings may be captured by Associations between Interfaces as shown in the example in Figure 10.12. 
This shows the specification of three Interfaces, IAlarm, ISensor, and IBuzzer. IAlarm and ISensor are shown as 
engaged in a bidirectional protocol, meaning that any implementation of ISensor must maintain the information needed 
to realize the theAlarm property, and similarly for IAlarm and theSensor. IBuzzer describes an Interface that implementers 
of IAlarm must be able to access.

«interface»
IBuzzer

volume : Integer
start ( )
reset ( )

1

*

+ theBuzzer

«interface»

IAlarm

notify ( )

+ theAlarm

+ theSensor

1

1

«interface»
ISensor
activate ( )
read ( )

Figure 10.12  A set of collaborating Interfaces

Unified Modeling Language 2.5

171

10.5
10.5.1

Classifier Descriptions
BehavioredClassifier [Abstract Class]

10.5.1.1

Description

A BehavioredClassifier may have InterfaceRealizations, and owns a set of Behaviors one of which may specify the 
behavior of the BehavioredClassifier itself.

10.5.1.2

Diagrams

Interfaces, Use Cases, Classes, Collaborations, Behaviors

10.5.1.3

Generalizations

Classifier

10.5.1.4

Specializations

Actor, UseCase, Class, Collaboration

10.5.1.5

Association Ends

•

•

•

classifierBehavior : Behavior [0..1]{subsets BehavioredClassifier::ownedBehavior} (opposite 
A_classifierBehavior_behavioredClassifier::behavioredClassifier)
A Behavior that specifies the behavior of the BehavioredClassifier itself.

♦ interfaceRealization : InterfaceRealization [0..*]{subsets Element::ownedElement, subsets 
NamedElement::clientDependency} (opposite InterfaceRealization::implementingClassifier)
The set of InterfaceRealizations owned by the BehavioredClassifier. Interface realizations reference the 
Interfaces of which the BehavioredClassifier is an implementation.

♦ ownedBehavior : Behavior [0..*]{subsets Namespace::ownedMember} (opposite 
A_ownedBehavior_behavioredClassifier::behavioredClassifier)
Behaviors owned by a BehavioredClassifier.

10.5.1.6

Constraints

•

class_behavior
If a behavior is classifier behavior, it does not have a specification.

inv: classifierBehavior->notEmpty() implies classifierBehavior.specification->isEmpty()

10.5.2

10.5.2.1

DataType [Class]

Description

A DataType is a type whose instances are identified only by their value.

10.5.2.2

Diagrams

DataTypes, Properties, Operations

10.5.2.3

Generalizations

Classifier

172

Unified Modeling Language 2.5

10.5.2.4

Specializations

Enumeration, PrimitiveType

10.5.2.5

Association Ends

•

•

♦ ownedAttribute : Property [0..*]{ordered, subsets Classifier::attribute, subsets Namespace::ownedMember} 
(opposite Property::datatype)
The attributes owned by the DataType.

♦ ownedOperation : Operation [0..*]{ordered, subsets Classifier::feature, subsets 
A_redefinitionContext_redefinableElement::redefinableElement, subsets Namespace::ownedMember} 
(opposite Operation::datatype)
The Operations owned by the DataType.

10.5.3

10.5.3.1

Enumeration [Class]

Description

An Enumeration is a DataType whose values are enumerated in the model as EnumerationLiterals.

10.5.3.2

Diagrams

DataTypes

10.5.3.3

Generalizations

DataType

10.5.3.4

Association Ends

•

♦ ownedLiteral : EnumerationLiteral [0..*]{ordered, subsets Namespace::ownedMember} (opposite 
EnumerationLiteral::enumeration)
The ordered set of literals owned by this Enumeration.

10.5.3.5

Constraints

•

immutable

inv: ownedAttribute->forAll(isReadOnly)

10.5.4

10.5.4.1

EnumerationLiteral [Class]

Description

An EnumerationLiteral is a user-defined data value for an Enumeration.

10.5.4.2

Diagrams

DataTypes

10.5.4.3

Generalizations

InstanceSpecification

Unified Modeling Language 2.5

173

10.5.4.4

Association Ends

•

•

/classifier : Enumeration [1..1]{redefines InstanceSpecification::classifier} (opposite 
A_classifier_enumerationLiteral::enumerationLiteral)
The classifier of this EnumerationLiteral derived to be equal to its Enumeration.

enumeration : Enumeration [1..1]{subsets NamedElement::namespace} (opposite Enumeration::ownedLiteral)
The Enumeration that this EnumerationLiteral is a member of.

10.5.4.5

Operations

•

classifier() : Enumeration
Derivation of Enumeration::/classifier

body: enumeration

10.5.5

10.5.5.1

Interface [Class]

Description

Interfaces declare coherent services that are implemented by BehavioredClassifiers that implement the Interfaces via 
InterfaceRealizations.

10.5.5.2

Diagrams

Interfaces, Encapsulated Classifiers, Components, Properties, Operations

10.5.5.3

Generalizations

Classifier

10.5.5.4

Association Ends

•

•

•

•

•

♦ nestedClassifier : Classifier [0..*]{ordered, subsets 
A_redefinitionContext_redefinableElement::redefinableElement, subsets Namespace::ownedMember} 
(opposite A_nestedClassifier_interface::interface)
References all the Classifiers that are defined (nested) within the Interface.

♦ ownedAttribute : Property [0..*]{ordered, subsets Classifier::attribute, subsets Namespace::ownedMember} 
(opposite Property::interface)
The attributes (i.e., the Properties) owned by the Interface.

♦ ownedOperation : Operation [0..*]{ordered, subsets Classifier::feature, subsets 
A_redefinitionContext_redefinableElement::redefinableElement, subsets Namespace::ownedMember} 
(opposite Operation::interface)
The Operations owned by the Interface.

♦ ownedReception : Reception [0..*]{subsets Classifier::feature, subsets Namespace::ownedMember} 
(opposite A_ownedReception_interface::interface)
Receptions that objects providing this Interface are willing to accept.

♦ protocol : ProtocolStateMachine [0..1]{subsets Namespace::ownedMember} (opposite 
A_protocol_interface::interface)

174

Unified Modeling Language 2.5

References a ProtocolStateMachine specifying the legal sequences of the invocation of the BehavioralFeatures 
described in the Interface.

•

redefinedInterface : Interface [0..*]{subsets Classifier::redefinedClassifier} (opposite 
A_redefinedInterface_interface::interface)
References all the Interfaces redefined by this Interface.

10.5.5.5

Constraints

•

visibility
The visibility of all Features owned by an Interface must be public.

inv: feature->forAll(visibility = VisibilityKind::public)

10.5.6

10.5.6.1

InterfaceRealization [Class]

Description

An InterfaceRealization is a specialized realization relationship between a BehavioredClassifier and an Interface. This 
relationship signifies that the realizing BehavioredClassifier conforms to the contract specified by the Interface.

10.5.6.2

Diagrams

Interfaces

10.5.6.3

Generalizations

Realization

10.5.6.4

Association Ends

•

•

contract : Interface [1..1]{subsets Dependency::supplier} (opposite 
A_contract_interfaceRealization::interfaceRealization)
References the Interface specifying the conformance contract.

implementingClassifier : BehavioredClassifier [1..1]{subsets Dependency::client, subsets Element::owner} 
(opposite BehavioredClassifier::interfaceRealization)
References the BehavioredClassifier that owns this InterfaceRealization, i.e., the BehavioredClassifier that 
realizes the Interface to which it refers.

10.5.7

10.5.7.1

PrimitiveType [Class]

Description

A PrimitiveType defines a predefined DataType, without any substructure. A PrimitiveType may have an algebra and 
operations defined outside of UML, for example, mathematically.

10.5.7.2

Diagrams

DataTypes

10.5.7.3

Generalizations

DataType

Unified Modeling Language 2.5

175

10.5.8

10.5.8.1

Reception [Class]

Description

A Reception is a declaration stating that a Classifier is prepared to react to the receipt of a Signal.

10.5.8.2

Diagrams

Signals, Interfaces, Classes

10.5.8.3

Generalizations

BehavioralFeature

10.5.8.4

Association Ends

•

signal : Signal [1..1] (opposite A_signal_reception::reception)
The Signal that this Reception handles.

10.5.8.5

Constraints

•

•

same_name_as_signal
A Reception has the same name as its signal

inv: name = signal.name

same_structure_as_signal
A Reception's parameters match the ownedAttributes of its signal by name, type, and multiplicity

inv: signal.ownedAttribute->size() = ownedParameter->size() and
Sequence{1..signal.ownedAttribute->size()}->forAll( i |
    ownedParameter->at(i).direction = ParameterDirectionKind::_'in' and
    ownedParameter->at(i).name = signal.ownedAttribute->at(i).name and
    ownedParameter->at(i).type = signal.ownedAttribute->at(i).type and
    ownedParameter->at(i).lowerBound() = signal.ownedAttribute->at(i).lowerBound() and
    ownedParameter->at(i).upperBound() = signal.ownedAttribute->at(i).upperBound()
)

10.5.9

10.5.9.1

Signal [Class]

Description

A Signal is a specification of a kind of communication between objects in which a reaction is asynchronously triggered 
in the receiver without a reply.

10.5.9.2

Diagrams

Signals, Events, Invocation Actions

10.5.9.3

Generalizations

Classifier

10.5.9.4

Association Ends

•

176

♦ ownedAttribute : Property [0..*]{ordered, subsets Classifier::attribute, subsets Namespace::ownedMember} 
(opposite A_ownedAttribute_owningSignal::owningSignal)
The attributes owned by the Signal.

Unified Modeling Language 2.5

10.6
10.6.1

Association Descriptions
A_classifierBehavior_behavioredClassifier [Association]

10.6.1.1

Diagrams

Interfaces, Behaviors

10.6.1.2

Generalizations

A_ownedBehavior_behavioredClassifier

10.6.1.3

Owned Ends

•

behavioredClassifier : BehavioredClassifier [0..1]{redefines 
A_ownedBehavior_behavioredClassifier::behavioredClassifier} (opposite 
BehavioredClassifier::classifierBehavior)

10.6.2

10.6.2.1

A_classifier_enumerationLiteral [Association]

Diagrams

DataTypes

10.6.2.2

Generalizations

A_classifier_instanceSpecification

10.6.2.3

Owned Ends

•

enumerationLiteral : EnumerationLiteral [0..*]{redefines 
A_classifier_instanceSpecification::instanceSpecification} (opposite EnumerationLiteral::classifier)

10.6.3

10.6.3.1

A_contract_interfaceRealization [Association]

Diagrams

Interfaces

10.6.3.2

Owned Ends

•

interfaceRealization : InterfaceRealization [0..*]{subsets 
A_supplier_supplierDependency::supplierDependency} (opposite InterfaceRealization::contract)

10.6.4

10.6.4.1

A_interfaceRealization_implementingClassifier [Association]

Diagrams

Interfaces

10.6.4.2

Member Ends

• BehavioredClassifier::interfaceRealization

 

 

Unified Modeling Language 2.5

177

•

InterfaceRealization::implementingClassifier
 

 

10.6.5

10.6.5.1

A_nestedClassifier_interface [Association]

Diagrams

Interfaces

10.6.5.2

Owned Ends

•

interface : Interface [0..1]{subsets NamedElement::namespace, subsets 
RedefinableElement::redefinitionContext} (opposite Interface::nestedClassifier)

10.6.6

10.6.6.1

A_ownedAttribute_datatype [Association]

Diagrams

DataTypes, Properties

10.6.6.2

Member Ends

 

• DataType::ownedAttribute
•

Property::datatype
 

 

 

10.6.7

10.6.7.1

A_ownedAttribute_interface [Association]

Diagrams

Interfaces, Properties

10.6.7.2

Member Ends

•

•

Interface::ownedAttribute
 

 

Property::interface
 

 

10.6.8

10.6.8.1

A_ownedAttribute_owningSignal [Association]

Diagrams

Signals

10.6.8.2

Owned Ends

•

owningSignal : Signal [0..1]{subsets NamedElement::namespace, subsets A_attribute_classifier::classifier} 
(opposite Signal::ownedAttribute)

10.6.9

10.6.9.1

A_ownedBehavior_behavioredClassifier [Association]

Diagrams

Interfaces, Behaviors

178

Unified Modeling Language 2.5

10.6.9.2

Specializations

A_classifierBehavior_behavioredClassifier

10.6.9.3

Owned Ends

•

behavioredClassifier : BehavioredClassifier [0..1]{subsets NamedElement::namespace} (opposite 
BehavioredClassifier::ownedBehavior)

10.6.10

A_ownedLiteral_enumeration [Association]

10.6.10.1

Diagrams

DataTypes

10.6.10.2

Member Ends

•

•

Enumeration::ownedLiteral
 

 

EnumerationLiteral::enumeration
 

 

10.6.11

A_ownedOperation_datatype [Association]

10.6.11.1

Diagrams

DataTypes, Operations

10.6.11.2

Member Ends

 

• DataType::ownedOperation
• Operation::datatype

 

 

 

10.6.12

A_ownedOperation_interface [Association]

10.6.12.1

Diagrams

Interfaces, Operations

10.6.12.2

Member Ends

•

Interface::ownedOperation
 

 

• Operation::interface

 

 

10.6.13

A_ownedReception_interface [Association]

10.6.13.1

Diagrams

Interfaces

Unified Modeling Language 2.5

179

10.6.13.2

Owned Ends

•

interface : Interface [0..1]{subsets Feature::featuringClassifier, subsets NamedElement::namespace} (opposite 
Interface::ownedReception)

10.6.14

A_protocol_interface [Association]

10.6.14.1

Diagrams

Interfaces

10.6.14.2

Owned Ends

•

interface : Interface [0..1]{subsets NamedElement::namespace} (opposite Interface::protocol)
Specifies the namespace in which the protocol state machine is defined.

10.6.15

A_redefinedInterface_interface [Association]

10.6.15.1

Diagrams

Interfaces

10.6.15.2

Owned Ends

•

interface : Interface [0..*]{subsets A_redefinedClassifier_classifier::classifier} (opposite 
Interface::redefinedInterface)

10.6.16

A_signal_reception [Association]

10.6.16.1

Diagrams

Signals

10.6.16.2

Owned Ends

•

reception : Reception [0..*] (opposite Reception::signal)

180

Unified Modeling Language 2.5

Structured Classifiers
Summary

11
11.1
StructuredClassifiers are Classifiers that may have an internal structure comprising a network of linked roles (which can 
themselves be instances of structured classifiers) and an external structure consisting of one or more Ports. The Ports of 
EncapsulatedClassifiers act as local agents of remote collaborators, allowing EncapsulatedClassifiers to differentiate 
between them but without being directly coupled to them. Classes, Components, Associations and Collaborations are 
concrete metaclasses that use these capabilities.

Structured Classifiers
Summary

11.2
11.2.1
StructuredClassifiers may contain an internal structure of connected elements each of which plays a  role in the overall 
behavior modeled by the StructuredClassifier. It may be helpful to read this sub clause in conjunction with sub clause
11.5 - Associations.

11.2.2

Abstract Syntax

Classifier

ParameterableElement

TypedElement

StructuredClassifier

{readOnly, union, subsets
memberNamespace}
+ /structuredClassifier

*

{readOnly, union,
subsets member}
+ /role

*

ConnectableElement

1

TemplateParameter

ConnectableElementTemplateParameter

{redefines
parameteredElement}
+ parameteredElement

{redefines templateParameter}

0..1 + templateParameter

+ role

1

{readOnly}
+ /definingEnd

0..1

+ connectorEnd

*

{readOnly}
+ /end

*

{subsets owner}
+ connector

{ordered, subsets
ownedElement}
+ end

1

2..*

ConnectorEnd

{subsets namespace,
subsets classifier, redefines
structuredClassifier}

+ structuredClassifier

{ordered, subsets attribute,
subsets role, subsets
ownedMember}
+ ownedAttribute

Property

0..1

+ structuredClassifier

0..1

*

{readOnly}
+ /part

*

{subsets featuringClassifier,
subsets namespace, subsets
redefinitionContext}

+ structuredClassifier

{subsets feature, subsets
redefinableElement, subsets
ownedMember}
+ ownedConnector

Feature

Connector

0..1

*

+ /kind : ConnectorKind {readOnly}

{subsets redefinableElement}
+ connector

*

«enumeration»
ConnectorKind
assembly
delegation

*

+ connector

*

+ connector

*

MultiplicityElement

+ redefinedConnector

{subsets redefinedElement}

+ type

0..1

Association

+ contract

*

Behavior

Figure 11.1  Structured Classifiers

Unified Modeling Language 2.5

181

11.2.3

11.2.3.1

Semantics

Connectable Elements

ConnectableElement is an abstract metaclass. Each ConnectableElement represents a participant within the internal 
structure of a StructuredClassifier; these participants are called roles. Roles may be joined by Connectors, and specify 
configurations of linked instances contained or referenced within an instance of the containing StructuredClassifier.
The detailed semantics of ConnectableElement is given by its concrete subtypes. In general, each ConnectableElement 
exhibits a set of effective required Interfaces and a set of effective provided Interfaces. These sets are used to determine 
the connectability of ConnectableElements using Connectors, see below.
For ConnectableElements except delegating Ports (see 11.3.3) the effective required Interfaces are the required 
Interfaces, and the effective provided Interfaces are the provided Interfaces, derived as follows:

The provided Interfaces comprises the union of the sets of Interfaces realized by the type of the 
ConnectableElement and its supertypes, or the set containing just its type if it is typed by an Interface.
The required Interfaces comprises the union of the sets of Interfaces used by the type of the 
ConnectableElement and its supertypes.

•

•

A ConnectableElement may be exposed via a ConnectableElementTemplateParameter as a formal parameter for a 
template. The semantics and notation for this are only defined when the ConnectableElement is a Property (see the 
semantics and notation for Property in 9.5).

11.2.3.2

Parts and Roles

The Properties of a StructuredClassifier obey the semantics of Property specified in 9.5.
Property is a kind of ConnectableElement. All of the ownedAttributes of a StructuredClassifier are roles and can be 
connected using Connectors.
Those ownedAttributes of a StructuredClassifier that have isComposite = true (see 9.5.3) are called its parts. Hence parts 
constitute a subset of roles.

11.2.3.3

Connectors

A Connector specifies links (see 11.5 Associations) between two or more instances playing owned or inherited roles 
within a StructuredClassifier. Each link may be realized by something as simple as a pointer or by something as 
complex as a network connection, and may represent the possibility of instances being able to communicate because 
their identities are known by virtue of being passed in as parameters, held in variables or slots, or even because the 
communicating instances are the same instance.
In contrast to Associations, which specify links between any suitably-typed instance of the associated Classifiers, 
Connectors specify links between instances playing the connected roles only.
Each Connector may be attached to two or more ConnectableElements, each representing a set of instances that 
contribute to the instantiation of the containing StructuredClassifier.
A ConnectorEnd is an endpoint of a Connector, which attaches the Connector to a ConnectableElement.
Links corresponding to Connectors may be created upon the creation of the instance of the containing 
StructuredClassifier. All such links are destroyed when the containing StructuredClassifier instance is destroyed.
A Connector may be typed by an Association, in which case the links specified by the Connector are instances of the 
typing Association.
Each feature of each of the effective required Interfaces of each ConnectableElement at the end of a Connector must 
have at least one compatible feature among the features of the effective provided Interfaces of ConnectableElements at 
the other ends. One feature is compatible with another at least in the cases when the two features are the same or when 

182

Unified Modeling Language 2.5

they are both properties or operations and the second feature is a redefinition of the first. However, conforming tools 
may allow additional cases of compatible features beyond this.
When there are multiple connectors attached to a single ConnectableElement, the semantics are the same as a single n-
ary Connector connecting the ConnectableElement to all of the ConnectableElements connected via the multiple 
connectors.
Connectors have a kind, whose value is assembly or delegation. The semantics of delegation connectors are only related 
to Ports and described under Port (see 11.3). All other Connectors are assembly connectors.
ConnectorKind is an enumeration of the following literal values:

assembly
delegation

Indicates that the Connector is an assembly Connector.
Indicates that the Connector is a delegation Connector.

Behaviors may be associated with Connectors as contracts to specify valid interaction patterns across the Connector.

11.2.3.4

Multiplicities and topologies

The multiplicities on ConnectableElements constrain the number of objects that may be created within an instance of 
the containing StructuredClassifier, according to the semantics of MultiplicityElement (see 7.5.3).
For a binary Connector, the ConnectorEnd’s multiplicity indicates the number of instances that may be linked to each 
instance of the ConnectableElement on the other end. For an n-ary Connector, the multiplicity of one end constrains the 
number of links that may refer to a set containing one particular instance for each of the other ends.
When an instance is removed from a role of an instance of a StructuredClassifier, links that exist due to Connectors 
between that role and others are destroyed.
The topologies that result from matching the multiplicities of ConnectorEnds and those of ConnectableElements they 
interconnect cannot always be deduced from the model. Specific examples in which the topology can be determined 
from the multiplicities are shown in Figure 11.6 and Figure 11.7.

Notation

11.2.4
The internal structure of a StructuredClassifier is shown in a separate compartment with the name “internal structure.” 
This compartment is mandatory: all tools that conform to the concrete syntax of UML must implement it. The internal 
structure compartment contains symbols representing the roles and connectors. The internal structure compartment 
appears below the attributes and operations compartments.
A part may be shown by graphical nesting of a box symbol with a solid outline representing the part within the internal 
structure compartment. A role that is not a composition may be shown by graphical nesting of a box symbol with a 
dashed outline. In either case the box may be called a part box, even though strictly-speaking only the compositions are 
parts. Lollipop and socket symbols may optionally be shown to indicate the provided and required interfaces of the part, 
using the same notation as for the definition of the part’s type (see 10.4.4).
The part box symbol has a name compartment, which contains a string according to the syntax defined in sub clause 
9.5.4. Detail may also be shown within the part box indicating specific values for Properties of the part’s type when 
instances corresponding to the Property are created.
The multiplicity for a Property may also be shown as a multiplicity mark in the top right corner of the part box.
When a role is typed by an EncapsulatedClassifier (see 11.3), any Ports of the type may also be shown as small square 
symbols overlapping the boundary of the part box denoting the role. The name of the Port is shown near the Port; the 
multiplicity follows the name surrounded by square brackets. Name and multiplicity may be elided. Lollipop and socket 
symbols may optionally be shown to indicate the provided and required interfaces of the Port, using the same notation 
as for the Port’s definition (see 11.3.4).

Unified Modeling Language 2.5

183

If a role is typed by a classifier other than Class, the name compartment of the part box symbol contains the appropriate 
keyword (e.g., «component») above the name. For some kinds of Classifiers, optionally in the right hand corner an icon 
denoting the kind of Classifier can be displayed.
A Connector is drawn using similar notation to that for Association (see 11.5.4). The optional name string of the 
Connector obeys the following syntax:

<connector> ::= ( [<name> ] ’:’ <associationname> ) | ([<name> ] ’:’ <associationclassname> ) | 
[<name> ]

where <name> is the name of the Connector, and <associationname> or <associationclassname> is the name of the 
Association or AssociationClass, respectively, that is its type. A stereotype keyword within guillemets may be placed 
above or in front of the Connector name. A property string may be placed after or below the Connector name.
Adornments may be shown on the ConnectorEnd using the same notation as adornments on Association ends. If no 
multiplicity is shown, the multiplicity matches the multiplicity of the role the end is attached to.
If a ConnectorEnd is attached to a Port on a part or role of the internal structure and no multiplicity is shown, the 
multiplicity of the ConnectorEnd matches the multiplicity of the Port multiplied by the multiplicity of the role (if any).
The notational specifications in the next three paragraphs are optional: a conforming tool does not need to implement 
them. They are useful for scalability in complex systems.
If the parts have simple Ports (Ports with a single required or provided Interface), then ball-and-socket notation may be 
used to represent assembly Connectors between those Ports. Ball-and-socket notation may not be used to connect 
complex (i.e., non-simple) Ports or parts without Ports.
When connecting simple Ports, normal Connector notation for assembly or delegation may be shown connected to the 
ball or socket symbol rather than to the Port symbol itself.
When there is an n-ary Connector connecting more than two simple Ports, and two or more of the Ports provide or 
require the same or compatible Interfaces, a single symbol representing the Interface can be shown, and lines from the 
Components can be drawn to that symbol, in a “channeled ball-and-socket” notation.
An internal structure compartment may also contain symbols representing CollaborationUses, following the notation 
described in 11.7.4.

11.2.5

Examples

Figure 11.2  Parts and roles

Figure 11.2 shows examples of part boxes. On the left, the part box denotes that the containing instance will own four 
instances of the Wheel class by composition. The multiplicity is shown in the corner of the part box. The part box on the 
right is not composite, and denotes that the containing instance will reference one or two instances of the Engine class.

Figure 11.3  Parts and roles with Ports

Figure 11.3 shows examples of part boxes for properties typed by EncapsulatedClassifiers with Ports, in this case 
simple Ports. The notation for more complex Ports can also be used.

184

Unified Modeling Language 2.5

Figure 11.4  Alternative notations for connecting parts and roles with Ports

Figure 11.4 shows three alternative notations for connecting simple Ports on the parts and roles within a 
StructuredClassifier. In the top example, the connector is joined to the Port symbols themselves. This is the only 
mandatory notation for connecting Ports in an internal structure. The lollipops and sockets indicate the provided and 
required interfaces of the Ports; their appearance is optional.
In the second example, the connector line is attached to the ball and socket symbols; in the third example, ball-and-
socket notation is used. These notations correspond to the same model as the top example.

Figure 11.5  Associations compared with Connectors

Figure 11.5 shows two possible views of the Car Class. In subfigure (i), Car is shown as having a composition 
Association with role name rear to a class Wheel and an Association with role name e to a class Engine. In subfigure (ii), 
the same is specified. However, in addition, in subfigure (ii) it is specified that rear and e belong to the internal structure 
of the class Car. This allows specification of detail that holds only for instances of the Wheel and Engine classes within 
the context of the class Car, but which will not hold for wheels and engines in general. For example, subfigure (i) 
specifies that any instance of class Engine can be linked to an arbitrary number of instances of class Wheel. Subfigure 
(ii), however, specifies that within the context of class Car, the instance playing the role of e may only be connected to 
two instances playing the role of rear. In addition, the instances playing the e and rear roles may only be linked if they 
are roles of the same instance of class Car. In other words, subfigure (ii) asserts additional constraints on the instances 
of the classes Wheel and Engine, when they are playing the respective roles within an instance of class Car. These 
constraints are not true for instances of Wheel and Engine in general. Other wheels and engines may be arbitrarily 
linked as specified in subfigure (i).
For each instance playing a role in an internal structure, there will initially be as many links as indicated by the lower 
multiplicity of the opposite ends of Connectors attached to that role. If the multiplicities of the ends match the 
multiplicities of the roles they are attached to as defined in Figure 11.6 (i), the initial configuration that will be created 
when an instance of the containing StructuredClassifier is created consists of the set of instances corresponding to the 
roles (as specified by the multiplicities on the roles) fully connected by links; see the resultant instance shown in Figure 
11.6 (ii).

Unified Modeling Language 2.5

185

Figure 11.6  "Star" Connector pattern

Links will be created for each instance playing the connected roles according to their ordering until the minimum 
ConnectorEnd multiplicity is reached for both ends of the Connector; see the resultant instance in Figure 11.7 (ii). In 
this example, only two links are created.

Figure 11.7  "Array" Connector pattern

Figure 11.8 shows example notation for parts typed by Components with simple Ports (Ports with only one interface), 
and the optional ball-and-socket notation to represent an assembly Connector between compatible Ports. The 
Component definitions are on the left and the corresponding parts on the right.

186

Unified Modeling Language 2.5

Figure 11.8  An assembly Connector maps a simple Port of a Component to a matching simple Port of another 
Component.

Figure 11.9 shows “channeled ball-and-socket notation” for a 4-ary Connector. The two simple Ports that require Person 
have been channeled into a single socket, and the two simple Ports that provide Person (either directly or indirectly) 
have been channeled into a single ball.

Figure 11.9  An n-ary Connector that assembles four simple Ports using channeled ball-and-socket notation.

Encapsulated Classifiers
Summary

11.3
11.3.1
EncapsulatedClassifier extends StructuredClassifier with the ability to own Ports, a mechanism for isolating an 
EncapsulatedClassifier from its environment.

Unified Modeling Language 2.5

187

11.3.2

Abstract Syntax

StructuredClassifier

EncapsulatedClassifier

Property

+ partWithPort

+ connectorEnd

0..1

*

ConnectorEnd

{readOnly, subsets ownedAttribute}
+ /ownedPort
*

0..1
+ encapsulatedClassifier
{subsets structuredClassifier}

Port

+ isBehavior : Boolean = false
+ isConjugated : Boolean = false
+ isService : Boolean = true

{subsets property}
+ port

*

*

+ redefinedPort
{subsets redefinedProperty}

+ port

*

+ port

*

+ port

*

{readOnly}
+ /required

*

{readOnly}
+ /provided

*

+ protocol

0..1

Interface

ProtocolStateMachine

Figure 11.10  Encapsulated Classifiers

11.3.3

11.3.3.1

Semantics

Ports

Ports represent interaction points through which an EncapsulatedClassifier communicates with its environment. 
Multiple Ports can be defined for an EncapsulatedClassifier, enabling different communications to be distinguished 
based on the Port through which they occur. By decoupling the internals of the EncapsulatedClassifier from its 
environment, Ports allow an EncapsulatedClassifier to be defined independently of its environment, making it reusable 
in any environment that conforms to the constraints imposed by its Ports.
A Port is a Property of an EncapsulatedClassifier that specifies a distinct interaction point between that 
EncapsulatedClassifier and its environment or between the Behavior of the EncapsulatedClassifier and its internal roles. 
Ports are connected by Connectors through which requests can be made to invoke the BehavioralFeatures of an 
EncapsulatedClassifier. A Port may specify the services an EncapsulatedClassifier provides (offers) to its environment 
as well as the services that an EncapsulatedClassifier expects (requires) of its environment.
The property isService, when true, indicates that this Port is used to provide the published functionality of an 
EncapsulatedClassifier. If false, this Port is used to implement the EncapsulatedClassifier but is not part of the essential 
externally-visible functionality of the EncapsulatedClassifier and can, therefore, be altered or deleted along with the 
internal implementation of the EncapsulatedClassifier and other properties that are considered part of its 
implementation.
The phrase Port on Part or more generally Port on Property signifies the situation where a Property playing a role in a 
StructuredClassifier is typed by an EncapsulatedClassifier that has Ports. A Connector within the containing 
StructuredClassifier may be connected to one of these Ports. In such a case, the property partWithPort of the applicable 
ConnectorEnd references the actual Property being connected: in general, there might be many Properties in the 
structure typed by the same EncapsulatedClassifier, and partWithPort is used to signify the right one.
The Interfaces associated with a Port specify the nature of the interactions that may occur over it. The  required Interfaces 
of a Port characterize the requests that may be made from the EncapsulatedClassifier to its environment through this 
Port. Instances of this EncapsulatedClassifier expect that the Features owned by its required Interfaces will be offered by 
one or more instances in its environment. The provided Interfaces of a Port characterize requests to the 
EncapsulatedClassifier that its environment may make through this Port. The owning EncapsulatedClassifier must offer 
the Features owned by the provided Interfaces.
As a kind of Property, a Port has a type. The provided and required interfaces of the Port are related to its type mediated by 
the value of isConjugated as follows:

•

If isConjugated is false, provided is derived as the union of the sets of Interfaces realized by the type of the Port 
and its supertypes, or directly from the type of the Port if the Port is typed by an Interface; required is derived as 
the union of the sets of Interfaces used by the type of the Port and its supertypes.

188

Unified Modeling Language 2.5

•

If isConjugated is true, provided is derived as the union of the sets of Interfaces used by the type of the Port and 
its supertypes; required is derived as the union of the sets of Interfaces realized by the type of the Port and its 
supertypes, or directly from the type of the Port if the Port is typed by an Interface.

The Interfaces do not necessarily establish the exact sequences of interactions across the Port. A Port’s protocol may 
reference a ProtocolStateMachine that describes valid sequences of Operation and Reception invocations that may occur 
at this Port.
When an instance of an EncapsulatedClassifier is created, instances corresponding to each of its Ports are created and 
held in the slots specified by each Port, in accordance with its type and multiplicity. These instances are referred to as 
“interaction points” and provide unique references. It is, therefore, possible for an EncapsulatedClassifier instance to 
differentiate between requests for the invocation of a BehavioralFeature targeted at its different Ports. Similarly, it is 
possible to direct such requests at a Port, and the requests will be routed as specified by the links corresponding to 
Connectors attached to this Port.
NOTE. In the following, “requests arriving at a Port” shall mean “request occurrences arriving at the interaction point 
of this instance corresponding to this Port.”
A Port has the ability, by setting the property isBehavior to true, to specify that any requests arriving at this Port are 
handled by the Behavior of the instance of the owning EncapsulatedClassifier, rather than being forwarded to any 
contained instances, if any. Such a Port is called a behavior Port. If there is no Behavior defined for this 
EncapsulatedClassifier, any communication arriving at a behavior Port is lost.
A delegation Connector is a Connector that links a Port to a role within the owning EncapsulatedClassifier. It represents 
the forwarding of requests (Operation invocations and Signals). A request that arrives at a Port that has a delegation 
Connector to one or more Properties or Ports on Properties will be passed on to those targets for handling.
Delegation Connectors can be used to model the hierarchical decomposition of behavior, where services provided by an 
EncapsulatedClassifier may ultimately be realized by one that is nested multiple levels deep within it.
As a ConnectableElement, the effective provided Interfaces (see 11.2.3) of a Port are its provided interfaces, and the 
effective required Interfaces are its required Interfaces. However, for a delegating Port, i.e., a Port that is at an end of a 
delegation Connector and is not on a role and that is not a behavior Port, the effective provided Interfaces are its required
interfaces and its effective required Interfaces are its provided interfaces. Consequently a delegating Port behaves, for 
connection, as though it had an internal “face” that is the conjugate of its external “face.”
If several Connectors are attached on one side of a Port, then any request arriving at this Port on a link derived from a 
Connector on the other side of the Port will be forwarded on links corresponding to these Connectors. It is not defined 
whether these requests will be forwarded on all links, or on only one of those links.

Notation

11.3.4
A Port of an EncapsulatedClassifier is shown as a small square symbol. The name of the Port is placed near the square 
symbol. The Port symbol may be placed either overlapping the boundary of the rectangle symbol denoting that 
EncapsulatedClassifier or it may be shown inside the rectangle symbol. When the Port is connected to elements visually 
contained in a compartment of the EncapsulatedClassifier, such as parts or roles in the internal structure compartment, 
the Port symbol must be placed within or overlapping the boundary of that compartment.
The type of a Port may be shown following the Port name, separated by colon (“:”). When isConjugated is true for the 
Port, the type of the Port is shown with a tilde “~” prepended. A provided Interface may be shown using the lollipop 
notation (see Interface – 10.4) attached to the Port. A required Interface may be shown by the socket notation attached to 
the Port.
A behavior Port is indicated by a Port being connected through a line to a small state symbol drawn inside the symbol 
representing the containing EncapsulatedClassifier. The small state symbol indicates the Behavior of the containing 
EncapsulatedClassifier.

Unified Modeling Language 2.5

189

The name of a Port may be suppressed. Every depiction of an unnamed Port denotes a different Port from any other 
Port.
If there are multiple Interfaces associated with a Port, these Interfaces may be listed on the one Interface lollipop, 
separated by commas.
In the case of a Dependency wired from a simple Port with a required Interface to a simple Port to a provided Interface 
it is a notational option to show the dependency arrow joining the socket to the lollipop.

Examples

11.3.5
Figure 11.11 illustrates the notation for Ports. At the top of the figure is the definition of a class PowerTrain, together 
with an interface IPowerTrain that it realizes, and an interface IFeedback that it uses.
On the lower left figure, p is a Port on the Engine Class which is typed by PowerTrain. As a consequence, the provided 
Interface of Port p is IPowerTrain and the required Interface is IFeedback. The multiplicity of p is 1, and isConjugated is 
false. On the right figure, e is a Port of the Class Wheel, which also has the type PowerTrain and isConjugated set to true,
which results in the reversal of the provided and required Interfaces.

Figure 11.11  Port notation

Figure 11.12 illustrates a behavior port p, as indicated by its connection to the small state symbol representing the 
Behavior of the Engine Class. Its type is PowerTrain, as in the earlier example.

Figure 11.12  Behavior Port notation

Figure 11.13 below shows a Port OnlineServices on the OrderProcess Class with two provided Interfaces, OrderEntry 
and Tracking listed on the same interface lollipop, as well as a required Interface Payment.

190

Unified Modeling Language 2.5

Figure 11.13  Port notation showing multiple provided Interfaces

Figure 11.14  Port examples

Figure 11.14 shows a Class Engine with a Port p typed by its provided Interface IPowerTrain. This Interface specifies the 
services that the Engine offers at this Port (i.e., the Operations and Receptions that are accessible by communication 
arriving at this Port).
Two uses of the Engine Class are depicted: Both a Boat and a Car contain a part that is an Engine. The Car Class 
connects Port p of the Engine to a pair of Wheels via the axle. The Boat Class connects Port p of the engine to a 
Propeller via the shaft. As long as the interaction between the Engine and the part linked to its Port p obeys the 
constraints specified by its Interface, the Engine will function as specified, whether it is in a Car or a Boat. This 
example also shows that Connectors need not necessarily attach to parts via Ports (as shown in the Car Class).
Because the Ports are simple, the depiction of the connector within Boat could have been shown using any of the 
notational options shown in Figure 11.4.

Unified Modeling Language 2.5

191

Classes
Summary

11.4
11.4.1
Class is the concrete realization of EncapsulatedClassifier and BehavioredClassifier. The purpose of a Class is to 
specify a classification of objects and to specify the Features that characterize the structure and behavior of those 
objects.

11.4.2

Abstract Syntax

EncapsulatedClassifier

BehavioredClassifier

Class

+ isAbstract : Boolean = false {redefines isAbstract}
+ isActive : Boolean = false

*

+ class

{subsets classifier}

*

+ /superClass

{redefines general}

{subsets namespace, subsets
redefinitionContext}

+ nestingClass

0..1

{subsets namespace,
subsets structuredClassifier,
subsets classifier}
+ class

0..1

{subsets featuringClassifier,
subsets namespace, subsets
redefinitionContext}
+ class
0..1

{ordered, subsets
redefinableElement,
subsets ownedMember}
+ nestedClassifier

Classifier

*

{ordered, subsets attribute, subsets
ownedMember, redefines
ownedAttribute}

+ ownedAttribute

*

Property

{ordered, subsets
feature, subsets
redefinableElement,
subsets ownedMember}
+ ownedOperation

*

{subsets featuringClassifier,
subsets namespace}
+ class

{subsets feature, subsets
ownedMember}
+ ownedReception

0..1

{readOnly}
+ /metaclass

1

*

{readOnly}
+ /extension

*

Operation

Reception

Extension

Figure 11.15  Classes

11.4.3

11.4.3.1

Semantics

Classes

Class is a kind of EncapsulatedClassifier whose Features are Properties, Operations, Receptions, Ports and Connectors. 
Attributes of a Class are Properties that are owned by the Class. Some of these attributes may represent the ends of 
binary Associations.
Objects of a Class must contain values for each attribute that is a member of that Class, in accordance with the 
characteristics of the attribute, for example its type and multiplicity.

192

Unified Modeling Language 2.5

When an object is instantiated in a Class, for every attribute of the Class that has a specified default, if an initial value of 
the attribute is not specified explicitly for the instantiation, then the default ValueSpecification is evaluated to set the 
initial value of the attribute for the object.
Operations of a Class can be invoked on an object, given a particular set of values for the parameters of the Operation, 
according to the semantics specified in 9.6.3.
A Class cannot access private Features of another Class, or protected Features on another Class that is not its ancestor.
A Class acts as the namespace for various kinds of Classifiers defined within its scope, including Classes. Nested 
Classifiers are members of the namespace of the containing Class. Classifier nesting is used for reasons of information 
hiding.
A Class may be designated by setting isActive to true as active (i.e., each of its instances is an active object). When 
isActive is false the Class is passive (i.e., each of its instances executes within the context of some other object).
An active object is an object that, as a direct consequence of its creation, commences to execute its  classifierBehavior, and 
does not cease until either the complete Behavior is executed or the object is terminated by some external object. (This 
is sometimes referred to as “the object having its own thread of control.”) The points at which an active object responds 
to communications from other objects is determined solely by the Behavior of the active object and not by the invoking 
object. If the classifierBehavior of an active object completes, the object is terminated.
A Class’s Receptions specify which Signals the instances of this Class handle.
An InstanceSpecification may be used to specify the initial value to be created for a Class.
All instances corresponding to parts and ports of a Class are destroyed recursively, when an instance of that Class is 
deleted.
A Class may act as a metaclass in the definition of Profiles and metamodels. See Profiles in 12.3.

Notation

11.4.4
A Class is shown using the Classifier symbol. As Class is the most widely used Classifier, no keyword is needed to 
indicate that the metaclass is Class.
A Class has four mandatory compartments: attributes, operations, receptions (see 9.2.4) and internal structure (see
11.2.4). A Class may also have optional compartments as described for Classifiers in general (see 9.2.4).
The operations compartment of a Class contains notation for its ownedOperations using the notation specified in 9.6.4. 
The receptions compartment contains ownedReceptions using the notation specified in 10.3.4.
A usage dependency may relate an InstanceSpecification to a constructor for a Class, describing the single value 
returned by the constructor Operation. The Operation is the client, the created instance the supplier. The 
InstanceSpecification may reference parameters declared by the Operation. A constructor is an Operation having a 
single return result parameter of the type of the owning Class, and marked with the standard stereotype «Create». The 
InstanceSpecification that is the supplier of the usage dependency represents the default value of the single return result 
parameter of a constructor Operation.
A Class with the Property isActive = true can be shown by a Class box with an additional vertical bar on either side.
A Class that represents a metaclass may be extended by the optional stereotype «Metaclass» (see StandardProfile in 
clause 22) shown above or before its name.

Examples

11.4.5
Figure 11.16 shows three ways of displaying the Class Window, according to the options set out for Classifier notation 
in 9.2.4. The top left symbol shows all compartments suppressed. The lower left symbol shows the attributes and 
operations compartments, each listing the features but suppressing details such as default values, parameters, and 
visibility markings. The right symbol shows these details, as well as the optional compartment headers.

Unified Modeling Language 2.5

193

NOTE. The display() and hide() operations have no visibility specified.

Figure 11.16  Class notation variants

Figure 11.17 shows the visibility grouping option (see 9.2.4) applied to the attributes and operations compartments in 
the Class Window.

Figure 11.17  Class notation: attributes and Operations grouped according to visibility

Figure 11.18 shows an example of an active class.

Figure 11.18  Active Class

The following example uses two Classes, Car and Wheel. The Car Class has four parts, all of type Wheel, representing 
the four wheels of the car. The front wheels and the rear wheels are linked via Connectors representing the front and 
rear axle, respectively. Figure 11.19 specifies that whenever an instance of the Car Class is created, four instances of the
Wheel Class are created and held by composition within the car instance. In addition, one link each is created between 
the front wheel instances and the rear wheel instances.

194

Unified Modeling Language 2.5

Figure 11.19  Connectors and Parts

Figure 11.20 specifies an equivalent system, but relies on multiplicities to show the replication of the wheel and axle 
arrangement. This diagram specifies that there will be exactly two instances of the left wheel and exactly two instances 
of the right wheel, with each matching instance connected by a link deriving from the Connector representing the axle.

Figure 11.20  Connectors and Parts in a structure diagram using multiplicities

Figure 11.21 shows an InstanceSpecification (see 9.8) for an instance of the Car Class (as specified in Figure 11.19). It 
describes the internal structure of the Car that it creates and how the four contained instances of Wheel will be 
initialized. In this case, every instance of Wheel will have the predefined size and use the brand of tire as specified. The 
left wheel instances are given names, and all wheel instances are shown as playing the respective roles. The types of the 
wheel instances have been suppressed.

l1 / leftFront

tire = "Michelin" 
size = "215x95"

: Car

frontaxle

/ rightFront

tire = "Michelin" 
size = "215x95"

Wheel

tire : String 
size : String

l2 / leftRear

tire = "Firestone" 
size = "215x95"

rearaxle

l2 / rightRear

tire = "Firestone" 
size = "215x95"

Figure 11.21  An Instance of the Car Class

Figure 11.22 shows a constructor for the Window class, illustrating how the standard stereotype «Create» is applied to 
the makeWindow Operation to mark it as a constructor.

Unified Modeling Language 2.5

195

Window

«Create» makeWindow(...) : Window

theW : Window

Figure 11.22  InstanceSpecification indicating a constructor

Figure 11.23 shows a constructor for the Car Class. This constructor takes a parameter brand of type String. It describes 
the internal structure of the Car that it creates and how the four contained instances of Wheel will be initialized. In this 
case, every instance of Wheel will have the predefined size and use the brand of tire passed as parameter. The left wheel 
instances are given names, and all wheel instances are shown as playing the parts. The types of the wheel instances have 
been suppressed.

Car

«Create» createCar(brand: String)

l1 / leftFront

tire = "Michelin" 
size = "215x95"

: Car

frontaxle

/ rightFront

tire = "Michelin" 
size = "215x95"

l2 / leftRear

tire = "Firestone" 
size = "215x95"

rearaxle

l2 / rightRear

tire = "Firestone" 
size = "215x95"

Figure 11.23  A constructor for the Car Class

In Figure 11.24, it is made explicit that the extended Class Interface is in fact a metaclass (from a reference metamodel).

Figure 11.24  Showing that the extended Class is a metaclass

196

Unified Modeling Language 2.5

Associations
Summary

11.5
11.5.1
An Association classifies a set of tuples representing links between typed instances. An AssociationClass is both an 
Association and a Class.

11.5.2

Abstract Syntax

{ordered, subsets feature, subsets
redefinableElement, subsets
memberEnd, subsets
ownedMember}
+ ownedEnd

*

Property

Relationship

Classifier

{subsets featuringClassifier,
subsets namespace, subsets
association, subsets
redefinitionContext}

+ owningAssociation
0..1

Association

+ isDerived : Boolean = false

{subsets ownedEnd}
+ navigableOwnedEnd
*

{subsets owningAssociation}
+ association
0..1

{ordered, subsets member}
+ memberEnd

2..*

{subsets memberNamespace}
+ association
0..1

+ associationEnd
{subsets owner}

0..1

* + qualifier

{ordered, subsets
ownedElement}

Class

{subsets relationship}
+ association

*

{readOnly, subsets
relatedElement}

1..* + /endType

AssociationClass

Type

Figure 11.25  Associations

11.5.3

11.5.3.1

Semantics

Associations

An Association specifies a semantic relationship that can occur between typed instances. It has at least two memberEnds 
represented by Properties, each of which has the type of the end. More than one end of the Association may have the 
same type.
An Association declares that there can be links between instances whose types conform to or implement the associated 
types. A link is a tuple with one value for each memberEnd of the Association, where each value is an instance whose 
type conforms to or implements the type at the end.
Not all links need to be classified by an Association.
When one or more ends of the Association have isUnique=false, it is possible to have several links associating the same 
set of instances. In such a case, links carry an additional identifier apart from their end values.
When one or more ends of the Association are ordered, links carry ordering information in addition to their end values.
For an Association with N memberEnds, choose any N-1 ends. Let the Property that constitutes the other end be called 
oep, so that the Classifiers at the chosen N-1 ends are the context for oep (see 9.5.3). Associate specific instances with 
the context ends. Then the collection of links of the Association that refer to these specific instances will identify a set 

Unified Modeling Language 2.5

197

of instances at oep. The value represented by oep (see 9.5.3) is a collection calculated from this set as follows: All of the 
instances in the set occur in the collection, and nothing else does. If oep is marked as unique, each instance will occur in 
the collection just once, regardless of how many links connect to it. If oep is marked as nonunique, each instance will 
occur in the collection once for each link that connects to it. If oep is marked as ordered, the collection will be ordered 
in accordance with the ordering information in the links. The cardinality of this collection is its size. The multiplicity of 
oep constrains this cardinality, or in the case of qualified associations, the size of the collection partition that may be 
associated with a qualifier value.
Subsetting of Association ends has the meaning specified for Property (see 9.5.3).
Specialization is, in contrast to subsetting, a relationship in the domain of intentional semantics, which is to say it 
characterizes the criteria whereby membership in the collection is defined, not by the membership. In the case of 
Associations, specialization means that a link classified by the specializing Association is also classified by the 
specialized Association. Semantically this implies that sets calculated by eliminating duplicates from the collections 
representing the ends of the specializing Association are subsets of the corresponding sets calculated by eliminating 
duplicates from collections representing the ends of the specialized Association; this fact of subsetting may or may not 
be explicitly declared in a model.
NOTE. For n-ary Associations, the lower multiplicity of an end is typically 0. A lower multiplicity for an end of an n-
ary Association of 1 (or more) implies that one link (or more) must exist for every possible combination of values for 
the other ends.
A binary Association may represent a composite aggregation (i.e., a whole/part relationship). Composition is 
represented by the isComposite attribute on the part end of the Association being set to true. See the semantics of 
composition in 9.5.3. An end Property of an Association may only be marked as a shared or composite aggregation if 
the Association is binary and the other end is not marked as a shared or composite aggregation.
An end Property of an Association that is owned by an end Class or that is a navigableOwnedEnd of the Association 
indicates that the Association is navigable from the opposite ends; otherwise, the Association is not navigable from the 
opposite ends. Navigability means that instances participating in links at runtime (instances of an Association) can be 
accessed efficiently from instances at the other ends of the Association. The precise mechanism by which such efficient 
access is achieved is implementation specific. If an end is not navigable, access from the other ends may or may not be 
possible, and if it is, it might not be efficient.
NOTE. Tools operating on UML models are not prevented from navigating Associations from non-navigable ends.
A qualified Association end has qualifiers that partition the instances associated with an instance at that end, the qualified 
instance. Each partition is designated by a qualifier value, which is a tuple comprising one value for each qualifier. The 
multiplicities at the other ends of the association determine the number of instances in each partition. So, for example, 
0..1 means there is at most one instance per qualifier value. If the lower bounds are non-zero, the qualifier values must be a 
finite set, for example because the qualifiers are typed by enumerations.
The existence of an association may be derived from other information in the model. The logical relationship between 
the derivation of an Association and the derivation of its ends is model-specific.

11.5.3.2

Association Classes

An AssociationClass is a declaration of an Association that has a set of Features of its own. An AssociationClass is both 
an Association and a Class, and preserves the static and dynamic semantics of both. An AssociationClass describes a set 
of objects that each share the same specifications of Features, Constraints, and semantics entailed by the 
AssociationClass as a kind of Class, and correspond to a unique link instantiating the AssociationClass as a kind of 
Association.
Both Association and Class are Classifiers and hence have a set of common properties, like being able to have Features, 
having a name, etc. These properties are multiply inherited from the same construct (Classifier), and are not duplicated. 
Therefore, an AssociationClass has only one name, and has the set of Features that are defined for Classes and 
Associations. The constraints defined for Class and Association also are applicable for AssociationClass, which implies 
for example that the attributes of the AssociationClass, the memberEnds of the AssociationClass, and the opposite ends of 
Associations connected to the AssociationClass must all have distinct names. Moreover, the specialization and 

198

Unified Modeling Language 2.5

refinement rules defined for Class and Association are also applicable to AssociationClass. Redefinition is applicable to 
an AssociationClass nested in the context of a Classifier just as it is applicable to a nested Class.
An AssociationClass inherits the composite Properties Class::ownedAttribute and Association::ownedEnd. Values of 
ownedAttribute are Properties that are attributes of the Class, not ends of the AssociationClass owned through 
Association::ownedEnd. Values of Association::ownedEnd are the ends of the Association owned by the AssociationClass, not
attributes of the AssociationClass. As Association ends, they can be used for navigation between end objects, as in all 
Associations, depending on whether they are navigable (see Navigability in the semantics of Association).
An instance of an AssociationClass has the characteristics both of a link representing an instantiation of the 
AssociationClass as a kind of Association, and of an object representing an instantiation of the AssociationClass as a 
kind of Class.
NOTE. Even when all ends of the AssociationClass have isUnique=true, it is possible to have several instances 
associating the same set of instances of the end Classes.
An AssociationClass cannot be a generalization of an Association or a Class.

Notation

11.5.4
Any Association may be drawn as a diamond (larger than a terminator on a line) with a solid line for each Association 
memberEnd connecting the diamond to the Classifier that is the end’s type. An Association with more than two ends can 
only be drawn this way.
A binary Association is normally drawn as a solid line connecting two Classifiers, or a solid line connecting a single 
Classifier to itself (the two ends are distinct). A line may consist of one or more connected segments. The individual 
segments of the line itself have no semantic significance, but they may be graphically meaningful to a tool in dragging 
or resizing an Association symbol.
An Association symbol may be adorned as follows:

•

The Association’s name can be shown as a name string near the Association symbol, but not near enough to an 
end to be confused with the end’s name.

• A slash appearing in front of the name of an Association, or in place of the name if no name is shown, marks 

the Association as being derived.

• A property string may be placed near the Association symbol, but far enough from any end to not be confused 

with a property string on an end.

On a binary Association drawn as a solid line, a solid triangular arrowhead next to or in place of the name of the 
Association and pointing along the line in the direction of one end indicates that end to be the last in the order of the 
ends of the Association. The arrow indicates that the Association is to be read as associating the end away from the 
direction of the arrow with the end to which the arrow is pointing (see Figure 11.27). This notation is for documentation 
purposes only and has no general semantic interpretation. It is used to capture some application-specific detail of the 
relationship between the associated Classifiers.
Generalizations between Associations can be shown using a generalization arrow between the Association symbols. 
Other notational options for Generalizations such as “shared target style” (see 9.2.4) and the notations defined in 9.7.4 
may be used for Generalizations between Associations, but a conforming tool is not required to support those options.
An Association end is the connection between the line depicting an Association and the icon (often a box) depicting the 
connected Classifier. A name string may be placed near the end of the line to show the name of the Association end. The 
name is optional and suppressible.
Various other notations can be placed near the end of the line as follows:

• A multiplicity

Unified Modeling Language 2.5

199

• A <prop-modifier> enclosed in curly braces, where <prop-modifier> is defined in Property (see 9.5.4).

• A <visibility> symbol (see 9.5.4).

NOTE. If no multiplicity is shown on the diagram, no conclusion may be drawn about the multiplicity in the model.
An open arrowhead on the end of an Association indicates the end is navigable. A small x on the end of an Association 
indicates the end is not navigable.
If the Association end is derived, this may be shown by putting a slash in front of the name, or in place of the name if no 
name is shown.
A binary Association may have one end with aggregation = AggregationKind::shared or aggregation = 
AggregationKind::composite. When one end has aggregation = AggregationKind::shared a hollow diamond is added as a 
terminal adornment at the end of the Association line opposite the end marked with aggregation = 
AggregationKind::shared. The diamond shall be noticeably smaller than the diamond notation for Associations. An 
Association with aggregation = AggregationKind::composite likewise has a diamond at the corresponding end, but 
differs in having the diamond filled in.
Ownership of Association ends by an associated Classifier may be indicated graphically by a small filled circle, which 
for brevity we will term a dot. The dot is to be drawn integral to the graphic path of the line, at the point where it meets 
the Classifier, inserted between the end of the line and the side of the node representing the Classifier. The diameter of 
the dot shall not exceed half the height of the aggregation diamond, and shall be larger than the width of the line. This 
avoids visual confusion with the filled diamond notation while ensuring that it can be distinguished from the line. The 
dot shows that the model includes a Property of the type represented by the Classifier touched by the dot. This Property 
is owned by the Classifier at the other end. In such a case it is normal to suppress the Property from the attributes 
compartment of the owning Classifier.
The dot may be used in combination with the other graphic line-path notations for Properties of Associations and 
Association ends. These include aggregation type and navigability.
Explicit end-ownership notation is not mandatory, i.e., a conforming tool may not support it. Where the dot notation is 
used, it shall be applied consistently throughout each diagram, so that the absence of the dot signifies ownership by the 
Association. Stated otherwise, when applying this notation to a binary Association in a user model, the dot will be 
omitted only for ends which are not owned by a Classifier. In this way, in contexts where the notation is used, the 
absence of the dot on certain ends does not leave the ownership of those ends ambiguous.
The dot is illustrated in Figure 11.26, at the maximum allowed size. The diagram shows endA to be owned by Classifier 
B, and because the notation must be applied consistently throughout the diagram, this diagram also shows 
unambiguously that endB is owned by BinaryAssociationAB.

Figure 11.26  Graphic notation indicating exactly one Association end owned by the Association

Navigability notation was often used in the past according to an informal convention, whereby non-navigable ends were 
assumed to be owned by the Association whereas navigable ends were assumed to be owned by the Classifier at the 
opposite end. This convention is now deprecated. Aggregation type, navigability, and end ownership are separate 
concepts, each with their own explicit notation. Association ends owned by classes are always navigable, while those 
owned by associations may be navigable or not.
An AssociationClass is shown as a Class symbol attached to the Association path by a dashed line. The Association path 
may include a diamond, in which case the Class symbol shall be shown attached to the diamond by a dashed line. The 
Association path and the AssociationClass symbol represent the same underlying model element, which has a single 
name. The name may be placed on the path, in the Class symbol, or on both, but they must be the same name. 

200

Unified Modeling Language 2.5

Association end names appear in the same position as regular Associations, not in the attribute compartment of the 
AssociationClass.
Logically, the AssociationClass and the Association are the same semantic entity; however, they are graphically distinct. 
The AssociationClass symbol can be dragged away from the line, but the dashed line must remain attached to both the 
path and the Class symbol.
When two association lines cross, a conforming tool may provide the option to show a small semicircular jog to indicate 
that the lines do not intersect (as in electrical circuit diagrams).
In practice, it is often convenient to suppress some of the arrows and crosses that signify navigability of association 
ends. A conforming tool may provide various options for showing navigation arrows and crosses. As with dot notation, 
these options apply at the level of complete diagrams.

•

•

•

Show all arrows and crosses. Navigation and its absence are made completely explicit.

Suppress all arrows and crosses. No inference can be drawn about navigation.

Suppress all crosses. Suppress arrows for Associations with navigability in both directions, and show arrows 
only for Associations with one-way navigability. In this case, the two-way navigability cannot be distinguished 
from situations where there is no navigation at all; however, the latter case occurs rarely in practice.

If there are two or more aggregations to the same aggregate, a conforming tool may as a purely presentational option 
show them as a tree by merging the aggregation ends into a single segment adorned by the solid or hollow aggregation 
diamond symbol. Any adornments on that single segment apply to all of the aggregation ends. The absence of an 
adornment on a merged segment does not imply that the properties corresponding to the suppressed adornment have 
equal values for all of the aggregation ends.
A qualifier is shown as a small rectangle attached to the end of an association path between the final path segment and the 
symbol of the Classifier that it connects to. The qualifier rectangle should be smaller than the attached class rectangle, 
unless this is not practical. The qualifier rectangle is part of the association path, not part of the Classifier. The qualifier 
rectangle is attached to the end of the association path that represents the memberEnd that owns the qualifier.
The multiplicity attached to the target end denotes the possible cardinalities of the set of target instances selected by the 
pairing of a qualified instance and a qualifier value.
The qualifier attributes are drawn within the qualifier box. There may be one or more attributes, shown one to a line. 
Qualifier attributes have the same notation as Classifier attributes, except that initial value expressions are not 
meaningful.
It is permissible (although somewhat rare), to have a qualifier on every end of a single association.
A qualifier may not be suppressed.

Examples

11.5.5
Figure 11.27 shows a binary Association from Player to Year named PlayedInYear.

Unified Modeling Language 2.5

201

Figure 11.27  Binary and ternary Associations

The solid triangle indicates the order of reading: Player PlayedInYear Year. The figure further shows a ternary 
Association between Team, Year, and Player with ends named team, season, and goalie respectively.
The following example shows Association ends with various adornments.

Figure 11.28  Association ends with various adornments

The following adornments are shown on the four Association ends in Figure 11.28.

• Names a, b, and d on three of the ends.

•

Public visibility marked on the ends a, b and d.

• Multiplicities 0..1 on a, * on b, and 0..1 on d.

•

•

Specification of ordering on b and d.

Subsetting on d. For an instance of Class C, the collection d is a subset of the collection b. This is equivalent to 
the OCL constraint:

context C inv: b->includesAll(d)

The following examples show notation for ends owned by an association (no dots).

202

Unified Modeling Language 2.5

Figure 11.29  Examples of navigable association-owned ends

In Figure 11.29:

•

•

•

•

•

The top pair AB shows a binary Association with two navigable ends.

The second pair CD shows a binary Association with two non-navigable ends.

The third pair EF shows a binary Association with unspecified navigability. In a diagram where arrows are 
only shown for one-way navigable associations, this probably signifies bidirectional navigability.

The fourth pair GH shows a binary Association with one end navigable and the other non-navigable.

The fifth pair IJ shows a binary Association with one end navigable and the other non-navigable, in a diagram 
where arrows are only shown for one-way navigable associations, and crosses are suppressed.

The following examples show some class-owned ends, where class ownership is indicated by the dot. In Figure 11.30:

•

•

•

•

In the top pair AB, end b is owned by Class A and end a is owned by Class B. Because the ends are class-
owned, they are navigable.

In the second pair CD, end d is owned by Class C, and hence is navigable. End c is owned by the Association, 
and is marked as navigable.

In the third pair EF, end f is owned by Class E, and hence is navigable. End e is owned by the Association, and 
is marked as not navigable, in a diagram where arrows are only shown for one-way navigable associations, and 
crosses are suppressed.

In the fourth pair GH, end h is owned by Class G and end g is owned by Class H. Because the ends are class-
owned, they are navigable. This is in a diagram where arrows are only shown for one-way navigable 
associations.

Unified Modeling Language 2.5

203

Figure 11.30  Examples of class-owned ends

Figure 11.31 shows that the attribute notation can be used for an Association end owned by a Class, because an 
Association end owned by a Class is also an attribute. Although it would typically be suppressed on grounds of 
redundancy, this notation may be used in conjunction with the association notation to make it perfectly clear that the 
attribute is also an Association end.

Figure 11.31  Example of attribute notation for navigable end owned by an end Class

Figure 11.32 shows the notation for a derived union. The attribute A::b is derived by being the strict union of all of the 
attributes that subset it. In this case there is just one of these, C::d. So for an instance of the Class C, d is a subset of b, 
and b is derived from d.

Figure 11.32  Derived supersets (union)

Figure 11.33 shows the black diamond notation for composite aggregation. The names of the composite ends have been 
suppressed in the diagram.

204

Unified Modeling Language 2.5

Figure 11.33  Composite aggregation is depicted as a black diamond

Figure 11.34 shows a similar model using the notational option of sharing the same source segment between multiple 
compositions. The multiplicity and name adornments on the shared end apply to all of the compositions. The model 
values for absent adornments on the merged segment, such as property modifiers or visibility, may differ.

Figure 11.34  Composite aggregation sharing a source segment

Figure 11.35 shows the notation for an AssociationClass. In this example the name of the AssociationClass appears 
twice, once on the Class rectangle and once on the Association. These are both renderings of the same model element.

Figure 11.35  Example AssociationClass Job, which is defined between the two Classes Person and Company

Figure 11.36 shows the same model using the diamond notation for the AssociationClass.

Unified Modeling Language 2.5

205

Job

Person

*

person

1 ..*
company

Company

Job

salary

Figure 11.36  Example AssociationClass using diamond symbol

Figure 11.37 illustrates some qualified Associations. The left diagram shows that given a Bank, a particular accountNo 
identifies zero or one Person. The qualifier is the Property accountNo, and the qualified object is the Bank. The qualifier is 
owned by the unnamed Property at the Bank end of the Association, i.e., the Property whose type is Bank.
The right diagram shows how an individual Square on the Chessboard may be identified by rank and file; in this case 
because the multiplicity is 1, the diagram shows that every possible value for Rank and File indicates an individual 
Square. In this case the qualifiers are owned by the unnamed association end Property whose type is Chessboard, while 
the opposite Property whose type is Square is marked with aggregation = composite.

Figure 11.37  Qualified associations

Components
Summary

11.6
11.6.1
This sub clause specifies a set of constructs that can be used to define software systems of arbitrary size and complexity. 
In particular, it specifies a Component as a modular unit with well-defined Interfaces that is replaceable within its 
environment. The Component concept addresses the area of component-based development and component-based 
system structuring, where a Component is modeled throughout the development life cycle and successively refined into 
deployment and run-time.
An important aspect of component-based development is the reuse of previously constructed Components. A 
Component can always be considered an autonomous unit within a system or subsystem. It has one or more provided 
and/or required Interfaces (potentially exposed via Ports), and its internals are hidden and inaccessible other than as 
provided by its Interfaces. Although it may be dependent on other elements in terms of Interfaces that are required, a 
Component is encapsulated and its Dependencies are designed such that it can be treated as independently as possible. 
As a result, Components and subsystems can be flexibly reused and replaced by connecting (“wiring”) them together. 

206

Unified Modeling Language 2.5

The aspects of autonomy and reuse also extend to Components at deployment time. The artifacts that implement 
Component are intended to be capable of being deployed and re-deployed independently, for instance to update an 
existing system.
The Components package supports the specification of both logical Components (e.g., business components, process 
components) and physical Components (e.g., EJB components, CORBA components, COM+ and .NET components, 
WSDL components, etc.), along with the artifacts that implement them and the nodes on which they are deployed and 
executed. It is anticipated that profiles based around Components will be developed for specific component 
technologies and associated hardware and software environments.

11.6.2

Abstract Syntax

Class

Component

Realization

{subsets supplier,
subsets owner}
+ abstraction

{subsets ownedElement,
subsets supplierDependency}

+ realization

ComponentRealization

+ isIndirectlyInstantiated : Boolean = true

0..1

*

+ component

*

*

+ component

{subsets namespace}

0..1 + component

{readOnly}
+ /required

*

*

{readOnly}
+ /provided

*

{subsets ownedMember}
+ packagedElement

{subsets clientDependency}

* + componentRealization

{subsets client}

1..* + realizingClassifier

Interface

PackageableElement

Classifier

Figure 11.38  Components

11.6.3

11.6.3.1

Semantics

Components

A Component represents a modular part of a system that encapsulates its contents and whose manifestation is 
replaceable within its environment.
A Component is a self-contained unit that encapsulates the state and behavior of a number of Classifiers. A Component 
specifies a formal contract of the services that it provides to its clients and those that it requires from other Components 
or services in the system in terms of its provided and required Interfaces.
A Component is a substitutable unit that can be replaced at design time or run-time by a Component that offers 
equivalent functionality based on compatibility of its Interfaces. As long as the environment is fully compatible with the
provided and required Interfaces of a Component, it will be able to interact with this environment. Similarly, a system can 
be extended by adding new Component types that add new functionality. Larger pieces of a system’s functionality may 
be assembled by reusing Components as parts in an encompassing Component or assembly of Components, and wiring 
them together.
A Component is modeled throughout the development life cycle and successively refined into deployment and run-time. 
A Component may be manifested by one or more Artifacts, and in turn, that Artifact may be deployed to its execution 
environment. A DeploymentSpecification may define values that parameterize the Component’s execution. (See 
Deployments – Clause 19).
The required and provided Interfaces of a Component allow for the specification of StructuralFeatures such as attributes 
and Association ends, as well as BehavioralFeatures such as Operations and Receptions. A Component may implement 
a provided Interface directly, or its realizing Classifiers may do so, or they may be inherited. The required and provided 
Interfaces may optionally be organized through Ports; these enable the definition of named sets of provided and required 
Interfaces that are typically (but not always) addressed at run-time.

Unified Modeling Language 2.5

207

A Component has an external view (or “black-box” view) by means of its publicly visible Properties and Operations. 
Optionally, a Behavior such as a ProtocolStateMachine may be attached to an Interface, Port, and to the Component 
itself, to define the external view more precisely by making dynamic constraints in the sequence of Operation calls 
explicit.
The wiring between Components in a system or other context can be structurally defined by using Dependencies 
between compatible simple Ports, or between Usages and matching InterfaceRealizations that are represented by 
sockets and lollipops (see 10.4.4) on Components on Component diagrams. Creating a wiring Dependency between a 
Usage and a matching InterfaceRealization, or between compatible simple Ports, means that there may be some 
additional information, such as performance requirements, transport bindings, or other policies that determine that the 
Interface is realized in a way that is suitable for consumption by the depending Component. Such additional information 
could be captured in a profile by means of stereotypes.
A Component also has an internal view (or “white-box” view) by means of its private Properties and realizing 
Classifiers. This view shows how the external Behavior is realized internally. Dependencies on the external view 
provide a convenient overview of what may happen in the internal view; they do not prescribe what must happen. More 
detailed behavior specifications such as Interactions and Activities may be used to detail the mapping from external to 
internal behavior.
The execution time semantics for an assembly Connector in a Component are that requests (signals and operation 
invocations) travel along an instance of a Connector. The execution semantics for multiple Connectors directed to and 
from different roles, or n-ary Connectors where n> 2, indicates that the instance that will originate or handle the request 
will be determined at execution time.
A number of UML standard stereotypes exist that apply to Component. For example, «Subsystem» to model large-scale 
Components, and «Specification» and «Realization» to model Components with distinct specification and realization 
definitions, where one specification may have multiple realizations (see the Standard Profiles).
A Component may be realized (or implemented) by a number of Classifiers. In that case, a Component owns a set of 
ComponentRealizations to these Classifiers.
A component acts like a Package for all model elements that are involved in or related to its definition, which should be 
either owned or imported explicitly. Typically the Classifiers that realize a Component are owned by it.
The isDirectlyInstantiated property specifies the kind of instantiation that applies to a Component. If false, the Component 
is instantiated as an addressable object. If true, the Component is defined at design-time, but at run-time (or execution-
time) an object specified by the Component does not exist, that is, the Component is instantiated indirectly, through the 
instantiation of its realizing Classifiers or parts.

Notation

11.6.4
A Component is shown as a Classifier rectangle with the keyword «component». Optionally, in the right hand corner a 
Component icon can be displayed. This is a Classifier rectangle with two smaller rectangles protruding from its left 
hand side. If the icon symbol is shown, the keyword «component» may be hidden.
The attributes, operations and internal structure compartments all have their normal meaning. The internal structure uses 
the notation defined in StructuredClassifiers (11.2).
The provided and required Interfaces of a Component may be shown by means of ball (lollipop) and socket notation 
(see 10.4.4), where the lollipops and sockets stick out of the Component rectangle.
For displaying the full signature of a provided or required Interface of a Component, the Interfaces can also be 
displayed as normal expandable Classifier rectangles. For this option, the Interface rectangles are connected to the 
Component rectangle by appropriate dependency arrows, as specified in 7.7.4 and 10.4.4.
A conforming tool may optionally support compartments named “provided interfaces” and “required interfaces” listing 
the provided and required Interfaces by name. This may be a useful option in scenarios in which a Component has a 
large number of provided or required Interfaces.

208

Unified Modeling Language 2.5

Additional optional compartments “realizations” and “artifacts” may be used to list the realizing Classifiers (Classifiers 
reached by following the realization property) and manifesting Artifacts (Artifacts that manifest this component – see 
19.3).
A ComponentRealization is notated in the same way as a Realization dependency (i.e., as a general dashed line with a 
hollow triangle as an arrowhead).
The packagedElements of a Component may be displayed in an optional compartment named “packaged elements,” 
according to the specification for optional compartments for ownedMembers set out in 9.2.4.

Examples

11.6.5
An overview diagram can show Components related by Dependencies, which signify some further unspecified kind of 
dependency between the components, and by implication a lack of dependency where there are no Dependency arrows.

Figure 11.39  Example of an overview diagram showing Components and their general Dependencies

Figure 11.40 shows an external (“black-box”) view of a Component by means of interface lollipops and sockets sticking 
out of the Component rectangle.

Figure 11.40  A Component with two provided and three required Interfaces

Figure 11.41 shows provided and required interfaces listed in optional compartments.

Unified Modeling Language 2.5

209

Figure 11.41  Black box notation showing a listing of provided and required interfaces

Figure 11.42 shows a “white box” view of a Component listing realizing Classifiers and manifesting Artifacts in 
additional optional compartments.

Figure 11.42  Optional “white-box” representation of a Component

Figure 11.43 shows explicit representation of the provided and required Interfaces using Dependency notations, 
allowing Interface details such as Operations to be displayed.

Figure 11.43  Explicit representation of provided and required Interfaces using Dependency notation.

Figure 11.44 shows a set of Classifiers that realize a Component with realization arrows representing the 
ComponentRealizations.

210

Unified Modeling Language 2.5

Figure 11.44  A representation of the realization of a complex Component

Figure 11.45 shows owned Classes that realize a Component nested within an optional “packaged elements” 
compartment of the Component shape.

Figure 11.45  An alternative nested representation of a complex Component

Figure 11.46 shows various ways of wiring Components using Dependencies.
The Dependency on the right of the figure is from the Usage of OrderableItem to the InterfaceRealization of 
OrderableItem. This also shows that “/OrderableItem” is an Interface that is implemented by a supertype of Product, 
following the notation specified in 10.4.4.
The Dependency between the AccountPayable Ports illustrates the notational option of showing the dependency arrow 
joining the socket to the lollipop, when a Dependency is wired between simple Ports.
When realizing Classifiers are shown in a packaged elements compartment, a Dependency may be shown from a simple 
Port to a realizing Classifier to indicate that the Interface provided or required by the Port is dependent in some way 
upon the Classifier. This is illustrated by the Dependency from AccountPayable to OrderHeader, which indicates that 
something about the fact that the Component requires AccountPayable is dependent upon OrderHeader.

Unified Modeling Language 2.5

211

Figure 11.46  Example model of a Component, its provided and required Interfaces, and wiring through 
Dependencies

Figure 11.47 shows an internal or white-box view of the internal structure of a Component that contains other 
Components with simple Ports as parts of its internal assembly. The assembly Connectors use ball-and-socket notation. 
The delegation connectors use the notational option that the Connector line can end on the ball or socket, rather than the 
simple port itself.

Figure 11.47  Internal structure of a Component

Figure 11.48 shows delegation Connectors from delegating Ports to handling parts; in this example the parts in the 
internal structure compartment are typed by Classes shown in the optional packaged elements compartment.

212

Unified Modeling Language 2.5

Figure 11.48  Delegation Connectors connect externally provided Interfaces to the parts that realize or require 
them.

Collaborations
Summary

11.7
11.7.1
The primary purpose of Collaborations is to explain how a system of communicating elements collectively accomplish 
a specific task or set of tasks without necessarily having to incorporate detail that is irrelevant to the explanation. 
Collaborations are one way that UML may be used to capture design patterns.
A CollaborationUse represents the application of the pattern described by a Collaboration to a specific situation 
involving specific elements playing its collaborationRoles.

11.7.2

Abstract Syntax

StructuredClassifier

BehavioredClassifier

+ type

1

+ collaborationUse

*

Collaboration

{subsets structuredClassifier}
+ collaboration

{subsets role}
+ collaborationRole

*

*

ConnectableElement

Figure 11.49  Collaborations

NamedElement

CollaborationUse

+ collaborationUse
{subsets ownedElement}

+ classifier
{subsets owner}

*

0..1

+ representation
{subsets collaborationUse}

Classifier

0..1

0..1

{subsets owner}
+ collaborationUse

0..1

{subsets ownedElement}
+ roleBinding

*

Dependency

Unified Modeling Language 2.5

213

11.7.3

11.7.3.1

Semantics

Collaborations

Collaborations may be used to explain how a collection of cooperating instances achieve a joint task or set of tasks. 
Therefore, a Collaboration typically incorporates only those aspects that are necessary for its explanation and 
suppresses everything else. Thus, a given object may be simultaneously playing collaborationRoles in multiple different 
Collaborations, but each Collaboration would only represent those aspects of that object that are relevant to its purpose.
A Collaboration defines a set of cooperating participants that are needed for a given task. The collaborationRoles of a 
Collaboration will be played by instances when interacting with each other. Their relationships relevant for the given 
task are shown as Connectors between the collaborationRoles. CollaborationRoles of Collaborations define a usage of 
instances, while the Classifiers typing these collaborationRoles specify all required Properties of these instances. Thus, a 
Collaboration specifies what Properties instances must have to be able to participate in the Collaboration. The 
Connectors between the collaborationRoles specify what communication paths must exist between the participating 
instances.
Neither all Features nor all contents of the participating instances nor all links between these instances are always 
required in a particular Collaboration. Therefore, a Collaboration is often defined in terms of collaborationRoles typed by 
Interfaces.
Collaborations may be specialized from other Collaborations. If a collaborationRole is extended in the specialization, its 
type in the specialized Collaboration must conform to its type in the general Collaboration. The specialization of the 
types of the collaborationRoles does not imply corresponding specialization of the Classifiers that realize those 
collaborationRoles. It is sufficient that they conform to the constraints defined by those collaborationRoles.
A Collaboration is not directly instantiable. Instead, the cooperation defined by the Collaboration comes about as a 
consequence of the actual cooperation between the instances that play the collaborationRoles defined in the Collaboration.

11.7.3.2

CollaborationUses

A CollaborationUse represents a particular use of a Collaboration to explain the relationships between a set of elements. 
A CollaborationUse shows how the pattern described by a Collaboration is applied in a given context Classifier, by 
binding specific ConnectableElements from that context to the collaborationRoles of the Collaboration. There may be 
multiple CollaborationUses related to a given Collaboration within a Classifier, each bound differently. A given 
collaborationRole or Connector may be involved in multiple uses of the same or different Collaborations.
The roleBindings are implemented using Dependencies owned by the CollaborationUse. Each collaborationRole in the 
Collaboration is bound by a distinct Dependency and is its supplier. The client of the Dependency is a 
ConnectableElement that relates in some way to the context Classifier: it may be a direct collaborationRole of the context 
Classifier, or an element reachable by some set of references from the context Classifier. These  roleBindings indicate 
which ConnectableElement from the context Classifier plays which collaborationRole in the Collaboration.
Connectors in a Collaboration typing a CollaborationUse must have corresponding Connectors between elements bound 
in the context Classifier, and these corresponding Connectors must have the same or more general type than the 
Collaboration Connectors.
One of the CollaborationUses owned by a Classifier may be singled out as representing the Behavior of the Classifier as 
a whole. This is called the Classifier’s representation. The Collaboration that is related to the Classifier by its 
representation shows how the instances corresponding to the StructuralFeatures of this Classifier (e.g., its attributes and 
parts) interact to generate the overall Behavior of the Classifier. The representing Collaboration may be used to provide 
a description of the Behavior of the Classifier at a different level of abstraction than is offered by the internal structure 
of the Classifier. The Properties of the Classifier are mapped to collaborationRoles in the Collaboration by the roleBindings 
of the CollaborationUse.
Any Behavior attached to the Collaboration applies to the set of collaborationRoles and Connectors bound within a given 
CollaborationUse. For example, an interaction among parts of a Collaboration applies to the Classifier parts bound to a 
single CollaborationUse.

214

Unified Modeling Language 2.5

If the same ConnectableElement is used in both the Collaboration and the represented element, no roleBinding is 
required.
It is not specified further when client and supplier elements in roleBindings are compatible.

Notation

11.7.4
A Collaboration is shown as a dashed ellipse shape containing the name of the Collaboration. The internal structure of a 
Collaboration as comprised by collaborationRoles and Connectors may be shown in a compartment within the dashed 
ellipse shape. This compartment follows the same notational specification as for the internal structure compartment of a 
normal Classifier rectangle.
Alternatively, a composite structure diagram can be used, or a normal Classifier rectangle with the keyword 
«collaboration».
There is no notation defined for a Collaboration whose collaborationRoles are not Properties.
Using an alternative notation for Properties, a line may be drawn from the elliptical Collaboration shape to rectangles 
denoting Classifiers that are the types of Properties of the Collaboration. Each line is labeled by the name of the 
Property. In this manner, a diagram can show the definition of a Collaboration together with the actual Classifiers that 
type the collaborationRoles in that definition
A CollaborationUse is shown within an internal structure compartment of the context Classifier by a dashed ellipse 
containing the name of the occurrence, a colon, and the name of the Collaboration type. For every roleBinding, there is a 
dashed line from the ellipse to the client element; the dashed line is labeled on the client end with the name of the supplier 
element. With this notation the Connectors that must exist in the context Classifier as a consequence of the bindings 
may be suppressed.
An optional notation for CollaborationUse is as a dashed arrow with the keyword «occurrence» pointing from the using 
Classifier to the used Collaboration. In conjunction with this the roleBindings are shown as normal Dependency arrows. 
With this option any Connectors that must exist in the context Classifier as a consequence of the bindings should be 
shown.

Examples

11.7.5
Figure 11.50 shows the internal structure of the Collaboration named Observer, with two parts that are collaborationRoles 
named subject and observer, and a Connector between them.

Figure 11.50  The internal structure of the Observer Collaboration

Figure 11.51 shows the alternative notation for definition of the parts of the Observer Collaboration, which allows the 
details of the Classes CallQueue and SlidingBarIcon to be shown in the same definition. Any instance playing the 
Subject collaborationRole must possess the Properties specified by CallQueue, and similarly for the Observer 
collaborationRole. The example also shows a Constraint on Observer.

Unified Modeling Language 2.5

215

Figure 11.51  Alternative notation for the parts of the Observer Collaboration.

The next example shows the definition of two Collaborations, Sale (Figure 11.52) and BrokeredSale (Figure 11.53). 
Sale is used twice as part of the definition of BrokeredSale. Sale is a Collaboration among two collaborationRoles 
(actually parts), a seller and a buyer. An interaction, or other Behavior specification, could be attached to Sale to specify 
the steps involved in making a Sale.

Figure 11.52  The Sale Collaboration

BrokeredSale is a Collaboration among three collaborationRoles, a producer, a broker, and a consumer. The specification 
of BrokeredSale shows that it consists of two CollaborationUses of the Sale Collaboration, indicated by the dashed 
ellipses. The occurrence wholesale indicates a Sale in which the producer is the seller and the broker is the buyer. The 
occurrence retail indicates a Sale in which the broker is the seller and the consumer is the buyer. The Connectors 
between sellers and buyers are not shown in the two occurrences; these Connectors must exist in the BrokeredSale 
Collaboration as a consequence of the Connector defined in Sale. The BrokeredSale Collaboration could itself be used 
as part of a larger Collaboration.

Figure 11.53  The BrokeredSale Collaboration

216

Unified Modeling Language 2.5

Figure 11.54 shows part of the BrokeredSale Collaboration using the optional «occurrence» notation.

Figure 11.54  A subset of the BrokeredSale Collaboration using «occurrence» and Dependency arrows

11.8
11.8.1

Classifier Descriptions
Association [Class]

11.8.1.1

Description

A link is a tuple of values that refer to typed objects. An Association classifies a set of links, each of which is an 
instance of the Association. Each value in the link refers to an instance of the type of the corresponding end of the 
Association.

11.8.1.2

Diagrams

Structured Classifiers, Associations, Profiles, Nodes, Properties, Link Actions

11.8.1.3

Generalizations

Relationship, Classifier

11.8.1.4

Specializations

AssociationClass, Extension, CommunicationPath

11.8.1.5

Attributes

•

isDerived : Boolean [1..1] = false
Specifies whether the Association is derived from other model elements such as other Associations.

11.8.1.6

Association Ends

•

/endType : Type [1..*]{subsets Relationship::relatedElement} (opposite A_endType_association::association)
The Classifiers that are used as types of the ends of the Association.

• memberEnd : Property [2..*]{ordered, subsets Namespace::member} (opposite Property::association)

Each end represents participation of instances of the Classifier connected to the end in links of the Association.

•

navigableOwnedEnd : Property [0..*]{subsets Association::ownedEnd} (opposite 
A_navigableOwnedEnd_association::association)
The navigable ends that are owned by the Association itself.

Unified Modeling Language 2.5

217

•

♦ ownedEnd : Property [0..*]{ordered, subsets Classifier::feature, subsets 
A_redefinitionContext_redefinableElement::redefinableElement, subsets Association::memberEnd, subsets 
Namespace::ownedMember} (opposite Property::owningAssociation)
The ends that are owned by the Association itself.

11.8.1.7

Operations

•

endType() : Type [1..*]
endType is derived from the types of the member ends.

body: memberEnd->collect(type)->asSet()

11.8.1.8

Constraints

•

•

•

•

•

specialized_end_number
An Association specializing another Association has the same number of ends as the other Association.

inv: parents()->select(oclIsKindOf(Association)).oclAsType(Association)->forAll(p | 
p.memberEnd->size() = self.memberEnd->size())

specialized_end_types
When an Association specializes another Association, every end of the specific Association corresponds to an 
end of the general Association, and the specific end reaches the same type or a subtype of the corresponding 
general end.

inv: Sequence{1..memberEnd->size()}->

forAll(i | general->select(oclIsKindOf(Association)).oclAsType(Association)->

forAll(ga | self.memberEnd->at(i).type.conformsTo(ga.memberEnd->at(i).type)))

binary_associations
Only binary Associations can be aggregations.

inv: memberEnd->exists(aggregation <> AggregationKind::none) implies (memberEnd->size() = 2 
and memberEnd->exists(aggregation = AggregationKind::none))

association_ends
Ends of Associations with more than two ends must be owned by the Association itself.

inv: memberEnd->size() > 2 implies ownedEnd->includesAll(memberEnd)

ends_must_be_typed

inv: memberEnd->forAll(type->notEmpty())

11.8.2

11.8.2.1

AssociationClass [Class]

Description

A model element that has both Association and Class properties. An AssociationClass can be seen as an Association that 
also has Class properties, or as a Class that also has Association properties. It not only connects a set of Classifiers but 
also defines a set of Features that belong to the Association itself and not to any of the associated Classifiers.

11.8.2.2

Diagrams

Associations

218

Unified Modeling Language 2.5

11.8.2.3

Generalizations

Class, Association

11.8.2.4

Constraints

•

•

cannot_be_defined
An AssociationClass cannot be defined between itself and something else.

inv: self.endType()->excludes(self) and self.endType()->collect(et|
et.oclAsType(Classifier).allParents())->flatten()->excludes(self)

disjoint_attributes_ends
The owned attributes and owned ends of an AssociationClass are disjoint.

inv: ownedAttribute->intersection(ownedEnd)->isEmpty()

11.8.3

11.8.3.1

Class [Class]

Description

A Class classifies a set of objects and specifies the features that characterize the structure and behavior of those objects. 
A Class may have an internal structure and Ports.

11.8.3.2

Diagrams

Classes, Associations, Components, Profiles, Nodes, Behaviors, Properties, Operations

11.8.3.3

Generalizations

BehavioredClassifier, EncapsulatedClassifier

11.8.3.4

Specializations

AssociationClass, Component, Behavior, Stereotype, Node

11.8.3.5

Attributes

•

•

isAbstract : Boolean [1..1] = false
If true, the Class does not provide a complete declaration and cannot be instantiated. An abstract Class is 
typically used as a target of Associations or Generalizations.

isActive : Boolean [1..1] = false
Determines whether an object specified by this Class is active or not. If true, then the owning Class is referred 
to as an active Class. If false, then such a Class is referred to as a passive Class.

11.8.3.6

Association Ends

•

•

/extension : Extension [0..*]{} (opposite Extension::metaclass)
This property is used when the Class is acting as a metaclass. It references the Extensions that specify 
additional properties of the metaclass. The property is derived from the Extensions whose memberEnds are 
typed by the Class.

♦ nestedClassifier : Classifier [0..*]{ordered, subsets 
A_redefinitionContext_redefinableElement::redefinableElement, subsets Namespace::ownedMember} 

Unified Modeling Language 2.5

219

(opposite A_nestedClassifier_nestingClass::nestingClass)
The Classifiers owned by the Class that are not ownedBehaviors.

•

•

•

•

♦ ownedAttribute : Property [0..*]{ordered, subsets Classifier::attribute, subsets Namespace::ownedMember, 
redefines StructuredClassifier::ownedAttribute} (opposite Property::class)
The attributes (i.e., the Properties) owned by the Class.

♦ ownedOperation : Operation [0..*]{ordered, subsets Classifier::feature, subsets 
A_redefinitionContext_redefinableElement::redefinableElement, subsets Namespace::ownedMember} 
(opposite Operation::class)
The Operations owned by the Class.

♦ ownedReception : Reception [0..*]{subsets Classifier::feature, subsets Namespace::ownedMember} 
(opposite A_ownedReception_class::class)
The Receptions owned by the Class.

/superClass : Class [0..*]{redefines Classifier::general} (opposite A_superClass_class::class)
The superclasses of a Class, derived from its Generalizations.

11.8.3.7

Operations

•

•

extension() : Extension [0..*]
Derivation for Class::/extension : Extension

body: Extension.allInstances()->select(ext |
  let endTypes : Sequence(Classifier) = ext.memberEnd->collect(type.oclAsType(Classifier)) 
in
  endTypes->includes(self) or endTypes.allParents()->includes(self) )

superClass() : Class [0..*]
Derivation for Class::/superClass : Class

body: self.general()->select(oclIsKindOf(Class))->collect(oclAsType(Class))->asSet()

11.8.3.8

Constraints

•

passive_class
Only an active Class may own Receptions and have a classifierBehavior.

inv: not isActive implies (ownedReception->isEmpty() and classifierBehavior = null)

11.8.4

11.8.4.1

Collaboration [Class]

Description

A Collaboration describes a structure of collaborating elements (roles), each performing a specialized function, which 
collectively accomplish some desired functionality.

11.8.4.2

Diagrams

Collaborations

11.8.4.3

Generalizations

StructuredClassifier, BehavioredClassifier

220

Unified Modeling Language 2.5

11.8.4.4

Association Ends

•

11.8.5

11.8.5.1

collaborationRole : ConnectableElement [0..*]{subsets StructuredClassifier::role} (opposite 
A_collaborationRole_collaboration::collaboration)
Represents the participants in the Collaboration.

CollaborationUse [Class]

Description

A CollaborationUse is used to specify the application of a pattern specified by a Collaboration to a specific situation.

11.8.5.2

Diagrams

Collaborations, Classifiers

11.8.5.3

Generalizations

NamedElement

11.8.5.4

Association Ends

•

•

♦ roleBinding : Dependency [0..*]{subsets Element::ownedElement} (opposite 
A_roleBinding_collaborationUse::collaborationUse)
A mapping between features of the Collaboration and features of the owning Classifier. This mapping indicates 
which ConnectableElement of the Classifier plays which role(s) in the Collaboration. A ConnectableElement 
may be bound to multiple roles in the same CollaborationUse (that is, it may play multiple roles).

type : Collaboration [1..1] (opposite A_type_collaborationUse::collaborationUse)
The Collaboration which is used in this CollaborationUse. The Collaboration defines the cooperation between 
its roles which are mapped to ConnectableElements relating to the Classifier owning the CollaborationUse.

11.8.5.5

Constraints

•

•

•

client_elements
All the client elements of a roleBinding are in one Classifier and all supplier elements of a roleBinding are in 
one Collaboration.

inv: roleBinding->collect(client)->forAll(ne1, ne2 |
  ne1.oclIsKindOf(ConnectableElement) and ne2.oclIsKindOf(ConnectableElement) and
    let ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement), ce2 : 
ConnectableElement = ne2.oclAsType(ConnectableElement) in
      ce1.structuredClassifier = ce2.structuredClassifier)
and
  roleBinding->collect(supplier)->forAll(ne1, ne2 |
  ne1.oclIsKindOf(ConnectableElement) and ne2.oclIsKindOf(ConnectableElement) and
    let ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement), ce2 : 
ConnectableElement = ne2.oclAsType(ConnectableElement) in
      ce1.collaboration = ce2.collaboration)

every_role
Every collaborationRole in the Collaboration is bound within the CollaborationUse.

inv: type.collaborationRole->forAll(role | roleBinding->exists(rb | rb.supplier-
>includes(role)))

connectors
Connectors in a Collaboration typing a CollaborationUse must have corresponding Connectors between 

Unified Modeling Language 2.5

221

elements bound in the context Classifier, and these corresponding Connectors must have the same or more 
general type than the Collaboration Connectors.

inv: type.ownedConnector->forAll(connector |
  let rolesConnectedInCollab : Set(ConnectableElement) = connector.end.role->asSet(),
        relevantBindings : Set(Dependency) = roleBinding->select(rb | rb.supplier-
>intersection(rolesConnectedInCollab)->notEmpty()),
        boundRoles : Set(ConnectableElement) = relevantBindings-
>collect(client.oclAsType(ConnectableElement))->asSet(),
        contextClassifier : StructuredClassifier = boundRoles-
>any(true).structuredClassifier->any(true) in
          contextClassifier.ownedConnector->exists( correspondingConnector |
              correspondingConnector.end.role->forAll( role | boundRoles->includes(role) )
              and (connector.type->notEmpty() and correspondingConnector.type->notEmpty()) 
implies connector.type->forAll(conformsTo(correspondingConnector.type)) )
)

11.8.6

11.8.6.1

Component [Class]

Description

A Component represents a modular part of a system that encapsulates its contents and whose manifestation is 
replaceable within its environment.

11.8.6.2

Diagrams

Components

11.8.6.3

Generalizations

Class

11.8.6.4

Attributes

•

isIndirectlyInstantiated : Boolean [1..1] = true
If true, the Component is defined at design-time, but at run-time (or execution-time) an object specified by the 
Component does not exist, that is, the Component is instantiated indirectly, through the instantiation of its 
realizing Classifiers or parts.

11.8.6.5

Association Ends

•

•

•

•

222

♦ packagedElement : PackageableElement [0..*]{subsets Namespace::ownedMember} (opposite 
A_packagedElement_component::component)
The set of PackageableElements that a Component owns. In the namespace of a Component, all model 
elements that are involved in or related to its definition may be owned or imported explicitly. These may 
include e.g., Classes, Interfaces, Components, Packages, UseCases, Dependencies (e.g., mappings), and 
Artifacts.

/provided : Interface [0..*]{} (opposite A_provided_component::component)
The Interfaces that the Component exposes to its environment. These Interfaces may be Realized by the 
Component or any of its realizingClassifiers, or they may be the Interfaces that are provided by its public Ports.

♦ realization : ComponentRealization [0..*]{subsets Element::ownedElement, subsets 
A_supplier_supplierDependency::supplierDependency} (opposite ComponentRealization::abstraction)
The set of Realizations owned by the Component. Realizations reference the Classifiers of which the 
Component is an abstraction; i.e., that realize its behavior.

/required : Interface [0..*]{} (opposite A_required_component::component)
The Interfaces that the Component requires from other Components in its environment in order to be able to 

Unified Modeling Language 2.5

offer its full set of provided functionality. These Interfaces may be used by the Component or any of its 
realizingClassifiers, or they may be the Interfaces that are required by its public Ports.

11.8.6.6

Operations

•

•

provided() : Interface [0..*]
Derivation for Component::/provided

body: let  ris : Set(Interface) = allRealizedInterfaces(),
        realizingClassifiers : Set(Classifier) =  self.realization.realizingClassifier-
>union(self.allParents()->collect(realization.realizingClassifier))->asSet(),
        allRealizingClassifiers : Set(Classifier) = realizingClassifiers-
>union(realizingClassifiers.allParents())->asSet(),
        realizingClassifierInterfaces : Set(Interface) = allRealizingClassifiers->iterate(c; 
rci : Set(Interface) = Set{} | rci->union(c.allRealizedInterfaces())),
        ports : Set(Port) = self.ownedPort->union(allParents()->collect(ownedPort))-
>asSet(),
        providedByPorts : Set(Interface) = ports.provided->asSet()
in     ris->union(realizingClassifierInterfaces) ->union(providedByPorts)->asSet()

required() : Interface [0..*]
Derivation for Component::/required

body: let  uis : Set(Interface) = allUsedInterfaces(),
        realizingClassifiers : Set(Classifier) = self.realization.realizingClassifier-
>union(self.allParents()->collect(realization.realizingClassifier))->asSet(),
        allRealizingClassifiers : Set(Classifier) = realizingClassifiers-
>union(realizingClassifiers.allParents())->asSet(),
        realizingClassifierInterfaces : Set(Interface) = allRealizingClassifiers->iterate(c; 
rci : Set(Interface) = Set{} | rci->union(c.allUsedInterfaces())),
        ports : Set(Port) = self.ownedPort->union(allParents()->collect(ownedPort))-
>asSet(),
        usedByPorts : Set(Interface) = ports.required->asSet()
in    uis->union(realizingClassifierInterfaces)->union(usedByPorts)->asSet()

11.8.6.7

Constraints

•

•

no_nested_classifiers
A Component cannot nest Classifiers.

inv: nestedClassifier->isEmpty()

no_packaged_elements
A Component nested in a Class cannot have any packaged elements.

inv: nestingClass <> null implies packagedElement->isEmpty()

11.8.7

11.8.7.1

ComponentRealization [Class]

Description

Realization is specialized to (optionally) define the Classifiers that realize the contract offered by a Component in terms 
of its provided and required Interfaces. The Component forms an abstraction from these various Classifiers.

11.8.7.2

Diagrams

Components

11.8.7.3

Generalizations

Realization

Unified Modeling Language 2.5

223

11.8.7.4

Association Ends

•

•

11.8.8

11.8.8.1

abstraction : Component [0..1]{subsets Dependency::supplier, subsets Element::owner} (opposite 
Component::realization)
The Component that owns this ComponentRealization and which is implemented by its realizing Classifiers.

realizingClassifier : Classifier [1..*]{subsets Dependency::client} (opposite 
A_realizingClassifier_componentRealization::componentRealization)
The Classifiers that are involved in the implementation of the Component that owns this Realization.

ConnectableElement [Abstract Class]

Description

ConnectableElement is an abstract metaclass representing a set of instances that play roles of a StructuredClassifier. 
ConnectableElements may be joined by attached Connectors and specify configurations of linked instances to be 
created within an instance of the containing StructuredClassifier.

11.8.8.2

Diagrams

Structured Classifiers, Collaborations, Activities, Lifelines, Features, Properties

11.8.8.3

Generalizations

TypedElement, ParameterableElement

11.8.8.4

Specializations

Variable, Parameter, Property

11.8.8.5

Association Ends

•

•

/end : ConnectorEnd [0..*]{} (opposite ConnectorEnd::role)
A set of ConnectorEnds that attach to this ConnectableElement.

templateParameter : ConnectableElementTemplateParameter [0..1]{redefines 
ParameterableElement::templateParameter} (opposite 
ConnectableElementTemplateParameter::parameteredElement)
The ConnectableElementTemplateParameter for this ConnectableElement parameter.

11.8.8.6

Operations

•

end() : ConnectorEnd [0..*]
Derivation for ConnectableElement::/end : ConnectorEnd

body: ConnectorEnd.allInstances()->select(role = self)

ConnectableElementTemplateParameter [Class]

Description

11.8.9

11.8.9.1

A ConnectableElementTemplateParameter exposes a ConnectableElement as a formal parameter for a template.

224

Unified Modeling Language 2.5

11.8.9.2

Diagrams

Structured Classifiers

11.8.9.3

Generalizations

TemplateParameter

11.8.9.4

Association Ends

•

parameteredElement : ConnectableElement [1..1]{redefines TemplateParameter::parameteredElement} 
(opposite ConnectableElement::templateParameter)
The ConnectableElement for this ConnectableElementTemplateParameter.

11.8.10

Connector [Class]

11.8.10.1

Description

A Connector specifies links that enables communication between two or more instances. In contrast to Associations, 
which specify links between any instance of the associated Classifiers, Connectors specify links between instances 
playing the connected parts only.

11.8.10.2

Diagrams

Structured Classifiers, Messages, Information Flows

11.8.10.3

Generalizations

Feature

11.8.10.4

Attributes

•

/kind : ConnectorKind [1..1]
Indicates the kind of Connector. This is derived: a Connector with one or more ends connected to a Port which 
is not on a Part and which is not a behavior port is a delegation; otherwise it is an assembly.

11.8.10.5

Association Ends

•

•

•

•

contract : Behavior [0..*] (opposite A_contract_connector::connector)
The set of Behaviors that specify the valid interaction patterns across the Connector.

♦ end : ConnectorEnd [2..*]{ordered, subsets Element::ownedElement} (opposite 
A_end_connector::connector)
A Connector has at least two ConnectorEnds, each representing the participation of instances of the Classifiers 
typing the ConnectableElements attached to the end. The set of ConnectorEnds is ordered.

redefinedConnector : Connector [0..*]{subsets RedefinableElement::redefinedElement} (opposite 
A_redefinedConnector_connector::connector)
A Connector may be redefined when its containing Classifier is specialized. The redefining Connector may 
have a type that specializes the type of the redefined Connector. The types of the ConnectorEnds of the 
redefining Connector may specialize the types of the ConnectorEnds of the redefined Connector. The 
properties of the ConnectorEnds of the redefining Connector may be replaced.

type : Association [0..1] (opposite A_type_connector::connector)
An optional Association that classifies links corresponding to this Connector.

Unified Modeling Language 2.5

225

11.8.10.6

Operations

•

kind() : ConnectorKind
Derivation for Connector::/kind : ConnectorKind

body: if end->exists(

role.oclIsKindOf(Port)
and partWithPort->isEmpty()
and not role.oclAsType(Port).isBehavior)

then ConnectorKind::delegation
else ConnectorKind::assembly
endif

11.8.10.7

Constraints

•

•

types
The types of the ConnectableElements that the ends of a Connector are attached to must conform to the types 
of the ends of the Association that types the Connector, if any.

inv: type<>null implies
  let noOfEnds : Integer = end->size() in
  (type.memberEnd->size() = noOfEnds) and Sequence{1..noOfEnds}->forAll(i | end-
>at(i).role.type.conformsTo(type.memberEnd->at(i).type))

roles
The ConnectableElements attached as roles to each ConnectorEnd owned by a Connector must be owned or 
inherited roles of the Classifier that owned the Connector, or they must be Ports of such roles.

inv: structuredClassifier <> null
and
  end->forAll( e | structuredClassifier.allRoles()->includes(e.role)
or
  e.role.oclIsKindOf(Port) and structuredClassifier.allRoles()->includes(e.partWithPort))

11.8.11

ConnectorEnd [Class]

11.8.11.1

Description

A ConnectorEnd is an endpoint of a Connector, which attaches the Connector to a ConnectableElement.

11.8.11.2

Diagrams

Encapsulated Classifiers, Structured Classifiers

11.8.11.3

Generalizations

MultiplicityElement

11.8.11.4

Association Ends

•

•

226

/definingEnd : Property [0..1]{} (opposite A_definingEnd_connectorEnd::connectorEnd)
A derived property referencing the corresponding end on the Association which types the Connector owing this 
ConnectorEnd, if any. It is derived by selecting the end at the same place in the ordering of Association ends as 
this ConnectorEnd.

partWithPort : Property [0..1] (opposite A_partWithPort_connectorEnd::connectorEnd)
Indicates the role of the internal structure of a Classifier with the Port to which the ConnectorEnd is attached.

Unified Modeling Language 2.5

•

role : ConnectableElement [1..1] (opposite ConnectableElement::end)
The ConnectableElement attached at this ConnectorEnd. When an instance of the containing Classifier is 
created, a link may (depending on the multiplicities) be created to an instance of the Classifier that types this 
ConnectableElement.

11.8.11.5

Operations

•

definingEnd() : Property [0..1]
Derivation for ConnectorEnd::/definingEnd : Property

body: if connector.type = null
then
  null
else
  let index : Integer = connector.end->indexOf(self) in
    connector.type.memberEnd->at(index)
endif

11.8.11.6

Constraints

•

•

role_and_part_with_port
If a ConnectorEnd references a partWithPort, then the role must be a Port that is defined or inherited by the 
type of the partWithPort.

inv: partWithPort->notEmpty() implies
  (role.oclIsKindOf(Port) and partWithPort.type.oclAsType(Namespace).member->includes(role))

part_with_port_empty
If a ConnectorEnd is attached to a Port of the containing Classifier, partWithPort will be empty.

inv: (role.oclIsKindOf(Port) and role.owner = connector.owner) implies partWithPort-
>isEmpty()

• multiplicity

The multiplicity of the ConnectorEnd may not be more general than the multiplicity of the corresponding end 
of the Association typing the owning Connector, if any.

inv: self.compatibleWith(definingEnd)

•

self_part_with_port
The Property held in self.partWithPort must not be a Port.

inv: partWithPort->notEmpty() implies not partWithPort.oclIsKindOf(Port)

11.8.12

ConnectorKind [Enumeration]

11.8.12.1

Description

ConnectorKind is an enumeration that defines whether a Connector is an assembly or a delegation.

11.8.12.2

Diagrams

•

Structured Classifiers
 

 

Unified Modeling Language 2.5

227

11.8.12.3

Literals

•

•

assembly
Indicates that the Connector is an assembly Connector.

delegation
Indicates that the Connector is a delegation Connector.

11.8.13

EncapsulatedClassifier [Abstract Class]

11.8.13.1

Description

An EncapsulatedClassifier may own Ports to specify typed interaction points.

11.8.13.2

Diagrams

Encapsulated Classifiers, Classes

11.8.13.3

Generalizations

StructuredClassifier

11.8.13.4

Specializations

Class

11.8.13.5

Association Ends

•

♦ /ownedPort : Port [0..*]{subsets StructuredClassifier::ownedAttribute} (opposite 
A_ownedPort_encapsulatedClassifier::encapsulatedClassifier)
The Ports owned by the EncapsulatedClassifier.

11.8.13.6

Operations

•

ownedPort() : Port [0..*]{ordered}
Derivation for EncapsulatedClassifier::/ownedPort : Port

body: ownedAttribute->select(oclIsKindOf(Port))->collect(oclAsType(Port))->asOrderedSet()

11.8.14

Port [Class]

11.8.14.1

Description

A Port is a property of an EncapsulatedClassifier that specifies a distinct interaction point between that 
EncapsulatedClassifier and its environment or between the (behavior of the) EncapsulatedClassifier and its internal 
parts. Ports are connected to Properties of the EncapsulatedClassifier by Connectors through which requests can be 
made to invoke BehavioralFeatures. A Port may specify the services an EncapsulatedClassifier provides (offers) to its 
environment as well as the services that an EncapsulatedClassifier expects (requires) of its environment. A Port may 
have an associated ProtocolStateMachine.

11.8.14.2

Diagrams

Encapsulated Classifiers, Events, Invocation Actions

228

Unified Modeling Language 2.5

11.8.14.3

Generalizations

Property

11.8.14.4

Attributes

•

•

•

isBehavior : Boolean [1..1] = false
Specifies whether requests arriving at this Port are sent to the classifier behavior of this EncapsulatedClassifier. 
Such a Port is referred to as a behavior Port. Any invocation of a BehavioralFeature targeted at a behavior Port 
will be handled by the instance of the owning EncapsulatedClassifier itself, rather than by any instances that it 
may contain.

isConjugated : Boolean [1..1] = false
Specifies the way that the provided and required Interfaces are derived from the Port’s Type.

isService : Boolean [1..1] = true
If true, indicates that this Port is used to provide the published functionality of an EncapsulatedClassifier. If 
false, this Port is used to implement the EncapsulatedClassifier but is not part of the essential externally-visible 
functionality of the EncapsulatedClassifier and can, therefore, be altered or deleted along with the internal 
implementation of the EncapsulatedClassifier and other properties that are considered part of its 
implementation.

11.8.14.5

Association Ends

•

•

•

•

protocol : ProtocolStateMachine [0..1] (opposite A_protocol_port::port)
An optional ProtocolStateMachine which describes valid interactions at this interaction point.

/provided : Interface [0..*]{} (opposite A_provided_port::port)
The Interfaces specifying the set of Operations and Receptions that the EncapsulatedClassifier offers to its 
environment via this Port, and which it will handle either directly or by forwarding it to a part of its internal 
structure. This association is derived according to the value of isConjugated. If isConjugated is false, provided 
is derived as the union of the sets of Interfaces realized by the type of the port and its supertypes, or directly 
from the type of the Port if the Port is typed by an Interface. If isConjugated is true, it is derived as the union of 
the sets of Interfaces used by the type of the Port and its supertypes.

redefinedPort : Port [0..*]{subsets Property::redefinedProperty} (opposite A_redefinedPort_port::port)
A Port may be redefined when its containing EncapsulatedClassifier is specialized. The redefining Port may 
have additional Interfaces to those that are associated with the redefined Port or it may replace an Interface by 
one of its subtypes.

/required : Interface [0..*]{} (opposite A_required_port::port)
The Interfaces specifying the set of Operations and Receptions that the EncapsulatedCassifier expects its 
environment to handle via this port. This association is derived according to the value of isConjugated. If 
isConjugated is false, required is derived as the union of the sets of Interfaces used by the type of the Port and 
its supertypes. If isConjugated is true, it is derived as the union of the sets of Interfaces realized by the type of 
the Port and its supertypes, or directly from the type of the Port if the Port is typed by an Interface.

11.8.14.6

Operations

•

provided() : Interface [0..*]
Derivation for Port::/provided

body: if isConjugated then basicRequired() else basicProvided() endif

Unified Modeling Language 2.5

229

•

•

•

required() : Interface [0..*]
Derivation for Port::/required

body: if isConjugated then basicProvided() else basicRequired() endif

basicProvided() : Interface [0..*]
The union of the sets of Interfaces realized by the type of the Port and its supertypes, or directly the type of the 
Port if the Port is typed by an Interface.

body: if type.oclIsKindOf(Interface)
then type.oclAsType(Interface)->asSet()
else type.oclAsType(Classifier).allRealizedInterfaces()
endif

basicRequired() : Interface [0..*]
The union of the sets of Interfaces used by the type of the Port and its supertypes.

body:  type.oclAsType(Classifier).allUsedInterfaces()

11.8.14.7

Constraints

•

•

•

port_aggregation
Port.aggregation must be composite.

inv: aggregation = AggregationKind::composite

default_value
A defaultValue for port cannot be specified when the type of the Port is an Interface.

inv: type.oclIsKindOf(Interface) implies defaultValue->isEmpty()

encapsulated_owner
All Ports are owned by an EncapsulatedClassifier.

inv: owner = encapsulatedClassifier

11.8.15

StructuredClassifier [Abstract Class]

11.8.15.1

Description

StructuredClassifiers may contain an internal structure of connected elements each of which plays a role in the overall 
Behavior modeled by the StructuredClassifier.

11.8.15.2

Diagrams

Encapsulated Classifiers, Structured Classifiers, Collaborations

11.8.15.3

Generalizations

Classifier

11.8.15.4

Specializations

Collaboration, EncapsulatedClassifier

230

Unified Modeling Language 2.5

11.8.15.5

Association Ends

•

•

•

•

♦ ownedAttribute : Property [0..*]{ordered, subsets Classifier::attribute, subsets StructuredClassifier::role, 
subsets Namespace::ownedMember} (opposite A_ownedAttribute_structuredClassifier::structuredClassifier)
The Properties owned by the StructuredClassifier.

♦ ownedConnector : Connector [0..*]{subsets Classifier::feature, subsets 
A_redefinitionContext_redefinableElement::redefinableElement, subsets Namespace::ownedMember} 
(opposite A_ownedConnector_structuredClassifier::structuredClassifier)
The connectors owned by the StructuredClassifier.

/part : Property [0..*]{} (opposite A_part_structuredClassifier::structuredClassifier)
The Properties specifying instances that the StructuredClassifier owns by composition. This collection is 
derived, selecting those owned Properties where isComposite is true.

/role : ConnectableElement [0..*]{union, subsets Namespace::member} (opposite 
A_role_structuredClassifier::structuredClassifier)
The roles that instances may play in this StructuredClassifier.

11.8.15.6

Operations

•

•

part() : Property [0..*]
Derivation for StructuredClassifier::/part

body: ownedAttribute->select(isComposite)

allRoles() : ConnectableElement [0..*]
All features of type ConnectableElement, equivalent to all direct and inherited roles.

body: allFeatures()->select(oclIsKindOf(ConnectableElement))-
>collect(oclAsType(ConnectableElement))->asSet()

11.9
11.9.1

Association Descriptions
A_collaborationRole_collaboration [Association]

11.9.1.1

Diagrams

Collaborations

11.9.1.2

Owned Ends

•

collaboration : Collaboration [0..*]{subsets A_role_structuredClassifier::structuredClassifier} (opposite 
Collaboration::collaborationRole)

11.9.2

A_connectableElement_templateParameter_parameteredElement 
[Association]

11.9.2.1

Diagrams

Structured Classifiers

Unified Modeling Language 2.5

231

11.9.2.2

Member Ends

 

• ConnectableElement::templateParameter
• ConnectableElementTemplateParameter::parameteredElement

 

 

 

11.9.3

11.9.3.1

A_contract_connector [Association]

Diagrams

Structured Classifiers

11.9.3.2

Owned Ends

•

11.9.4

11.9.4.1

connector : Connector [0..*] (opposite Connector::contract)

A_definingEnd_connectorEnd [Association]

Diagrams

Structured Classifiers

11.9.4.2

Owned Ends

•

11.9.5

11.9.5.1

connectorEnd : ConnectorEnd [0..*] (opposite ConnectorEnd::definingEnd)

A_endType_association [Association]

Diagrams

Associations

11.9.5.2

Owned Ends

•

11.9.6

11.9.6.1

association : Association [0..*]{subsets A_relatedElement_relationship::relationship} (opposite 
Association::endType)

A_end_connector [Association]

Diagrams

Structured Classifiers

11.9.6.2

Owned Ends

•

11.9.7

11.9.7.1

232

connector : Connector [1..1]{subsets Element::owner} (opposite Connector::end)

A_end_role [Association]

Diagrams

Structured Classifiers

Unified Modeling Language 2.5

11.9.7.2

Member Ends
• ConnectableElement::end
• ConnectorEnd::role

 

 

 

 

11.9.8

11.9.8.1

A_extension_metaclass [Association]

Diagrams

Classes, Profiles

11.9.8.2

Member Ends

 

• Class::extension
 
•

Extension::metaclass
 
 

11.9.9

11.9.9.1

A_memberEnd_association [Association]

Diagrams

Associations, Properties

11.9.9.2

Member Ends
• Association::memberEnd
 
•

Property::association
 
 

 

11.9.10

A_navigableOwnedEnd_association [Association]

11.9.10.1

Diagrams

Associations

11.9.10.2

Owned Ends

•

association : Association [0..1]{subsets Property::owningAssociation} (opposite 
Association::navigableOwnedEnd)

11.9.11

A_nestedClassifier_nestingClass [Association]

11.9.11.1

Diagrams

Classes

11.9.11.2

Owned Ends

•

nestingClass : Class [0..1]{subsets NamedElement::namespace, subsets 
RedefinableElement::redefinitionContext} (opposite Class::nestedClassifier)

Unified Modeling Language 2.5

233

11.9.12

A_ownedAttribute_class [Association]

11.9.12.1

Diagrams

Classes, Properties

11.9.12.2

Member Ends
• Class::ownedAttribute
 
•

Property::class
 
 

 

11.9.13

A_ownedAttribute_structuredClassifier [Association]

11.9.13.1

Diagrams

Structured Classifiers

11.9.13.2

Generalizations

A_role_structuredClassifier

11.9.13.3

Owned Ends

•

structuredClassifier : StructuredClassifier [0..1]{subsets NamedElement::namespace, subsets 
A_attribute_classifier::classifier, redefines A_role_structuredClassifier::structuredClassifier} (opposite 
StructuredClassifier::ownedAttribute)

11.9.14

A_ownedConnector_structuredClassifier [Association]

11.9.14.1

Diagrams

Structured Classifiers

11.9.14.2

Owned Ends

•

structuredClassifier : StructuredClassifier [0..1]{subsets Feature::featuringClassifier, subsets 
NamedElement::namespace, subsets RedefinableElement::redefinitionContext} (opposite 
StructuredClassifier::ownedConnector)

11.9.15

A_ownedEnd_owningAssociation [Association]

11.9.15.1

Diagrams

Associations, Properties

11.9.15.2

Member Ends
• Association::ownedEnd
 
•

 

Property::owningAssociation
 
 

234

Unified Modeling Language 2.5

11.9.16

A_ownedOperation_class [Association]

11.9.16.1

Diagrams

Classes, Operations

11.9.16.2

 

 

Member Ends
• Class::ownedOperation
• Operation::class

 

 

11.9.17

A_ownedPort_encapsulatedClassifier [Association]

11.9.17.1

Diagrams

Encapsulated Classifiers

11.9.17.2

Owned Ends

•

encapsulatedClassifier : EncapsulatedClassifier [0..1]{subsets 
A_ownedAttribute_structuredClassifier::structuredClassifier} (opposite EncapsulatedClassifier::ownedPort)

11.9.18

A_ownedReception_class [Association]

11.9.18.1

Diagrams

Classes

11.9.18.2

Owned Ends

•

class : Class [0..1]{subsets Feature::featuringClassifier, subsets NamedElement::namespace} (opposite 
Class::ownedReception)

11.9.19

A_packagedElement_component [Association]

11.9.19.1

Diagrams

Components

11.9.19.2

Owned Ends

•

component : Component [0..1]{subsets NamedElement::namespace} (opposite Component::packagedElement)

11.9.20

A_partWithPort_connectorEnd [Association]

11.9.20.1

Diagrams

Encapsulated Classifiers

11.9.20.2

Owned Ends

•

connectorEnd : ConnectorEnd [0..*] (opposite ConnectorEnd::partWithPort)

Unified Modeling Language 2.5

235

11.9.21

A_part_structuredClassifier [Association]

11.9.21.1

Diagrams

Structured Classifiers

11.9.21.2

Owned Ends

•

structuredClassifier : StructuredClassifier [0..1] (opposite StructuredClassifier::part)

11.9.22

A_protocol_port [Association]

11.9.22.1

Diagrams

Encapsulated Classifiers

11.9.22.2

Owned Ends

•

port : Port [0..*] (opposite Port::protocol)

11.9.23

A_provided_component [Association]

11.9.23.1

Diagrams

Components

11.9.23.2

Owned Ends

•

component : Component [0..*] (opposite Component::provided)

11.9.24

A_provided_port [Association]

11.9.24.1

Diagrams

Encapsulated Classifiers

11.9.24.2

Owned Ends

•

port : Port [0..*] (opposite Port::provided)

11.9.25

A_realization_abstraction_component [Association]

11.9.25.1

Diagrams

Components

11.9.25.2

Member Ends
• Component::realization
 
• ComponentRealization::abstraction

 

 

 

236

Unified Modeling Language 2.5

11.9.26

A_realizingClassifier_componentRealization [Association]

11.9.26.1

Diagrams

Components

11.9.26.2

Owned Ends

•

componentRealization : ComponentRealization [0..*]{subsets NamedElement::clientDependency} (opposite 
ComponentRealization::realizingClassifier)

11.9.27

A_redefinedConnector_connector [Association]

11.9.27.1

Diagrams

Structured Classifiers

11.9.27.2

Owned Ends

•

connector : Connector [0..*]{subsets A_redefinedElement_redefinableElement::redefinableElement} (opposite
Connector::redefinedConnector)

11.9.28

A_redefinedPort_port [Association]

11.9.28.1

Diagrams

Encapsulated Classifiers

11.9.28.2

Owned Ends

•

port : Port [0..*]{subsets A_redefinedProperty_property::property} (opposite Port::redefinedPort)

11.9.29

A_required_component [Association]

11.9.29.1

Diagrams

Components

11.9.29.2

Owned Ends

•

component : Component [0..*] (opposite Component::required)

11.9.30

A_required_port [Association]

11.9.30.1

Diagrams

Encapsulated Classifiers

11.9.30.2

Owned Ends

•

port : Port [0..*] (opposite Port::required)

Unified Modeling Language 2.5

237

11.9.31

A_roleBinding_collaborationUse [Association]

11.9.31.1

Diagrams

Collaborations

11.9.31.2

Owned Ends

•

collaborationUse : CollaborationUse [0..1]{subsets Element::owner} (opposite CollaborationUse::roleBinding)

11.9.32

A_role_structuredClassifier [Association]

11.9.32.1

Diagrams

Structured Classifiers

11.9.32.2

Specializations

A_ownedAttribute_structuredClassifier

11.9.32.3

Owned Ends

•

/structuredClassifier : StructuredClassifier [0..*]{union, subsets 
A_member_memberNamespace::memberNamespace} (opposite StructuredClassifier::role)

11.9.33

A_superClass_class [Association]

11.9.33.1

Diagrams

Classes

11.9.33.2

Owned Ends

•

class : Class [0..*]{subsets A_general_classifier::classifier} (opposite Class::superClass)

11.9.34

A_type_collaborationUse [Association]

11.9.34.1

Diagrams

Collaborations

11.9.34.2

Owned Ends

•

collaborationUse : CollaborationUse [0..*] (opposite CollaborationUse::type)

11.9.35

A_type_connector [Association]

11.9.35.1

Diagrams

Structured Classifiers

11.9.35.2

Owned Ends

connector : Connector [0..*] (opposite Connector::type)

•

238

Unified Modeling Language 2.5

12 Packages
Summary
12.1
Packages provide the main generic structuring and organizing capability of UML. There are specializations for Models 
and for Profiles which organize extensions to UML.

Packages
Summary

12.2
12.2.1
This sub clause provides the specification for Packages and Models.

12.2.2

Abstract Syntax

TemplateableElement

Namespace

PackageableElement

{subsets ownedMember}

* + packagedElement

Package
+ URI : String [0..1]

{subsets namespace}
+ owningPackage

0..1

{subsets owningPackage}

{subsets packagedElement}

+ package

0..1

+ /ownedType

*

Type

{subsets source,
subsets owner}
+ receivingPackage

1
{subsets target}
+ mergedPackage
1

DirectedRelationship

{subsets ownedElement,
subsets directedRelationship}

+ packageMerge
*

PackageMerge

{subsets directedRelationship}
+ packageMerge

*

{subsets packagedElement}
+ /nestedPackage

*

0..1

+ nestingPackage
{subsets owningPackage}

Model

+ viewpoint : String [0..1]

Figure 12.1  Packages

12.2.3

12.2.3.1

Semantics

Package

A Package is a namespace for its members, which comprise those elements associated via packagedElement (which are 
said to be owned or contained), and those imported.
A Package definition can extend the contents of other Packages through the merging of the contained elements.

Unified Modeling Language 2.5

239

A Package may be defined as a template and bound to other templates: see sub clause 7.3, Templates, for further 
information.
The URI can be specified to provide a unique identifier for a Package. Within UML there is no predetermined usage for 
this, with the exception of profiles (see sub clause 12.3.3). It may, for example, be used by model management facilities 
for model identification. The URI should hence be unique and unchanged once assigned. There is no requirement that 
the URI be dereferenceable (though this is of course permitted).

12.2.3.2

PackageMerge

A PackageMerge is a directed relationship between two Packages that indicates that the contents of the target 
mergedPackage are combined into the source receivingPackage according to a set of rules defined below. It is very similar 
to Generalization in the sense that the source element conceptually adds the characteristics of the target element to its 
own characteristics resulting in an element that combines the characteristics of both. Just as a subclass is not normally 
depicted with its inherited features, a receiving Package is not normally depicted with the merged elements from its 
mergedPackages. In terms of model semantics, there is no difference between a model with explicit PackageMerges, and 
a model in which all the merges have been performed. Likewise XMI files containing PackageMerge are semantically 
equivalent to the same XMI files with the PackageMerges expanded.
Also, as with Generalization, a Package may not merge itself (directly or indirectly).
This capability is designed to be used when elements defined in different Packages have the same name and are intended 
to represent the same concept. A given base concept may be merged for different purposes, with each purpose defined in 
a separate receiving Package. By selecting different receiving packages, it is possible to obtain a custom definition of a 
concept for a specific end.
Thus, any reference to a model element contained in the receiving Package implies a reference to the results of the 
merge rather than to the increment that is contained in that Package. This is illustrated by the example in Figure 12.2 in 
which Package P2 defines an increment of Class A originally defined in P1. Package P2 merges the contents of Package 
P1, which implies the merging of P1::A into increment P2::A. Package P3 defines a subclass of P2::A called SubA. In 
this case, element A in Package P2 (P2::A) represents the result of the merge of P1::A into P2::A and not just the 
increment P2::A.
NOTE. If another package were to import P1, then a reference to A in the importing package would represent P1::A 
rather than the A resulting from merge.

Figure 12.2  Illustration of the Meaning of Package Merge

A PackageMerge can be viewed as an operation (that is itself a set of transformations) whereby the contents of the 
Package to be merged are combined with the contents of the receiving Package. In cases in which certain elements in 
the two Packages match (according to defined rules), their contents are (conceptually) merged into a single resulting 
element according to the formal rules of PackageMerge specified below. This operation is akin to “copying down” the 
features of superclasses into a subclass: the fully expanded subclass is the equivalent to the resulting package.
To understand the rules of PackageMerge, it is necessary to clearly distinguish between three distinct entities: the 
mergedPackage (e.g., P1 in Figure 12.2), the receivingPackage (e.g., P2), and the result of the merge transformations (also 
P2). The receivingPackage also plays the role of resultingPackage. This dual interpretation of the same model element can 
be confusing, so it is useful to introduce the following terminology that aids understanding:

• merged package - the package that is to be merged into the receiving package (this is the package that is the 

target of the merge arrow in the diagrams).

240

Unified Modeling Language 2.5

•

•

receiving package - the package that, conceptually, contains the results of the merge (and which is the source 
of the merge arrow in the diagrams). However, this term is used to refer to the package and its contents before 
the merge transformations have been performed.

resulting package - the package that, conceptually, contains the results of the merge. In the model, this is, of 
course, the same package as the receiving package, but this particular term is used to refer to the package and 
its contents after the merge has been performed.

• merged element - refers to a model element that exists in the merged package.

•

•

•

•

receiving element - is a model element in the receiving package. If the element has a matching (as defined 
below) merged element, the two are combined to produce the resulting element (see below). This term is used 
to refer to the element before the merge has been performed.

resulting element - is a model element in the resulting package after the merge was performed. For receiving 
elements that have a matching merged element, this is the combined element after the merge was performed. 
For merged elements that have no matching receiving element, this is the same as the merged element. For 
receiving elements that have no matching merged element, this is the same as the receiving element.

element type - refers to the type of any kind of TypedElement, such as the type of a Parameter or 
StructuralFeature.

element metatype - is the MOF type of a model element (e.g., Classifier, Association, Feature).

This terminology is based on a conceptual view of PackageMerge that is represented by the schematic diagram in
Figure 12.3 (NB: this is not a UML diagram). The packagedElements (direct and indirect) of Packages A and B are all 
incorporated into the namespace of Package B'. However, it is important to emphasize that this view is merely a 
convenience for describing the semantics of PackageMerge and is not reflected in the stored model, that is, the physical 
model itself is not transformed in any way by the presence of PackageMerges.

Figure 12.3  Conceptual View of the Package Merge Semantics

The semantics of PackageMerge are defined by a set of constraints and transformations. The constraints specify the 
preconditions for a valid PackageMerge, while the transformations describe its semantic effects (i.e., postconditions). If 
any constraints are violated, the PackageMerge is ill-formed and the model that contains it is invalid. Different element 
metatypes have different semantics, but the general principle is always the same: a resulting element will not be any less 

Unified Modeling Language 2.5

241

capable than it was prior to the merge: meaning, for instance, that the resulting navigability, multiplicity, visibility, etc. 
of a receiving model element will not be reduced as a result of a PackageMerge. One of the key consequences of this is 
that model elements in the resulting Package are compatible extensions of the corresponding elements in the 
(unmerged) receiving package.
In this specification, explicit merge transformations are only defined for certain general element metatypes found 
mostly in metamodels (Packages, Classes, Associations, Properties, etc.), as the semantics of merging other kinds of 
element metatypes (e.g., state machines, interactions) are complex and domain specific. Elements of all other kinds of 
metatypes are transformed according to the default rule: they are simply deep copied into the resulting package. (This 
rule can be superseded for specific metatypes through profiles or other kinds of language extensions.)

12.2.3.3

General Package Merge Rules

A merged element and a receiving element match if they satisfy the matching rules for their metatype.
CONSTRAINTS:

1

There can be no cycles in the «merge» directed graph.

2 A Package cannot merge a Package in which it is contained (via owningPackage – direct or indirect).

3 A Package cannot merge a Package that it contains (via packagedElement – direct or indirect).

4 A merged element whose metatype is not a kind of Package, Class, DataType, Property, Association, 

Operation, Constraint, Enumeration, or EnumerationLiteral cannot have a receiving element with the same 
name and metatype unless that receiving element is an exact copy of the merged element (i.e., they are the 
same).

5 A PackageMerge is valid if and only if all the constraints (in this clause) required to perform the merge are 

satisfied.

6 Matching typed elements (e.g., Properties, Parameters) must have conforming types. For types that are Classes 

or Datatypes, a conforming type is either the same type or a common supertype. For all other cases, 
conformance means that the types must be the same.

7 A receiving element cannot have explicit references to any merged element.

8 Any redefinitions associated with matching RedefinableElements must not be conflicting.

TRANSFORMATIONS:

1

2

(The default rule) Merged or receiving elements for which there is no matching element are deep copied into 
the resulting package.

The result of merging two elements with matching names and metatypes that are exact copies of each other is 
the receiving element.

3 Matching elements are combined according to the transformation rules specific to their metatype and the 

results included in the resulting Package.

4 All type references to typed elements that end up in the resulting package are transformed into references to the 

corresponding resulting TypedElements (i.e., not to their respective increments).

5

For all matching elements: if both matching elements have private visibility, the resulting element will have 
private visibility; otherwise, the resulting element will have public visibility.

242

Unified Modeling Language 2.5

6

7

8

9

For all matching Classifier elements: if both matching elements have isAbstract = true, the resulting element 
has isAbstract = true; otherwise, the resulting element has isAbstract = false.

For all matching Classifier elements: if both matching elements has isFinalSpecialization = true, the resulting 
element has isFinalSpecialization = true; otherwise, the resulting element has isFinalSpecialization = false.

For all matching elements: if both matching elements are not derived, the resulting element is also not derived; 
otherwise, the resulting element is derived.

For all matching MultiplicityElements: the lower bound of the resulting element is the lesser of the lower bounds 
of the matching elements.

10 For all matching MultiplicityElements: the upper bound of the resulting element is the greater of the upper 

bounds of the matching elements.

11 Any stereotypes applied to a model element in either a merged or receiving element are also applied to the 

corresponding resulting element.

12 For matching RedefinableElements: different redefinitions of matching RedefinableElements are all applied to 

the resulting element.

13 For matching RedefinableElements: if both matching elements have isLeaf = true, the resulting element also 

has isLeaf = true; otherwise, the resulting element has isLeaf = false.

12.2.3.4

Package Rules

Elements that are kinds of Package match by name and metatype
CONSTRAINTS:

1 All Classifiers in the merged Package must have a non-empty qualifiedName and have isDistinguishableFrom() = 

true in the merged Package.

2 All Classifiers in the receiving Package must have a non-empty qualifiedName and have isDistinguishableFrom() = 

true in the receiving Package.

TRANSFORMATIONS:

1 A nestedPackage from the merged Package is transformed into a nestedPackage with the same name and contents 

in the resulting Package, unless the receiving Package already contains a nestedPackage that matches. In the 
latter case, the merged nestedPackage is recursively merged with the matching receiving nestedPackage.

2 An ElementImport which is an elementImport of the receiving Package is transformed into a corresponding 

ElementImport in the resulting Package. Imported elements are not merged (unless there is also a 
PackageMerge to the Package owning the imported element).

12.2.3.5

Class and DataType Rules

Elements that are kinds of Class or DataType match by name and metatype.
TRANSFORMATIONS:

1 All Properties that are ownedAttributes of the merged Classifier are merged with the receiving Classifier to 

produce the resulting Classifier according to the Property transformation rules specified below.

Unified Modeling Language 2.5

243

2

nestedClassifiers are merged recursively according to the same rules.

12.2.3.6

Property Rules

Elements that are kinds of Property match by name and metatype.
CONSTRAINTS:

1

2

The value of isStatic of matching Properties must be the same.

The value of isUnique of matching Properties must be the same.

3 Any Constraints associated with matching Properties must not be conflicting.

TRANSFORMATIONS:

1

2

3

4

5

6

7

8

For merged Properties that do not have a matching receiving Property, the resulting Property is a Property in 
the resulting Classifier that is the same as the merged Property.

For merged Properties that have a matching receiving Property, the resulting Property is a Property with the 
same name and characteristics except where these characteristics are different. Where these characteristics are 
different, the resulting Property characteristics are determined by application of the appropriate transformation 
rules.

For matching Properties: if both Properties have isReadOnly = true, the resulting Property also has isReadOnly = 
true; otherwise, the resulting Property has isReadOnly = false.

For matching Properties: if both Properties have isOrdered = false, then the resulting Property also has isOrdered
= false; otherwise, the resulting Property has isOrdered = true.

For matching Properties: if neither Property is designated as a subset of some derived union, then the resulting 
Property will not be designated as a subset; otherwise, the resulting Property will be designated as a subset of 
that derived union.

For matching Properties: different Constraints of matching Properties are all applied to the resulting Property.

For matching Properties: if either the merged and/or receiving elements have isUnique = false, the resulting 
element has isUnique = false; otherwise, the resulting element has isUnique = true.

The value of type for the resulting Property is transformed to refer to the corresponding type in the resulting 
Package.

12.2.3.7

Association Rules

Elements that are kinds of Association match by name and metatype.
CONSTRAINTS:

1

2

3

244

These rules only apply to binary Associations. (For merging n-ary associations the default rule is used)

The receiving association end must have aggregation = composite if the matching merged association end has 
aggregation = composite.

The receiving association end must be owned by the Association if the matching merged association end is 
owned by the Association.

Unified Modeling Language 2.5

TRANSFORMATIONS:

1 A merge of matching Associations is accomplished by merging the Association classifiers (using the merge 

rules for Classifiers) and merging their corresponding ownedEnd Properties according to the rules for Properties 
and the following rule for association ends.

2

For matching association ends: if neither association end is in ownedNavigableEnd, then the resulting association 
end is also not in ownedNavigableEnd. In all other cases, the resulting association end is in ownedNavigableEnd.

12.2.3.8

Operation Rules

Elements that are kinds of Operation match by name, Parameter order, and Parameter types, not including any return 
type.
CONSTRAINTS:

1 Operation Parameters and their types must conform to the same rules for type and multiplicity as were defined 

for Properties.

2

The receiving Operation must have isQuery = true if the matching merged Operation has isQuery = true.

TRANSFORMATIONS:

1

2

For merged Operations that do not have a matching receiving Operation, the resulting Operation is an 
Operation with the same name and signature in the resulting classifier.

For merged Operations that have a matching receiving Operation, the resulting Operation is the outcome of a 
merge of the matching merged and receiving Operations, with Parameter transformations performed according 
to the Property transformations defined above.

12.2.3.9

Enumeration Rules

Elements that are kinds of EnumerationLiteral match by owning Enumeration and Literal name.
CONSTRAINTS:

1 Matching EnumerationLiterals must be in the same order.

TRANSFORMATIONS:

1 Non-matching EnumerationLiterals from the merged Enumeration are included in the receiving Enumeration.

12.2.3.10

Constraint Rules

CONSTRAINTS:

1 Constraints must be mutually non-contradictory.

TRANSFORMATIONS:

1

The Constraints of the merged model elements are all added to the Constraints of the matching receiving 
model elements.

12.2.3.11

Model

A Model is a description of a system, where ‘system’ is meant in the broadest sense and may include not only software 
and hardware but organizations and processes. It describes the system from a certain viewpoint (or vantage point) for a 

Unified Modeling Language 2.5

245

certain category of stakeholders (e.g., designers, users, or customers of the system) and at a certain level of abstraction. 
A Model is complete in the sense that it covers the whole system, although only those aspects relevant to its purpose 
(i.e., within the given level of abstraction and viewpoint) are represented in the Model.
As a Package, a Model has a set of members that together describe the system being modeled. The organization of these 
elements varies by the modeling method being used. One approach is one or more composition hierarchies where a top-
most Package/Component represents the boundary of the system. A Model may also contain elements describing 
relevant parts of the system’s environment. The environment is typically modeled by Actors and their Interfaces. As 
these are external to the system, they reside outside the Package/Component hierarchy. They may be collected in a 
separate Package, or owned directly by the Model as packagedElements.
Different Models can be defined for the same system, where typically the different Models are complementary and 
defined from the perspectives (viewpoints) of different system stakeholders. With composition of Models, a container 
model represents a comprehensive view of the system given by the different views defined by the contained Models.
Models can have Abstraction Dependencies between them: refinement (stereotyped by «Refine» from the Standard 
Profile) or mapping ( for example stereotyped by «Trace» from the Standard Profile). These are typically represented in 
more detail by Dependencies between the elements contained in the Models. Relationships between elements in 
different Models generally no direct impact on the contents of the Models because each Model is meant to be complete. 
However, they are useful for tracing refinements and for keeping track of cross-references between models.

Notation

12.2.4
A Package is shown as a large rectangle with a small rectangle (a “tab”) attached to the left side of the top of the large 
rectangle: collectively this represents a ‘folder icon.’ The members of the Package may be shown within the large 
rectangle. Members may also be shown by branching lines to member elements, drawn outside the package. A plus sign 
(+) within a circle is drawn at the end attached to the Package.
Conformant tools may restrict the use of these notations to packagedElements. Optionally, elements that become 
available for use in an importing Package through a PackageImport or an ElementImport may have a distinct color or be 
dimmed to indicate that they are not packagedElements.

•

•

If the members of the Package are not shown within the large rectangle, then the name of the Package should be 
placed within the large rectangle.

If the members of the Package are shown within the large rectangle, then the name of the Package should be 
placed within the tab.

The visibility of a packagedElement may be indicated by preceding the name by a visibility symbol (‘+’ for public and ‘-’ 
for private). Packages may not have protected or package visibility.
A tool may show visibility by a graphic marker, such as color or font. A tool may also show visibility by selectively 
displaying those elements that meet a given visibility level (e.g., only public elements). A diagram showing a Package 
with members need not necessarily show all its members; it may show a subset of the members according to some 
criterion.
The URI for a Package may be indicated with the text {uri = <uri>} following the Package name.
A PackageMerge is shown using a dashed line with an open arrowhead pointing from the receivingPackage (the source) 
to the mergedPackage (the target). In addition, the keyword «merge» is shown near the dashed line.

246

Unified Modeling Language 2.5

Figure 12.4  Notation for Package Merge

A Model is notated using the ordinary Package symbol (a folder icon) with a small triangle in the upper right corner of 
the large rectangle.
Optionally, especially if the members of the Model are shown within the large rectangle, the triangle may be drawn to 
the right of the Model name in the tab.
A Model may also be notated as a Package, using the ordinary Package symbol with the keyword «model» placed above 
the name of the Model.

Examples

12.2.5
There are three alternative representations of the same Package named Types in Figure 12.5. The one on the left just 
shows the Package without revealing any of its members. The middle one shows some of the members within the borders 
of the Package rectangle (and also its URI), and the one to the right shows some of the members using the alternative 
ownership notation.

Figure 12.5  Examples of a Package with Members

In Figure 12.6, packages P and Q are being merged by package R, while package S merges only package Q.

Unified Modeling Language 2.5

247

Figure 12.6  Simple Example of Package Merge

The conceptually resulting packages R and S are shown in Figure 12.7. The expressions in square brackets indicate 
which individual elements were merged to produce the final result, with the “@” character denoting the conceptual 
merge ‘transformation’ as an operator, where X@Y signifies the resulting element from the merge transformation 
applied to matching receiving element X and merged element Y.
NOTE. These expressions are not part of the standard notation, but are included here for explanatory purposes.

Figure 12.7  Simple Example of Transformed Packages Following the Merges

In Figure 12.8, additional PackageMerges are introduced by having Package T, which has no packagedElements of its 
own, merge Packages R and S defined previously.

248

Unified Modeling Language 2.5

Figure 12.8  Introducing Additional Package Merges

In Figure 12.9, the conceptually resulting Package T is depicted. In this Package, the definitions of A, B, C, and D have 
all been brought together.
NOTE. The types of the ends of the Associations that were originally in the packages Q and S have all been updated to 
refer to the appropriate elements in Package T.

Figure 12.9  Result of the Additional Package Merges

Figure 12.10  Three Models Representing Parts of a System

Unified Modeling Language 2.5

249

Figure 12.11  Two Views of One System Collected in a Container Model

Profiles
Summary

12.3
12.3.1
The Profiles clause describes capabilities that allow metaclasses to be extended to adapt them for different purposes. 
This includes the ability to tailor the UML metamodel for different platforms (such as J2EE or .NET) or domains (such 
as real-time or Service Oriented Architecture). The Profiles clause is consistent with the OMG Meta Object Facility 
(MOF).

12.3.1.1

Positioning Profiles versus Metamodels, MOF and UML

UML is reused at several meta-levels in various OMG specifications that deal with modeling. For example, MOF uses it 
to provide the ability to model metamodels. This clause deals with use cases comparable to the MOF at the meta-meta-
level, which is one level higher than the rest of the superstructure specification. In order to allow this, the reference 
metamodel must be defined as an instance of UML that corresponds to its definition using MOF. Thus when defining a 
UML profile, the profile’s stereotypes are defined to extend the UML classes in the normative version of the UML 
metamodel whose XMI serialization is referenced in Annex E.
Profiles are not a first-class extension capability (i.e., it does not allow for creating new metamodels). Rather, the 
intention of Profiles is to give a straightforward mechanism for adapting an existing metamodel with constructs that are 
specific to a particular domain, platform, or method. Each such adaptation is grouped in a Profile. It is not possible to 
remove any of the Constraints that apply to UML using a Profile, but it is possible to add new Constraints that are 
specific to the Profile. The only other restrictions are those inherent in this Profiles clause; there is nothing else that is 
intended to limit the way in which a metamodel is customized.
First-class extensibility is handled through MOF, where there are no restrictions at the metamodel level: it is possible to 
add subclasses and associations as necessary.
There are several reasons why you may want to extend UML:

• Give a terminology that is adapted to a particular platform or domain (for example EJB terminology like 

Home interfaces, Enterprise Java Beans, and Archives).

• Give a syntax for constructs that do not have a notation (such as in the case of Actions).

• Give a different notation for already existing symbols (such as being able to use a picture of a computer 

instead of the ordinary Node symbol to represent a computer in a network).

• Add additional semantics to UML or specific metaclasses.

• Add types that do not exist in UML (such as defining a timer, clock, or continuous time).

250

Unified Modeling Language 2.5

• Add Constraints that restrict the way UML’s constructs are used (such as disallowing multiple 

inheritance).

• Add information that can be used when transforming a model to another model or code (such as defining 

mapping rules between a model and Java code).

There is no simple answer for when to create a new metamodel, when to create a new profile, and when to create both 
(one for UML tooling, the other for MOF-based tooling).

12.3.2

Abstract Syntax

DirectedRelationship

ProfileApplication

+ isStrict : Boolean = false

{subsets ownedElement, subsets
directedRelationship}
+ profileApplication

*

{subsets directedRelationship}
+ profileApplication

{subsets target}
+ appliedProfile

*

1

{subsets source,
subsets owner}
+ applyingPackage

1

Profile

Package

Class

{redefines owningPackage}
+ owningPackage

1

{readOnly}
+ /metaclass

{readOnly}
+ /extension

1

*

{readOnly, subsets packagedElement}

+ /ownedStereotype

*

+ /profile

+ stereotype

Stereotype

*

1

{subsets owner}

0..1 + stereotype

{subsets
importingNamespace}
+ profile

0..1

1
{readOnly}

{subsets
importingNamespace}

0..1 + profile

{subsets packageImport}
+ metamodelReference

*

{subsets elementImport}
+ metaclassReference

*

PackageImport

ElementImport

Figure 12.12  Profiles

12.3.3

12.3.3.1

Semantics

Profiles

Association

Extension

+ /isRequired : Boolean {readOnly}

{subsets owningAssociation}

+ extension

{redefines ownedEnd}

+ ownedEnd

1

1

ExtensionEnd

+ /lower : Integer [0..1] {redefines lower}

{redefines type}
+ type

*
+ extensionEnd
{subsets typedElement}

{subsets ownedElement}
+ icon

*

Property

Image

+ content : String [0..1]
+ format : String [0..1]
+ location : String [0..1]

Element

A Profile is a restricted form of metamodel that can be used to extend UML, as described below. The primary extension 
construct is the Stereotype.

Restricting Availability of UML Elements

12.3.3.1.1
The metaclassReference ElementImports and metamodelReference PackageImports may be used to specify the Profile’s 
filtering rules. The filtering rules determine which UML elements are available when the Profile is applied and which 
ones are hidden.
NOTE. Applying a Profile to a model does not change that model in any way; it merely defines a view of the 
underlying model.
The effects of a metaclass being hidden (not available) are as follows:

Unified Modeling Language 2.5

251

•

•

•

It is not possible to create new instances of that metaclass (or its subclasses).

Existing instances of that metaclass (or its subclasses) can no longer be seen in diagrams or selected in lists, 
including browser panes.

Relationships with existing instances of that metaclass (or its subclasses) can no longer be seen in diagrams or 
selected in lists, including browser panes.

Tools may vary in how they implement the above – for example they may hide the metaclass/instances completely in 
selection lists or make them grayed out/unselectable .
In order for the filtering rules (described further below) on a Profile to be activated, the Profile must be applied in Strict 
mode: specifically the isStrict attribute on the ProfileApplication must be set to true; otherwise the filtering rules are 
ignored for this profile application.
The most common case is when a Profile imports UML itself using a metamodelReference. A conformant tool may 
provide this as built-in behavior when the user creates a Profile. In that case, every UML metaclass is available. 
Alternatively, specific metaclasses could be referenced through metaclassReferences and only those would then be 
available. A further option is to use one or more metamodelReferences to Package(s) that contain ElementImports for a 
subset of UML metaclasses. This allows the set to be reusable across many Profiles without having to specify individual
metaclassReferences each time.
The visibility and alias properties of ElementImports are ignored when it is used as a metaclassReference.
Where both a metaclassReference and a metamodelReference are present on a profile, the latter is ignored and only the 
specific metaclasses are available.
In detail, the following rules are used to determine whether a model element is available after a Profile has been applied 
in Strict mode. Metaclasses and their instances are available if they are:

1

2

3

referenced by an explicit metaclassReference, or

(in the absence of a metaclassReference) members (directly or transitively) of a Package that is referenced by an 
explicit metamodelReference, or

extended by a Stereotype which is a member of the applied profile (even if the extended metaclass itself is not 
available).

All other model elements are hidden (not available) when the Profile is applied in Strict mode.
This makes invalid the combination of applied profiles that specify non-overlapping (disjoint) sets of available 
metaclasses.
If a Profile P1 imports another Profile P2, then all metaclassReference and metamodelReference associations will be 
combined at the P1 level, and the filtering rules apply to this union. Stereotypes imported from another Profile using 
ElementImport or PackageImport are added to the namespace members of the importing profile.Profile Contents.
A Profile can define or import Classes, Associations, DataTypes, PrimitiveTypes and Enumerations as well as 
Stereotypes. More precisely all the constraints of a CMOF-compliant metamodel apply to a UML Profile. These are 
defined in detail in Section 14.4 of the MOF Core Specification. The effect of these constraints is that, except for 
Stereotypes and Extensions, all other Types defined or imported in a Profile must be exactly one of the Types explicitly 
mentioned in the above subset and that no specialization outside this subset is allowed. The term Profile-defined Type 
corresponds to a CMOF-compliant Class, Association, DataType, PrimitiveType or Enumeration defined or imported in 
a Profile.
Profile-defined Types can only be used as the type of Properties in that Profile or as a general classifier of another 
Profile-defined Type. They cannot be used as Types in models the Profile is applied to, such as the type of a 
TypedElement, the classifier of an InstanceSpecification or the general or specific classifier in a Generalization 

252

Unified Modeling Language 2.5

relationship. It is however possible to define these types in separate Packages and import them as needed in both 
Profiles and model Packages in order to use them for both purposes.
Stereotypes can participate only in binary Associations. The opposite class can be another Stereotype, a non-Stereotype 
Class that is a packagedElement of a Profile (directly or indirectly), or a UML metaclass. For these Associations there 
must be an ownedAttribute Property typed by the opposite class. Where the opposite class is not a stereotype, the opposite 
property must be an ownedMember of the Association itself rather than the other class/metaclass. The effect of these rules 
is that Associations in a Profile are not required to involve a Stereotype but may not own both of their Ends. According 
to CMOF-compliant metamodel constraints, Profile-defined binary Associations may have at most one end with 
aggregation = AggregationKind::composite; other ends shall have aggregation = AggregationKind::none. Furthermore, 
a Property of a Stereotype or Profile-defined Class can have composite aggregation if and only if its type is a Profile-
defined Class whereas a Property of a Stereotype or Profile-defined Class or DataType shall have aggregation = 
AggregationKind::none if its type is a Profile-defined DataType, PrimitiveType, or Enumeration.
The most direct implementation of the Profile capability that a tool can provide is by having a metamodel based 
implementation, similar to the Profile metamodel. However, this is not a requirement of the current standard, which 
requires only the support of the specification, and the standard XMI based interchange capacities. The Profile capability 
has been designed to be implementable by tools that do not have a metamodel-based implementation. Practically any 
mechanism used to attach new values to model elements can serve as a valid profile implementation; however, creating 
such values requires a limited metamodel-like capability for creating and referring to instances of Profile-defined 
Classes and DataTypes as the values of Properties typed by such Classes or DataTypes and for referring to instances of 
Profile-defined Classes for creating link instances of Profile-defined Associations. As an example, the UML1.4 profile 
metamodel could be the basis for implementing a UML2-compliant profile tool.

Integrating and Extending Profiles

12.3.3.1.2
There is a number of ways to create, extend, and integrate Profiles. These are described briefly in this sub clause in 
order to foster better profile integration and reuse.
The simplest form of Profile integration is to simply apply multiple Profiles to the same Package. This requires no 
integration between the Profiles at all. Such Profiles might be designed to complement each other, addressing different 
concerns.
It is also possible for one Profile to reuse all of or parts of another, and to extend other Profiles. Like any other Class, 
Stereotypes can be defined in Packages or Profiles that can be factored for reuse. These Stereotypes can be directly 
reused by being referenced or specialized in other Profiles. Normal rules apply as to whether a referenced Stereotype is 
visible to users of the extending Profile.: a public import is needed to ensure that Stereotypes from other profiles are 
visible after applying the extending one.
For example, the Unified Profile for DoDAF and MODAF (UPDM) Profile could integrate with the SysML Profile to 
reuse Stereotypes such as Requirement and ViewPoint. UPDM could be designed to use ViewPoint in a manner that is 
semantically consistent with SysML. However UPDM could extend ViewPoint with additional properties and 
associations for its purposes. The UPDM specification could note to users that ViewPoint is a stereotype in UPDM that 
represents a "placeholder" to ViewPoint in SysML. Users could then apply UPDM to a model, and get UPDM's 
ViewPoint capabilities without any coupling with, or need for SysML. UPDM could then provide another compliance 
point that merges with the SysML profile resulting in stereotypes Requirement and ViewPoint having the capabilities of 
both profiles. The SysML::ViewPoint would be merged with the UPDM::ViewPoint allowing the shared semantics to be 
supported without making any changes to the existing model. Users who want UPDM with SysML would then apply 
this merged profile.

MOF-Equivalent Semantics

12.3.3.1.3
This sub clause specifies the semantics of Stereotypes and their instances using MOF. That does not mean that tools 
need implement Profiles using MOF, but that a non-MOF-based implementation must do whatever is necessary under 
the covers to ensure it behaves, in all observable ways, as if it were a MOF implementation.
The same mapping to MOF is used to determine how to serialize applied profiles using XMI. A Profile is an instance of 
the UML2 metamodel, not a CMOF metamodel. Therefore the MOF to XMI mapping rules do not directly apply for 
instances of a Profile. Figure 12.15 is an example of a mapping between a UML2 Profile and an equivalent CMOF 

Unified Modeling Language 2.5

253

model. This mapping is used as a means to explain and formally specify how Profiles are serialized and exchanged as 
XMI. Using the following Profile to CMOF mapping rules, the XMI specification can be used to determine how 
Profiles, and models with Profiles applied, are represented in XMI. In the mapping:

• A Profile maps to a CMOF Package.

• A Stereotype maps to a CMOF class with the same name and properties.

• A Metaclass is already a CMOF class so it maps to itself.

• An Extension maps to an Association as described in the Semantics sub clause of Extension.

• Any other elements in the Profile (i.e., non-Stereotype Classes, DataTypes, PrimitiveTypes, Enumerations and 

Associations) are treated as MOF elements.

• An instance of a Stereotype (created when the Stereotype is applied to an Element) maps to an instance of the 

CMOF class representing the Stereotype. This stereotype instance is compositionally associated with the 
Element to which it applies using a Link that is an instance of the composite Association to which the 
Extension is mapped.

For a Profile the URI Property (inherited from Package) is used to determine the nsURI to be used to identify instances 
of the Profile in XMI.
NOTE. By default the name attribute of the Profile is used for the nsPrefix in XMI but this can be overridden by the 
CMOF tag org.omg.xmi.nsPrefix.
OMG normative Profiles, such as the UML Standard Profile, follow an OMG normative naming scheme for URIs. For 
non-standard profiles a recommended convention is:

nsUri = http://<profileParentQualifiedName>/<version>/<profileName>.xmi
nsPrefix = <profileName>

where:
•

<profileParentQualifiedName>is the qualified name of the Package containing the Profile (if any) 
with / (forward slash) substituted for ::, and all other illegal XML QName characters removed.

• <version> is a version identifier.

NOTE. For OMG normative profiles this is a date in the format YYYYMMnn where nn is a serial number 
within the month, and represents the version of the Profile XMI not that of the specification which might be re-
issued without affecting the XMI.
<profileName> is the name of the Profile.

•

A Profile can be exchanged just like any model, as an XMI file, and models that have a Profile applied can also be 
interchanged.
Figure 12.19 shows a Stereotype named Home extending the Interface UML2 metaclass. Figure 12.15 illustrates the 
MOF correspondence for that example, basically by introducing an Association from the Home MOF class to the 
Interface MOF class. For illustration purposes, we add a Property “magic:String” to the Home Stereotype.
The first serialization below shows how the model in Figure 12.19 (definition of the Profile extending the UML2 
metamodel) can be exchanged.

<?xml version="1.0" encoding="UTF-8"?>

254

Unified Modeling Language 2.5

 <xmi:XMI xmlns:xmi=http://www.omg.org/spec/XMI/YYYYMMnn>
 xmlns:mofext=http://www.omg.org/spec/MOF/YYYYMMnn xmlns:uml=http://www.omg.org/spec/UML/YYYYMMnn
    <uml:Profile  xmi:id="id0" xmi:type=”uml:Profile” name="HomeExample">

<metamodelReference xmi:type=”uml:PackageImport” xmi:id="id2">

<importedPackage href="http://www.omg.org/spec/UMLYYYYMMnn/UML.xmi#_0"/>

</metamodelReference >
<packagedElement xmi:type="uml:Stereotype" xmi:id="id3" name="Home">

<ownedAttribute xmi:type="uml:Property" xmi:id="id5" name="base_Interface" 

association="id6">

</ownedAttribute>

memberEnd="id7 id5">

aggregation="composite">

</ownedEnd>
</packagedElement>

 <type href="http://www.omg.org/spec/UML/YYYYMMnn/UML.xmi#Interface"/>

</packagedElement>
<packagedElement xmi:type="uml:Extension" xmi:id="id6" name="A_Interface_Home" 

<ownedEnd xmi:type="uml:ExtensionEnd" xmi:id="id7" name="extension_Home" type="id3" 

</uml:Profile>
<mofext:Tag xmi:type=”mofext:Tag” name="org.omg.xmi.nsPrefix" value="HomeExample"/>
<mofext:Tag xmi:type=”mofext:Tag” name="org.omg.xmi.nsURI" 
value="http://HomeExample/20120501/HomeExample.xmi"/>
</xmi:XMI>

Figure 12.13 is an example model that includes an instance of Interface extended by the Home stereotype.

Figure 12.13  Using the HomeExample Profile to Extend a Model

The XMI serialization of a model to which zero or more Profiles are applied is an XMI file organized in two 
logical parts (which may be physically organized in any order within a file or in separate files):

1
2

the XMI serialization of the model,
the XMI serialization of the instances corresponding to each application of a Profile to the model or 
some part of it.

Since deleting the application of Profiles applied to the model or some parts of it must not modify the XMI 
serialization of the model itself, all XMI elements in Part (1) cannot have any XMI reference to any XMI 
element in Part (2). Typically, the values of the applied Stereotype’s “base” properties and of properties typed 
by metaclasses cause XMI elements corresponding to instances of Stereotypes in Part (2) to make reference 
to XMI elements in Part (1). In general, Part (2) contains the following kinds of instances:

Instances of Stereotypes (see the example in Figure 12.13).

•
• Optionally, instances of Extensions according to their MOF-equivalent mapping as composite 

•

Associations.
Instances of Profile-defined Classes and DataTypes. In particular, such instances should not be 
confused, replaced, or substituted with InstanceSpecifications, which are a UML-based model 
representation of instances but are not the same as, substitutable with or equivalent to the instances 
that they represent.

• Optionally, instances of Profile-defined composite and non-composite Associations.

The XMI below shows how the model of Figure 12.13 is serialized in XMI. A tool importing that XMI file can filter out 
the elements related to the HomeExample Profile, if the tool does not have this Profile definition.

<?xml version="1.0" encoding="UTF-8"?>

Unified Modeling Language 2.5

255

<xmi:XMI xmlns:xmi="http://www.omg.org/spec/XMI/YYYYMMnn" 
xmlns:uml="http://www.omg.org/spec/UML/YYYYMMnn" 
xmlns:HomeExample="http://HomeExample/20120501/HomeExample.xmi">

<uml:Package xmi:type=”uml:Package” xmi:id="id1" name="ClientPackage">

<profileApplication xmi:type=”uml:ProfileApplication” xmi:id="id3">

<appliedProfile href="http://HomeExample/20120501/HomeExample.xmi#id0"/>

</profileApplication>
<packagedElement xmi:type="uml:Interface" xmi:id="id2" name="Client"/>

</uml:Package>
<!-- applied stereotypes -->
<HomeExample:Home xmi:id= "id4" base_Interface="id2"/>

</xmi:XMI>

12.3.3.2

Defining Profiles for Non-UML Metamodels

In theory the Profiles capability can be used to define extensions for metamodels other than UML, though this 
capability has rarely, if at all, been used in practice. It would require any tooling implementing that metamodel to also 
support some kind of profile application mechanism – that is outside the scope of this specification. The following 
describes how the Profile definition mechanism may be used in this way.
In addition to UML, a Profile may be related to another MOF-compliant reference metamodel. In general a reference 
metamodel typically consists of metaclasses that are either imported or locally owned. All metaclasses that are extended 
by a profile have to be members (directly or indirectly) of the same reference metamodel. The  metaclassReference 
ElementImports and metamodelReference PackageImports serve two purposes: (1) they identify the reference metamodel 
elements that are imported by the profile and (2) they specify the Profile’s filtering rules. The filtering rules determine 
which elements of the metamodel are available when the Profile is applied and which ones are hidden.
NOTE. Applying a Profile does not change the underlying model in any way; it merely defines a view of the underlying 
model.
In general, only model elements that are instances of imported reference metaclasses will be visible when the profile is 
applied. Instances of all other metaclasses will be hidden and further instances may not be created. By default, model 
elements whose metaclasses are owned by the reference metamodel are visible. This applies transitively to any 
subpackages of the reference metamodel according to the default rules of package import. If any metaclass is imported 
using a metaclassReference ElementImport, then model elements whose metaclasses are the same as that metaclass are 
available. However, a metaclassReference blocks a metamodelReference whenever an element or Package of the referenced 
metamodel is also referenced by a metaclass reference. In such cases, only the elements that are explicitly referenced by 
the metaclassReference will be visible, while all other elements of the metamodel Package will be hidden.
The following rules are used to determine whether a model element is available or hidden after a Profile has been 
applied. Model elements are available if they are instances of metaclasses that are:

1

2

referenced by an explicit metaclassReference, or

contained (directly or transitively) in a Package that is referenced by an explicit metamodelReference; unless 
there are other elements of subpackages of that Package that are explicitly referenced by a MetaclassReference, 
or

3

extended by a Stereotype owned by the applied profile (even if the extended metaclass itself is not visible).

All other model elements are hidden (not available) when the Profile is applied.
The most common case is when a Profile just imports an entire metamodel using a metamodelReference. In that case, 
every element instantiating a metaclass in the metamodel is visible.
In the example in Figure 12.14, MyMetamodel is a metamodel containing two metaclasses: Metaclass1 and Metaclass2. 
MyProfile is a profile that references MyMetamodel and Metaclass2. However, there is also an explicit metaclass 
reference to Metaclass2, which overrides the metamodel reference. An application of MyProfile to some model based 
on MyMetamodel will show instances of Metaclass2 (because it is referenced by an explicit metaclass reference). Also, 
those instances of Metaclass1 that are extended by an instance of MyStereotype will be visible. However, instances of 
Metaclass1 that are not extended by MyStereotype remain hidden.

256

Unified Modeling Language 2.5

Figure 12.14  Specification of an Available Metaclass

If a Profile P1 imports another Profile P2, then all metaclassReference and metamodelReference associations will be 
combined at the P2 level, and the filtering rules apply to this union.
The filtering rules defined at the Profile level are, in essence, merely a suggestion to modeling tools on what to do when 
a profile is applied to a model.
The isStrict attribute on a ProfileApplication specifies that the filtering rules have to be applied strictly. If isStrict is true 
on a ProfileApplication, then no other metaclasses than the accessible one defined by the profile shall be accessible 
when the Profile is applied on a model. This prohibits the combination of applied profiles that specify different 
accessible metaclasses.

12.3.3.3

ProfileApplication

A ProfileApplication is used to record which Profiles have been applied to a Package.
One or more Profiles that extend UML may be applied at will to a model Package. Applying a Profile means that it is 
possible to apply the Stereotypes that are defined as part of the Profile. It is possible to apply multiple Profiles to a 
Package, though this could make the Package invalid if they have conflicting Constraints. Applying a Profile means 
recursively applying all its nested and imported Profiles. Stereotypes that are public members of a Profile may be applied 
to applicable model elements in Packages to which the Profile has been applied.
When a Profile is applied, instances of the appropriate Stereotypes must be created for those elements that are instances 
of metaclasses with ExtensionEnds which have isRequired = true. The model is not well-formed without these instances.
Once a Profile has been applied to a Package, it is allowed to remove the applied Profile at will. Removing a Profile 
implies that all elements that are instances of Stereotypes defined in the Profile are deleted including the instances of 
Profile-defined Classes they compositionally aggregate and the instances of Profile-defined composite Associations 
linking them. Other instances that are not compositionally aggregated must also be deleted if their defining type is no 
longer accessible from any other Profile applied to the same model.The removal of an applied Profile leaves the 
instances of elements from the referenced metamodel intact. It is only the instances of the elements from the Profile that 
are deleted. This means that for example a profiled UML model can always be interchanged with another tool that does 
not support the profile and be interpreted as a pure UML model.
A Profile which is a packagedElement of another Profile can be applied individually. However, the nested Profile must 
specify any required metaclass and/or metamodel references if it contains any Stereotypes and may use PackageImport 
to indicate other Profiles to be co-applied. Metaclass and/or metamodel references are not inherited from a containing 
Profile.

12.3.3.4

Stereotypes

A Stereotype defines an extension for one or more metaclasses, and enables the use of specific terminology or notation 
in place of, or in addition to, the ones used for the extended metaclasses. If a Stereotype extends several metaclasses, it 
can only be applied to exactly one instance of one of those metaclasses at any point in time. It is, however, possible to 
detach the Stereotype instance from an instance of one metaclass and attach it to an instance of another metaclass.

Unified Modeling Language 2.5

257

A Stereotype is a limited kind of metaclass that cannot be used by itself, but must always be used in conjunction with 
one of the metaclasses it extends. Each Stereotype may extend one or more metaclasses through association (Extension) 
rather than generalization/specialization. Similarly, a metaclass may be extended by one or more Stereotypes. Relating 
an instance “S” of Stereotype to a metaclass “C” from UML using an “Extension” (which is a specific kind of 
Association) signifies that model elements of type “C” can be extended by an instance of “S” (see example in Figure 
12.24  Defining a Stereotype). At the model level (such as in Figure 12.29) instances of “S” are related to “C” model 
elements (instances of “C”) by links (occurrences of the Association/Extension from “S” to “C”).
Any metaclass referenced by a metaclassReference or contained in a Package referenced by metamodelReference of the 
closest Profile directly or indirectly containing a Stereotype can be extended by the Stereotype. For example States, 
Transitions, Activities, Use Cases, Components, Properties, Dependencies, etc. can all be extended with Stereotypes if 
the metamodelReference is UML. A Stereotype may be contained in a Package in which case the metaclasses available for 
extension are those referenced by the closest parent Profile containing the Package.
Just like a Class, a Stereotype may have Properties, which have traditionally been referred to as Tag Definitions. When 
a Stereotype is applied to a model element, the values of the Properties have traditionally been referred to as tagged 
values. Stereotype specializes Class and its Properties have the same meaning in Stereotypes as they do in Class. A 
Stereotype Property can have composite aggregation; just like the value of a composite aggregation Property on a Class 
is owned by an instance of that Class, the value of a composite aggregation Property on a Stereotype is owned by an 
instance of that Stereotype. Since a profile can be unapplied without modifying the model it was originally applied to, 
instances of metaclasses in the model cannot refer to instances of stereotypes or to values of their properties. The type 
of a composite aggregation Stereotype Property cannot be a Stereotype (since Stereotypes are owned by their 
Extensions) or a metaclass (since instances of metaclasses are owned by other instances of metaclasses); however, the 
type of such Property can be a Class defined in the Profile or a DataType defined in the Profile or accessible via import 
or via the Profile’s metamodel reference.Tool vendors may choose to support extensibility that includes owned 
operations and behaviors, but are not required to do so. Tools must however support Stereotype ownedAttributes.
Its Profile or Package defines the namespace for the Stereotype. When Profiles are applied to a Package, the available 
Stereotypes for use are defined by the applied Profiles, and these Stereotypes can be displayed using the fully qualified 
name if needed in order to distinguish Stereotypes with the same name in different Profiles or Packages. PackageImport 
and ElementImport can be used to allow the use of unqualified names. Stereotypes directly owned by an applied Profile 
(ownedStereotype) may be used without qualified names.

12.3.3.5

Images

The Image class provides the necessary information to display an Image in a diagram. Icons are typically handled 
through the Image class.
Information such as physical placement or format is provided by the Image class. The Image class provides a generic 
way of representing images in different formats. Although some predefined values are specified for  format for 
convenience and interoperability, the set of possible formats is open ended. However there is no requirement for a tool 
to be able to interpret and display any specific format, including those predefined values.
The format property indicates the format of the content, which is how the string content should be interpreted. The 
following values are reserved: SVG, GIF, PNG, JPG, WMF, EMF, BMP. In addition the prefix ‘MIME:’ is also 
reserved: this must be followed by a valid MIME type as defined by RFC3023. This option can be used as an alternative 
to express the reserved values above, for example “SVG” could instead be expressed “MIME: image/svg+xml.”

12.3.3.6

Extensions

An Extension is used to indicate that the properties of a metaclass are extended through a Stereotype, and gives the 
ability to flexibly add (and later remove) stereotypes to classes.
Extension is a kind of Association. One end of the Extension is an ordinary Property and the other end is an 
ExtensionEnd. The former ties the Extension to a (meta)Class, while the latter ties the Extension to a Stereotype that 
extends the Class.
A required Extension (isRequired = true) means that an instance of this Stereotype must be linked to each instance of the 
extended metaclass in the model to which the containing Profile has been applied (otherwise the model is not well-

258

Unified Modeling Language 2.5

formed). If the extending Stereotype has subclasses, then at most one instance of the Stereotype or one of its subclasses 
is required.
A non-required Extension (isRequired = false) means that an instance of this Stereotype may be linked to an instance of 
an extended metaclass at will, and also later deleted at will; however, there is no requirement that each instance of a 
metaclass be stereotyped. However the same stereotype (or its subtypes) can never be applied twice to the same 
element. An instance of a Stereotype is deleted when either the instance of the extended metaclass is deleted, or when 
the Profile defining the stereotype is removed from the appliedProfiles of the Package.
The equivalence to a MOF construction for single metaclass extension is shown in Figure 12.15. This figure illustrates 
the case shown in Figure 12.19, where the Stereotype named Home extends the Interface metaclass. In this figure, 
Interface is an instance of the UML metaclass (a CMOF Class) and Home is an instance of a Stereotype (also 
considered a CMOF Class for this purpose). The MOF construct equivalent to an Extension is a composition from the 
extended metaclass to the extension Stereotype, owned by the extended metaclass. When the Extension is required, then 
the multiplicity of the property typed by the extension Stereotype is 1.
The name of the Property typed by the extended metaclass is:

‘base_’ extendedMetaclassName

The name of the Property typed by the extension Stereotype (the ExtensionEnd) is:

‘extension_’ stereotypeName

Constraints are frequently added to Stereotypes. The above Properties may be used for expressing OCL navigations. For 
example, the following OCL expression states that a Home Interface shall not have attributes:

self.base_Interface.ownedAttributes->isEmpty()

Figure 12.15  MOF Model Equivalent to Extending "Interface" by the "Home" Stereotype

An example for multiple metaclass extension is depicted in Figure 12.16. The Stereotype TestCase extends both 
metaclass Operation and Behavior.

<<Metaclass>>

Operation

<<Metaclass>>

Behavior

<<stereotypes>>

TestCase

Figure 12.16  Example of Multiple Metaclass Extension

The corresponding equivalence to a MOF construction for multiple metaclass extension is shown in Figure 12.17.

Unified Modeling Language 2.5

259

Operation

base_Operation [0..1]

extension_TestCase [0..1]

xor

TestCase

Behavior

base_Behavior [0..1]

extension_TestCase [0..1]

Figure 12.17  MOF Model Equivalent to Multiple Metaclass Extension

12.3.3.7

ExtensionEnd

An ExtensionEnd is used to tie an Extension to a Stereotype when extending a metaclass: it is a navigableOwnedEnd of 
the Extension, avoiding an extra ownedAttribute on the extended Class. It is always typed by a Stereotype and must 
always have isComposite = true.
The default multiplicity of an ExtensionEnd is 0..1. It may be 1..1 if the Stereotype is required but the upperBound may 
never be more than 1.

Notation

12.3.4
The notation for an Extension is an arrow pointing from a Stereotype to the extended Class, where the arrowhead is 
shown as a filled triangle. An Extension may have the same adornments as an ordinary Association, but they are 
typically elided and navigability arrows are never shown. If isRequired = true, the adornment {required} is shown near 
the ExtensionEnd.

Figure 12.18  The Notation for an Extension

It is possible to use the multiplicities 0..1 or 1 on the ExtensionEnd as an alternative to the adornment {required}. Due 
to how isRequired is derived, the multiplicity 0..1 corresponds to isRequired = false.
A Profile uses the same notation as a Package, with the addition that the keyword «profile» is shown before or above 
the name of the Package. Profile::metaclassReference and Profile::metamodelReference use the same notation as 
Package::elementImport and Package::packageImport, respectively but with the keyword «reference».
ProfileApplications are shown using a dashed arrow with an open arrowhead from the Package to each applied Profile. 
Either the keyword «apply» is shown near the arrow, or the keyword «strict» - the latter if isStrict = true.
If multiple appliedProfiles have Stereotypes with the same name, it may be necessary to qualify the name of the 
Stereotype (with the profile name).
A Stereotype uses the same notation as a Class, with the addition that the keyword «stereotype» is shown before or 
above the name of the Class.
When a Stereotype is applied to a model element (an instance of a Stereotype is linked to an instance of a metaclass), 
the name of the Stereotype is shown within a pair of guillemets above or before the name of the model element, or 
where the name would appear if the name is omitted or not displayed. For model elements that are not NamedElements 
but do have a graphical representation, unless specifically stated elsewhere, the stereotypes can be displayed within a 
pair of guillemets near the upper right corner of the graphical representation. If multiple stereotypes are applied, the 
names of the applied stereotypes are shown as a comma-separated list within a pair of guillemets. When the extended 
model element has a keyword, then the stereotype name(s) will be displayed close to the keyword, within the same or 
separate guillemets (example: «interface» «Clock» or «Clock, interface»).
Normally a Stereotype’s name starts with an upper-case letter, to follow the convention for naming Classes. However 
Profiles may use different conventions. Matching between the names of Stereotype definitions and applications is case-
insensitive, so naming stereotype applications with lower-case letters where the stereotypes are defined using upper-

260

Unified Modeling Language 2.5

case letters is valid, although stylistically obsolete. For legacy reasons a tool may display stereotype names with the 
initial letter in lower case even when defined in upper case.
A tool can choose whether it will display Stereotypes or not. In particular, tools can choose not to display required 
stereotypes, but to display only the values of their ownedAttributes if any.
The values of the ownedAttributes of a Stereotype (or its generalizations) applied to a model element can be shown in one 
of the following three ways:

1 As part of a comment symbol connected to the graphic node representing the model element.

2

In separate compartments of the graphic node representing that model element.

3 Above the name string within the graphic node or, else, before the name string.

In the case where a compartment or comment symbol is used, the stereotype name may be shown in guillemets before 
the name string in addition to being included in the compartment or comment.
The values are displayed as name-value pairs:

<namestring> ‘=’ <valuestring>

If a Stereotype Property is multi-valued, then the <valuestring> is displayed as a comma-separated list:

<valuestring> ::= <value> [‘,’ <value>]*

Certain values have special display rules:

• As an alternative to a name-value pair, when displaying the values of Boolean Properties, tools may 

use the convention that if the <namestring> is displayed, then the value is true; otherwise, the value is
false.

•

If the value is the name of a NamedElement, then, optionally, the qualifiedName of that element can be 
displayed.

If compartments are used to display Stereotype Property values, then an additional compartment is required for each 
applied Stereotype whose Property values are to be displayed. Each such compartment is headed by the name of the 
applied stereotype in guillemets. Such compartments are only applicable to elements for which compartments generally 
may be used: specifically Classifiers and States.
Within a comment symbol, or, if displayed before or above the model element’s name, the Property values from a 
specific Stereotype are optionally preceded with the name of the applied Stereotype within a pair of guillemets. This is 
useful if values of more than one applied stereotype should be shown.
When displayed in compartments or in a comment symbol, at most one namestring-valuestring pair can appear on a 
single line. When displayed above or before a model element’s name, the name-value pairs are separated by semicolons 
and all pairs for a given stereotype are enclosed in braces.

12.3.4.1

Icon presentation

It is possible to attach Images to a Stereotype that can be used in lieu of, or in addition to, the normal notation of a 
model element to which the Stereotype is applied.
When a Stereotype has a value for icon, the referenced Image can be graphically attached to the model elements to 
which the Stereotype has been applied. Every model element that has a graphical presentation can have an attached 
icon. When model elements are graphically expressed as:

•

Boxes (see Figure 12.25): the box may be replaced by the Image, and the name of the model element 
appears below the Image. This presentation option can be used only when a model element has one 

Unified Modeling Language 2.5

261

single Stereotype applied and when Properties of the model element (e.g., ownedAttributes, 
ownedOperations of a Class) are not presented. As another option, the Image may be presented in a 
reduced size, inside and to the top of the box representing the model element. When several 
Stereotypes are applied, several Images may be presented within the box.

•

•

Lines: the Image may be placed close to the line.

Textual notation: the Image may be presented to the left of the textual notation.

Several Images may be referenced by a Stereotype’s icon Property. The interpretation of the different attached Images in 
that case is a semantic variation point. Some tools may use the different Images for different purposes: the icon 
replacing the box, for the reduced-size icon inside the box, for icons within tree browsers, etc. Alternatively, depending 
on the Image format, tools may choose to scale one single Image into different sizes for these different purposes.
Some model elements already use an icon for their default presentation. A typical example of this is the Actor model 
element, which uses the “stickman” icon. When a Stereotype with an icon is applied to such a model element, the 
Stereotype’s icon replaces the default presentation icon within diagrams.

Examples

12.3.5
In Figure 12.19, a simple example of using an Extension is shown, where the stereotype Home extends the metaclass 
Interface.

Figure 12.19  Example of Using an Extension

An instance of the stereotype Home can be added to and removed from an instance of the class Interface at will, which 
provides for a flexible approach of dynamically adding (and removing) information specific to a Profile to a Package.
In Figure 12.20, each instance of metaclass Component in a model to which the Profile has been applied must have 
applied an instance of the stereotype Bean, as the Extension has isRequired = true. (As the stereotype Bean is abstract, 
this means that each instance of metaclass Component must be stereotyped by an instance of one of its concrete 
subclasses.) The model is not well-formed unless such a Stereotype is applied. This provides a way to express 
Extensions that should always be present for all instances of the base metaclass depending on which Profiles are 
applied.

Figure 12.20  Example of a Required Extension

In Figure 12.21, a simple example of an EJB profile is shown.

262

Unified Modeling Language 2.5

Figure 12.21  Defining a Simple EJB Profile

The Profile defines that the abstract stereotype Bean is required to be applied to metaclass Component, which means 
that an instance of either of the concrete subclasses Entity and Session of Bean must be linked to each instance of 
Component. The Constraints that are part of the Profile are evaluated when the Profile is applied to a Package, and these 
Constraints need to be satisfied in order for the model to be well-formed.

Figure 12.22  Importing a Package from a Profile

In Figure 12.22, the Package named Types is imported by the Profile named Manufacturer. The Enumeration named 
Color and the Class named JavaInteger are then used as the type of Properties of the Stereotype named Device as well 
as the standard PrimitiveType String.
If the Profile Manufacturer is later applied to a Package, then the types from Types are not available for use in the 
Package to which the Profile is applied unless package Types is explicitly imported. This means that the class 
JavaInteger can be used as the type of a Stereotype Property (e.g., in Device) but not as an ordinary Property (as part 
of the Class TV) unless Package Factory also imports Package Types (which it does).
NOTE. The value of the volume Property is displayed once the Stereotype Device has been applied to the Class TV.
Given the profiles Java and EJB, Figure 12.23shows how these may be applied to the Package WebShopping.

Unified Modeling Language 2.5

263

Figure 12.23  Profiles Applied to a Package

In Figure 12.24, a simple stereotype Clock is defined to be applicable at will (dynamically) to instances of the metaclass 
Class.

Figure 12.24  Defining a Stereotype

Figure 12.25  Presentation Options for an Extended Class

In Figure 12.26, an instance diagram of the example in Figure 12.24 is shown.
NOTE. The ExtensionEnd must be composite, and that the derived isRequired Property in this case is false.
Figure 12.26 shows the instances representing the definition of the Stereotype named Clock defined in Figure 12.24. In 
this definition, the extended metaclass (:Class; “name = Class”) is defined in the UML2 metamodel (reference 
metamodel). In a UML modeling tool this representation of the UML2 standard metamodel would typically be in a 
“read only” form, or presented as proxies to the metaclass being extended.
(It is therefore still at the same meta-level as UML, and does not show the instance model of a model extended by the 
stereotype. An example of this is provided in Figure 12.28 and Figure 12.29.) The Semantics sub clause of the 
Extension concept explains the MOF equivalent, and how constraints can be attached to stereotypes.

Figure 12.26  An Instance Diagram when Defining a Stereotype

264

Unified Modeling Language 2.5

Figure 12.27 shows how the same Stereotype named Clock extends both the metaclass Component and the metaclass 
Class (though each instance of the Stereotype can extend only one model element). It also shows how different 
Stereotypes can extend the same metaclass.

Figure 12.27  Defining Multiple Stereotypes on Multiple Stereotypes

Figure 12.28 shows how the Stereotype Clock, as defined in Figure 12.27, is applied to a Class named StopWatch.

Figure 12.28  Using a Stereotype

Figure 12.29 shows the underlying semantics for when the Stereotype named Clock is applied to a class called 
StopWatch. The right-hand side uses instance diagram notation to show the MOF-equivalent instances that should be 
used to understand the behavior and XMI serialization of the UML diagram on the left. The Extension between the 
Stereotype and the metaclass Class results in a link between the instance of Stereotype Clock and the (user-defined) 
Class named StopWatch.

Figure 12.29  Showing Values of Stereotypes and a Simple Instance Specification

Next, two stereotypes, Clock and Creator, are applied to the same model element, as shown in Figure 12.30.
NOTE. The Property values of each of the applied Stereotypes are shown in a comment symbol attached to the model 
element.

Figure 12.30  Using Stereotypes and Showing Values

Finally, two more alternative notational forms are shown in Figure 12.31.

Unified Modeling Language 2.5

265

Figure 12.31  Other Notational Forms for Depicting Stereotype Values

Figure 12.32 shows an example of a profile with profile-defined classes and binary composite and noncomposite 
associations.

Figure 12.32  Example of a Profile defining Classes and binary composite and non-composite Associations

The following shows the XMI serialization of the profile shown in Figure 12.32:
<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmlns:xmi="http://www.omg.org/spec/XMI/YYYYMMnn"
         xmlns:uml="http://www.omg.org/spec/UML/YYYYMMnn"
         xmlns:mofext="http://www.omg.org/spec/MOF/YYYYMMnn">
  <uml:Profile xmi:type="uml:Profile"
               URI="http://www.example.org/IssuesProfile"
               xmi:id="id0"
               name="IssuesProfile"
               metamodelReference="id309">
    <packageImport xmi:id="id309">
      <importedPackage xmi:type="uml:Model"
                       href="http://www.omg.org/spec/UML/YYYYMMnn/UML.xmi#_0"/>
    </packageImport>
    <packagedElement xmi:type="uml:Class"
                     xmi:id="id312"
                     name="IssueDetail">
      <ownedAttribute xmi:id="id315" name="number">
        <type xmi:type="uml:PrimitiveType"
              href="http://www.omg.org/spec/UML/YYYYMMnn/PrimitiveTypes.xmi#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="id318" name="url">
        <type xmi:type="uml:PrimitiveType"
              href="http://www.omg.org/spec/UML/YYYYMMnn/PrimitiveTypes.xmi#String"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="id321" name="text">
        <type xmi:type="uml:PrimitiveType"
              href="http://www.omg.org/spec/UML/YYYYMMnn/PrimitiveTypes.xmi#String"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="id324"
                      name="issueComment"
                      type="id343"
                      aggregation="composite"
                      association="id352">
        <upperValue xmi:type="uml:LiteralUnlimitedNatural"
                    xmi:id="id328"
                    value="*"/>
        <lowerValue value="0"
                    xmi:type="uml:LiteralInteger"
                    xmi:id="id331"/>
      </ownedAttribute>

266

Unified Modeling Language 2.5

      <ownedAttribute xmi:id="id334"
                      name="duplicatesIssue"
                      type="id312"
                      association="id364">
        <upperValue xmi:type="uml:LiteralUnlimitedNatural"
                    xmi:id="id337"
                    value="*"/>
        <lowerValue value="0"
                    xmi:type="uml:LiteralInteger"
                    xmi:id="id340"/>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="uml:Class"
                     xmi:id="id343"
                     name="IssueComment">
      <ownedAttribute xmi:id="id346" name="number">
        <type xmi:type="uml:PrimitiveType"
              href="http://www.omg.org/spec/UML/YYYYMMnn/PrimitiveTypes.xmi#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="id349" name="text">
        <type xmi:type="uml:PrimitiveType"
              href="http://www.omg.org/spec/UML/YYYYMMnn/PrimitiveTypes.xmi#String"/>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="uml:Association"
                     xmi:id="id352"
                     name="A_issueDetail_issueComment"
                     memberEnd="id324 id355">
      <ownedEnd xmi:id="id355"
                name="issueDetail"
                type="id312"
                association="id352"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Association"
                     xmi:id="id364"
                     name="A_issueDetail_duplicatesIssue"
                     memberEnd="id334 id367">
      <ownedEnd xmi:id="id367"
                name="issueDetail"
                type="id312"
                association="id364">
        <upperValue xmi:type="uml:LiteralUnlimitedNatural"
                    xmi:id="id371"
                    value="*"/>
        <lowerValue value="0"
                    xmi:type="uml:LiteralInteger"
                    xmi:id="id374"/>
      </ownedEnd>
    </packagedElement>
    <packagedElement xmi:type="uml:Stereotype"
                     xmi:id="id377"
                     name="IssueTag">
      <ownedAttribute xmi:id="id380"
                      name="base_Element"
                      association="id418">
        <type xmi:type="uml:Class"
              href="http://www.omg.org/spec/UML/YYYYMMnn/UML.xmi#Element"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="id383" name="reviewed">
        <type xmi:type="uml:PrimitiveType"
              href="http://www.omg.org/spec/UML/YYYYMMnn/PrimitiveTypes.xmi#Boolean"/>
        <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="id386"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="id389"
                      name="issueDetail"
                      type="id312"
                      aggregation="composite"
                      association="id424">
        <upperValue xmi:type="uml:LiteralUnlimitedNatural"
                    xmi:id="id393"
                    value="*"/>
        <lowerValue value="0"
                    xmi:type="uml:LiteralInteger"
                    xmi:id="id396"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="id399"
                      name="affectedBy"
                      type="id312"
                      association="id436">
        <upperValue xmi:type="uml:LiteralUnlimitedNatural"
                    xmi:id="id403"

Unified Modeling Language 2.5

267

                    value="*"/>
        <lowerValue value="0"
                    xmi:type="uml:LiteralInteger"
                    xmi:id="id406"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="id409"
                      name="relatedElement"
                      association="id448">
        <type xmi:type="uml:Class"
              href="http://www.omg.org/spec/UML/YYYYMMnn/UML.xmi#Element"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural"
                    xmi:id="id412"
                    value="*"/>
        <lowerValue value="0"
                    xmi:type="uml:LiteralInteger"
                    xmi:id="id415"/>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="uml:Extension"
                     xmi:id="id418"
                     name="Element_IssueTag"
                     memberEnd="id421 id380">
      <ownedEnd xmi:type="uml:ExtensionEnd"
                xmi:id="id421"
                name="extension_IssueTag"
                type="id377"
                aggregation="composite"
                association="id418"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Association"
                     xmi:id="id424"
                     name="A_issueTag_issueDetail"
                     memberEnd="id389 id427">
      <ownedEnd xmi:id="id427"
                name="issueTag"
                type="id377"
                association="id424"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Association"
                     xmi:id="id436"
                     name="A_issueTag_affectedBy"
                     memberEnd="id399 id439">
      <ownedEnd xmi:id="id439"
                name="issueTag"
                type="id377"
                association="id436">
        <upperValue xmi:type="uml:LiteralUnlimitedNatural"
                    xmi:id="id442"
                    value="*"/>
        <lowerValue value="0"
                    xmi:type="uml:LiteralInteger"
                    xmi:id="id445"/>
      </ownedEnd>
    </packagedElement>
    <packagedElement xmi:type="uml:Association"
                     xmi:id="id448"
                     name="A_issueTag_relatedElement"
                     memberEnd="id409 id451">
      <ownedEnd xmi:id="id451"
                name="issueTag"
                type="id377"
                association="id448">
        <upperValue xmi:type="uml:LiteralUnlimitedNatural"
                    xmi:id="id454"
                    value="*"/>
        <lowerValue value="0"
                    xmi:type="uml:LiteralInteger"
                    xmi:id="id457"/>
      </ownedEnd>
    </packagedElement>
  </uml:Profile>
  <mofext:Tag xmi:type="mofext:Tag"
              org.omg.xmi.nsURI="http://www.example.org/IssuesProfile"/>
  <mofext:Tag xmi:type="mofext:Tag"
              org.omg.xmi.nsPrefix="IssuesProfile"/>
</xmi:XMI>
Figure 12.33 shows an example of applying the profile shown in Figure 12.32.

268

Unified Modeling Language 2.5

Figure 12.33  Diagram example of applying a profile defining Classes and Associations and of creating instances 
of such Classes. Tools can provide a notation similar to that of object diagrams for instances of Profile-defined 
Classes, DataTypes and Associations

The following shows the XMI serialization of the example shown in Figure 12.33 without link instances of profile-
defined associations:
<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmlns:xmi="http://www.omg.org/spec/XMI/YYYYMMnn"
         xmlns:uml="http://www.omg.org/spec/UML/YYYYMMnn"
         xmlns:IssuesProfile="http://www.example.org/IssuesProfile">
  <uml:Package xmi:id="ex0"
               name="IssueExample">
    <packagedElement xmi:type="uml:Class" xmi:id="ex57" name="B">
      <generalization xmi:id="ex60" general="ex65"/>
      <ownedAttribute xmi:id="ex63" name="x">
        <type xmi:type="uml:PrimitiveType"
              href="http://www.omg.org/spec/UML/YYYYMMnn/PrimitiveTypes.xmi#String"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="ex64" name="y"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="ex65" name="A">
      <ownedAttribute xmi:id="ex69" name="width"/>
      <ownedAttribute xmi:id="ex70" name="length"/>
    </packagedElement>
    <profileApplication xmi:id="ex77">
      <appliedProfile href="http://www.example.org/IssuesProfile#id0"/>
    </profileApplication>
  </uml:Package>
  <IssuesProfile:IssueTag xmi:id="ex66"
                          base_Element="ex65"
                          relatedElement="ex69 ex70">
    <issueDetail xmi:id="ex67"
                 number="1"
                 url="http://www.example.org/issues/1"
                 text="Some attributes lack a type.">
      <issueComment xmi:id="ex68"
                    number="3"
                    text="Type should be string."/>
    </issueDetail>
  </IssuesProfile:IssueTag>
  <IssuesProfile:IssueTag xmi:id="ex58"
                          base_Element="ex57"
                          affectedBy="ex66 ex61"
                          relatedElement="ex64">
    <issueDetail xmi:id="ex59"
                 number="2"
                 url="http://www.example.org/issues/2"
                 text="Some attributes lack a type."
                 duplicatesIssue="ex67"/>
  </IssuesProfile:IssueTag>
  <IssuesProfile:IssueTag xmi:id="ex61" base_Element="ex60">
    <issueDetail xmi:id="ex62"
                 number="4"
                 url="http://www.example.org/issues/4"

Unified Modeling Language 2.5

269

                text="Why does B specialize A?"/>
  </IssuesProfile:IssueTag>
</xmi:XMI>
The following shows the XMI serialization of the example shown in Figure 12.33 with link instances of profile-defined 
associations serialized:
<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmlns:xmi="http://www.omg.org/spec/XMI/YYYYMMnn"
         xmlns:uml="http://www.omg.org/spec/UML/YYYYMMnn"
         xmlns:IssuesProfile="http://www.example.org/IssuesProfile">
  <uml:Package xmi:id="ex0" name="IssueExample">
    <packagedElement xmi:type="uml:Class" xmi:id="ex73" name="B">
      <generalization xmi:id="ex76" general="ex81"/>
      <ownedAttribute xmi:id="ex79" name="x">
        <type xmi:type="uml:PrimitiveType"
              href="http://www.omg.org/spec/UML/YYYYMMnn/PrimitiveTypes.xmi#String"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="ex80" name="y"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="ex81" name="A">
      <ownedAttribute xmi:id="ex85" name="width"/>
      <ownedAttribute xmi:id="ex86" name="length"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Package"
                     xmi:id="ex87"
                     name="PrimitiveTypes"/>
    <profileApplication xmi:id="ex97">
      <appliedProfile href="http://www.example.org/IssuesProfile#id0"/>
    </profileApplication>
  </uml:Package>
  <IssuesProfile:IssueTag xmi:id="ex82"
                          base_Element="ex81"
                          relatedElement="ex85 ex86">
    <issueDetail xmi:id="ex83"
                 number="1"
                 url="http://www.example.org/issues/1"
                 text="Some attributes lack a type.">
      <issueComment xmi:id="ex84"
                    number="3"
                    text="Type should be string."/>
    </issueDetail>
  </IssuesProfile:IssueTag>
  <IssuesProfile:A_issueTag_issueDetail xmi:id="d1e109" issueTag="ex82" issueDetail="ex83"/>
  <IssuesProfile:A_issueDetail_issueComment xmi:id="d1e110"
                                            issueDetail="ex83"
                                            issueComment="ex84"/>
  <IssuesProfile:A_issueTag_relatedElement xmi:id="ex82ex85"
                                           issueTag="ex82"
                                           relatedElement="ex85"/>
  <IssuesProfile:A_issueTag_relatedElement xmi:id="ex82ex86"
                                           issueTag="ex82"
                                           relatedElement="ex86"/>
  <IssuesProfile:IssueTag xmi:id="ex74"
                          base_Element="ex73"
                          affectedBy="ex82 ex77"
                          relatedElement="ex80">
    <issueDetail xmi:id="ex75"
                 number="2"
                 url="http://www.example.org/issues/2"
                 text="Some attributes lack a type."
                 duplicatesIssue="ex83"/>
  </IssuesProfile:IssueTag>
  <IssuesProfile:A_issueTag_issueDetail xmi:id="d1e112" issueTag="ex74" issueDetail="ex75"/>
  <IssuesProfile:A_issueDetail_duplicatesIssue xmi:id="ex75ex83"
                                               issueDetail="ex75"
                                               duplicatesIssue="ex83"/>
  <IssuesProfile:A_issueTag_affectedBy xmi:id="ex74ex82" issueTag="ex74" affectedBy="ex82"/>
  <IssuesProfile:A_issueTag_affectedBy xmi:id="ex74ex77" issueTag="ex74" affectedBy="ex77"/>
  <IssuesProfile:A_issueTag_relatedElement xmi:id="ex74ex80"
                                           issueTag="ex74"
                                           relatedElement="ex80"/>
  <IssuesProfile:IssueTag xmi:id="ex77" base_Element="ex76">
    <issueDetail xmi:id="ex78"
                 number="4"
                 url="http://www.example.org/issues/4"
                 text="Why does B specialize A?"/>
  </IssuesProfile:IssueTag>
  <IssuesProfile:A_issueTag_issueDetail xmi:id="d1e114" issueTag="ex77" issueDetail="ex78"/>
</xmi:XMI>

270

Unified Modeling Language 2.5

12.4
12.4.1

Classifier Descriptions
Extension [Class]

12.4.1.1

Description

An extension is used to indicate that the properties of a metaclass are extended through a stereotype, and gives the 
ability to flexibly add (and later remove) stereotypes to classes.

12.4.1.2

Diagrams

Profiles, Classes

12.4.1.3

Generalizations

Association

12.4.1.4

Attributes

•

/isRequired : Boolean [1..1]
Indicates whether an instance of the extending stereotype must be created when an instance of the extended 
class is created. The attribute value is derived from the value of the lower property of the ExtensionEnd 
referenced by Extension::ownedEnd; a lower value of 1 means that isRequired is true, but otherwise it is false. 
Since the default value of ExtensionEnd::lower is 0, the default value of isRequired is false.

12.4.1.5

Association Ends

•

•

/metaclass : Class [1..1]{} (opposite Class::extension)
References the Class that is extended through an Extension. The property is derived from the type of the 
memberEnd that is not the ownedEnd.

♦ ownedEnd : ExtensionEnd [1..1]{redefines Association::ownedEnd} (opposite 
A_ownedEnd_extension::extension)
References the end of the extension that is typed by a Stereotype.

12.4.1.6

Operations

•

isRequired() : Boolean
The query isRequired() is true if the owned end has a multiplicity with the lower bound of 1.

body: ownedEnd.lowerBound() = 1

• metaclass() : Class

The query metaclass() returns the metaclass that is being extended (as opposed to the extending stereotype).

body: metaclassEnd().type.oclAsType(Class)

• metaclassEnd() : Property

The query metaclassEnd() returns the Property that is typed by a metaclass (as opposed to a stereotype).

body: memberEnd->reject(p | ownedEnd->includes(p.oclAsType(ExtensionEnd)))->any(true)

Unified Modeling Language 2.5

271

12.4.1.7

Constraints

•

•

non_owned_end
The non-owned end of an Extension is typed by a Class.

inv: metaclassEnd()->notEmpty() and metaclassEnd().type.oclIsKindOf(Class)

is_binary
An Extension is binary, i.e., it has only two memberEnds.

inv: memberEnd->size() = 2

12.4.2

12.4.2.1

ExtensionEnd [Class]

Description

An extension end is used to tie an extension to a stereotype when extending a metaclass. The default multiplicity of an 
extension end is 0..1.

12.4.2.2

Diagrams

Profiles

12.4.2.3

Generalizations

Property

12.4.2.4

Attributes

•

/lower : Integer [0..1]
This redefinition changes the default multiplicity of association ends, since model elements are usually 
extended by 0 or 1 instance of the extension stereotype.

12.4.2.5

Association Ends

•

type : Stereotype [1..1]{redefines TypedElement::type} (opposite A_type_extensionEnd::extensionEnd)
References the type of the ExtensionEnd. Note that this association restricts the possible types of an 
ExtensionEnd to only be Stereotypes.

12.4.2.6

Operations

•

lowerBound() : Integer [0..1] {redefines MultiplicityElement::lowerBound()}
The query lowerBound() returns the lower bound of the multiplicity as an Integer. This is a redefinition of the 
default lower bound, which normally, for MultiplicityElements, evaluates to 1 if empty.

body: if lowerValue=null then 0 else lowerValue.integerValue() endif

12.4.2.7

Constraints

• multiplicity

The multiplicity of ExtensionEnd is 0..1 or 1.

inv: (lowerBound() = 0 or lowerBound() = 1) and upperBound() = 1

272

Unified Modeling Language 2.5

•

aggregation
The aggregation of an ExtensionEnd is composite.

inv: self.aggregation = AggregationKind::composite

12.4.3

12.4.3.1

Image [Class]

Description

Physical definition of a graphical image.

12.4.3.2

Diagrams

Profiles

12.4.3.3

Generalizations

Element

12.4.3.4

Attributes

•

•

•

content : String [0..1]
This contains the serialization of the image according to the format. The value could represent a bitmap, image 
such as a GIF file, or drawing 'instructions' using a standard such as Scalable Vector Graphic (SVG) (which is 
XML based).

format : String [0..1]
This indicates the format of the content, which is how the string content should be interpreted. The following 
values are reserved: SVG, GIF, PNG, JPG, WMF, EMF, BMP. In addition the prefix 'MIME: ' is also reserved. 
This option can be used as an alternative to express the reserved values above, for example "SVG" could 
instead be expressed as "MIME: image/svg+xml".

location : String [0..1]
This contains a location that can be used by a tool to locate the image as an alternative to embedding it in the 
stereotype.

12.4.4

12.4.4.1

Model [Class]

Description

A model captures a view of a physical system. It is an abstraction of the physical system, with a certain purpose. This 
purpose determines what is to be included in the model and what is irrelevant. Thus the model completely describes 
those aspects of the physical system that are relevant to the purpose of the model, at the appropriate level of detail.

12.4.4.2

Diagrams

Packages

12.4.4.3

Generalizations

Package

12.4.4.4

Attributes

•

viewpoint : String [0..1]
The name of the viewpoint that is expressed by a model (this name may refer to a profile definition).

Unified Modeling Language 2.5

273

12.4.5

12.4.5.1

Package [Class]

Description

A package can have one or more profile applications to indicate which profiles have been applied. Because a profile is a 
package, it is possible to apply a profile not only to packages, but also to profiles. Package specializes 
TemplateableElement and PackageableElement specializes ParameterableElement to specify that a package can be used 
as a template and a PackageableElement as a template parameter. A package is used to group elements, and provides a 
namespace for the grouped elements.

12.4.5.2

Diagrams

Packages, Profiles, Namespaces

12.4.5.3

Generalizations

PackageableElement, TemplateableElement, Namespace

12.4.5.4

Specializations

Model, Profile

12.4.5.5

Attributes
• URI : String [0..1]

Provides an identifier for the package that can be used for many purposes. A URI is the universally unique 
identification of the package following the IETF URI specification, RFC 2396 
http://www.ietf.org/rfc/rfc2396.txt and it must comply with those syntax rules.

12.4.5.6

Association Ends

•

•

•

•

•

•

♦ /nestedPackage : Package [0..*]{subsets Package::packagedElement} (opposite Package::nestingPackage)
References the packaged elements that are Packages.

nestingPackage : Package [0..1]{subsets A_packagedElement_owningPackage::owningPackage} (opposite 
Package::nestedPackage)
References the Package that owns this Package.

♦ /ownedStereotype : Stereotype [0..*]{subsets Package::packagedElement} (opposite 
A_ownedStereotype_owningPackage::owningPackage)
References the Stereotypes that are owned by the Package.

♦ /ownedType : Type [0..*]{subsets Package::packagedElement} (opposite Type::package)
References the packaged elements that are Types.

♦ packageMerge : PackageMerge [0..*]{subsets Element::ownedElement, subsets 
A_source_directedRelationship::directedRelationship} (opposite PackageMerge::receivingPackage)
References the PackageMerges that are owned by this Package.

♦ packagedElement : PackageableElement [0..*]{subsets Namespace::ownedMember} (opposite 
A_packagedElement_owningPackage::owningPackage)
Specifies the packageable elements that are owned by this Package.

274

Unified Modeling Language 2.5

•

♦ profileApplication : ProfileApplication [0..*]{subsets Element::ownedElement, subsets 
A_source_directedRelationship::directedRelationship} (opposite ProfileApplication::applyingPackage)
References the ProfileApplications that indicate which profiles have been applied to the Package.

12.4.5.7

Operations

•

•

allApplicableStereotypes() : Stereotype [0..*]
The query allApplicableStereotypes() returns all the directly or indirectly owned stereotypes, including 
stereotypes contained in sub-profiles.

body: let ownedPackages : Bag(Package) = ownedMember->select(oclIsKindOf(Package))-
>collect(oclAsType(Package)) in
 ownedStereotype->union(ownedPackages.allApplicableStereotypes())->flatten()->asSet()

containingProfile() : Profile [0..1]
The query containingProfile() returns the closest profile directly or indirectly containing this package (or this 
package itself, if it is a profile).

body: if self.oclIsKindOf(Profile) then

self.oclAsType(Profile)

else

endif

self.namespace.oclAsType(Package).containingProfile()

• makesVisible(el : NamedElement) : Boolean

The query makesVisible() defines whether a Package makes an element visible outside itself. Elements with no 
visibility and elements with public visibility are made visible.

pre: member->includes(el)
body: ownedMember->includes(el) or
(elementImport->select(ei|ei.importedElement = VisibilityKind::public)-
>collect(importedElement.oclAsType(NamedElement))->includes(el)) or
(packageImport->select(visibility = VisibilityKind::public)->collect(importedPackage.member-
>includes(el))->notEmpty())

• mustBeOwned() : Boolean {redefines Element::mustBeOwned()}

The query mustBeOwned() indicates whether elements of this type must have an owner.

•

•

•

•

body: false

nestedPackage() : Package [0..*]
Derivation for Package::/nestedPackage

body: packagedElement->select(oclIsKindOf(Package))->collect(oclAsType(Package))->asSet()

ownedStereotype() : Stereotype [0..*]
Derivation for Package::/ownedStereotype

body: packagedElement->select(oclIsKindOf(Stereotype))->collect(oclAsType(Stereotype))-
>asSet()

ownedType() : Type [0..*]
Derivation for Package::/ownedType

body: packagedElement->select(oclIsKindOf(Type))->collect(oclAsType(Type))->asSet()

visibleMembers() : PackageableElement [0..*]
The query visibleMembers() defines which members of a Package can be accessed outside it.

Unified Modeling Language 2.5

275

body: member->select( m | m.oclIsKindOf(PackageableElement) and self.makesVisible(m))-
>collect(oclAsType(PackageableElement))->asSet()

12.4.5.8

Constraints

•

elements_public_or_private
If an element that is owned by a package has visibility, it is public or private.

inv: packagedElement->forAll(e | e.visibility<> null implies e.visibility = 
VisibilityKind::public or e.visibility = VisibilityKind::private)

12.4.6

12.4.6.1

PackageMerge [Class]

Description

A package merge defines how the contents of one package are extended by the contents of another package.

12.4.6.2

Diagrams

Packages

12.4.6.3

Generalizations

DirectedRelationship

12.4.6.4

Association Ends

• mergedPackage : Package [1..1]{subsets DirectedRelationship::target} (opposite 

A_mergedPackage_packageMerge::packageMerge)
References the Package that is to be merged with the receiving package of the PackageMerge.

•

receivingPackage : Package [1..1]{subsets DirectedRelationship::source, subsets Element::owner} (opposite 
Package::packageMerge)
References the Package that is being extended with the contents of the merged package of the PackageMerge.

12.4.7

12.4.7.1

Profile [Class]

Description

A profile defines limited extensions to a reference metamodel with the purpose of adapting the metamodel to a specific 
platform or domain.

12.4.7.2

Diagrams

Profiles

12.4.7.3

Generalizations

Package

12.4.7.4

Association Ends

•

276

♦ metaclassReference : ElementImport [0..*]{subsets Namespace::elementImport} (opposite 
A_metaclassReference_profile::profile)
References a metaclass that may be extended.

Unified Modeling Language 2.5

•

♦ metamodelReference : PackageImport [0..*]{subsets Namespace::packageImport} (opposite 
A_metamodelReference_profile::profile)
References a package containing (directly or indirectly) metaclasses that may be extended.

12.4.7.5

Constraints

• metaclass_reference_not_specialized

An element imported as a metaclassReference is not specialized or generalized in a Profile.

inv: metaclassReference.importedElement->

select(c | c.oclIsKindOf(Classifier) and

(c.oclAsType(Classifier).allParents()->collect(namespace)->includes(self)))-

>isEmpty()
and
packagedElement->
    select(oclIsKindOf(Classifier))->collect(oclAsType(Classifier).allParents())->
       intersection(metaclassReference.importedElement->select(oclIsKindOf(Classifier))-
>collect(oclAsType(Classifier)))->isEmpty()

•

references_same_metamodel
All elements imported either as metaclassReferences or through metamodelReferences are members of the 
same base reference metamodel.

inv: metamodelReference.importedPackage.elementImport.importedElement.allOwningPackages()->
  union(metaclassReference.importedElement.allOwningPackages() )->notEmpty()

12.4.8

12.4.8.1

ProfileApplication [Class]

Description

A profile application is used to show which profiles have been applied to a package.

12.4.8.2

Diagrams

Profiles

12.4.8.3

Generalizations

DirectedRelationship

12.4.8.4

Attributes

•

isStrict : Boolean [1..1] = false
Specifies that the Profile filtering rules for the metaclasses of the referenced metamodel shall be strictly 
applied.

12.4.8.5

Association Ends

•

•

appliedProfile : Profile [1..1]{subsets DirectedRelationship::target} (opposite 
A_appliedProfile_profileApplication::profileApplication)
References the Profiles that are applied to a Package through this ProfileApplication.

applyingPackage : Package [1..1]{subsets DirectedRelationship::source, subsets Element::owner} (opposite 
Package::profileApplication)
The package that owns the profile application.

Unified Modeling Language 2.5

277

12.4.9

12.4.9.1

Stereotype [Class]

Description

A stereotype defines how an existing metaclass may be extended, and enables the use of platform or domain specific 
terminology or notation in place of, or in addition to, the ones used for the extended metaclass.

12.4.9.2

Diagrams

Profiles

12.4.9.3

Generalizations

Class

12.4.9.4

Association Ends

•

•

♦ icon : Image [0..*]{subsets Element::ownedElement} (opposite A_icon_stereotype::stereotype)
Stereotype can change the graphical appearance of the extended model element by using attached icons. When 
this association is not null, it references the location of the icon content to be displayed within diagrams 
presenting the extended model elements.

/profile : Profile [1..1]{} (opposite A_profile_stereotype::stereotype)
The profile that directly or indirectly contains this stereotype.

12.4.9.5

Operations

•

•

containingProfile() : Profile
The query containingProfile returns the closest profile directly or indirectly containing this stereotype.

body: self.namespace.oclAsType(Package).containingProfile()

profile() : Profile
A stereotype must be contained, directly or indirectly, in a profile.

body: self.containingProfile()

12.4.9.6

Constraints

•

•

•

278

binaryAssociationsOnly
Stereotypes may only participate in binary associations.

inv: ownedAttribute.association->forAll(memberEnd->size()=2)

generalize
A Stereotype may only generalize or specialize another Stereotype.

inv: allParents()->forAll(oclIsKindOf(Stereotype))
and Classifier.allInstances()->forAll(c | c.allParents()->exists(oclIsKindOf(Stereotype)) 
implies c.oclIsKindOf(Stereotype))

name_not_clash
Stereotype names should not clash with keyword names for the extended model element.

Cannot be expressed in OCL

Unified Modeling Language 2.5

•

•

•

•

associationEndOwnership
Where a stereotype’s property is an association end for an association other than a kind of extension, and the 
other end is not a stereotype, the other end must be owned by the association itself.

inv: ownedAttribute
->select(association->notEmpty() and not association.oclIsKindOf(Extension) and not 
type.oclIsKindOf(Stereotype))
->forAll(opposite.owner = association)

base_property_upper_bound
The upper bound of base-properties is exactly 1.

Cannot be expressed in OCL

base_property_multiplicity_single_extension
If a Stereotype extends only one metaclass, the multiplicity of the corresponding base-property shall be 1..1.

Cannot be expressed in OCL

base_property_multiplicity_multiple_extension
If a Stereotype extends more than one metaclass, the multiplicity of the corresponding base-properties shall be 
[0..1]. At any point in time, only one of these base-properties can contain a metaclass instance during runtime.

Cannot be expressed in OCL

12.5
12.5.1

Association Descriptions
A_appliedProfile_profileApplication [Association]

12.5.1.1

Diagrams

Profiles

12.5.1.2

Owned Ends

•

profileApplication : ProfileApplication [0..*]{subsets A_target_directedRelationship::directedRelationship} 
(opposite ProfileApplication::appliedProfile)

12.5.2

12.5.2.1

A_icon_stereotype [Association]

Diagrams

Profiles

12.5.2.2

Owned Ends

•

stereotype : Stereotype [0..1]{subsets Element::owner} (opposite Stereotype::icon)

12.5.3

12.5.3.1

A_mergedPackage_packageMerge [Association]

Diagrams

Packages

Unified Modeling Language 2.5

279

12.5.3.2

Owned Ends

•

packageMerge : PackageMerge [0..*]{subsets A_target_directedRelationship::directedRelationship} (opposite 
PackageMerge::mergedPackage)

12.5.4

12.5.4.1

A_metaclassReference_profile [Association]

Diagrams

Profiles

12.5.4.2

Owned Ends

•

profile : Profile [0..1]{subsets ElementImport::importingNamespace} (opposite Profile::metaclassReference)

12.5.5

12.5.5.1

A_metamodelReference_profile [Association]

Diagrams

Profiles

12.5.5.2

Owned Ends

•

profile : Profile [0..1]{subsets PackageImport::importingNamespace} (opposite Profile::metamodelReference)

12.5.6

12.5.6.1

A_nestedPackage_nestingPackage [Association]

Diagrams

Packages

12.5.6.2

Member Ends

•

•

Package::nestedPackage
 

 

Package::nestingPackage
 

 

12.5.7

12.5.7.1

A_ownedEnd_extension [Association]

Diagrams

Profiles

12.5.7.2

Owned Ends

•

extension : Extension [1..1]{subsets Property::owningAssociation} (opposite Extension::ownedEnd)

12.5.8

12.5.8.1

A_ownedStereotype_owningPackage [Association]

Diagrams

Profiles

280

Unified Modeling Language 2.5

12.5.8.2

Generalizations

A_packagedElement_owningPackage

12.5.8.3

Owned Ends

•

owningPackage : Package [1..1]{redefines A_packagedElement_owningPackage::owningPackage} (opposite 
Package::ownedStereotype)

12.5.9

12.5.9.1

A_ownedType_package [Association]

Diagrams

Packages

12.5.9.2

Member Ends

•

•

Package::ownedType
 

 

Type::package
 

 

12.5.10

A_packageMerge_receivingPackage [Association]

12.5.10.1

Diagrams

Packages

12.5.10.2

Member Ends

•

•

Package::packageMerge
 

 

PackageMerge::receivingPackage
 

 

12.5.11

A_packagedElement_owningPackage [Association]

12.5.11.1

Diagrams

Packages

12.5.11.2

Specializations

A_ownedStereotype_owningPackage

12.5.11.3

Owned Ends

•

owningPackage : Package [0..1]{subsets NamedElement::namespace} (opposite Package::packagedElement)

12.5.12

A_profileApplication_applyingPackage [Association]

12.5.12.1

Diagrams

Profiles

Unified Modeling Language 2.5

281

12.5.12.2

Member Ends

•

•

Package::profileApplication
 

 

ProfileApplication::applyingPackage
 

 

12.5.13

A_profile_stereotype [Association]

12.5.13.1

Diagrams

Profiles

12.5.13.2

Owned Ends

•

stereotype : Stereotype [0..*] (opposite Stereotype::profile)

12.5.14

A_type_extensionEnd [Association]

12.5.14.1

Diagrams

Profiles

12.5.14.2

Owned Ends

•

extensionEnd : ExtensionEnd [0..*]{subsets A_type_typedElement::typedElement} (opposite 
ExtensionEnd::type)

282

Unified Modeling Language 2.5

Summary

13 Common Behavior
13.1
This clause specifies the core concepts underlying all behavioral modeling in UML. Structural models of Classifiers in 
UML define the allowable instances that may exist at any point in time, what values their StructuralFeatures may have 
and how those instances may be related to each other. Behavioral modeling, on the other hand, models how these 
instances may change over time.
UML provides Behavior, Event, and Trigger constructs to model the corresponding fundamental concepts of behavioral 
modeling.
Behavior is the basic concept for modeling dynamic change. Behavior may be executed, either by direct invocation or 
through the creation of an active object that hosts the behavior. Behavior may also be emergent, resulting from the 
interaction of one or more participant objects that are themselves carrying out their own individual behaviors.
Dynamic behavior results in events of interest that occur at specific points in time. Such events may be implicit, 
occurring on the change of some value or the passage of some interval of time. They may also be explicit, occurring 
when an operation is called or an asynchronous signal is received.
The occurrence of an event may then trigger new behavior, or change the course of already executing behavior. Explicit 
events thus provide the basic mechanism for communication between behaviors, in which an action carried out in one 
behavior, such as calling an operation or sending a signal, can trigger a response in another behavior.
The remainder of this clause further details the fundamental UML modeling mechanisms of Behaviors, Events and 
Triggers. These mechanisms then provide the framework for the specification in the following clauses of various 
complete UML behavioral modeling constructs.

Behaviors
Summary

13.2
13.2.1
This sub clause introduces the framework for modeling behavior in UML. The concrete subtypes of Behavior, described 
in subsequent clauses, then provide different mechanisms to specify behaviors.
A variety of behavioral specification mechanisms are supported by UML, including:

StateMachines that model finite automata (see Clause 14)

•
• Activities defined using Petri-net-like graphs (see Clause 15)
•

Interactions that model partially-ordered sequences of event occurrences (see Clause 17).

These behavioral specification mechanisms differ in their expressive power and domain of applicability. This means 
that not all behaviors can be described by each of the mechanisms. Nevertheless, many behaviors can be described by 
one or more of the mechanisms, in which case the choice of mechanism is one of convenience, or, alternatively, 
multiple mechanisms can be used to provide different models of the same behavior.

Unified Modeling Language 2.5

283

13.2.2

Abstract Syntax

BehavioredClassifier

{readOnly, subsets
redefinitionContext}
+ /context

{subsets
redefinableElement}
+ behavior

0..1

*

Behavior

+ isReentrant : Boolean = true

Class

{redefines
behavioredClassifier}
+ behavioredClassifier

0..1

{subsets ownedBehavior}

+ classifierBehavior

0..1

{subsets namespace}
+ behavioredClassifier

{subsets ownedMember}

+ ownedBehavior

0..1

+ specification

0..1

{ordered, subsets
ownedMember}

+ ownedParameter
*

*

+ method

*

{subsets namespace}
+ behavior
0..1

BehavioralFeature

Parameter

{subsets context}

+ behavior

{subsets ownedRule}

+ precondition

0..1

*

Constraint

{subsets context}
+ behavior

{subsets ownedRule}
+ postcondition

+ behavior

{subsets classifier}

*

0..1

*

*

+ redefinedBehavior

{subsets redefinedClassifier}

{subsets namespace}
+ behavior

*

ParameterSet

0..1

+ ownedParameterSet
{subsets ownedMember}

OpaqueBehavior

+ body : String [*] {ordered, nonunique}
+ language : String [*] {ordered}

FunctionBehavior

Figure 13.1  Behaviors

13.2.3

13.2.3.1

Semantics

Behaviors

A Behavior is a specification of events that may occur dynamically over time (see also sub clause 13.3 on the explicit 
modeling of Events in UML). This specification may be prescriptive of specifically what events may occur in what 
situations, descriptive of emergent behavior or illustrative of possible sequences of event occurrences. Every Behavior 
defines at least one event, the event of its invocation. A Behavior may be invoked directly, via a BehavioralFeature that 
it implements as a method or as the classifierBehavior of a BehavioredClassifier.
On each invocation, the subsequent actual sequence of event occurrences due to the invocation, consistent with the 
specification of the Behavior, is called an execution trace for the Behavior. An execution trace always begins with the 
invocation of the Behavior and may continue indefinitely (if the Behavior does not terminate), or it may end in the 
occurrence of a termination event for the Behavior, in which case the execution of the Behavior is said to have 
completed. A Behavior may either complete normally, or it may complete as a result of the raising of an exception, in 
which case, if the Behavior was invoked synchronously (see below), the exception is propagated to the caller (see also 
the discussion of exceptions in sub clause 15.5.3). Event occurrences during an execution trace include both 
occurrences caused by the Behavior, such as attribute value changes, creation and destruction of objects and invocation 
of other Behaviors, and occurrences that trigger responses within the Behavior, such as the changing of a monitored 
value or the receipt of a Signal instance.
Behaviors in UML are kinds of Classes, which means that they may be instantiated as objects. An object that is an 
instance of a Behavior is known as a behavior execution. Invoking the Behavior corresponds to instantiating the 
Behavior, and there is a specific execution trace corresponding to each Behavior execution.

284

Unified Modeling Language 2.5

Since a Behavior is a Class, it may be specialized and may also itself own StructuralFeatures and BehavioralFeatures. 
These features may be referenced in the specification of the Behavior. An execution of the Behavior may then access 
these features, such as reading and modifying attributes of the Behavior. Public features of a Behavior may also be 
referenced from outside of the Behavior, as usual for the features of any Class.
A Behavior may be invoked many times. A reentrant Behavior (i.e., one with its isReentrant property equal to true) may 
be invoked again before a previous invocation has completed (this is the default). On the other hand, a non-reentrant 
Behavior (i.e, one with its isReentrant property equal to false) shall not be invoked again if a previous invocation has not 
completed. A reentrant Behavior may have many ongoing executions at any one time, but a non-reentrant Behavior shall 
have at most one uncompleted execution at any time. If an invoking Behavior attempts to invoke a non-reentrant 
Behavior that already has an uncompleted execution, then the invoker shall block until the existing execution completes 
(or indefinitely, if the execution never completes).
A Behavior may be invoked synchronously or asynchronously. Synchronous invocation means that an invoking 
Behavior retains a reference to the invoked Behavior execution and waits for the execution to complete. Asynchronous 
invocation, on the other hand, means that the invoked Behavior execution proceeds concurrently with the invoking 
Behavior.
The preconditions for a Behavior define conditions that shall be true when the Behavior is invoked. These preconditions 
may be assumed in the detailed specification of the Behavior. The semantics of an invocation of a Behavior when a 
precondition is not satisfied are intentionally undefined.
The postconditions for a Behavior define conditions that will be true when the invocation of the Behavior completes 
successfully, assuming the preconditions were satisfied. These postconditions shall be satisfied in the detailed specification 
of the Behavior.

13.2.3.2

Behavior Parameters

A Behavior may have Parameters (see sub clause 9.4) that provide the ability to pass values into and out of Behavior 
executions.
When a Behavior is invoked, argument values may be provided corresponding to Parameters with direction “in” or 
“inout”, as constrained by the multiplicity of those Parameters. If such an input Parameter has a defaultValue, and no 
explicit argument value is given for it, then the defaultValue is evaluated to provide argument values for the Parameter 
(even if the Parameter has a multiplicity lower bound of 0, so having no value would be valid for it). Argument values 
are available to affect the course of the invoked Behavior execution.
When a Behavior execution completes, it may produce result values corresponding to Parameters with direction “inout,” 
“out,” and “return,” as constrained by the multiplicity of those Parameters. If such an output Parameter has a 
defaultValue, and no explicit result value is given for it, then the defaultValue is evaluated to provide result values for the 
Parameter (even if the Parameter has a multiplicity lower bound of 0, so having no value would be valid for it). If the 
Behavior was invoked synchronously, then result values are returned to the invoker. However, if the Behavior was 
invoked asynchronously, then any result values are lost when the Behavior execution completes.
Parameters may also be marked as streaming (i.e., have the isStreaming property be true). Such Parameters allow values 
to be passed into and out of a Behavior execution any time during its course, rather than just on invocation and 
completion.
If an input Parameter is streaming, then argument values may be provided for the Parameter during the course of a 
Behavior execution rather than just at invocation. One or more argument values may be posted to a streaming input 
Parameter at or any time after the invocation of a Behavior and before its completion. These argument values are then 
available to affect the further course of the Behavior execution from that time forward.
If an output Parameter is streaming, then a Behavior execution may provide result values for the Parameter during its 
course rather than just at completion. One or more result values may be posted to a streaming output Parameter any time 
after the invocation of a Behavior up to or at its completion. These result values are then available to affect the further 
course of the execution of the invoking Behavior from that time forward.

Unified Modeling Language 2.5

285

NOTE. In order for an invoker to be able to obtain posted values from streaming output Parameters, the invoked 
Behavior has to be invoked synchronously, even though streamed outputs could potentially trigger asynchronous 
responses in the invoker. (See sub clause 16.3.3 on the semantics of CallActions in the case of streaming Parameters, 
including the effect of the multiplicity of such Parameters.)
A reentrant Behavior shall not have streaming Parameters, because there are potentially multiple executions of the 
Behavior going at the same time, and it would be ambiguous which execution would be receiving or producing 
streamed values.
A Behavior may have one or more output Parameters marked as isException=true. In this case, when an execution of the 
Behavior completes, either none of these Parameters shall have values or exactly one shall have a value and no other 
parameters (exception or otherwise) shall have any values.
NOTE. Returning a value in an exception Parameter is not considered to be “raising an exception” in the sense 
described in sub clause 15.5.3.
A Behavior with input ParameterSets can only accept inputs from Parameters in one of the sets per execution. A 
Behavior with output ParameterSets can only post outputs to the Parameters in one of the sets per execution. The 
semantics of conditions of input and output ParameterSets are the same as Behavior preconditions and postconditions, 
respectively, but apply only to the set of Parameters specified.

13.2.3.3

Opaque and Function Behaviors

An OpaqueBehavior is a Behavior whose specification is given in a textual language other than UML.
An OpaqueBehavior has a body that consists of a sequence of text Strings representing alternative means of specifying 
the required behavior. A corresponding sequence of language Strings may be used to specify the languages in which each 
of the body Strings is to be interpreted. Languages are matched to body Strings by order. The UML specification does not 
define how body Strings are interpreted relative to any language, though other specifications may define specific 
language Strings to be used to indicate interpretation with respect to those specifications (e.g., “OCL” for expressions to 
be interpreted according to the OCL specification).
NOTE. It is not required to specify the languages. If they are unspecified, then the interpretation of any body Strings 
shall be determined implicitly from the form of the bodies or the context of use of the OpaqueBehavior.
If an OpaqueBehavior has more than one body String, then any one of the bodies can be used to determine the behavior 
of the OpaqueBehavior. The UML specification does not determine how this choice is made.
A FunctionBehavior is an OpaqueBehavior that does not access or modify any objects or other external data. During the 
execution of a FunctionBehavior, no communication or interaction with anything external to the FunctionBehavior is 
allowed. The amount of time to compute its results is undefined. A FunctionBehavior may raise exceptions for certain 
input values, in which case the computation is abandoned.
FunctionBehaviors thus represent functions that transform a set of input argument values (given by the input Parameters 
of the FunctionBehavior) to a set of output result values (given by the output Parameters of the FunctionBehavior). The 
execution of a FunctionBehavior depends only on the argument values and has no other effect than to compute result 
values. Examples of functions that might be modeled as FunctionBehaviors include primitive arithmetic, Boolean, and 
String functions.

13.2.3.4

Behaviored Classifiers

A BehavioredClassifier is a Classifier that may have ownedBehaviors, at most one of which may be considered to specify 
the behavior of the BehavioredClassifier itself. Conversely, a Behavior that is the ownedBehavior of a 
BehavioredClassifier has that BehavioredClassifier as its context. The specification of such a Behavior may reference 
features of the context BehavioredClassifier as well as any other elements visible to the context BehavioredClassifier.
A Behavior that is not directly an ownedBehavior of a BehavioredClassifier may nevertheless still have a context. To 
determine the context of a Behavior that is not directly an ownedBehavior, find the first BehavioredClassifier reached by 
following the chain of ownership relationships from the Behavior, if any. If there is such a BehavioredClassifier, then it 

286

Unified Modeling Language 2.5

is the context, unless it is itself a Behavior with a non-empty context, in which case this is also the context for the original 
Behavior. For example, the context of an entry Behavior (see sub clause 14.2) in a StateMachine owned by a 
BehavioredClassifier is the classifier that owns the StateMachine, not the StateMachine.
A Behavior that is owned directly by a Class as a nestedClassifier (see sub clause 11.4), rather than as an ownedBehavior, 
does not have the Class as its context. The nestedClassifiers of a Class are simply nested in the Class considered as a 
Namespace. As a nestedClassifier, a Behavior has visibility of elements defined within the owning Class and other 
elements visible to that Class, and it may itself be visible outside the Class, depending on its declared visibility. But its 
semantics as a “stand-alone” Behavior are not otherwise affected by being nested in the Class.
If a Behavior has a context, then an execution of the Behavior always has an associated context object that is an instance 
of the context BehavioredClassifier (as long as that BehavioredClassifier is instantiable). A Behavior without a context 
BehavioredClassifier may still be invoked as a “stand-alone” Behavior. In this case, the Behavior execution serves as its 
own context object. The Behavior execution also serves as its own context object in the case that the context 
BehavioredClassifier is not instantiable, that is, if it is a Component with isIndirectlyInstantiated=true (see sub clause 11.6) 
or a Collaboration (see sub clause 11.7). Thus, a Behavior execution always has a context object, whether or not the 
Behavior has an explicit, instantiable context BehavioredClassifier.
A BehavioredClassifier may have a distinguished ownedBehavior called its classifierBehavior. A classifierBehavior describes 
the behavior an instance of the owning Classifier may undergo in the course of its lifetime. The classifierBehavior of a 
BehavioredClassifier is considered to be invoked when an instance of the owning BehavioredClassifier is created and 
the resulting execution has the new instance as its context object. The execution is terminated if the instance is 
destroyed.
The precise semantics of a classifierBehavior depend on the kind of BehavioredClassifier that owns it. For example, the 
classifierBehavior of a Collaboration (see sub clause 11.7) represents emergent behavior of all the parts, whereas the 
classifierBehavior of a Class (see sub clause 11.4) is just the behavior of instances of the Class separated from the 
behaviors of any of its parts. However, a passive Class (with isActive=false) shall not have a classifierBehavior.

13.2.3.5

Behavioral Features and Methods

There are two kinds of BehavioralFeatures: Operations (see sub clause 9.6) and Receptions (see sub clause 10.3). Of the 
different kinds of BehavioredClassifiers in UML, only Classes may have BehavioralFeatures and only active Classes 
may have Receptions (see sub clause 11.4). Calling an Operation on or sending a Signal instance to an object of a Class 
is a request for the object to carry out an identified BehavioralFeature. An Operation call identifies a specific operation 
to be invoked. The receipt of an instance of a Signal, on the other hand, is considered to be a request for any Reception 
of the receiving object that references that Signal or any direct or indirect generalization of it.
A BehavioralFeature of a Class may be implemented by one or more method Behaviors. Such a BehavioralFeature 
specifies that instances of the owning Class will respond to a request for the BehavioralFeature by invoking one of the 
feature’s implementing methods. A Behavior shall be the method for no more than one BehavioralFeature, called its 
specification. The specification of a Behavior shall be an owned or inherited member of the Class of which the Behavior is 
an ownedBehavior. It is possible to have more than one method associated with a single BehavioralFeature, but there shall 
be at most one Behavior for a particular pairing of a Class (as owner of the Behavior) and a BehavioralFeature (as the 
specification for the Behavior). This means that a single BehavioralFeature may have methods both in its owning Class 
and any direct or indirect subclass of that Class, but with no more than one method per Class.
The receiving object becomes the context object for the execution of any invoked methods.
NOTE. Methods of a Reception are always invoked asynchronously, while the methods of an Operation may be invoked 
either synchronously or asynchronously, depending on how the Operation is called.
The method resolution process shall be based on the BehavioralFeature being requested, the object receiving the request 
and any data values associated with the request (i.e., Operation input parameter values or Signal attribute values). 
However, the UML specification does not mandate that a conforming UML tool support any particular resolution 
process. In general, the resolution process may be complicated, to include such mechanisms as before-after methods, 
delegation, etc. In some of these variations, multiple Behaviors may be executed as a result of a single call. If no 
methods are identified by the resolution process, then it is undefined what happens.

Unified Modeling Language 2.5

287

The following is a simple object-oriented resolution process for a CallEvent that always results in at most one method 
being identified:

If the Class of the receiving object owns a method for the Operation identified in the CallEvent, then that 
method is the result of the resolution. Otherwise, the superclass of the Class of the receiving object is examined 
for a method for the Operation, and so on up the generalization hierarchy until a method is found or the root of 
the hierarchy is reached. If a Class has multiple superclasses, then all of them are examined for a method. If no 
method is found, or a method is found in more than one ancestor Class along different paths, then the model is 
ill-formed for this resolution process and it results in no method.

A method of an Operation shall have Parameters corresponding to the Parameters of the Operation. Similarly, a method of 
a Reception shall have Parameters corresponding to the attributes of the Signal referenced by the Reception, which are 
considered as effective “in” Parameters of the Reception. The data values associated with a request – input Operation 
parameter values or Signal attribute values – are then passed to a method invoked due to the request via the method 
parameters. For a synchronous Operation call, output Parameter values from the method execution are also passed back 
to the Operation caller via the corresponding Operation output Parameters.
However, no specific approach is defined for matching the Parameters of the method to the Parameters of the 
BehavioralFeature. Possible approaches include exact match (i.e., the type of the corresponding Parameters, in order, 
must be the same), co-variant match (the type of a Parameter of the method may be a subtype of the type of the Parameter 
of the BehavioralFeature), contra-variant match (the type of a Parameter of the method may be a supertype of the type of 
the Parameter of the BehavioralFeature), or a combination thereof.

Notation

13.2.4
The notation for various subclasses of Behavior are defined in subsequent clauses.
The notation for Signals and Receptions is covered under Simple Classifiers in sub clause 10.3.4.
The notation for active Classes is covered under Structured Classifiers in sub clause 11.4.4.

Examples

13.2.5
None.

Events
Summary

13.3
13.3.1
An Event is a something that may occur at a specific instant in time. One Event may have many occurrences, which 
may happen at different times. In this sense, an Event can be considered a classification of its occurrences, though 
Events are not actually Classifiers in UML.
Of particular importance are Events that trigger a response within a Behavior. Such Events that may be explicitly 
modeled within UML include TimeEvents that occur at a specified time or after a duration, ChangeEvents that occur 
when a specified Boolean value becomes true and MessageEvents that occur on the receipt of a message, which is a 
communication from one Behavior to another requesting an Operation call or Signal reception.

288

Unified Modeling Language 2.5

13.3.2

Abstract Syntax

NamedElement

PackageableElement

Port

+ port
*

+ trigger

Trigger

+ trigger

+ event

Event

*

*

1

MessageEvent

ChangeEvent

TimeEvent

+ isRelative : Boolean = false

{subsets owner}
+ changeEvent

0..1

{subsets owner}

0..1 + timeEvent

{subsets ownedElement}
+ changeExpression

1

{subsets ownedElement}
+ when

1

AnyReceiveEvent

SignalEvent

CallEvent

ValueSpecification

TimeExpression

+ signalEvent

*

*

+ callEvent

+ signal

1

1

+ operation

Signal

Operation

Figure 13.2  Events

13.3.3

13.3.3.1

Semantics

Event Dispatching

An Event is the specification of some occurrence that may potentially trigger behavioral effects. A Trigger specifies a 
specific point in the definition of a Behavior at which an Event occurrence may have such an effect. Event is a 
PackageableElement, allowing Events to be modeled independently of their use. A Trigger, however, always appears as 
a part of some larger behavioral specification (e.g., on a StateMachine Transition or in an AcceptEventAction). A single 
Event may be used in several different Triggers.
As discussed in sub clause 13.2.3, a Behavior execution always has an associated context object (which may be the 
execution itself). A context object mediates the handling of Event occurrences for all of its associated Behavior 
executions. When an Event occurrence is recognized by a context object, it may have an immediate effect or it may be 
saved for later triggered effect. An immediate effect is manifested by direct invocation of a Behavior as determined by 
the Event, such as the invocation of the method of a BehavioralFeature (see sub clause 13.2.3). A triggered effect is 
manifested by the storage of the occurrence in the event pool of the object and the later consumption of the occurrence 
by an ongoing Behavior execution that reaches a Trigger that matches the Event corresponding to the occurrence in the 
pool.
In general, when a Behavior execution comes to a wait point where it needs a Trigger to continue, the event pool of its 
context object is examined for an event that satisfies the outstanding Trigger (or Triggers). If the pool contains an event 
occurrence that satisfies one of the Triggers, the occurrence is removed from the pool and dispatched to the Behavior, 
which continues its execution as specified. Any data associated with the Event occurrence are made available to the 
triggered Behavior during its further execution.
NOTE. All Behaviors with the same context object share the event pool of that object, but any Event occurrence in the 
pool can be consumed by only one Behavior.
There is no requirement for a specific order in which Event occurrences in an event pool are examined or dispatched. If 
an event pool contains an occurrence that satisfies no Triggers at a wait point, then the general semantics of 

Unified Modeling Language 2.5

289

BehavioredClassifiers do not specify what happens to it. (However, see the specific semantics for the dispatching and 
deferring of event occurrences for StateMachines in sub clause 14.2.)

13.3.3.2

Message Events

A message is a communication in which a sender makes a request for either an Operation call or Signal reception by a 
receiver. This communication involves two events: the event of sending the message and the event of receiving the 
message. Sending events, however, are not modeled as explicit model elements in UML, though they are implicit in the 
execution of InvocationActions (see sub clause 16.3) and occurrences of such events can be modeled in Interactions 
(see sub clause 17.5). A MessageEvent, on the other hand, is an explicit model of the receipt of a message, in order to be 
able to specify a Trigger that responds to occurrences of that event.
A message contains:

• Data associated with the request being made (arguments for Operation parameters or values for Signal 

attributes).
Information about the nature of the request (i.e., the BehavioralFeature invoked).

•

•

For a synchronous invocation, sufficient information to enable the return of a reply from the invoked Behavior.

While each message is targeted at exactly one receiver object and caused by exactly one sending object, an occurrence 
of a sending event may result in a number of messages being generated (as in SignalBroadcastAction, see sub clause 
16.3). The receiver of a message may be the same as the sender, it may be local (i.e., an object held in a slot of the 
currently executing Behavior or its context object) or it may be remote. The manner of transmitting the message, the 
amount of time required to transmit it, the order in which the transmissions reach their receiver object and the path for 
reaching the receiver object are undefined.
The receipt of a message is manifested as a MessageEvent occurrence. A CallEvent is a MessageEvent for messages 
requesting that a specific Operation be called. A SignalEvent is a MessageEvent for messages requesting the reception 
of an instance of a specific Signal. An AnyReceiveEvent is a MessageEvent for any message that is not explicitly 
handled by any other related Trigger.
In the case of a CallEvent for an Operation or a SignalEvent for a Signal that matches a Reception on the receiver, if the 
Operation or Reception has one or more methods, then the method resolution process described for Behavioral Features 
and Methods in sub clause 13.2.3 shall be carried out to determine a method to be used to handle a MessageEvent 
occurrence. If a method is so identified, it is invoked to respond to the message request. Otherwise, the MessageEvent 
occurrence is saved in the event pool of the receiving object. When a MessageEvent occurrence is dispatched from the 
event pool and matches a Trigger defined in the Behavior specification for the receiver, it causes the execution of a 
response within the Behavior.
A Trigger for an AnyReceiveEvent may be triggered by the receipt of any message (Signal send or Operation call). 
However, if there is a relevant SignalEvent or CallEvent Trigger that specifically matches the message, then the 
AnyReceiveEvent Trigger is not triggered by the message. Which other Triggers are related to an AnyReceiveEvent 
Trigger depends on the context of the Trigger (in particular, see sub clause 14.2 on Transitions and sub clause 16.10 on 
AcceptEventActions). An AnyReceiveEvent may also be triggered by the receipt of a message containing an object 
other than a SignalInstance, as may be sent by a SendObjectAction (see sub clause 16.3.3).
A Trigger may also specify one or more ports, in which case the event of the Trigger shall be a MessageEvent. In this 
case the Trigger only matches event occurrences for messages received through one of the specified Ports (see also sub 
clause 11.3 on EncapsulatedClassifiers and Ports).

13.3.3.3

Change Events

A ChangeEvent occurs when a Boolean changeExpression becomes true. For example, this could be as a result of a 
change in the value of some Attribute or a change in the value referenced by a link corresponding to an Association. A 
ChangeEvent occurs implicitly and is not the result of any explicit action.

290

Unified Modeling Language 2.5

An occurrence is considered to be generated any time the value of the changeExpression changes from false to true. 
However, it is not defined specifically when a changeExpression is evaluated or whether a ChangeEvent occurrence 
remains available for detection even if the associated changeExpression value changes back to false before the occurrence 
is consumed.

13.3.3.4

Time Events

A TimeEvent specifies an instant in time at which it occurs. The instant is specified using a TimeExpression (see sub 
clause 8.4). If the TimeEvent is absolute, then the time resulting from the evaluation of the TimeExpression is the 
absolute time at which the TimeEvent occurs. If the TimeEvent is relative, then the TimeEvent shall be used in the 
context of a Trigger, and the time of occurrence is relative to a starting time determined for the Trigger.
As discussed above under “Event Dispatching”, a Behavior may come to a wait point at which it has one or more 
Triggers available to which event occurrences may be dispatched. If such an outstanding Trigger has a relative 
TimeEvent, then the starting time for that TimeEvent is the time at which the Behavior came to the wait point.

Notation

13.3.4
There is no notation for Events outside of the context of their use in Triggers. A Trigger is denoted textually based on 
the kind of Event it is for:
<trigger> ::= <call-event> | <signal-event> | <any-receive-event> | <time-event> | <change-event>
where:

• A CallEvent is denoted by the name of the triggering Operation, optionally followed by an assignment 

specification:
<call-event> ::= <name> [‘(‘ [<assignment-specification>] ‘)’]
<assignment-specification> ::= <assigned-name> [‘,’ <assigned-name>]*
where:
<assigned-name> is an implicit assignment of the argument value for the corresponding Parameter of the 
Operation to a Property or Variable of the context object for the triggered Behavior.
<assignment-specification> is optional and may be omitted even if the Operation has Parameters. No standard 
mapping is defined from an assignment specification to the UML abstract syntax. A conforming tool is not 
required to support this notation. If it does, it may provide a mapping to standard UML abstract syntax, e.g., by 
implicitly inserting Actions to carry out the behavior implied by the notation.

• A SignalEvent is denoted by name of the triggering Signal, optionally followed by an assignment specification:

<signal-event> ::= <name> [‘(‘ [<assignment-specification>] ‘)’]
<assignment-specification> ::= <attr-name> [‘,’<attr-name>]*
where <assignment-specification> is defined as for CallEvent above.

• Any AnyReceiveEvent is denoted by “all”:

<any-receive-event> ::= ‘all’

• A ChangeEvent is denoted by “when” followed by a Boolean ValueSpecification:

<change-event> ::= ‘when’ <value-specification>
See Clause 8 for the notation for various kinds of ValueSpecifications.

• A relative TimeEvent is denoted with “after” followed by a TimeExpression, such as “after 5 seconds.” An 
absolute TimeEvent is specified with “at” followed by a TimeExpression, such as “at Jan. 1, 2000, Noon”.

Unified Modeling Language 2.5

291

<time-event> ::= <relative-time-event> | <absolute-time-event>
<relative-time-event> ::= ‘after’ <time-expression>
<absolute-time-event> ::= ‘at’ <time-expression>
See also sub clause 8.4.4 on the notation for TimeExpressions.

Examples

Classifier Descriptions
AnyReceiveEvent [Class]

13.3.5
None.

13.4
13.4.1

13.4.1.1

Description

A trigger for an AnyReceiveEvent is triggered by the receipt of any message that is not explicitly handled by any related 
trigger.

13.4.1.2

Diagrams

Events

13.4.1.3

Generalizations

MessageEvent

13.4.2

13.4.2.1

Behavior [Abstract Class]

Description

Behavior is a specification of how its context BehavioredClassifier changes state over time. This specification may be 
either a definition of possible behavior execution or emergent behavior, or a selective illustration of an interesting subset 
of possible executions. The latter form is typically used for capturing examples, such as a trace of a particular execution.

13.4.2.2

Diagrams

Behaviors, Object Nodes, Activities, Control Nodes, Expressions, Structured Classifiers, Behavior State 
Machines, Interfaces, Interactions, Occurrences, Features, Invocation Actions, Other Actions

13.4.2.3

Generalizations

Class

13.4.2.4

Specializations

OpaqueBehavior, Activity, StateMachine, Interaction

13.4.2.5

Attributes

•

isReentrant : Boolean [1..1] = true
Tells whether the Behavior can be invoked while it is still executing from a previous invocation.

292

Unified Modeling Language 2.5

13.4.2.6

Association Ends

•

•

•

•

•

•

•

/context : BehavioredClassifier [0..1]{subsets RedefinableElement::redefinitionContext} (opposite 
A_context_behavior::behavior)
The BehavioredClassifier that is the context for the execution of the Behavior. A Behavior that is directly 
owned as a nestedClassifier does not have a context. Otherwise, to determine the context of a Behavior, find 
the first BehavioredClassifier reached by following the chain of owner relationships from the Behavior, if any. 
If there is such a BehavioredClassifier, then it is the context, unless it is itself a Behavior with a non-empty 
context, in which case that is also the context for the original Behavior. For example, following this algorithm, 
the context of an entry Behavior in a StateMachine is the BehavioredClassifier that owns the StateMachine. 
The features of the context BehavioredClassifier as well as the Elements visible to the context Classifier are 
visible to the Behavior.

♦ ownedParameter : Parameter [0..*]{ordered, subsets Namespace::ownedMember} (opposite 
A_ownedParameter_behavior::behavior)
References a list of Parameters to the Behavior which describes the order and type of arguments that can be 
given when the Behavior is invoked and of the values which will be returned when the Behavior completes its 
execution.

♦ ownedParameterSet : ParameterSet [0..*]{subsets Namespace::ownedMember} (opposite 
A_ownedParameterSet_behavior::behavior)
The ParameterSets owned by this Behavior.

♦ postcondition : Constraint [0..*]{subsets Namespace::ownedRule} (opposite 
A_postcondition_behavior::behavior)
An optional set of Constraints specifying what is fulfilled after the execution of the Behavior is completed, if 
its precondition was fulfilled before its invocation.

♦ precondition : Constraint [0..*]{subsets Namespace::ownedRule} (opposite 
A_precondition_behavior::behavior)
An optional set of Constraints specifying what must be fulfilled before the Behavior is invoked.

specification : BehavioralFeature [0..1] (opposite BehavioralFeature::method)
Designates a BehavioralFeature that the Behavior implements. The BehavioralFeature must be owned by the 
BehavioredClassifier that owns the Behavior or be inherited by it. The Parameters of the BehavioralFeature 
and the implementing Behavior must match. A Behavior does not need to have a specification, in which case it 
either is the classifierBehavior of a BehavioredClassifier or it can only be invoked by another Behavior of the 
Classifier.

redefinedBehavior : Behavior [0..*]{subsets Classifier::redefinedClassifier} (opposite 
A_redefinedBehavior_behavior::behavior)
References the Behavior that this Behavior redefines. A subtype of Behavior may redefine any other subtype of 
Behavior. If the Behavior implements a BehavioralFeature, it replaces the redefined Behavior. If the Behavior 
is a classifierBehavior, it extends the redefined Behavior.

13.4.2.7

Operations

•

context() : BehavioredClassifier [0..1]
A Behavior that is directly owned as a nestedClassifier does not have a context. Otherwise, to determine the 
context of a Behavior, find the first BehavioredClassifier reached by following the chain of owner relationships 
from the Behavior, if any. If there is such a BehavioredClassifier, then it is the context, unless it is itself a 
Behavior with a non-empty context, in which case that is also the context for the original Behavior.

Unified Modeling Language 2.5

293

body: if nestingClass <> null then
    null
else
    let b:BehavioredClassifier = self.behavioredClassifier(self.owner) in
    if b.oclIsKindOf(Behavior) and b.oclAsType(Behavior)._'context' <> null then
        b.oclAsType(Behavior)._'context'
    else
        b
    endif
endif

behavioredClassifier(from : Element) : BehavioredClassifier [0..1]
The first BehavioredClassifier reached by following the chain of owner relationships from the Behavior, if any.

body: if from.oclIsKindOf(BehavioredClassifier) then
    from.oclAsType(BehavioredClassifier)
else if from.owner = null then
    null
else
    self.behavioredClassifier(from.owner)
endif
endif

inputParameters() : Parameter [0..*]{ordered}
The in and inout ownedParameters of the Behavior.

body: ownedParameter->select(direction=ParameterDirectionKind::_'in' or 
direction=ParameterDirectionKind::inout)

outputParameters() : Parameter [0..*]{ordered}
The out, inout and return ownedParameters.

body: ownedParameter->select(direction=ParameterDirectionKind::out or 
direction=ParameterDirectionKind::inout or direction=ParameterDirectionKind::return)

•

•

•

13.4.2.8

Constraints

• most_one_behavior

There may be at most one Behavior for a given pairing of BehavioredClassifier (as owner of the Behavior) and 
BehavioralFeature (as specification of the Behavior).

inv: specification <> null implies _'context'.ownedBehavior-
>select(specification=self.specification)->size() = 1

parameters_match
If a Behavior has a specification BehavioralFeature, then it must have the same number of ownedParameters as 
its specification. The Behavior Parameters must also "match" the BehavioralParameter Parameters, but the 
exact requirements for this matching are not formalized.

inv: specification <> null implies ownedParameter->size() = specification.ownedParameter-
>size()

feature_of_context_classifier
The specification BehavioralFeature must be a feature (possibly inherited) of the context BehavioredClassifier 
of the Behavior.

inv: _'context'.feature->includes(specification)

Unified Modeling Language 2.5

•

•

294

13.4.3

13.4.3.1

CallEvent [Class]

Description

A CallEvent models the receipt by an object of a message invoking a call of an Operation.

13.4.3.2

Diagrams

Events

13.4.3.3

Generalizations

MessageEvent

13.4.3.4

Association Ends

•

operation : Operation [1..1] (opposite A_operation_callEvent::callEvent)
Designates the Operation whose invocation raised the CalEvent.

13.4.4

13.4.4.1

ChangeEvent [Class]

Description

A ChangeEvent models a change in the system configuration that makes a condition true.

13.4.4.2

Diagrams

Events

13.4.4.3

Generalizations

Event

13.4.4.4

Association Ends

•

♦ changeExpression : ValueSpecification [1..1]{subsets Element::ownedElement} (opposite 
A_changeExpression_changeEvent::changeEvent)
A Boolean-valued ValueSpecification that will result in a ChangeEvent whenever its value changes from false 
to true.

13.4.5

13.4.5.1

Event [Abstract Class]

Description

An Event is the specification of some occurrence that may potentially trigger effects by an object.

13.4.5.2

Diagrams

Events

13.4.5.3

Generalizations

PackageableElement

13.4.5.4

Specializations

ChangeEvent, MessageEvent, TimeEvent

Unified Modeling Language 2.5

295

13.4.6

13.4.6.1

FunctionBehavior [Class]

Description

A FunctionBehavior is an OpaqueBehavior that does not access or modify any objects or other external data.

13.4.6.2

Diagrams

Behaviors

13.4.6.3

Generalizations

OpaqueBehavior

13.4.6.4

Operations

•

hasAllDataTypeAttributes(d : DataType) : Boolean
The hasAllDataTypeAttributes query tests whether the types of the attributes of the given DataType are all 
DataTypes, and similarly for all those DataTypes.

body: d.ownedAttribute->forAll(a |
    a.type.oclIsKindOf(DataType) and
      hasAllDataTypeAttributes(a.type.oclAsType(DataType)))

13.4.6.5

Constraints

•

•

one_output_parameter
A FunctionBehavior has at least one output Parameter.

inv: self.ownedParameter->
  select(p | p.direction = ParameterDirectionKind::out or p.direction= 
ParameterDirectionKind::inout or p.direction= ParameterDirectionKind::return)->size() >= 1

types_of_parameters
The types of the ownedParameters are all DataTypes, which may not nest anything but other DataTypes.

inv: ownedParameter->forAll(p | p.type <> null and
  p.type.oclIsTypeOf(DataType) and hasAllDataTypeAttributes(p.type.oclAsType(DataType)))

13.4.7

13.4.7.1

MessageEvent [Abstract Class]

Description

A MessageEvent specifies the receipt by an object of either an Operation call or a Signal instance.

13.4.7.2

Diagrams

Events

13.4.7.3

Generalizations

Event

13.4.7.4

Specializations

AnyReceiveEvent, CallEvent, SignalEvent

296

Unified Modeling Language 2.5

13.4.8

13.4.8.1

OpaqueBehavior [Class]

Description

An OpaqueBehavior is a Behavior whose specification is given in a textual language other than UML.

13.4.8.2

Diagrams

Behaviors

13.4.8.3

Generalizations

Behavior

13.4.8.4

Specializations

FunctionBehavior

13.4.8.5

Attributes

•

•

body : String [0..*]
Specifies the behavior in one or more languages.

language : String [0..*]
Languages the body strings use in the same order as the body strings.

13.4.9

13.4.9.1

SignalEvent [Class]

Description

A SignalEvent represents the receipt of an asynchronous Signal instance.

13.4.9.2

Diagrams

Events

13.4.9.3

Generalizations

MessageEvent

13.4.9.4

Association Ends

•

signal : Signal [1..1] (opposite A_signal_signalEvent::signalEvent)
The specific Signal that is associated with this SignalEvent.

13.4.10

TimeEvent [Class]

13.4.10.1

Description

A TimeEvent is an Event that occurs at a specific point in time.

13.4.10.2

Diagrams

Events

Unified Modeling Language 2.5

297

13.4.10.3

Generalizations

Event

13.4.10.4

Attributes

•

isRelative : Boolean [1..1] = false
Specifies whether the TimeEvent is specified as an absolute or relative time.

13.4.10.5

Association Ends

•

♦ when : TimeExpression [1..1]{subsets Element::ownedElement} (opposite A_when_timeEvent::timeEvent)
Specifies the time of the TimeEvent.

13.4.10.6

Constraints

• when_non_negative

The ValueSpecification when must return a non-negative Integer.

inv: when.integerValue() >= 0

13.4.11

Trigger [Class]

13.4.11.1

Description

A Trigger specifies a specific point at which an Event occurrence may trigger an effect in a Behavior. A Trigger may be 
qualified by the Port on which the Event occurred.

13.4.11.2

Diagrams

Events, Behavior State Machines, Accept Event Actions

13.4.11.3

Generalizations

NamedElement

13.4.11.4

Association Ends

•

•

event : Event [1..1] (opposite A_event_trigger::trigger)
The Event that detected by the Trigger.

port : Port [0..*] (opposite A_port_trigger::trigger)
A optional Port of through which the given effect is detected.

13.4.11.5

Constraints

•

trigger_with_ports
If a Trigger specifies one or more ports, the event of the Trigger must be a MessageEvent.

inv: port->notEmpty() implies event.oclIsKindOf(MessageEvent)

298

Unified Modeling Language 2.5

13.5
13.5.1

Association Descriptions
A_changeExpression_changeEvent [Association]

13.5.1.1

Diagrams

Events

13.5.1.2

Owned Ends

•

changeEvent : ChangeEvent [0..1]{subsets Element::owner} (opposite ChangeEvent::changeExpression)

13.5.2

13.5.2.1

A_context_behavior [Association]

Diagrams

Behaviors

13.5.2.2

Owned Ends

•

behavior : Behavior [0..*]{subsets A_redefinitionContext_redefinableElement::redefinableElement} (opposite 
Behavior::context)

13.5.3

13.5.3.1

A_event_trigger [Association]

Diagrams

Events

13.5.3.2

Owned Ends

•

trigger : Trigger [0..*] (opposite Trigger::event)

13.5.4

13.5.4.1

A_operation_callEvent [Association]

Diagrams

Events

13.5.4.2

Owned Ends

•

callEvent : CallEvent [0..*] (opposite CallEvent::operation)

13.5.5

13.5.5.1

A_ownedParameterSet_behavior [Association]

Diagrams

Behaviors

13.5.5.2

Owned Ends

•

behavior : Behavior [0..1]{subsets NamedElement::namespace} (opposite Behavior::ownedParameterSet)

Unified Modeling Language 2.5

299

13.5.6

13.5.6.1

A_ownedParameter_behavior [Association]

Diagrams

Behaviors

13.5.6.2

Owned Ends

•

behavior : Behavior [0..1]{subsets NamedElement::namespace} (opposite Behavior::ownedParameter)

13.5.7

13.5.7.1

A_port_trigger [Association]

Diagrams

Events

13.5.7.2

Owned Ends

•

trigger : Trigger [0..*] (opposite Trigger::port)

13.5.8

13.5.8.1

A_postcondition_behavior [Association]

Diagrams

Behaviors

13.5.8.2

Owned Ends

•

behavior : Behavior [0..1]{subsets Constraint::context} (opposite Behavior::postcondition)

13.5.9

13.5.9.1

A_precondition_behavior [Association]

Diagrams

Behaviors

13.5.9.2

Owned Ends

•

behavior : Behavior [0..1]{subsets Constraint::context} (opposite Behavior::precondition)

13.5.10

A_redefinedBehavior_behavior [Association]

13.5.10.1

Diagrams

Behaviors

13.5.10.2

Owned Ends

•

behavior : Behavior [0..*]{subsets A_redefinedClassifier_classifier::classifier} (opposite 
Behavior::redefinedBehavior)

300

Unified Modeling Language 2.5

13.5.11

A_signal_signalEvent [Association]

13.5.11.1

Diagrams

Events

13.5.11.2

Owned Ends

•

signalEvent : SignalEvent [0..*] (opposite SignalEvent::signal)

13.5.12

A_when_timeEvent [Association]

13.5.12.1

Diagrams

Events

13.5.12.2

Owned Ends

•

timeEvent : TimeEvent [0..1]{subsets Element::owner} (opposite TimeEvent::when)

Unified Modeling Language 2.5

301

Summary

14 StateMachines
14.1
The StateMachines package defines a set of concepts that can be used for modeling discrete event-driven Behaviors 
using a finite state-machine formalism. In addition to expressing the Behavior of parts of a system (e.g., the Behavior of 
Classifier instances), state machines can also be used to express the valid interaction sequences, called protocols, for 
parts of a system. These two kinds of StateMachines are referred to as behavior state machines and protocol state 
machines respectively.
The specific form of finite state automata used in UML is based on an object-oriented variant of David Harel’s 
statecharts formalism. (However, readers who are familiar with that formalism should note that there is a small number 
of semantic differences that distinguish the UML version from the original.)

Behavior StateMachines
Summary

14.2
14.2.1
Behavior StateMachines can be used to specify any of the following:

•
•
•
•

The classifierBehavior of an active Class.
An ownedBehavior of a BehavioredClassifier that is not the classifierBehavior of that BehavioredClassifier.
A stand-alone Behavior, that is, one that does not have a corresponding BehavioredClassifier.
A method corresponding to a BehavioralFeature (i.e., an Operation or a Reception).

Unified Modeling Language 2.5

303

14.2.2

Abstract Syntax

+ submachine
0..1

{subsets namespace}
+ stateMachine
0..1

Behavior

StateMachine

«enumeration»
TransitionKind
internal
local
external

0..1 + stateMachine

{subsets namespace}

Namespace

PseudostateKind
initial
deepHistory
shallowHistory
join
fork
junction
choice
entryPoint
exitPoint
terminate

{subsets ownedMember}
+ region

1..*

Region

{subsets namespace}

+ container
0..1

{subsets namespace}

+ container
1

{subsets ownedMember}

* + region

NamedElement

Vertex

{subsets ownedMember}
+ subvertex

*

+ target
1

+ source
1

*

Transition

{subsets ownedMember}
+ transition
{readOnly}
+ /incoming
*
{readOnly}
+ /outgoing
*

+ kind : TransitionKind = external

{subsets owner}
+ transition

0..1

{subsets owner}
+ transition

{subsets context}

0..1

0..1 + transition

ConnectionPointReference

{subsets ownedElement}
+ trigger

*

{subsets ownedRule}

0..1 + guard

Trigger

Constraint

{subsets ownedElement}
+ deferrableTrigger

*

0..1

{subsets ownedRule}
+ stateInvariant

+ connection
{subsets ownedMember}

*

{subsets namespace}

+ state

0..1

{subsets
namespace}
+ state

0..1

Namespace

+ connectionPointReference

0..1

+ connectionPointReference
0..1

{subsets ownedMember}
+ connectionPoint

*

* + entry

*

+ exit

State

+ /isComposite : Boolean {readOnly}
+ /isOrthogonal : Boolean {readOnly}
+ /isSimple : Boolean {readOnly}
+ /isSubmachineState : Boolean {readOnly}

FinalState

Pseudostate

+ kind : PseudostateKind = initial

{subsets ownedMember}
+ connectionPoint
*

0..1
+ state

{subsets namespace}

+ submachineState

*

Figure 14.1  Behavior StateMachines

14.2.3

14.2.3.1

Semantics

StateMachine

{subsets owner}
+ state

0..1

{subsets ownedElement}

0..1 + effect

Behavior

{subsets context}
+ owningState
0..1
{subsets owner}
+ state

0..1

{subsets ownedElement}
+ entry
0..1

{subsets owner}
+ state
0..1

{subsets ownedElement}
+ exit
0..1

{subsets owner}
+ state
0..1

{subsets ownedElement}
+ doActivity
0..1

A behavior StateMachine comprises one or more Regions, each Region containing a graph (possibly hierarchical) 
comprising a set of Vertices interconnected by arcs representing Transitions. State machine execution is triggered by 
appropriate Event occurrences. A particular execution of a StateMachine is represented by a set of valid path traversals 
through one or more Region graphs, triggered by the dispatching of an Event occurrence that match active Triggers in 
these graphs. The rules for matching Triggers are described below. In the course of such a traversal, a StateMachine 
instance may execute a potentially complex sequence of Behaviors associated with the particular elements of the graphs 
that are being traversed (transition effects, state entry and state exit Behaviors, etc.)
If the StateMachine has a kind of BehavioredClassifier context, then that Classifier defines which Signal and CallEvent 
triggers are applicable to that StateMachine, and which Features are available to the Behaviors owned by the 
StateMachine. Signal Triggers and CallEvent Triggers for the StateMachine are defined according to the Receptions and 
Operations of this Classifier respectively. These Features may be used to define message event Triggers of the 
StateMachine.
If the StateMachine has no BehavioredClassifier context (i.e., it is a stand-alone Behavior), then its Triggers do not need 
to be tied to any Receptions or Operations of some Classifier. For example, such a StateMachine might be defined as a 

304

Unified Modeling Language 2.5

Template with its Triggers defined as TemplateParameters. Such a StateMachine can then be reused with different 
context Classifiers by binding appropriate CallEvent or SignalEvent Triggers to these TemplateParameters.
In situations where a StateMachine specifies the method of a BehavioralFeature (Operation or Reception), the 
Parameters of the StateMachine shall match the Parameters of the BehavioralFeature (see sub clause 13.2.3). This is the 
means by which the StateMachine execution accesses the Parameters of the BehavioralFeature. Otherwise, the method 
by which an executing StateMachine instance accesses the dispatched Event occurrence and its associated data is not 
defined (see Clause 13).
By definition, invocations of StateMachine executions result in triggered effects (see sub clause 13.3.3) and, hence, 
there is an associated event pool with such an execution. The event pool for a StateMachine execution belongs to either 
its context Classifier object or, if the StateMachine defines a method of a BehavioralFeature, to the instance of the 
Classifier owning the BehavioralFeature.
Due to its event-driven nature, a StateMachine execution is either in transit or in state, alternating between the two. It is 
in transit when an event is dispatched that matches at least one of its associated Triggers. While in transit, it may 
execute a number of Behaviors associated with the paths it is taking.
NOTE. A StateMachine execution may be executing Behaviors even when it has settled in a stable state configuration, 
in cases where there are doActivity Behaviors associated with its active state configuration.

14.2.3.2

Regions

A Region denotes a behavior fragment that may execute concurrently with its orthogonal Regions. Two or more 
Regions are orthogonal to each other if they are either owned by the same State or, at the topmost level, by the same 
StateMachine. A Region becomes active (i.e., it begins executing) either when its owning State is entered or, if it is 
directly owned by a StateMachine (i.e., it is a top level Region), when its owning StateMachine starts executing. Each 
Region owns a set of Vertices and Transitions, which determine the behavioral flow within that Region. It may have its 
own initial Pseudostate as well as its own FinalState.
A default activation of a Region occurs if the Region is entered implicitly, that is, it is not entered through an incoming 
Transition that terminates on one of its component Vertices (e.g., a State or a history Pseudostate), but either

•

•

through a (local or external) Transition that terminates on the containing State or,

in case of a top level Region, when the StateMachine starts executing.

Default activation means that execution starts with the Transition originating from the initial Pseudostate of the Region, 
if one is defined. However, no specific approach is defined if there is no initial Pseudostate that exists within the 
Region. One possible approach is to deem the model ill defined. An alternative is that the Region remains inactive, 
although the State that contains it is active. In other words, the containing composite State is treated as a simple (leaf) 
State.
Conversely, an explicit activation occurs when a Region is entered by a Transition terminating on one of the Region’s 
contained Vertices. When one Region of an orthogonal State is activated explicitly, this will result in the default 
activation of all of its orthogonal Regions, unless those Regions are also entered explicitly (multiple orthogonal Regions 
can be entered explicitly in parallel through Transitions originating from the same fork Pseudostate).

14.2.3.3

Vertices

Vertex is an abstract class that captures the common characteristics for a variety of different concrete kinds of nodes in 
the StateMachine graph (States, Pseudostates, or ConnectionPointReferences). With certain exceptions described below, 
a Vertex can be the source and/or target of any number of Transitions. The semantics of a Vertex depend on the concrete 
kind of node it represents. In general, Pseudostates and ConnectionPointReferences are transitive, in the sense that a 
compound transition execution simply passes through them, arriving on an incoming Transition and leaving on an 
outgoing Transition without pause. State and FinalState, however, represent stable Vertices, such that, when a 
StateMachine execution enters them it remains in them until either some Event occurs that triggers a transition that 
moves it to a different State or the StateMachine is terminated.

Unified Modeling Language 2.5

305

The semantics of individual types of Vertices are described below.

14.2.3.4

States

A State models a situation in the execution of a StateMachine Behavior during which some invariant condition holds. In 
most cases this condition is not explicitly defined, but is implied, usually through the name associated with the State. 
For example, in Figure 14.36, which models the behavior of a telephone unit, the states “Idle” and “Active” represent 
situations where the telephone is and is not being used, respectively. This example also illustrates the fact that a State 
need not necessarily represent a fully static situation, as there is clearly some detailed activity occurring in the context 
of the “Active” state. However, throughout all that activity the telephone remains in use (i.e., “active”).

14.2.3.4.1
The following kinds of States are distinguished:

Kinds of States

•

•

•

simple State (isSimple = true)
composite State (isComposite = true)
submachine State (isSubmachineState = true)

A simple State has no internal Vertices or Transitions. A composite State contains at least one Region, whereas a 
submachine State refers to an entire StateMachine, which is, conceptually, deemed to be “nested” within the State. A 
composite State can be either a simple composite State with exactly one Region or an orthogonal State with multiple 
Regions (isOrthogonal = true). For example, in Figure 14.9, State “CourseAttempt” is an example of a composite State 
with a single Region, whereas State “Studying” is a composite State that contains three Regions.
Any State enclosed within a Region of a composite State is called a substate of that composite State. It is called a direct 
substate when it is not contained in any other State; otherwise, it is referred to as an indirect substate.

State configurations

14.2.3.4.2
In general, a StateMachine can have multiple Regions, each of which may contain States of its own, some of which may 
be composites with their own multiple Regions, etc. Consequently, a particular “state” of an executing StateMachine 
instance is represented by one or more hierarchies of States, starting with the topmost Regions of the StateMachine and 
down through the composition hierarchy to the simple, or leaf, States. Similarly, we can talk about such a hierarchy of 
substates within a composite State. This complex hierarchy of States is referred to as a state configuration (of a State or 
a StateMachine). For example, one valid state configuration for an execution of the StateMachine depicted in Figure 
14.9 is: <CourseAttempt - Studying – (Studying::Lab2, Studying::TermProject, Studying::FinalTest)>.  An executing StateMachine 
instance can only be in exactly one state configuration at a time, which is referred to as its active state configuration. 
StateMachine execution is represented by transitions from one active state configuration to another in response to Event 
occurrences that match the Triggers of the StateMachine.
A State is said to be active if it is part of the active state configuration.
A state configuration is said to be stable when:

•

•

no further Transitions from that state configuration are enabled and

all the entry Behaviors of that configuration, if present, have completed (but not necessarily the doActivity 
Behaviors of that configuration, which, if defined, may continue executing).

After it has been created and completed its initial Transition, a StateMachine is always “in” some state configuration. 
However, because States can be hierarchical and because there can be Behaviors associated with both Transitions and 
States, “entering” a hierarchical state configuration involves a dynamic process that terminates only after a stable state 
configuration (as defined above) is reached. This creates some potential ambiguity as to precisely when a StateMachine 
is “in” a particular state within a state configuration. The rules for when a StateMachine is deemed to be “in” a State 
and when it is deemed to have “left” a State are described below in the sections “Entering a State” and “Exiting a State 
respectively.

306

Unified Modeling Language 2.5

A configuration is deemed stable even if there are deferred, completion, or any other types of Event occurrences 
pending in the event pool of that StateMachine

State entry, exit, and doActivity Behaviors

14.2.3.4.3
A State may have an associated entry Behavior. This Behavior, if defined, is executed whenever the State is entered 
through an external Transition. In addition, a State may also have an associated exit Behavior, which, if defined, is 
executed whenever the State is exited.
A State may also have an associated doActivity Behavior. This Behavior commences execution when the State is entered 
(but only after the State entry Behavior has completed) and executes concurrently with any other Behaviors that may be 
associated with the State, until:

•

•

it completes (in which case a completion event is generated) or

the State is exited, in which case execution of the doActivity Behavior is aborted.

State history

The execution of a doActivity Behavior of a State is not affected by the firing of an internal Transition of that State.
14.2.3.4.4
The concept of State history was introduced by David Harel in the original statechart formalism. It is a convenience 
concept associated with Regions of composite States whereby a Region keeps track of the state configuration it was in 
when it was last exited. This allows easy return to that same state configuration, if desired, the next time the Region 
becomes active (e.g., after returning from handling an interrupt), or if there is a local Transition that returns to its 
history. This is achieved simply by terminating a Transition on the desired type of history Pseudostate inside the Region. 
The advantage provided by this facility is that it eliminates the need for users to explicitly keep track of history in cases 
where this type of behavior is desired, which can result in significantly simpler state machine models.
Two types of history Pseudostates are provided. Deep history (deepHistory) represents the full state configuration of the 
most recent visit to the containing Region. The effect is the same as if the Transition terminating on the deepHistory 
Pseudostate had, instead, terminated on the innermost State of the preserved state configuration, including execution of 
all entry Behaviors encountered along the way. Shallow history (shallowHistory) represents a return to only the topmost 
substate of the most recent state configuration, which is entered using the default entry rule.
In cases where a Transition terminates on a history Pseudostate when the State has not been entered before (i.e., no prior 
history) or it had reached its FinalState, there is an option to force a transition to a specific substate, using the default 
history mechanism. This is a Transition that originates in the history Pseudostate and terminates on a specific Vertex (the
default history state) of the Region containing the history Pseudostate. This Transition is only taken if execution leads to 
the history Pseudostate and the State had never been active before. Otherwise, the appropriate history entry into the 
Region is executed (see above). If no default history Transition is defined, then standard default entry of the Region is 
performed as explained below.
Deferred Events 
A State may specify a set of Event types that may be deferred in that State. This means that Event occurrences of those 
types will not be dispatched as long as that State remains active. Instead, these Event occurrences remain in the event 
pool until:

•

•

a state configuration is reached where these Event types are no longer deferred or,

if a deferred Event type is used explicitly in a Trigger of a Transition whose source is the deferring State (i.e., a 
kind of override option).

An Event may be deferred by a composite State or submachine States, in which case it remains deferred as long as the 
composite State remains in the active configuration.

Entering a State

14.2.3.4.5
The semantics of entering a State depend on the type of State and the manner in which it is entered. However, in all 
cases, the entry Behavior of the State is executed (if defined) upon entry, but only after any effect Behavior associated 

Unified Modeling Language 2.5

307

with the incoming Transition is completed. Also, if a doActivity Behavior is defined for the State, this Behavior 
commences execution immediately after the entry Behavior is executed. It executes concurrently with any subsequent 
Behaviors associated with entering the State, such as the entry Behaviors of substates entered as part of the same 
compound transition.
The above description fully covers the case of simple States. For composite States with a single Region the following 
alternatives exist:

•

•

• Default entry: This situation occurs when the composite State is the direct target of a Transition (graphically, 
this is indicated by an incoming Transition that terminates on the outside edge of the composite State). After 
executing the entry Behavior and forking a possible doActivity Behavior execution, if an initial Pseudostate is 
defined, State entry continues from that Vertex via its outgoing Transition (known as the default Transition of 
the State). If no initial Pseudostate is defined, there is no single approach defined. One alternative is to treat 
such a model as ill formed. A second alternative is to treat the composite State as a simple State, terminating 
the traversal on that State despite its internal parts.
Explicit entry: If the incoming Transition or its continuations terminate on a directly contained substate of the 
composite State, then that substate becomes active and its entry Behavior is executed after the execution of the 
entry Behavior of the containing composite State. This rule applies recursively if the Transition terminates on 
an indirect (deeply nested) substate.
Shallow history entry: If the incoming Transition terminates on a shallowHistory Pseudostate of a Region of the 
composite State, the active substate becomes the substate that was most recently active prior to this entry, 
unless:
o
o
o

In the latter two cases, if a default shallow history Transition is defined originating from the 
shallowHistory Pseudostate, it will be taken. Otherwise, default State entry is applied.

the most recently active substate is the FinalState, or

 this is the first entry into this State.

• Deep history entry: The rule for this case is the same as for shallow history except that the target Pseudostate is 
of type deepHistory and the rule is applied recursively to all levels in the active state configuration below this 
one.
Entry point entry: If a Transition enters a composite State through an entryPoint Pseudostate, then the effect 
Behavior associated with the outgoing Transition originating from the entry point and penetrating into the State 
(but after the entry Behavior of the composite State has been executed).

•

If the composite State is also an orthogonal State with multiple Regions, each of its Regions is also entered, either by 
default or explicitly. If the Transition terminates on the edge of the composite State (i.e., without entering the State), 
then all the Regions are entered using the default entry rule above. If the Transition explicitly enters one or more 
Regions (in case of a fork), these Regions are entered explicitly and the others by default.
Regardless of how a State is entered, the StateMachine is deemed to be “in” that State even before any entry Behavior or
effect Behavior (if defined) of that State start executing.

Exiting a State

14.2.3.4.6
When exiting a State, regardless of whether it is simple or composite, the final step involved in the exit, after all other 
Behaviors associated with the exit are completed, is the execution of the exit Behavior of that State. If the State has a 
doActivity Behavior that is still executing when the State is exited, that Behavior is aborted before the exit Behavior 
commences execution.
When exiting from a composite State, exit commences with the innermost State in the active state configuration. This 
means that exit Behaviors are executed in sequence starting with the innermost active State. If the exit occurs through an
exitPoint Pseudostate, then the exit Behavior of the State is executed after the effect Behavior of the Transition 
terminating on the exit point.

308

Unified Modeling Language 2.5

When exiting from an orthogonal State, each of its Regions is exited. After that, the exit Behavior of the State is 
executed.
Regardless of how a State is exited, the StateMachine is deemed to have “left” that State only after the exit Behavior (if 
defined) of that State has completed execution.
Encapsulated composite States
In some modeling situations, it is useful to encapsulate a composite State, by not allowing Transitions to penetrate 
directly into the State to terminate on one of its internal Vertices. (One common use case for this is when the internals of 
a State in an abstract Classifier are intended to be specified differently in different subtype refinements of the abstract 
Classifier.) Despite the encapsulation, it is often necessary to bind the internal elements of the composite State with 
incoming and outgoing Transitions. This is done by means of entry and exit points, which are realized via the entryPoint 
and exitPoint Pseudostates.
Entry points represent termination points (sources) for incoming Transitions and origination points (targets) for 
Transitions that terminate on some internal Vertex of the composite State. In effect, the latter is a continuation of the 
external incoming Transition, with the proviso that the execution of the entry Behavior of the composite State (if 
defined) occurs between the effect Behavior of the incoming Transition and the effect Behavior of the outgoing 
Transition. If there is no outgoing Transition inside the composite State, then the incoming Transition simply performs a 
default State entry.
Exit points are the inverse of entry points. That is, Transitions originating from a Vertex within the composite State can 
terminate on the exit point. In a well-formed model, such a Transition should have a corresponding external Transition 
outgoing from the same exit point, representing a continuation of the terminating Transition. If the composite State has 
an exit Behavior defined, it is executed after any effect Behavior of the incoming inside Transition and before any effect 
Behavior of the outgoing external Transition.

Submachine States and submachines

14.2.3.4.7
Submachines are a means by which a single StateMachine specification can be reused multiple times. They are similar 
to encapsulated composite States in that they need to bind incoming and outgoing Transitions to their internal Vertices. 
However, whereas encapsulated composite States and their internals are contained within the StateMachine in which 
they are defined, submachines are, like programming language macros, distinct Behavior specifications, which may be 
defined in a different context than the one where they are used (invoked). Consequently, they require a more complex 
binding. This is achieved through the concept of submachine State (i.e., States with isSubmachineState = true), which 
represent references to corresponding submachine StateMachines. The concept of ConnectionPointReference is 
provided to support binding between the submachine State and the referenced StateMachine. A 
ConnectionPointReference represents a point on the submachine State at which a Transition either terminates or 
originates. That is, they serve as targets for incoming Transitions to submachine States, as well as sources for outgoing 
Transitions from submachine States. Each ConnectionPointReference is matched by a corresponding entry or exit point 
in the referenced submachine StateMachine. This provides the necessary binding mechanism between the submachine 
invocation and its specification.
A submachine State implies a macro-like insertion of the specification of the corresponding submachine StateMachine. 
It is, therefore, semantically equivalent to a composite State. The Regions of the submachine StateMachine are the 
Regions of the composite State. The entry, exit, and effect Behaviors and internal Transitions are defined as contained in 
the submachine State.
NOTE. Each submachine State represents a distinct instantiation of a submachine, even when two or more submachine 
States reference the same submachine.
A submachine StateMachine can be entered via its default (initial) Pseudostate or via any of its entry points (i.e., it may 
imply entering a non-orthogonal or an orthogonal composite State with Regions). Entering via the initial Pseudostate has 
the same meaning as for ordinary composite States. An entry point is equivalent to a junction Pseudostate (fork in cases 
where the composite State is orthogonal): Entering via an entry point implies that the entry Behavior of the composite 
state is executed, followed by the Transition from the entry point to the target Vertex within the composite State. Any 
guards associated with these entry point Transitions must evaluate to true in order for the specification to be well 
formed.

Unified Modeling Language 2.5

309

Similarly, a submachine Statemachine can be exited as a result of:

•

•

•

reaching its FinalState,

triggering of a group Transition originating from a submachine State, or

via any of its exit points.

Exiting via a FinalState or by a group Transition has the same meaning as for ordinary composite States.

14.2.3.5

ConnectionPointReference

As noted above, a connection point reference represents a usage (as part of a submachine State) of an entry/exit point 
defined in the StateMachine referenced by the submachine State. Connection point references of a submachine State can 
be used as sources/targets of Transitions. They represent entries into or exits out of the submachine StateMachine 
referenced by the submachine State.
Connection point references are sources/targets of Transitions implying exits out of/entries into the submachine 
StateMachine referenced by a submachine State.
An entry point connection point reference as the target of a Transition implies that the target of the Transition is the 
entryPoint Pseudostate as defined in the submachine of the submachine State. As a result, the Regions of the 
submachine StateMachine are entered through the corresponding entryPoint Pseudostates.
An exit point connection point reference as the source of a Transition implies that the source of the Transition is the exit 
point Pseudostate as defined in the submachine of the submachine State that has the exit point connection point defined. 
When a Region of the submachine StateMachine reaches the corresponding exit point, the submachine state is exited 
via this exit point.

14.2.3.6

FinalState

FinalState is a special kind of State signifying that the enclosing Region has completed. Thus, a Transition to a 
FinalState represents the completion of the behaviors of the Region containing the FinalState.

14.2.3.7

Pseudostate and PseudostateKind

A Pseudostate is an abstraction that encompasses different types of transient Vertices in the StateMachine graph. 
Pseudostates are generally used to chain multiple Transitions into more complex compound transitions (see below). For 
example, by combining a Transition entering a fork Pseudostate with a set of Transitions exiting that Pseudostate, we get 
a compound Transition that can enter a set of orthogonal Regions.
The specific semantics of a Pseudostate depend on the kind of Pseudostate, which is defined by its kind attribute of type 
PseudostateKind. The following describes the different kinds and their semantics:

•

•

•

initial - An initial Pseudostate represents a starting point for a Region; that is, it is the point from which 
execution of its contained behavior commences when the Region is entered via default activation. It is the 
source for at most one Transition, which may have an associated effect Behavior, but not an associated trigger or 
guard. There can be at most one initial Vertex in a Region.
deepHistory – This type of Pseudostate is a kind of variable that represents the most recent active state 
configuration of its owning Region. As explained above, a Transition terminating on this Pseudostate implies 
restoring the Region to that same state configuration, but with all the semantics of entering a State (see the sub 
clause describing State entry). The entry Behaviors of all States in the restored state configuration are 
performed in the appropriate order starting with the outermost State. A deepHistory Pseudostate can only be 
defined for composite States and, at most one such Pseudostate can be contained in a Region of a composite 
State.
shallowHistory – As explained above, this type of Pseudostate is a kind of variable that represents the most 
recent active substate of its containing Region, but not the substates of that substate. A Transition terminating 
on this Pseudostate implies restoring the Region to that substate with all the semantics of entering a State. A 

310

Unified Modeling Language 2.5

single outgoing Transition from this Pseudostate may be defined terminating on a substate of the composite 
State. This substate is the default shallow history state of the composite State. A shallowHistory Pseudostate 
can only be defined for composite States and, at most one such Pseudostate can be included in a Region of a 
composite State.
join – This type of Pseudostate serves as a common target Vertex for two or more Transitions originating from 
Vertices in different orthogonal Regions. Transitions terminating on a join Pseudostate cannot have a guard or a 
trigger. Similar to junction points in Petri nets, join Pseudostates perform a synchronization function, whereby 
all incoming Transitions have to complete before execution can continue through an outgoing Transition.
fork – fork Pseudostates serve to split an incoming Transition into two or more Transitions terminating on 
Vertices in orthogonal Regions of a composite State. The Transitions outgoing from a fork Pseudostate cannot 
have a guard or a trigger.
junction – This type of Pseudostate is used to connect multiple Transitions into compound paths between 
States. For example, a junction Pseudostate can be used to merge multiple incoming Transitions into a single 
outgoing Transition representing a shared continuation path. Or, it can be used to split an incoming Transition 
into multiple outgoing Transition segments with different guard Constraints.
NOTE. Such guard Constraints are evaluated before any compound transition containing this Pseudostate is 
executed, which is why this is referred to as a static conditional branch.
It may happen that, for a particular compound transition, the configuration of Transition paths and guard values 
is such that the compound transition is prevented from reaching a valid state configuration. In those cases, the 
entire compound transition is disabled even though its Triggers are enabled. (As a way of avoiding this 
situation in some cases, it is possible to associate a predefined guard denoted as “else” with at most one 
outgoing Transition. This Transition is enabled if all the guards attached to the other Transitions evaluate to 
false). If more than one guard evaluates to true, one of these is chosen. The algorithm for making this selection 
is not defined.
choice – This type of Pseudostate is similar to a junction Pseudostate (see above) and serves similar purposes, 
with the difference that the guard Constraints on all outgoing Transitions are evaluated dynamically, when the 
compound transition traversal reaches this Pseudostate. Consequently, choice is used to realize a dynamic 
conditional branch. It allows splitting of compound transitions into multiple alternative paths such that the 
decision on which path to take may depend on the results of Behavior executions performed in the same 
compound transition prior to reaching the choice point. If more than one guard evaluates to true, one of the 
corresponding Transitions is selected. The algorithm for making this selection is not defined. If none of the 
guards evaluates to true, then the model is considered ill formed. To avoid this, it is recommended to define one 
outgoing Transition with the predefined “else” guard for every choice Pseudostate.
entryPoint – An entryPoint Pseudostate represents an entry point for a StateMachine or a composite State that 
provides encapsulation of the insides of the State or StateMachine. In each Region of the StateMachine or 
composite State owning the entryPoint, there is at most a single Transition from the entry point to a Vertex 
within that Region.
NOTE. If the owning State has an associated entry Behavior, this Behavior is executed before any behavior 
associated with the outgoing Transition. If multiple Regions are involved, the entry point acts as a fork 
Pseudostate.
exitPoint – An exitPoint Pseudostate is an exit point of a StateMachine or composite State that provides 
encapsulation of the insides of the State or StateMachine. Transitions terminating on an exit point within any 
Region of the composite State or a StateMachine referenced by a submachine State implies exiting of this 
composite State or submachine State (with execution of its associated exit Behavior). If multiple Transitions 
from orthogonal Regions within the State terminate on this Pseudostate, then it acts like a join Pseudostate.
terminate – Entering a terminate Pseudostate implies that the execution of the StateMachine is terminated 
immediately. The StateMachine does not exit any States nor does it perform any exit Behaviors. Any executing 
doActivity Behaviors are automatically aborted. Entering a terminate Pseudostate is equivalent to invoking a 
DestroyObjectAction.

•

•

•

•

•

•

•

Unified Modeling Language 2.5

311

14.2.3.8

Transitions

A Transition is a single directed arc originating from a single source Vertex and terminating on a single target Vertex (the 
source and target may be the same Vertex), which specifies a valid fragment of a StateMachine Behavior. It may have an 
associated effect Behavior, which is executed when the Transition is traversed (executed).
NOTE. The duration of a Transition traversal is undefined, allowing for different semantic interpretations, including 
both “zero” and non-“zero” time.
Transitions are executed as part of a more complex compound transition that takes a StateMachine execution from one 
stable state configuration to another. The semantics of compound transitions are described below.
In the course of execution, a Transition instance is said to be:

•

•

•

reached, when execution of its StateMachine execution has reached its source Vertex (i.e., its source State is in 
the active state configuration);
traversed, when it is being executed (along with any associated effect Behavior); and
completed, after it has reached its target Vertex.

A Transition may own a set of Triggers, each of which specifies an Event whose occurrence, when dispatched, may 
trigger traversal of the Transition. A Transition trigger is said to be enabled if the dispatched Event occurrence matches 
its Event type. When multiple triggers are defined for a Transition, they are logically disjunctive, that is, if any of them 
are enabled, the Transition will be triggered.

Transition kinds relative to source

14.2.3.8.1
The semantics of a Transition depend on its relationship to its source Vertex. Three different possibilities are defined, 
depending on the value of the Transition’s kind attribute:

•

•

•

kind = external means that the Transition exits its source Vertex. If the Vertex is a State, then executing this 
Transition will result in the execution of any associated exit Behavior of that State.
kind = local is the opposite of external, meaning that the Transition does not exit its containing State (and, 
hence, the exit Behavior of the containing State will not be executed). However, for local Transitions the target 
Vertex must be different from its source Vertex. A local Transition can only exist within a composite State.
kind = internal is a special case of a local Transition that is a self-transition (i.e., with the same source and 
target States), such that the State is never exited (and, thus, not re-entered), which means that no exit or entry 
Behaviors are executed when this Transition is executed. This kind of Transition can only be defined if the 
source Vertex is a State.

High-level (group) Transitions

14.2.3.8.2
Transitions whose source Vertex is a composite States are called high-level or group Transitions. If they are external, 
group Transitions result in the exiting of all substates of the composite State, executing any defined exit Behaviors 
starting with the innermost States in the active state configuration. In case of local Transitions, the exit Behaviors of the 
source State and the entry Behaviors of the target State will be executed, but not those of the containing State.

Completion Transitions and completion events

14.2.3.8.3
A special kind of Transition is a completion Transition, which has an implicit trigger. The event that enables this trigger 
is called a completion event and it signifies that all Behaviors associated with the source State of the completion 
Transition have completed execution. In case of simple States, a completion event is generated when the associated entry
and doActivity Behaviors have completed executing. If no such Behaviors are defined, the completion event is generated 
upon entry into the State. For composite or submachine States, a completion event is generated under the following 
circumstances:

• All internal activities (e.g., entry and doActivity Behaviors) have completed execution, and

312

Unified Modeling Language 2.5

•

•

if the State is a composite State, all its orthogonal Regions have reached a FinalState, or

if the State is a submachine State, the submachine StateMachine execution has reached a FinalState.

Completion events have dispatching priority. That is, they are dispatched ahead of any pending Event occurrences in the 
event pool. If two or more completion events corresponding to multiple orthogonal Regions occur simultaneously (i.e., 
as a result of the same Event occurrence), the order in which such completion occurrences are processed is not defined. 
Completion of all top level Regions in a StateMachine corresponds to a completion of the Behavior of the StateMachine 
and results in its termination.
Transition guards
A Transition may have an associated guard Constraint. Transitions that have a guard which evaluates to false are 
disabled. Guards are evaluated before the compound transition that contains them is enabled, unless they are on 
Transitions that originate from a choice Pseudostate. In the latter case, the guards are evaluated when the choice point is 
reached. A Transition that does not have an associated guard is treated as if it has a guard that is always true.
NOTE. A completion Transition may also have a guard.
A guard constraint may involve tests of orthogonal States of the current StateMachine, or explicitly designated States of 
some reachable object (for example, “in State1” or “not in State2”). State names may be fully qualified by the nested 
States and Regions that contain them, yielding pathnames of the form “RegionA::State1::Region1::State2::State3”. This 
may be used in case the same State name occurs in different composite State Regions.

Compound transitions

14.2.3.8.4
As noted earlier, when an Event occurrence triggers an enabled Transition or a StateMachine execution is created, this 
can initiate traversal of a set of connected and nested Transitions and Vertices until a stable state configuration is 
reached. In the general case, a trace of this traversal, known as a compound transition, can be represented by an 
acyclical directed graph. The root (source) of this graph can be one of the following:

• A Transition with one or more Triggers defined.
• A completion Transition.
• A set of Transitions (including, possibly, completion Transitions) originating from different orthogonal Regions 

that converge on a common join Pseudostate.

• A Transition originating from an initial Pseudostate of the topmost Region (i.e., a Region owned by the 

StateMachine); this variant applies only to cases when the StateMachine instance is created.

Branching in a compound transition execution occurs whenever an executing Transition performs a default entry into a 
State with multiple orthogonal Regions, with a separate branch created for each Region, or when a fork Pseudostate is 
encountered. The overall behavior that results from the execution of a compound transition is a partially ordered set of 
executions of Behaviors associated with the traversed elements, determined by the order in which the elements (Vertices 
and Transitions) are encountered. For example, if a Transition entering a compound State terminates on a substate of 
that State, then the effect Behavior of the Transition would be executed before the execution of the entry Behavior of the 
compound State, followed by the entry Behavior of the substate. If a fork Pseudostate is encountered in the traversal, 
then the effect Behaviors of the individual outgoing branches are, at least conceptually, executed concurrently with each 
other.
If a choice or join point is reached with multiple outgoing Transitions with guards, a Transition whose guard evaluates to 
true will be taken. If more than one guard evaluates to true, one of these Transitions is chosen for continuing the 
traversal. The algorithm for making this selection is undefined. In case of Transitions originating from a choice 
Pseudostate, if no guards evaluate to true when the Pseudostate is reached, the model is ill formed.

Unified Modeling Language 2.5

313

Transition ownership

14.2.3.8.5
The owner of a Transition is not explicitly constrained, though the Region in which it is contained must be owned 
directly or indirectly by the owning StateMachine. A suggested owner of a Transition is the innermost Region that 
contains both its source and target Vertices.

14.2.3.9

Event Processing for StateMachines

The run-to-completion paradigm

14.2.3.9.1
The processing of Event occurrences by a StateMachine execution conforms to the general semantics defined in Clause 
13. Upon creation, a StateMachine will perform its initialization during which it executes an initial compound transition 
prompted by the creation, after which it enters a wait point. In case of StateMachine Behaviors, a wait point is 
represented by a stable state configuration. It remains thus until an Event stored in its event pool is dispatched. This 
Event is evaluated and, if it matches a valid Trigger of the StateMachine and there is at least one enabled Transition that 
can be triggered by that Event occurrence, a single StateMachine step is executed. A step involves executing a 
compound transition and terminating on a stable state configuration (i.e., the next wait point). This cycle then repeats 
until either the StateMachine completes its Behavior or until it is asynchronously terminated by some external agent.
StateMachines can respond to any of the Event types described in Clause 13 as well as to completion events (see 
above).
NOTE. As explained above, completion events have priority and will be dispatched ahead of any pending Event 
occurrences in the event pool.
Event occurrences are detected, dispatched, and processed by the StateMachine execution, one at a time.
NOTE. The order of event dispatching is left undefined, allowing for varied scheduling algorithms.
This cycle is referred to as the run-to-completion paradigm, and the corresponding StateMachine step is called a run-to-
completion step. Run-to-completion means that, in the absence of exceptions or asynchronous destruction of the context 
Classifier object or the StateMachine execution, a pending Event occurrence is dispatched only after the processing of 
the previous occurrence is completed and a stable state configuration has been reached. That is, an Event occurrence 
will never be dispatched while the StateMachine execution is busy processing the previous one. This behavioral 
paradigm was chosen to avoid complications arising from concurrency conflicts that may arise when a StateMachine 
tries to respond to multiple concurrent or overlapping events.
When an Event occurrence is detected and dispatched, it may result in one or more Transitions being enabled for firing. 
If no Transition is enabled and the corresponding Event type is not in any of the deferrableTriggers lists of the active state 
configuration, the dispatched Event occurrence is discarded and the run-to-completion step is completed trivially.
Due to the presence of orthogonal Regions, it is possible that multiple Transitions (in different Regions) can be 
triggered by the same Event occurrence. The order in which these Transitions are executed is left undefined. Each 
orthogonal Region in the active state configuration that does not contain nested orthogonal Regions (i.e., a “bottom-
level” Region) can fire at most one Transition as a result of the current Event occurrence. When all orthogonal Regions 
have finished executing the Transition, the current Event occurrence is fully consumed, and the run-to-completion step 
is completed.
As mentioned above, it is possible for multiple mutually exclusive Transitions in a given Region to be enabled for firing 
by the same Event occurrence. In those cases, only one is selected and executed. Which of the enabled Transitions is 
chosen is determined by the Transition selection algorithm described below.
During a Transition, a number of actions Behaviors may be executed. If such a Behavior includes a synchronous 
invocation call on another object executing a StateMachine, then the Transition step is not completed until the invoked 
object method completes its run-to-completion step.
Run-to-completion may be implemented in various ways. For active Classes, it may be realized by an event-loop 
running in its own thread, and that reads event occurrences from a pool. For passive Classes it may be implemented 
using a monitor.

314

Unified Modeling Language 2.5

IMPLEMENTATION NOTE. Run-to-completion is often mistakenly interpreted as implying that an executing 
StateMachine cannot be interrupted, which, of course would lead to priority inversion issues in some time-sensitive 
systems. However, this is not the case; in a given implementation a thread executing a StateMachine step can be 
suspended, allowing higher-priority threads to run, and, once it is allocated processor time again by the underlying 
thread scheduler, it can safely resume its execution and complete its event processing.

14.2.3.9.2
A Transition is enabled if and only if:

Enabled Transitions

•
•

•

All of its source States are in the active state configuration.
At least one of the triggers of the Transition has an Event that is matched by the Event type of the dispatched 
Event occurrence. In case of Signal Events, any occurrence of the same or compatible type as specified in the 
Trigger will match. If one of the Triggers is for an AnyReceiveEvent, then either a Signal or CallEvent satisfies 
this Trigger, provided that there is no other Signal or CallEvent Trigger for the same Transition or any other 
Transition having the same source Vertex as the Transition with the AnyReceiveEvent trigger (see also 13.3.1).
If there exists at least one full path from the source state configuration to either the target state configuration or 
to a dynamic choice Pseudostate in which all guard conditions are true (Transitions without guards are treated as 
if their guards are always true).

As more than one Transition may be enabled by the same Event occurrence, being enabled is a necessary but not 
sufficient condition for the firing of a Transition.

Conflicting Transitions

14.2.3.9.3
It is possible for more than one Transition to be enabled within a StateMachine. If that happens, then such Transitions 
may be in conflict with each other. For example, consider the case of two Transitions originating from the same State, 
triggered by the same event, but with different guards. If that event occurs and both guard conditions are true, then at 
most one of those Transitions can fire in a given run-to-completion step.
Two Transitions are said to conflict if they both exit the same State, or, more precisely, that the intersection of the set of 
States they exit is non-empty. Only Transitions that occur in mutually orthogonal Regions may be fired simultaneously. 
This constraint guarantees that the new active state configuration resulting from executing the set of Transitions is well 
formed.
An internal Transition in a State conflicts only with Transitions that cause an exit from that State.

Firing priorities

14.2.3.9.4
In situations where there are conflicting Transitions, the selection of which Transitions will fire is based in part on an 
implicit priority. These priorities resolve some but not all Transition conflicts, as they only define a partial ordering. The 
priorities of conflicting Transitions are based on their relative position in the state hierarchy. By definition, a Transition 
originating from a substate has higher priority than a conflicting Transition originating from any of its containing States.
The priority of a Transition is defined based on its source State. The priority of Transitions chained in a compound 
transition is based on the priority of the Transition with the most deeply nested source State.
In general, if t1 is a Transition whose source State is s1, and t2 has source s2, then:

•
•

If s1 is a direct or indirectly nested substate of s2, then t1 has higher priority than t2.
If s1 and s2 are not in the same state configuration, then there is no priority difference between t1 and t2.

Transition selection algorithm

14.2.3.9.5
The set of Transitions that will fire are the Transitions in the Regions of the current state configuration that satisfy the 
following conditions:

•

All Transitions in the set are enabled.

Unified Modeling Language 2.5

315

•
•

There are no conflicting Transitions within the set.
There is no Transition outside the set that has higher priority than a Transition in the set (that is, enabled 
Transitions with highest priorities are in the set while conflicting Transitions with lower priorities are left out).

This can be implemented by a greedy selection algorithm, with a straightforward traversal of the active state 
configuration. States in the active state configuration are traversed starting with the innermost nested simple States and 
working outwards. For each State at a given level, all originating Transitions are evaluated to determine if they are 
enabled. This traversal guarantees that the priority principle is not violated. The only non-trivial issue is resolving 
Transition conflicts across orthogonal States on all levels. This is resolved by terminating the search in each orthogonal 
State once a Transition inside any one of its components is fired.

Transition execution sequence

14.2.3.9.6
Every Transition, except for internal and local Transitions, causes exiting of a source State, and entering of the target 
State. These two States, which may be composite, are designated as the main source and the main target of a Transition 
respectively.
The main source is a direct substate of the Region that contains the source States, and the main target is the substate of 
the Region that contains the target States.
NOTE. A Transition from one Region to another in the same immediate enclosing composite State is not allowed.
Once a Transition is enabled and is selected to fire, the following steps are carried out in order:

1

2

3

Starting with the main source State, the States that contain the main source State are exited according to the 
rules of State exit (or, composite State exit if the main source State is nested) as described earlier.
The series of State exits continues until the first Region that contains, directly or indirectly, both the main 
source and main target states is reached. The Region that contains both the main source and main target states 
is called their least common ancestor. At that point, the effect Behavior of the Transition that connects the sub-
configuration of source States to the sub-configuration of target States is executed. (A “sub-configuration” here 
refers to that subset of a full state configuration contained within the least common ancestor Region.)
The configuration of States containing the main target State is entered, starting with the outermost State in the 
least common ancestor Region that contains the main target State. The execution of Behaviors follows the rules 
of State entry (or composite State entry) described earlier.

This transition execution algorithm is illustrated by the StateMachine example in Figure 14.2. In this case, when event 
“sig” is dispatched while the StateMachine is in State “S11” (the main source), the following sequence of actions will 
be executed:
        xS11; t1; xS1; t2; eT1; eT11; t3; eT111

S1

exit/xS1

S11

exit/xS11

sig/t1

/t2

S

entry/eT1

T1

T11

entry/eT11

/t3

T111

entry/eT111

The Region of State S is 
the least common 
ancestor of S11 and T111

Figure 14.2  Compound transition example

316

Unified Modeling Language 2.5

14.2.4

14.2.4.1

Notation

StateMachine Diagrams

StateMachine diagrams specify StateMachines. This Clause outlines the graphic elements that may be shown in 
StateMachine diagrams, and provides cross references where detailed information about the semantics and concrete 
notation for each element can be found. It also furnishes examples that illustrate how the graphic elements can be 
assembled into diagrams.
A StateMachine diagram is a graph that represents a StateMachine. States and various other types of Vertices in the 
StateMachine graph are rendered by appropriate State and Pseudostate symbols, while Transitions are generally 
rendered by directed arcs that connect them, or by control symbols representing the actions of the Behavior on the 
Transition.

14.2.4.2

StateMachine

When depicting StateMachine redefinition in a class diagram, the default rectangle notation for Classifier can be used, 
with the keyword «statemachine» inside the name compartment above or before the name of the StateMachine.
The association between a StateMachine and its context Classifier or BehavioralFeatures does not have a special 
graphical representation.

14.2.4.3

Region

A composite State or StateMachine with Regions is shown by tiling the graph Region of the State/StateMachine using 
dashed lines to divide it into Regions (Figure 14.3). Each Region may have an optional name and contains the nested 
disjoint States and the Transitions between these. The text compartments of the entire State are separated from the 
orthogonal Regions by a solid line.

14.2.4.4

A composite State or StateMachine with just one Region is shown by showing a nested state diagram 
within the graph Region.

Figure 14.3  Notation for a composite State with Regions

14.2.4.5

State

State is shown as a rectangle with rounded corners, with the State name shown within (Figure 14.4).

Figure 14.4  State notation

Unified Modeling Language 2.5

317

Optionally, it may have an attached name tab (Figure 14.5). The name tab is a rectangle, usually resting on the outside 
of the top side of a State and it contains the name of that State. It is normally used to keep the name of a composite State 
that has orthogonal Regions, but may be used in other cases as well.

Figure 14.5  State with a name tab

A State may be subdivided into multiple compartments separated from each other by a horizontal line (Figure 14.6).

TypingPassword

entry/setEchoInvisible()
exit/setEchoNormal()
character/handleCharacter()
help/displayHelp()

Figure 14.6  State with compartments

The compartments of a State are:

•
•
•

name compartment
internal Behaviors compartment
internal Transitions compartment.

A composite State also has a:

•

decomposition compartment.

Each of these compartments is described below.

•

•

Name compartment
This compartment holds the (optional) name of the State, as a string. States without names are anonymous and 
are all distinct. It is undesirable to show the same named State twice in the same diagram, as confusion may 
ensue, unless control icons are used to show a Transition-oriented view of the StateMachine. Name 
compartments should not be used if a name tab is used and vice versa.
In case of a submachine State, the name of the referenced StateMachine is shown as a string following ‘:’ after 
the name of the State.
Internal activities Behaviors compartment
This compartment holds a list of internal Behaviors associated with a State. Each entry has the following 
format:

<behavior-type-label> ['/' <behavior-expression>]

The <behavior-type-label> identifies the circumstances under which the Behavior specified by the <behavior-
expression> will be invoked and can be one of the following:

o

entry — This label identifies a Behavior, specified by the corresponding expression, which is 
performed upon entry to the State (entry Behavior).

318

Unified Modeling Language 2.5

o

o

exit — This label identifies a Behavior, specified by the corresponding expression, that is performed 
upon exit from the State (exit Behavior).
do — This label identifies an ongoing Behavior (doActivity Behavior) that is performed as long as the 
modeled element is in the State or until the computation specified by the expression is completed.

The optional <behavior-expression> is an expression in some textual surface language, which may be either a 
vendor-specific or some standard language (see sub clause 16.1).
Internal Transition compartment
This compartment contains a list of internal Transitions, where each item has the following syntax:

•

{<trigger>}* ['[' <guard>']'] [/<behavior-expression>]

Where <trigger> is the notation for Triggers (see sub clause 13.3.4), <guard> is a Boolean expression for a 
guard, and the optional <behavior-expression> is the specification of the effect Behavior to be executed if the 
Event occurrence matches the trigger and guard of the internal Transition. It is an expression written in some 
textual surface language, which may be either a vendor-specific or some standard language (see sub clause 
16.1).

Alternatively, in place of a textual behavior expression, the various Behaviors associated with a State or internal 
Transition can be expressed using the appropriate graphical representation in a separate diagram (e.g., an activity 
diagram).

14.2.4.5.1

Composite State
decomposition compartment

•

This compartment shows its composition structure in terms of Regions, States, and Transition. In addition to the 
(optional) name and internal Transition compartments, the State may have an additional compartment that contains a 
nested diagram. For convenience and appearance, the text compartments may be shrunk horizontally within the graphic 
Region.
In some cases, it is convenient to hide the decomposition of a composite State. For example, there may be a large 
number of States nested inside a composite State and they may simply not fit in the graphical space available for the 
diagram. In that case, the composite State may be represented by a simple State graphic with a special “composite” 
icon, usually in the lower right-hand corner (see Figure 14.8). This icon, consisting of two horizontally placed and 
connected States, is an optional visual cue that the State has a decomposition that is not shown in this particular 
diagram. Instead, the contents of the composite State are shown in a separate diagram.
NOTE. The “hiding” here is purely a matter of graphical convenience and has no semantic significance in terms of 
access restrictions.
A composite State may have one or more entry and exit points on its outside border or in close proximity of that border 
(inside or outside).

Unified Modeling Language 2.5

319

Figure 14.7  Composite State with two States

Figure 14.8  Composite State with a hidden decomposition indicator icon

Figure 14.9  Composite State with Regions

320

Unified Modeling Language 2.5

LightOn

entry/ turn on main light 
do/ flash secondary light
exit/ turn off main light; turn off secondary light

Initial

go/

reset/

Initial

go/

Running

Running

Wait

stop/

stop/

pause/

Figure 14.10  Composite State with two Regions and entry, exit, and do Behaviors

14.2.4.5.2
The submachine State is depicted as a normal State where the string in the name compartment has the following syntax:

Submachine State

<state-name> ‘:’ <name-of-referenced-StateMachine>

The submachine State symbol may contain the references to one or more entry points and to one or more exit points. The 
notation for these connection point references comprises entry/exit Pseudostates on the border of the submachine State. 
The names are the names of the corresponding entry/exit points defined within the referenced StateMachine (see 
ConnectionPointReference).
If the submachine StateMachine is entered through its default initial Pseudostate or if it is exited as a result of the 
completion of the submachine, it is not necessary to use the entry/exit point notation. Similarly, an exit point is not 
required if the exit occurs through an explicit group Transition that originates from the boundary of the submachine 
State (implying that it applies to all the substates of the submachine).
Submachine States invoking the same submachine may occur multiple times in the same state diagram with the entry 
and exit points being part of different Transitions.
The diagram in Figure 14.11 shows a fragment from a StateMachine diagram in which a submachine State (the 
FailureSubmachine) is referenced. The actual submachine StateMachine is defined in some enclosing or imported 
namespace.

Unified Modeling Language 2.5

321

Figure 14.11  Submachine State example

In the above example, the Transition triggered by Event “error1” will terminate on entry point “sub1” of the 
FailureSubmachine StateMachine. The “error3” Transition implies taking the default Transition of the 
FailureSubmachine.
The Transition originating from the “subEnd” exit point of the submachine will execute the “fixed1” Behavior in 
addition to what is executed within the HandleFailure StateMachine. This Transition must have been triggered within 
the HandleFailure StateMachine. Finally, the Transition originating from the edge of the submachine State is taken as a 
result of the completion event generated when the FailureSubmachine reaches its FinalState.
NOTE. The same notation would apply to composite States with the exception that there would be no reference to a 
StateMachine in the State name.
Figure 14.12 is an example of a StateMachine defined with two exit points. Entry and exit points may be shown on the 
frame or within the state graph. Figure 14.12 is an example of a StateMachine defined with an exit point shown within 
the state graph. Figure 14.13 shows the same StateMachine using a notation shown on the frame of the StateMachine.

322

Unified Modeling Language 2.5

Figure 14.12  StateMachine with an exit point as part of the StateMachine graph

Figure 14.13  StateMachine with an exit point on the border

In Figure 14.14 the StateMachine shown in Figure 14.13 is referenced in a submachine State, and the presentation 
option with the exit points on the State symbol is shown.

Unified Modeling Language 2.5

323

Figure 14.14  Submachine Sate that uses an exit point

An example of the notation for entry and exit points for composite States is shown in Figure 14.23.

State list notation

14.2.4.5.3
State lists provide a graphical shortcut for certain situations that sometimes occur in practice.
NOTE. These are purely notational forms with no corresponding abstract syntax representation. They are interchanged 
with UML DI, see Annex B.4.4.
Multiple effect-free Transitions with the same Trigger values originating on different States but all either (a) targeting a 
common junction Vertex with a single outgoing Transition or (b) terminating on the same target State, may be 
represented by a Single Transition-like arc originating from a State-like graphic element, labeled with a list of the names 
of the originating States. This arc terminates on the joint target State. Figure 14.15 shows both possibilities and Figure 
14.16 shows the equivalent diagram without using statelists.

Figure 14.15  State list notation option

324

Unified Modeling Language 2.5

Figure 14.16  Diagram equivalent to Figure 14.15 without using statelists

14.2.4.6

FinalState

A FinalState is shown as a circle surrounding a small solid filled circle (see Figure 14.17). The corresponding 
completion Transition on the enclosing State has as notation an unlabeled Transition.

Figure 14.17  FinalState notation

Figure 14.7 has an example of a FinalState (the right-most of the States within the composite State).

14.2.4.7

Pseudostate

An initial Pseudostate is shown as a small solid filled circle (see Figure 14.18). In a Region of a ClassifierBehavior 
StateMachine, the Transition from an initial Pseudostate may be labeled with the Event type of the occurrence that 
creates the object; otherwise, it must be unlabeled. If it is unlabeled, it represents any Transition from the enclosing 
State.

Figure 14.18  initial Pseudostate

A shallowHistory Pseudostate is indicated by a small circle containing an ‘H’ (see Figure 14.19). It applies to the State 
Region that directly encloses it.

Figure 14.19  shallowHistory Pseudostate

A deepHistory Pseudostate is indicated by a small circle containing an ‘H*’ (see Figure 14.20). It applies to the State 
Region that directly encloses it.

Figure 14.20  deepHistory Pseudostate

Unified Modeling Language 2.5

325

An entry point is shown as a small circle on the border of the StateMachine diagram or composite State, with the name 
associated with it (see Figure 14.21).

Figure 14.21  entryPoint Pseudostate

Optionally it may be placed both within the StateMachine diagram and outside the border of the StateMachine diagram 
or composite State.
An exit point is shown as a small circle with a cross on the border of the StateMachine diagram or composite State, with 
the name associated with it (see Figure 14.22).

Figure 14.22  exitPoint Pseudostate

Optionally, an exit point symbol may be placed both within the StateMachine diagram or composite State and outside 
the border of the StateMachine diagram or composite State. Figure 14.23 illustrates the notation for depicting entry and 
exit points of composite States.

Figure 14.23  entryPoint and exitPoints on a composite State

Alternatively, the “bracket” notation shown in Figure 14.30 and Figure 14.31 can also be used for the transition-oriented 
notation.
A junction is represented by a small filled circle (see Figure 14.24).

326

Unified Modeling Language 2.5

Figure 14.24  junction Pseudostate with incoming and outgoing Transitions

A choice Pseudostate is shown as a diamond-shaped symbol as exemplified shown by the left-hand diagram in Figure 
14.25.

Figure 14.25  choice Pseudostates

NOTE. In cases when all guards associated with triggers of Transitions leaving a choice Pseudostate are binary 
expressions that share a common left operand, then the notation for choice Pseudostate may be simplified. The left 
operand may be placed inside the diamond-shaped symbol and the rest of the Guard expressions placed on the outgoing 
Transitions. This is illustrated by the right-hand diagram in Figure 14.25.
A terminate Pseudostate is shown as a cross, see Figure 14.26.

Figure 14.26  terminate Pseudostate

The notation for a fork and join is a short heavy bar (Figure 14.27). The bar may have one or more arrows from source 
States to the bar (when representing a join). The bar may have one or more arrows from the bar to States (when 
representing a fork). A Transition string may be shown near the bar.

Unified Modeling Language 2.5

327

Figure 14.27  fork and join Pseudostates

14.2.4.8

ConnectionPointReference

A connection point reference to an entry point has the same notation as an entry Pseudostate. The circle is placed on the 
border of the State symbol of a submachine State.

Figure 14.28  Entry point ConnectionPointReference notation

A connection point reference to an exit point has the same notation as an exit Pseudostate. The encircled cross is placed 
on the border of the State symbol of a submachine State.

Figure 14.29  Exit point ConnectionPointReference notation

Alternatively, a connection point reference to an entry point can also be visualized using a “bracketed space” symbol as 
shown in Figure 14.30. The text inside the symbol shall contain ‘via’ followed by the name of the connection point. This 
notation may only be used if the Transition ending with the connection point is defined using the graphical Transition 
notation, such as the one shown in Figure 14.32.

328

Unified Modeling Language 2.5

Figure 14.30  Alternative entry point ConnectionPointReference notation

A connection point reference to an exit point can also be visualized using a “bracketed space” symbol as shown in
Figure 14.31. The text inside the symbol shall contain ‘via’ followed by the name of the connection point. This notation 
may only be used if the Transition associated with the connection point is defined using the graphical Transition 
notation such as the one shown in Figure 14.32.

Figure 14.31  Alternative exit point ConnectionPointReference notation

14.2.4.9

Transition

The default textual notation for a Transition is defined by the following BNF expression:

[<trigger> [‘,’ <trigger>]* [‘[‘ <guard>’]’] [‘/’ <behavior-expression>]]

Where <trigger> is the standard notation for Triggers (see sub clause 13.3.4), <guard> is a Boolean expression for a 
guard, and the optional <behavior-expression> is an expression specifying the effect Behavior written in some vendor-
specific or standard textual surface language (see sub clause 16.1). The trigger may be any of the standard trigger types. 
SignalEvent triggers and CallEvent triggers are not distinguishable by syntax and must be discriminated by their 
declaration elsewhere.
As an alternative, in cases where the effect Behavior can be described as a control-flow based sequence of Actions, there 
is a graphical representation for Transitions and compound transitions which is similar to the notation used for 
Activities.
NOTE. Although this alternative notation contains graphical elements reminiscent of the notation used for Activities, it 
is a distinct form applicable only to StateMachines, and its elements map to appropriate StateMachine concepts.
This notation is in the form of a directed graph, which consists of one or more graphical symbols interconnected by 
directed arcs that represent control flow (see Figure 14.32). In all cases except for the Transition originating from the 
initial Pseudostate, the starting symbol, which has the form of the standard simple State notation, represents the source 
State of the Transition. If this Transition has a Signal-based Trigger, then the source state symbol is connected by an arc 

Unified Modeling Language 2.5

329

pointing to a special Signal receipt symbol described below. If there are multiple Triggers for the Transition, they are all 
listed in the same symbol as explained below.
If the Transition originates from the initial Pseudostate, the starting symbol is the initial symbol, which is the same as 
used for the initial Pseudostate: a filled black circle. In that case, there is no Signal receipt symbol immediately 
following the starting symbol.
Except for end symbols that terminate the paths, any of the following symbols can appear in the chain as appropriate:

•

•

•

•

an action symbol

a choice point symbol

a Signal send symbol

a merge symbol

The terminating symbol in these directed graphs is always either a State-like symbol representing the target State of the 
transition or a final state symbol (which is the same as the symbol for a FinalState).

Action symbols

14.2.4.9.1
Each action symbol is represented by a rectangle with an optional textual specification of the action. It maps either to an 
OpaqueAction or to a SequenceNode containing one or more Actions executed in sequence (see sub clause 16.11.3) and 
which are part of the Activity specifying the effect Behavior of the appropriate Transition in the compound transition.

Signal receipt symbol

14.2.4.9.2
The Signal receipt symbol is shown as a five-pointed polygon that looks like a rectangle with a triangular notch in one 
of its sides (either one). It maps to the trigger of the Transition and does not map to an Action of the Activity that 
specifies the effect Behavior. The names of the Signals of the Trigger as well as any guard are contained within the 
symbol as follows:

<trigger> [‘,’ <trigger>]* [‘[‘ <guard> ‘]’]

Where <trigger> is specified as described in sub clause 13.3.4 with the restriction that only Signal and change Event 
types are allowed. The trigger symbol is always first in the path of symbols and a compound transition can only have at 
most one such symbol.

Signal send symbol

14.2.4.9.3
This represents the special action of sending a signal and maps directly to a SendSignalAction that is part of the Activity 
that describes the effect Behavior of the corresponding Transition. The notation corresponds to the notation for the 
SendSignalAction (see sub clause 16.3.4).

Choice point symbol

14.2.4.9.4
This symbol maps directly to a choice Pseudostate and uses the same notation.
NOTE. It is not part of any Activity.

Merge symbol

14.2.4.9.5
A merge symbol is used to join multiple control-flow arcs and maps directly to a junction Pseudostate and uses the same 
notation. It is not part of any Activity.
Figure 14.32 shows a compound transition consisting of four connected Transitions: one from the Idle State to the 
choice symbol, one for each of the branches of the choice through the junction symbol, and one from the junction 
Pseudostate to the Busy State.

330

Unified Modeling Language 2.5

Figure 14.32  Symbols for Signal reception, Sending, and Actions on a Transition

Deferred triggers

14.2.4.9.6
A deferrable trigger is shown by listing it within the State followed by a slash and the label “defer”. An example of this 
notation is shown in Figure 14.33. In this example, handling of the “request” event occurrence is deferred in States 
“Initializing” and “Primed”. However, it will be handled once the “Operational” State is reached.

Unified Modeling Language 2.5

331

Initializing

request/defer

initDone/

Primed

request/defer

start/

Operational

request/handleReq()

Figure 14.33  Deferred Trigger notation

14.2.4.10

TransitionKind

•
•

•

Transitions of the kind internal are not shown explicitly in diagrams.
Transitions of the kind local can originate from the border of the containing composite State, or one of its entry 
points, or from a Vertex within the composite State. (Alternatively, a Transition of kind local can be shown as a 
Transition leaving a State symbol containing the text “*.” The Transition is then considered to belong to the 
enclosing composite State.) Transitions of this kind can only terminate on the border of the composite State, or 
one of its exit points, or on a Vertex within the composite State. All of the Transitions in Figure 14.34 are local.
Transitions of kind external can target any Vertex contained within or external to the source Vertex. The part of 
the external Transition closest to the source must be drawn outside of the source Vertex border. In the case of an 
external self Transition where the source is a State or exit point on the State, it may target the State itself or an 
entry point on the State and it will be drawn completely outside of the State border. All of the Transitions in
Figure 14.35 are external.

332

Unified Modeling Language 2.5

Figure 14.34  Local Transitions

Figure 14.35  External Transitions

Examples

14.2.5
Figure 14.36 is an example StateMachine diagram for the StateMachine for simple telephone. In addition to an initial 
Pseudostate, the StateMachine has an entry point called “activeEntry”. Also, in addition to the FinalState, it has an exit 
point called “aborted.”

Unified Modeling Language 2.5

333

Figure 14.36  StateMachine diagram representing a telephone

An example of submachine usage is shown in Figure 14.12 and Figure 14.13.

StateMachine Redefinition
Summary

14.3
14.3.1
StateMachines are used for the definition of Behavior (for example, Classes that are generalizable). As part of the 
specialization of a Class it may be required to specialize its Behavior definitions. This is achieved by defining the 
Behavior of the specialized Classifier as an extension of the Behavior of the general Classifier using redefinition.

334

Unified Modeling Language 2.5

RedefinableElement

Region

{subsets redefinableElement}
+ region

*

0..1

+ extendedRegion

{subsets redefinedElement}

{subsets redefinableElement}
+ state

*

{subsets redefinableElement}

State

+ state

*

0..1

+ redefinedState
{subsets redefinedElement}

{subsets redefinableElement}
+ transition

Transition

*

{subsets redefinableElement}
+ transition

*

0..1

+ redefinedTransition

{subsets redefinedElement}

14.3.2

Abstract Syntax

Classifier

{readOnly, redefines
redefinitionContext}
+ /redefinitionContext

1

*
+ region

{subsets
redefinableElement}

{readOnly, redefines
redefinitionContext}
+ /redefinitionContext

1

{readOnly, redefines
redefinitionContext}
+ /redefinitionContext
1

StateMachine

+ stateMachine
{subsets behavior}

*

*

+ extendedStateMachine

{redefines redefinedBehavior}

Figure 14.37  StateMachine redefinition

14.3.3

14.3.3.1

Semantics

StateMachine Extension

A StateMachine is generalizable. A specialized StateMachine is an extension of the general StateMachine, such that

•

•

•

new Regions, Vertices, and Transitions may be added;

Regions and States may be redefined (e.g., simple States can be redefined as composite States while composite 
States can be redefined by adding States and Transitions); and
Transitions can be redefined.

This can be done as part of Classifier specialization; that is, StateMachine behaviors and classifierBehaviors owned by a 
general Classifier can be specialized as can StateMachines that specify the methods of Behavioral features of a general 
Classifier.
A specialized StateMachine will have all the elements of the general StateMachine, and it may include additional 
elements. Regions may be added. Inherited Regions may be redefined by extension: States and Vertices are inherited, 
and States and Transitions of the Regions of the StateMachine may be redefined.

State redefinition

14.3.3.1.1
A simple State may be redefined (extended) to become a composite State by one or more Regions. A composite State 
can be redefined (extended) by:
adding new Regions,

•

Unified Modeling Language 2.5

335

•

•

•

adding Vertices and Transitions to inherited Regions,

adding entry/exit/doActivity Behaviors, if the general State does not have any,

redefining States and Transitions.

The redefinition of a State applies to the whole StateMachine.
A submachine State may also be redefined. The submachine StateMachine may be replaced by another submachine 
StateMachine, provided that it has the same entry/exit points as the redefined submachine StateMachine. However, it 
may have additional entry/exit points.
In case of multiple general Classifiers, extension implies that the extension StateMachine gets orthogonal Regions for 
each of the StateMachines of the general Classifiers in addition to a distinct new Region.

Transition redefinition

14.3.3.1.2
A Transition of an extended StateMachine may in the StateMachine extension be redefined. Transitions can have their 
effect and target State replaced, while the source State and trigger are preserved.

Notation

14.3.4
A StateMachine that is an extension of the StateMachine in a general Classifier will have the keyword «extended» 
associated with the name of the StateMachine (e.g., see Figure 14.39 and Figure 14.40). Similarly, to indicate that an 
inherited Region is extended or that a State is extended, the keyword «extended» is added to the name of the element. 
Inherited elements in a StateMachine, Region, or State are drawn either with dashed lines or light-toned lines (e.g.,
Figure 14.39). Finally, if a State is a leaf state (i.e., isLeaf = true), an additional label following the name of the State may 
be added consisting of the keyword «final».

Examples

14.3.5
As an example of StateMachine specialization, the States “VerifyCard,” “OutOfService,” and “VerifyTransaction” in the 
ATM StateMachine in Figure 14.38 have been designated as final, which means that they cannot be redefined in 
specializations of ATM. All other States can be redefined. The (verifyTransaction-releaseCard) Transition has also been 
specified as final, meaning that its effect Behavior and the target State cannot be redefined.

336

Unified Modeling Language 2.5

stm ATM

VerifyCard
«final» 

acceptCard/

ReadAmount

outOfService/

SelectAmount

OutOfService

«final» 

amount/

VerifyTransaction

«final» 

ReleaseCard 

releaseCard/

«final»

Figure 14.38  A general StateMachine

In Figure 14.39 a specialized ATM (which is the StateMachine of a Class that is a specialization of the Class with the 
ATM StateMachine of Figure 14.38) is defined by extending the composite State by adding a State and a Transition, so 
that users can enter the desired amount. In addition, a Transition is added from an inherited State to the newly 
introduced State.

stm ATM «extended» 

ReadAmount «extended» 

SelectAmount

otherAmount/

ok/

EnterAmount

rejectTransaction/

VerifyTransaction

Figure 14.39  An extended StateMachine

Figure 14.40 shows an example of adding Transitions to a specialized StateMachine.

Unified Modeling Language 2.5

337

ATM «extended» 

ReadAmount

SelectAmount

abort

EnterAmount

abort

ReleaseCard

Figure 14.40  Adding Transitions

ProtocolStateMachines
Summary

14.4
14.4.1
ProtocolStateMachines are used to express usage protocols. ProtocolStateMachines express the legal sequences of 
Event occurrences to which the Behaviors of an associated BehavioredClassifier must conform. The StateMachine 
notation is a convenient way to define the order of invocations of the behavioral features of a Classifier. 
ProtocolStateMachines can be associated with Classifiers, Interfaces, and Ports.

338

Unified Modeling Language 2.5

14.4.2

Abstract Syntax

StateMachine

ProtocolStateMachine

Transition

ProtocolTransition

{subsets source,
subsets owner}
+ specificMachine

1

{subsets target}
+ generalMachine
1

{subsets ownedElement,
subsets directedRelationship}

+ conformance
*

ProtocolConformance

{subsets directedRelationship}

+ protocolConformance

*

{redefines transition}
+ protocolTransition
0..1

{subsets guard}
+ preCondition

0..1

{subsets context}
+ owningTransition

{subsets ownedRule}
+ postCondition

Constraint

+ protocolTransition

*

0..1

0..1

{readOnly}
+ /referred

*

Operation

Figure 14.41  ProtocolStateMachines

14.4.3

14.4.3.1

Semantics

ProtocolStateMachine

A ProtocolStateMachine is always defined in the context of a Classifier. It specifies which BehavioralFeatures of that 
Classifier can be invoked in a given protocol state and under what conditions, thereby specifying allowed invocation 
sequences. In this manner, a specification of the lifecycle of an instance of the Classifier is defined from an external 
perspective.
ProtocolStateMachines help define the order in which BehavioralFeatures of a Classifier are invoked by specifying:

•
•
•

the behavioral context (i.e., which states and pre-conditions) in which they can be validly invoked,
the valid orderings of invocations,
the expected outcomes (post-conditions) of invocations.

ProtocolStateMachine present an external view of the owning Classifier as perceived by its collaborators. This extends 
beyond what can be captured via pre- and post-conditions on individual BehavioralFeatures, as ProtocolStateMachines 
also specify the valid orderings of invocations of the different features. This is achieved by a state machine specification 
in which the transition triggers are feature invocations and the guards of the transitions (ProtocolTransitions) specify the 
pre-condition that must apply for the invocation to be valid. The states (ProtocolStates) of this state machine, being a 
consequence of past invocation sequences, capture the state of the protocol and are also a form of pre-condition.
NOTE. Because ProtocolStateMachines provide a “black box” view of the behavior of a Classifier, their States may not 
necessarily correspond to the States of internal behavioral StateMachines.

Unified Modeling Language 2.5

339

ProtocolStateMachine interpretation can vary from:

1 Declarative ProtocolStateMachines, which specify the legal Transitions for BehavioralFeature invocations. 

The effects of a BehavioralFeature invocation is not specified. This type of specification only provides a 
contract for the user of the context Classifier.
Executable (run time) ProtocolStateMachines, which specify all Event occurrences that an object may receive 
and handle, together with the Transitions that these trigger. In this case, the legal Transitions for 
BehavioralFeature invocations must match exactly the triggered Transitions or a run-time exception occurs. 
The invocation results in the execution of the method associated with the invoked BehavioralFeatures.

2

The specifications for both interpretations is the same, the only difference being the direct dynamic implication that the 
latter interpretation provides.
The more sophisticated forms of modeling encountered in behavioral StateMachines such as compound Transitions, 
submachine StateMachines, composite States, and concurrent orthogonal Regions, can also be used for 
ProtocolStateMachines. For example, concurrent Regions make it possible to express protocols where an instance can 
have several active States simultaneously. Submachine StateMachines and compound transitions can be used for 
factorizing complex ProtocolStateMachines.
A Classifier may have several ProtocolStateMachines. This can be used, for example, when a Classifier has multiple 
parents, each having its own ProtocolStateMachine, and the protocols are orthogonal. An alternative to this is to simply 
have one ProtocolStateMachine, with distinct StateMachines in concurrent Regions.
State in ProtocolStateMachines 
The States of ProtocolStateMachines are exposed to the users of their context Classifiers. A protocol State represents an 
exposed stable situation of its context Classifier: When an instance of the Classifier classifier is not processing any 
BehavioralFeature invocation, users of this instance can always know its state configuration.
The States of a ProtocolStateMachine cannot have defined entry, exit, or doActivity Behaviors.

14.4.3.2

ProtocolTransition

A ProtocolTransition specifies a legal Transition for an invocation of a BehavioralFeature of the context Classifier. 
ProtocolTransitions have the following features:

•

•

•

a pre-condition (preCondition), which specializes the guard attribute of Transition,

a trigger,

a post-condition (postCondition).

The protocol Transition specifies that (a) the associated (referred) feature can be invoked on an instance of the context 
Classifier, if it is in the origin State and the guard condition holds, and that (b) upon completion of the Transition, the 
instance will be in the target State in which the post-condition will hold.
ProtocolTransitions do not have an associated effect Behavior. The consequence of a ProtocolTransition executed as a 
result of a BehavioralFeature invocation is implicit: it is the execution of the method corresponding to the invoked 
BehavioralFeature. In case of other types of Triggers, the consequences are unspecified except that a Transition will 
lead to another State under a specific post-condition, regardless of any Behaviors associated with this Transition.

Unexpected trigger reception

14.4.3.2.1
The interpretation of the reception of an Event occurrence that does not match a valid trigger for the current State, state 
invariant, or pre-condition is not defined (e.g., it can be ignored, rejected, or deferred; an exception can be raised; or the 
application can stop on an error). It corresponds semantically to a pre-condition violation, for which no predefined 
Behavior is defined in UML.

340

Unified Modeling Language 2.5

Unexpected Behavior

14.4.3.2.2
The interpretation of an unexpected Behavior, that is an unexpected result of a Transition (wrong FinalState or 
FinalState invariant, or post-condition) is also not defined. However, this should be interpreted as an error of the 
implementation of the ProtocolStateMachine.

Equivalences to pre- and post-conditions of operations

14.4.3.2.3
A protocol Transition can be semantically interpreted in terms of pre- and post-conditions on the associated operation. 
For example, the Transition in Figure 14.42 can be interpreted in the following way:

The operation “m1” can be called on an instance when it is in the ProtocolState “S1” under the condition “C1.”
1
2 When “m1” is called in the ProtocolState “S1” under the condition “C1,” then the ProtocolState “S2” must be 

reached under the condition “C2.”

Figure 14.42  An example of a ProtocolTransition associated with the operation "m1"

Operations referred by several Transitions

Figure 14.43  Example of several ProtocolTransitions associated with the same operation (m1)

In a ProtocolStateMachine, several Transitions can refer to the same operation as illustrated in Figure 14.43. In that 
case, all pre-and post-conditions will be combined in the operation pre-condition as shown below.

Operation m1()
Pre: 

in state S1 and condition C1
or
in state S3 and condition C3

Post:  if the initial condition was “in state S1 and condition C1”

then in S2 and C2 

else 
if the initial condition was “in state S3 and condition C3”

then in S4 and C4

A ProtocolStateMachine specifies all the legal ProtocolTransition for each BehavioralFeature referred by its Transitions.
Unreferred Operations 
If a BehavioralFeature is not referred by any ProtocolTransition, then the operation can be called for any State of the 
ProtocolStateMachine, and will not change the current State or pre- and post-conditions.

Using other types of Events in ProtocolStateMachines

14.4.3.2.4
Apart from invocations of BehavioralFeatures, other Events may be used for expressing the behavior of 
ProtocolStateMachines. A Trigger that is not a BehavioralFeature invocation can be specified for a protocol Transition. 
In that case, this specification is a requirement for the environment external to the ProtocolStateMachine. That is, it is 

Unified Modeling Language 2.5

341

legal to send an Event occurrence of this type to an instance of the context Classifier only under the conditions specified 
by the ProtocolStateMachine. The precise semantic interpretation of this is not defined.

14.4.3.3

ProtocolConformance

ProtocolStateMachines can be refined into more specific ProtocolStateMachines. Protocol conformance declares that 
the specific ProtocolStateMachine specifies a protocol that conforms to that specified by the general 
ProtocolStateMachine.
A ProtocolStateMachine is owned by a Classifier. The Classifiers owning a general StateMachine and an associated 
specific StateMachine are generally also connected by a Generalization or a Realization.
Protocol conformance represents a declaration that every rule and constraint specified for the general 
ProtocolStateMachine (state invariants, pre- and post-conditions for the operations referred by the 
ProtocolStateMachine) apply to the specific ProtocolStateMachine.

14.4.4

14.4.4.1

Notation

ProtocolStateMachine

The notation for ProtocolStateMachine is very similar to the one for behavioral StateMachines. The keyword «protocol» 
placed close to the name of the StateMachine differentiates graphically ProtocolStateMachine diagrams.

Door «protocol» 

create  /

opened

open  /

closed

[ doorway  - > isEmpty()] close/

lock /

unlock  /

lock

Figure 14.44  ProtocolStateMachine example

The textual expression of an invariant associated with a State in a ProtocolStateMachine is represented by placing it 
after or under the name of the State, enclosed in square brackets (Figure 14.45).

342

Unified Modeling Language 2.5

Figure 14.45  Notation for a State with an invariant

14.4.4.2

ProtocolTransition

The usual StateMachine notation applies. The difference is that no effect Behaviors are specified for 
ProtocolTransitions, and that post-conditions can exist. Post-conditions have the same syntax as guard conditions, but 
appear at the end of the Transition syntax.

Figure 14.46  ProtocolTransition notation

14.5
14.5.1

Classifier Descriptions
ConnectionPointReference [Class]

14.5.1.1

Description

A ConnectionPointReference represents a usage (as part of a submachine State) of an entry/exit point Pseudostate 
defined in the StateMachine referenced by the submachine State.

14.5.1.2

Diagrams

Behavior State Machines

14.5.1.3

Generalizations

Vertex

14.5.1.4

Association Ends

•

•

•

entry : Pseudostate [0..*] (opposite A_entry_connectionPointReference::connectionPointReference)
The entryPoint Pseudostates corresponding to this connection point.

exit : Pseudostate [0..*] (opposite A_exit_connectionPointReference::connectionPointReference)
The exitPoints kind Pseudostates corresponding to this connection point.

state : State [0..1]{subsets NamedElement::namespace} (opposite State::connection)
The State in which the ConnectionPointReference is defined.

14.5.1.5

Constraints

•

exit_pseudostates
The exit Pseudostates must be Pseudostates with kind exitPoint.

inv: exit->forAll(kind = PseudostateKind::exitPoint)

Unified Modeling Language 2.5

343

•

entry_pseudostates
The entry Pseudostates must be Pseudostates with kind entryPoint.

inv: entry->forAll(kind = PseudostateKind::entryPoint)

14.5.2

14.5.2.1

FinalState [Class]

Description

A special kind of State, which, when entered, signifies that the enclosing Region has completed. If the enclosing Region 
is directly contained in a StateMachine and all other Regions in that StateMachine also are completed, then it means 
that the entire StateMachine behavior is completed.

14.5.2.2

Diagrams

Behavior State Machines

14.5.2.3

Generalizations

State

14.5.2.4

Constraints

•

•

•

•

•

•

no_exit_behavior
A FinalState has no exit Behavior.

inv: exit->isEmpty()

no_outgoing_transitions
A FinalState cannot have any outgoing Transitions.

inv: outgoing->size() = 0

no_regions
A FinalState cannot have Regions.

inv: region->size() = 0

cannot_reference_submachine
A FinalState cannot reference a submachine.

inv: submachine->isEmpty()

no_entry_behavior
A FinalState has no entry Behavior.

inv: entry->isEmpty()

no_state_behavior
A FinalState has no state (doActivity) Behavior.

inv: doActivity->isEmpty()

344

Unified Modeling Language 2.5

14.5.3

14.5.3.1

ProtocolConformance [Class]

Description

A ProtocolStateMachine can be redefined into a more specific ProtocolStateMachine or into behavioral StateMachine. 
ProtocolConformance declares that the specific ProtocolStateMachine specifies a protocol that conforms to the general 
ProtocolStateMachine or that the specific behavioral StateMachine abides by the protocol of the general 
ProtocolStateMachine.

14.5.3.2

Diagrams

Protocol State Machines

14.5.3.3

Generalizations

DirectedRelationship

14.5.3.4

Association Ends

•

•

generalMachine : ProtocolStateMachine [1..1]{subsets DirectedRelationship::target} (opposite 
A_generalMachine_protocolConformance::protocolConformance)
Specifies the ProtocolStateMachine to which the specific ProtocolStateMachine conforms.

specificMachine : ProtocolStateMachine [1..1]{subsets DirectedRelationship::source, subsets Element::owner} 
(opposite ProtocolStateMachine::conformance)
Specifies the ProtocolStateMachine which conforms to the general ProtocolStateMachine.

14.5.4

14.5.4.1

ProtocolStateMachine [Class]

Description

A ProtocolStateMachine is always defined in the context of a Classifier. It specifies which BehavioralFeatures of the 
Classifier can be called in which State and under which conditions, thus specifying the allowed invocation sequences on 
the Classifier's BehavioralFeatures. A ProtocolStateMachine specifies the possible and permitted Transitions on the 
instances of its context Classifier, together with the BehavioralFeatures that carry the Transitions. In this manner, an 
instance lifecycle can be specified for a Classifier, by defining the order in which the BehavioralFeatures can be 
activated and the States through which an instance progresses during its existence.

14.5.4.2

Diagrams

Protocol State Machines, Encapsulated Classifiers, Interfaces

14.5.4.3

Generalizations

StateMachine

14.5.4.4

Association Ends

•

♦ conformance : ProtocolConformance [0..*]{subsets Element::ownedElement, subsets 
A_source_directedRelationship::directedRelationship} (opposite ProtocolConformance::specificMachine)
Conformance between ProtocolStateMachine

14.5.4.5

Constraints

•

classifier_context
A ProtocolStateMachine must only have a Classifier context, not a BehavioralFeature context.

Unified Modeling Language 2.5

345

•

•

•

inv: _'context' <> null and specification = null

deep_or_shallow_history
ProtocolStateMachines cannot have deep or shallow history Pseudostates.

inv: region->forAll (r | r.subvertex->forAll (v | v.oclIsKindOf(Pseudostate) implies
((v.oclAsType(Pseudostate).kind <>  PseudostateKind::deepHistory) and 
(v.oclAsType(Pseudostate).kind <> PseudostateKind::shallowHistory))))

entry_exit_do
The states of a ProtocolStateMachine cannot have entry, exit, or do activity Behaviors.

inv: region->forAll(r | r.subvertex->forAll(v | v.oclIsKindOf(State) implies
(v.oclAsType(State).entry->isEmpty() and v.oclAsType(State).exit->isEmpty() and 
v.oclAsType(State).doActivity->isEmpty())))

protocol_transitions
All Transitions of a ProtocolStateMachine must be ProtocolTransitions.

inv: region->forAll(r | r.transition->forAll(t | t.oclIsTypeOf(ProtocolTransition)))

14.5.5

14.5.5.1

ProtocolTransition [Class]

Description

A ProtocolTransition specifies a legal Transition for an Operation. Transitions of ProtocolStateMachines have the 
following information: a pre-condition (guard), a Trigger, and a post-condition. Every ProtocolTransition is associated 
with at most one BehavioralFeature belonging to the context Classifier of the ProtocolStateMachine.

14.5.5.2

Diagrams

Protocol State Machines

14.5.5.3

Generalizations

Transition

14.5.5.4

Association Ends

•

•

•

346

♦ postCondition : Constraint [0..1]{subsets Namespace::ownedRule} (opposite 
A_postCondition_owningTransition::owningTransition)
Specifies the post condition of the Transition which is the Condition that should be obtained once the 
Transition is triggered. This post condition is part of the post condition of the Operation connected to the 
Transition.

♦ preCondition : Constraint [0..1]{subsets Transition::guard} (opposite 
A_preCondition_protocolTransition::protocolTransition)
Specifies the precondition of the Transition. It specifies the Condition that should be verified before triggering 
the Transition. This guard condition added to the source State will be evaluated as part of the precondition of 
the Operation referred by the Transition if any.

/referred : Operation [0..*]{} (opposite A_referred_protocolTransition::protocolTransition)
This association refers to the associated Operation. It is derived from the Operation of the CallEvent Trigger 
when applicable.

Unified Modeling Language 2.5

14.5.5.5

Operations

•

referred() : Operation [0..*]
Derivation for ProtocolTransition::/referred

body: trigger->collect(event)->select(oclIsKindOf(CallEvent))-
>collect(oclAsType(CallEvent).operation)->asSet()

14.5.5.6

Constraints

•

•

•

refers_to_operation
If a ProtocolTransition refers to an Operation (i.e., has a CallEvent trigger corresponding to an Operation), then 
that Operation should apply to the context Classifier of the StateMachine of the ProtocolTransition.

inv: if (referred()->notEmpty() and containingStateMachine()._'context'->notEmpty()) then
    containingStateMachine()._'context'.oclAsType(BehavioredClassifier).allFeatures()-
>includesAll(referred())
else true endif

associated_actions
A ProtocolTransition never has associated Behaviors.

inv: effect = null

belongs_to_psm
A ProtocolTransition always belongs to a ProtocolStateMachine.

inv: container.belongsToPSM()

14.5.6

14.5.6.1

Pseudostate [Class]

Description

A Pseudostate is an abstraction that encompasses different types of transient Vertices in the StateMachine graph. A 
StateMachine instance never comes to rest in a Pseudostate, instead, it will exit and enter the Pseudostate within a single 
run-to-completion step.

14.5.6.2

Diagrams

Behavior State Machines

14.5.6.3

Generalizations

Vertex

14.5.6.4

Attributes

•

kind : PseudostateKind [1..1] = initial
Determines the precise type of the Pseudostate and can be one of: entryPoint, exitPoint, initial, deepHistory, 
shallowHistory, join, fork, junction, terminate or choice.

14.5.6.5

Association Ends

•

state : State [0..1]{subsets NamedElement::namespace} (opposite State::connectionPoint)
The State that owns this Pseudostate and in which it appears.

Unified Modeling Language 2.5

347

•

stateMachine : StateMachine [0..1]{subsets NamedElement::namespace} (opposite 
StateMachine::connectionPoint)
The StateMachine in which this Pseudostate is defined. This only applies to Pseudostates of the kind 
entryPoint or exitPoint.

14.5.6.6

Constraints

•

•

•

•

•

•

•

transitions_outgoing
All transitions outgoing a fork vertex must target states in different regions of an orthogonal state.

inv: (kind = PseudostateKind::fork) implies

-- for any pair of outgoing transitions there exists an orthogonal state which contains the 
targets of these transitions
-- such that these targets belong to different regions of that orthogonal state

outgoing->forAll(t1:Transition, t2:Transition | let contState:State = 
containingStateMachine().LCAState(t1.target, t2.target) in

((contState <> null) and (contState.region

and t2.target.isContainedInRegion(r2)))))

->exists(r1:Region, r2: Region | (r1 <> r2) and t1.target.isContainedInRegion(r1) 

choice_vertex
In a complete statemachine, a choice Vertex must have at least one incoming and one outgoing Transition.

inv: (kind = PseudostateKind::choice) implies (incoming->size() >= 1 and outgoing->size() >= 
1)

outgoing_from_initial
The outgoing Transition from an initial vertex may have a behavior, but not a trigger or a guard.

inv: (kind = PseudostateKind::initial) implies (outgoing.guard = null and outgoing.trigger-
>isEmpty())

join_vertex
In a complete StateMachine, a join Vertex must have at least two incoming Transitions and exactly one 
outgoing Transition.

inv: (kind = PseudostateKind::join) implies (outgoing->size() = 1 and incoming->size() >= 2)

junction_vertex
In a complete StateMachine, a junction Vertex must have at least one incoming and one outgoing Transition.

inv: (kind = PseudostateKind::junction) implies (incoming->size() >= 1 and outgoing->size() 
>= 1)

history_vertices
History Vertices can have at most one outgoing Transition.

inv: ((kind = PseudostateKind::deepHistory) or (kind = PseudostateKind::shallowHistory)) 
implies (outgoing->size() <= 1)

initial_vertex
An initial Vertex can have at most one outgoing Transition.

inv: (kind = PseudostateKind::initial) implies (outgoing->size() <= 1)

348

Unified Modeling Language 2.5

•

•

fork_vertex
In a complete StateMachine, a fork Vertex must have at least two outgoing Transitions and exactly one 
incoming Transition.

inv: (kind = PseudostateKind::fork) implies (incoming->size() = 1 and outgoing->size() >= 2)

transitions_incoming
All Transitions incoming a join Vertex must originate in different Regions of an orthogonal State.

inv: (kind = PseudostateKind::join) implies

-- for any pair of incoming transitions there exists an orthogonal state which contains the 
source vetices of these transitions
-- such that these source vertices belong to different regions of that orthogonal state

incoming->forAll(t1:Transition, t2:Transition | let contState:State = 
containingStateMachine().LCAState(t1.source, t2.source) in

((contState <> null) and (contState.region

and t2.source.isContainedInRegion(r2)))))

->exists(r1:Region, r2: Region | (r1 <> r2) and t1.source.isContainedInRegion(r1) 

14.5.7

14.5.7.1

PseudostateKind [Enumeration]

Description

PseudostateKind is an Enumeration type that is used to differentiate various kinds of Pseudostates.

14.5.7.2

Diagrams

• Behavior State Machines

 

 

14.5.7.3

Literals

•

•

•

•

•

•

•

•

•

•

initial

deepHistory

shallowHistory

join

fork

junction

choice

entryPoint

exitPoint

terminate

Unified Modeling Language 2.5

349

14.5.8

14.5.8.1

Region [Class]

Description

A Region is a top-level part of a StateMachine or a composite State, that serves as a container for the Vertices and 
Transitions of the StateMachine. A StateMachine or composite State may contain multiple Regions representing 
behaviors that may occur in parallel.

14.5.8.2

Diagrams

Behavior State Machines, State Machine Redefinition

14.5.8.3

Generalizations

Namespace, RedefinableElement

14.5.8.4

Association Ends

•

•

•

•

•

•

extendedRegion : Region [0..1]{subsets RedefinableElement::redefinedElement} (opposite 
A_extendedRegion_region::region)
The region of which this region is an extension.

/redefinitionContext : Classifier [1..1]{redefines RedefinableElement::redefinitionContext} (opposite 
A_redefinitionContext_region::region)
References the Classifier in which context this element may be redefined.

state : State [0..1]{subsets NamedElement::namespace} (opposite State::region)
The State that owns the Region. If a Region is owned by a State, then it cannot also be owned by a 
StateMachine.

stateMachine : StateMachine [0..1]{subsets NamedElement::namespace} (opposite StateMachine::region)
The StateMachine that owns the Region. If a Region is owned by a StateMachine, then it cannot also be owned 
by a State.

♦ subvertex : Vertex [0..*]{subsets Namespace::ownedMember} (opposite Vertex::container)
The set of Vertices that are owned by this Region.

♦ transition : Transition [0..*]{subsets Namespace::ownedMember} (opposite Transition::container)
The set of Transitions owned by the Region.

14.5.8.5

Operations

•

•

350

belongsToPSM() : Boolean
The operation belongsToPSM () checks if the Region belongs to a ProtocolStateMachine.

body: if  stateMachine <> null
then
  stateMachine.oclIsKindOf(ProtocolStateMachine)
else
  state <> null  implies  state.container.belongsToPSM()
endif

containingStateMachine() : StateMachine
The operation containingStateMachine() returns the StateMachine in which this Region is defined.

body: if stateMachine = null

Unified Modeling Language 2.5

then
  state.containingStateMachine()
else
  stateMachine
endif

isConsistentWith(redefiningElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isConsistentWith()}
The query isConsistentWith() specifies that a redefining Region is consistent with a redefined Region provided 
that the redefining Region is an extension of the Redefined region, i.e., its Vertices and Transitions conform to 
one of the following: (1) they are equal to corresponding elements of the redefined Region or, (2) they 
consistently redefine a State or Transition of the redefined region, or (3) they add new States or Transitions.

pre: redefiningElement.isRedefinitionContextValid(self)
body: -- the following is merely a default body; it is expected that the specific form of 
this constraint will be specified by profiles
true

isRedefinitionContextValid(redefinedElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isRedefinitionContextValid()}
The query isRedefinitionContextValid() specifies whether the redefinition contexts of a Region are properly 
related to the redefinition contexts of the specified Region to allow this element to redefine the other. The 
containing StateMachine or State of a redefining Region must Redefine the containing StateMachine or State 
of the redefined Region.

body: if redefinedElement.oclIsKindOf(Region) then
  let redefinedRegion : Region = redefinedElement.oclAsType(Region) in
    if stateMachine->isEmpty() then
    -- the Region is owned by a State
      (state.redefinedState->notEmpty() and state.redefinedState.region-
>includes(redefinedRegion))
    else -- the region is owned by a StateMachine
      (stateMachine.extendedStateMachine->notEmpty() and
        stateMachine.extendedStateMachine->exists(sm : StateMachine |
          sm.region->includes(redefinedRegion)))
    endif
else
  false
endif

redefinitionContext() : Classifier
The redefinition context of a Region is the nearest containing StateMachine.

•

•

•

body: let sm : StateMachine = containingStateMachine() in
if sm._'context' = null or sm.general->notEmpty() then
  sm
else
  sm._'context'
endif

14.5.8.6

Constraints

•

•

deep_history_vertex
A Region can have at most one deep history Vertex.

inv: self.subvertex->select (oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->
   select(kind = PseudostateKind::deepHistory)->size() <= 1

shallow_history_vertex
A Region can have at most one shallow history Vertex.

inv: subvertex->select(oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->
  select(kind = PseudostateKind::shallowHistory)->size() <= 1

Unified Modeling Language 2.5

351

•

•

owned
If a Region is owned by a StateMachine, then it cannot also be owned by a State and vice versa.

inv: (stateMachine <> null implies state = null) and (state <> null implies stateMachine = 
null)

initial_vertex
A Region can have at most one initial Vertex.

inv: self.subvertex->select (oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->
  select(kind = PseudostateKind::initial)->size() <= 1

14.5.9

14.5.9.1

State [Class]

Description

A State models a situation during which some (usually implicit) invariant condition holds.

14.5.9.2

Diagrams

Behavior State Machines, State Machine Redefinition, Object Nodes

14.5.9.3

Generalizations

RedefinableElement, Namespace, Vertex

14.5.9.4

Specializations

FinalState

14.5.9.5

Attributes

•

•

•

•

/isComposite : Boolean [1..1]
A state with isComposite=true is said to be a composite State. A composite State is a State that contains at least 
one Region.

/isOrthogonal : Boolean [1..1]
A State with isOrthogonal=true is said to be an orthogonal composite State. An orthogonal composite State 
contains two or more Regions.

/isSimple : Boolean [1..1]
A State with isSimple=true is said to be a simple State. A simple State does not have any Regions and it does 
not refer to any submachine StateMachine.

/isSubmachineState : Boolean [1..1]
A State with isSubmachineState=true is said to be a submachine State. Such a State refers to another 
StateMachine(submachine).

14.5.9.6

Association Ends

•

352

♦ connection : ConnectionPointReference [0..*]{subsets Namespace::ownedMember} (opposite 
ConnectionPointReference::state)
The entry and exit connection points used in conjunction with this (submachine) State, i.e., as targets and 
sources, respectively, in the Region with the submachine State. A connection point reference references the 
corresponding definition of a connection point Pseudostate in the StateMachine referenced by the submachine 
State.

Unified Modeling Language 2.5

•

•

•

•

•

•

•

•

•

•

♦ connectionPoint : Pseudostate [0..*]{subsets Namespace::ownedMember} (opposite Pseudostate::state)
The entry and exit Pseudostates of a composite State. These can only be entry or exit Pseudostates, and they 
must have different names. They can only be defined for composite States.

♦ deferrableTrigger : Trigger [0..*]{subsets Element::ownedElement} (opposite 
A_deferrableTrigger_state::state)
A list of Triggers that are candidates to be retained by the StateMachine if they trigger no Transitions out of the 
State (not consumed). A deferred Trigger is retained until the StateMachine reaches a State configuration where 
it is no longer deferred.

♦ doActivity : Behavior [0..1]{subsets Element::ownedElement} (opposite A_doActivity_state::state)
An optional Behavior that is executed while being in the State. The execution starts when this State is entered, 
and ceases either by itself when done, or when the State is exited, whichever comes first.

♦ entry : Behavior [0..1]{subsets Element::ownedElement} (opposite A_entry_state::state)
An optional Behavior that is executed whenever this State is entered regardless of the Transition taken to reach 
the State. If defined, entry Behaviors are always executed to completion prior to any internal Behavior or 
Transitions performed within the State.

♦ exit : Behavior [0..1]{subsets Element::ownedElement} (opposite A_exit_state::state)
An optional Behavior that is executed whenever this State is exited regardless of which Transition was taken 
out of the State. If defined, exit Behaviors are always executed to completion only after all internal and 
transition Behaviors have completed execution.

redefinedState : State [0..1]{subsets RedefinableElement::redefinedElement} (opposite 
A_redefinedState_state::state)
The State of which this State is a redefinition.

/redefinitionContext : Classifier [1..1]{redefines RedefinableElement::redefinitionContext} (opposite 
A_redefinitionContext_state::state)
References the Classifier in which context this element may be redefined.

♦ region : Region [0..*]{subsets Namespace::ownedMember} (opposite Region::state)
The Regions owned directly by the State.

♦ stateInvariant : Constraint [0..1]{subsets Namespace::ownedRule} (opposite 
A_stateInvariant_owningState::owningState)
Specifies conditions that are always true when this State is the current State. In ProtocolStateMachines state 
invariants are additional conditions to the preconditions of the outgoing Transitions, and to the postcondition of 
the incoming Transitions.

submachine : StateMachine [0..1] (opposite StateMachine::submachineState)
The StateMachine that is to be inserted in place of the (submachine) State.

14.5.9.7

Operations

•

containingStateMachine() : StateMachine {redefines Vertex::containingStateMachine()}
The query containingStateMachine() returns the StateMachine that contains the State either directly or 
transitively.

body: container.containingStateMachine()

Unified Modeling Language 2.5

353

•

•

•

•

•

•

•

isComposite() : Boolean
A composite State is a State with at least one Region.

body: region->notEmpty()

isConsistentWith(redefiningElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isConsistentWith()}
The query isConsistentWith() specifies that a redefining State is consistent with a redefined State provided that 
the redefining State is an extension of the redefined State. A simple State can be redefined (extended) to 
become a composite State (by adding one or more Regions) and a composite State can be redefined (extended) 
by adding Regions and by adding Vertices, States, and Transitions to inherited Regions. All States may add or 
replace entry, exit, and 'doActivity' Behaviors.

pre: redefiningElement.isRedefinitionContextValid(self)
body: -- the following is merely a default body; it is expected that the specific form of 
this constraint will be specified by profiles
true

isOrthogonal() : Boolean
An orthogonal State is a composite state with at least 2 regions.

body: region->size () > 1

isRedefinitionContextValid(redefinedElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isRedefinitionContextValid()}
The query isRedefinitionContextValid() specifies whether the redefinition contexts of a State are properly 
related to the redefinition contexts of the specified State to allow this element to redefine the other. This means 
that the containing Region of a redefining State must redefine the containing Region of the redefined State.

body: if redefinedElement.oclIsKindOf(State) then
  let redefinedState : State = redefinedElement.oclAsType(State) in
    container.redefinedElement.oclAsType(Region)->exists(r:Region |
      r.subvertex->includes(redefinedState))
else
  false
endif

isSimple() : Boolean
A simple State is a State without any regions.

body: (region->isEmpty()) and not isSubmachineState()

isSubmachineState() : Boolean
Only submachine State references another StateMachine.

body: submachine <> null

redefinitionContext() : Classifier
The redefinition context of a State is the nearest containing StateMachine.

body: let sm : StateMachine = containingStateMachine() in
if sm._'context' = null or sm.general->notEmpty() then
  sm
else
  sm._'context'
endif

354

Unified Modeling Language 2.5

14.5.9.8

Constraints

•

•

•

•

•

entry_or_exit
Only entry or exit Pseudostates can serve as connection points.

inv: connectionPoint->forAll(kind = PseudostateKind::entryPoint or kind = 
PseudostateKind::exitPoint)

submachine_states
Only submachine States can have connection point references.

inv: isSubmachineState implies connection->notEmpty( )

composite_states
Only composite States can have entry or exit Pseudostates defined.

inv: connectionPoint->notEmpty() implies isComposite

destinations_or_sources_of_transitions
The connection point references used as destinations/sources of Transitions associated with a submachine State 
must be defined as entry/exit points in the submachine StateMachine.

inv: self.isSubmachineState implies (self.connection->forAll (cp |
  cp.entry->forAll (ps | ps.stateMachine = self.submachine) and
  cp.exit->forAll (ps | ps.stateMachine = self.submachine)))

submachine_or_regions
A State is not allowed to have both a submachine and Regions.

inv: isComposite implies not isSubmachineState

14.5.10

StateMachine [Class]

14.5.10.1

Description

StateMachines can be used to express event-driven behaviors of parts of a system. Behavior is modeled as a traversal of 
a graph of Vertices interconnected by one or more joined Transition arcs that are triggered by the dispatching of 
successive Event occurrences. During this traversal, the StateMachine may execute a sequence of Behaviors associated 
with various elements of the StateMachine.

14.5.10.2

Diagrams

Behavior State Machines, State Machine Redefinition, Protocol State Machines

14.5.10.3

Generalizations

Behavior

14.5.10.4

Specializations

ProtocolStateMachine

14.5.10.5

Association Ends

•

♦ connectionPoint : Pseudostate [0..*]{subsets Namespace::ownedMember} (opposite 
Pseudostate::stateMachine)

Unified Modeling Language 2.5

355

The connection points defined for this StateMachine. They represent the interface of the StateMachine when 
used as part of submachine State.

•

•

•

extendedStateMachine : StateMachine [0..*]{redefines Behavior::redefinedBehavior} (opposite 
A_extendedStateMachine_stateMachine::stateMachine)
The StateMachines of which this is an extension.

♦ region : Region [1..*]{subsets Namespace::ownedMember} (opposite Region::stateMachine)
The Regions owned directly by the StateMachine.

submachineState : State [0..*] (opposite State::submachine)
References the submachine(s) in case of a submachine State. Multiple machines are referenced in case of a 
concurrent State.

14.5.10.6

Operations

•

•

•

•

LCA(s1 : Vertex, s2 : Vertex) : Region
The operation LCA(s1,s2) returns the Region that is the least common ancestor of Vertices s1 and s2, based on 
the StateMachine containment hierarchy.

body: if ancestor(s1, s2) then
    s2.container
else

if ancestor(s2, s1) then
    s1.container
else
    LCA(s1.container.state, s2.container.state)
endif

endif

ancestor(s1 : Vertex, s2 : Vertex) : Boolean
The query ancestor(s1, s2) checks whether Vertex s2 is an ancestor of Vertex s1.

body: if (s2 = s1) then

true

else

if s1.container.stateMachine->notEmpty() then
    true
else
    if s2.container.stateMachine->notEmpty() then
        false
    else
        ancestor(s1, s2.container.state)
     endif
 endif

endif

isConsistentWith(redefiningElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isConsistentWith()}
The query isConsistentWith() specifies that a redefining StateMachine is consistent with a redefined 
StateMachine provided that the redefining StateMachine is an extension of the redefined StateMachine : 
Regions are inherited and Regions can be added, inherited Regions can be redefined. In case of multiple 
redefining StateMachine, extension implies that the redefining StateMachine gets orthogonal Regions for each 
of the redefined StateMachine.

body: -- the following is merely a default body; it is expected that the specific form of 
this constraint will be specified by profiles
true

isRedefinitionContextValid(redefinedElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isRedefinitionContextValid()}

356

Unified Modeling Language 2.5

The query isRedefinitionContextValid() specifies whether the redefinition context of a StateMachine is 
properly related to the redefinition contexts of the specified StateMachine to allow this element to redefine the 
other. The context Classifier of a redefining StateMachine must redefine the context Classifier of the redefined 
StateMachine.

body: if redefinedElement.oclIsKindOf(StateMachine) then
  let redefinedStateMachine : StateMachine = redefinedElement.oclAsType(StateMachine) in
    self._'context'().oclAsType(BehavioredClassifier).redefinedClassifier->
      includes(redefinedStateMachine._'context'())
else
  false
endif

•

LCAState(v1 : Vertex, v2 : Vertex) : State
This utility function is like the LCA, except that it returns the nearest composite State that contains both input 
Vertices.

body: if v2.oclIsTypeOf(State) and ancestor(v1, v2) then

else if v1.oclIsTypeOf(State) and ancestor(v2, v1) then

v2.oclAsType(State)

v1.oclAsType(State)

else if (v1.container.state->isEmpty() or v2.container.state->isEmpty()) then

null.oclAsType(State)

else LCAState(v1.container.state, v2.container.state)
endif endif endif

14.5.10.7

Constraints

•

•

connection_points
The connection points of a StateMachine are Pseudostates of kind entry point or exit point.

inv: connectionPoint->forAll (kind = PseudostateKind::entryPoint or kind = 
PseudostateKind::exitPoint)

classifier_context
The Classifier context of a StateMachine cannot be an Interface.

inv: _'context' <> null implies not _'context'.oclIsKindOf(Interface)

• method

A StateMachine as the method for a BehavioralFeature cannot have entry/exit connection points.

inv: specification <> null implies connectionPoint->isEmpty()

•

context_classifier
The context Classifier of the method StateMachine of a BehavioralFeature must be the Classifier that owns the 
BehavioralFeature.

inv: specification <> null implies ( _'context' <> null and 
specification.featuringClassifier->exists(c | c = _'context'))

14.5.11

Transition [Class]

14.5.11.1

Description

A Transition represents an arc between exactly one source Vertex and exactly one Target vertex (the source and targets 
may be the same Vertex). It may form part of a compound transition, which takes the StateMachine from one steady 
State configuration to another, representing the full response of the StateMachine to an occurrence of an Event that 
triggered it.

Unified Modeling Language 2.5

357

14.5.11.2

Diagrams

Behavior State Machines, State Machine Redefinition, Protocol State Machines

14.5.11.3

Generalizations

Namespace, RedefinableElement

14.5.11.4

Specializations

ProtocolTransition

14.5.11.5

Attributes

•

kind : TransitionKind [1..1] = external
Indicates the precise type of the Transition.

14.5.11.6

Association Ends

•

•

•

•

•

•

•

•

container : Region [1..1]{subsets NamedElement::namespace} (opposite Region::transition)
Designates the Region that owns this Transition.

♦ effect : Behavior [0..1]{subsets Element::ownedElement} (opposite A_effect_transition::transition)
Specifies an optional behavior to be performed when the Transition fires.

♦ guard : Constraint [0..1]{subsets Namespace::ownedRule} (opposite A_guard_transition::transition)
A guard is a Constraint that provides a fine-grained control over the firing of the Transition. The guard is 
evaluated when an Event occurrence is dispatched by the StateMachine. If the guard is true at that time, the 
Transition may be enabled, otherwise, it is disabled. Guards should be pure expressions without side effects. 
Guard expressions with side effects are ill formed.

redefinedTransition : Transition [0..1]{subsets RedefinableElement::redefinedElement} (opposite 
A_redefinedTransition_transition::transition)
The Transition that is redefined by this Transition.

/redefinitionContext : Classifier [1..1]{redefines RedefinableElement::redefinitionContext} (opposite 
A_redefinitionContext_transition::transition)
References the Classifier in which context this element may be redefined.

source : Vertex [1..1] (opposite Vertex::outgoing)
Designates the originating Vertex (State or Pseudostate) of the Transition.

target : Vertex [1..1] (opposite Vertex::incoming)
Designates the target Vertex that is reached when the Transition is taken.

♦ trigger : Trigger [0..*]{subsets Element::ownedElement} (opposite A_trigger_transition::transition)
Specifies the Triggers that may fire the transition.

14.5.11.7

Operations

•

358

containingStateMachine() : StateMachine
The query containingStateMachine() returns the StateMachine that contains the Transition either directly or 
transitively.

Unified Modeling Language 2.5

•

•

body: container.containingStateMachine()

isConsistentWith(redefiningElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isConsistentWith()}
The query isConsistentWith() specifies that a redefining Transition is consistent with a redefined Transition 
provided that the redefining Transition has the following relation to the redefined Transition: A redefining 
Transition redefines all properties of the corresponding redefined Transition except the source State and the 
Trigger.

pre: redefiningElement.isRedefinitionContextValid(self)
body: -- the following is merely a default body; it is expected that the specific form of 
this constraint will be specified by profiles
true

redefinitionContext() : Classifier
The redefinition context of a Transition is the nearest containing StateMachine.

body: let sm : StateMachine = containingStateMachine() in
if sm._'context' = null or sm.general->notEmpty() then
  sm
else
  sm._'context'
endif

14.5.11.8

Constraints

•

•

•

•

•

•

state_is_external
A Transition with kind external can source any Vertex except entry points.

inv: (kind = TransitionKind::external) implies

not (source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = 

PseudostateKind::entryPoint)

join_segment_guards
A join segment must not have Guards or Triggers.

inv: (target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = 
PseudostateKind::join) implies (guard = null and trigger->isEmpty())

state_is_internal
A Transition with kind internal must have a State as its source, and its source and target must be equal.

inv: (kind = TransitionKind::internal) implies

(source.oclIsKindOf (State) and source = target)

outgoing_pseudostates
Transitions outgoing Pseudostates may not have a Trigger.

inv: source.oclIsKindOf(Pseudostate) and (source.oclAsType(Pseudostate).kind <> 
PseudostateKind::initial) implies trigger->isEmpty()

join_segment_state
A join segment must always originate from a State.

inv: (target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = 
PseudostateKind::join) implies (source.oclIsKindOf(State))

fork_segment_state
A fork segment must always target a State.

Unified Modeling Language 2.5

359

inv: (source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = 
PseudostateKind::fork) implies (target.oclIsKindOf(State))

state_is_local
A Transition with kind local must have a composite State or an entry point as its source.

inv: (kind = TransitionKind::local) implies

((source.oclIsKindOf (State) and source.oclAsType(State).isComposite) or
(source.oclIsKindOf (Pseudostate) and source.oclAsType(Pseudostate).kind = 

PseudostateKind::entryPoint))

initial_transition
An initial Transition at the topmost level Region of a StateMachine that has no Trigger.

inv: (source.oclIsKindOf(Pseudostate) and container.stateMachine->notEmpty()) implies

trigger->isEmpty()

fork_segment_guards
A fork segment must not have Guards or Triggers.

•

•

•

inv: (source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = 
PseudostateKind::fork) implies (guard = null and trigger->isEmpty())

14.5.12

TransitionKind [Enumeration]

14.5.12.1

Description

TransitionKind is an Enumeration type used to differentiate the various kinds of Transitions.

14.5.12.2

Diagrams

• Behavior State Machines

 

 

14.5.12.3

Literals

•

•

•

internal
Implies that the Transition, if triggered, occurs without exiting or entering the source State (i.e., it does not 
cause a state change). This means that the entry or exit condition of the source State will not be invoked. An 
internal Transition can be taken even if the SateMachine is in one or more Regions nested within the associated 
State.

local
Implies that the Transition, if triggered, will not exit the composite (source) State, but it will exit and re-enter 
any state within the composite State that is in the current state configuration.

external
Implies that the Transition, if triggered, will exit the composite (source) State.

14.5.13

Vertex [Abstract Class]

14.5.13.1

Description

A Vertex is an abstraction of a node in a StateMachine graph. It can be the source or destination of any number of 
Transitions.

360

Unified Modeling Language 2.5

14.5.13.2

Diagrams

Behavior State Machines

14.5.13.3

Generalizations

NamedElement

14.5.13.4

Specializations

ConnectionPointReference, Pseudostate, State

14.5.13.5

Association Ends

•

•

•

container : Region [0..1]{subsets NamedElement::namespace} (opposite Region::subvertex)
The Region that contains this Vertex.

/incoming : Transition [0..*]{} (opposite Transition::target)
Specifies the Transitions entering this Vertex.

/outgoing : Transition [0..*]{} (opposite Transition::source)
Specifies the Transitions departing from this Vertex.

14.5.13.6

Operations

•

•

•

•

containingStateMachine() : StateMachine
The operation containingStateMachine() returns the StateMachine in which this Vertex is defined.

body: if container <> null
then
-- the container is a region
   container.containingStateMachine()
else
   if (self.oclIsKindOf(Pseudostate)) and ((self.oclAsType(Pseudostate).kind = 
PseudostateKind::entryPoint) or (self.oclAsType(Pseudostate).kind = 
PseudostateKind::exitPoint)) then
      self.oclAsType(Pseudostate).stateMachine
   else
      if (self.oclIsKindOf(ConnectionPointReference)) then
          self.oclAsType(ConnectionPointReference).state.containingStateMachine() -- no 
other valid cases possible
      else
          null
      endif
   endif
endif

incoming() : Transition [0..*]
Derivation for Vertex::/incoming.

body: Transition.allInstances()->select(target=self)

outgoing() : Transition [0..*]
Derivation for Vertex::/outgoing

body: Transition.allInstances()->select(source=self)

isContainedInState(s : State) : Boolean
This utility operation returns true if the Vertex is contained in the State s (input argument).

Unified Modeling Language 2.5

361

body: if not s.isComposite() or container->isEmpty() then

if container.state = s then

true

container.state.isContainedInState(s)

false

else

else

endif

endif

true

else

else

endif

endif

•

isContainedInRegion(r : Region) : Boolean
This utility query returns true if the Vertex is contained in the Region r (input argument).

body: if (container = r) then

if (r.state->isEmpty()) then

false

container.state.isContainedInRegion(r)

14.6
14.6.1

Association Descriptions
A_conformance_specificMachine [Association]

14.6.1.1

Diagrams

Protocol State Machines

14.6.1.2

Member Ends

•

•

ProtocolStateMachine::conformance
 

 

ProtocolConformance::specificMachine
 

 

14.6.2

14.6.2.1

A_connectionPoint_state [Association]

Diagrams

Behavior State Machines

14.6.2.2

Member Ends

•

•

State::connectionPoint
 
 

Pseudostate::state
 
 

14.6.3

14.6.3.1

A_connectionPoint_stateMachine [Association]

Diagrams

Behavior State Machines

14.6.3.2

Member Ends

•

StateMachine::connectionPoint
 

 

362

Unified Modeling Language 2.5

•

Pseudostate::stateMachine
 

 

14.6.4

14.6.4.1

A_connection_state [Association]

Diagrams

Behavior State Machines

14.6.4.2

Member Ends

•

State::connection
 
 

• ConnectionPointReference::state

 

 

14.6.5

14.6.5.1

A_deferrableTrigger_state [Association]

Diagrams

Behavior State Machines

14.6.5.2

Owned Ends

•

state : State [0..1]{subsets Element::owner} (opposite State::deferrableTrigger)

14.6.6

14.6.6.1

A_doActivity_state [Association]

Diagrams

Behavior State Machines

14.6.6.2

Owned Ends

•

state : State [0..1]{subsets Element::owner} (opposite State::doActivity)

14.6.7

14.6.7.1

A_effect_transition [Association]

Diagrams

Behavior State Machines

14.6.7.2

Owned Ends

•

transition : Transition [0..1]{subsets Element::owner} (opposite Transition::effect)

14.6.8

14.6.8.1

A_entry_connectionPointReference [Association]

Diagrams

Behavior State Machines

14.6.8.2

Owned Ends

•

connectionPointReference : ConnectionPointReference [0..1] (opposite ConnectionPointReference::entry)

Unified Modeling Language 2.5

363

14.6.9

14.6.9.1

A_entry_state [Association]

Diagrams

Behavior State Machines

14.6.9.2

Owned Ends

•

state : State [0..1]{subsets Element::owner} (opposite State::entry)

14.6.10

A_exit_connectionPointReference [Association]

14.6.10.1

Diagrams

Behavior State Machines

14.6.10.2

Owned Ends

•

connectionPointReference : ConnectionPointReference [0..1] (opposite ConnectionPointReference::exit)

14.6.11

A_exit_state [Association]

14.6.11.1

Diagrams

Behavior State Machines

14.6.11.2

Owned Ends

•

state : State [0..1]{subsets Element::owner} (opposite State::exit)

14.6.12

A_extendedRegion_region [Association]

14.6.12.1

Diagrams

State Machine Redefinition

14.6.12.2

Owned Ends

•

region : Region [0..*]{subsets A_redefinedElement_redefinableElement::redefinableElement} (opposite 
Region::extendedRegion)

14.6.13

A_extendedStateMachine_stateMachine [Association]

14.6.13.1

Diagrams

State Machine Redefinition

14.6.13.2

Owned Ends

•

364

stateMachine : StateMachine [0..*]{subsets A_redefinedBehavior_behavior::behavior} (opposite 
StateMachine::extendedStateMachine)

Unified Modeling Language 2.5

14.6.14

A_generalMachine_protocolConformance [Association]

14.6.14.1

Diagrams

Protocol State Machines

14.6.14.2

Owned Ends

•

protocolConformance : ProtocolConformance [0..*]{subsets 
A_target_directedRelationship::directedRelationship} (opposite ProtocolConformance::generalMachine)

14.6.15

A_guard_transition [Association]

14.6.15.1

Diagrams

Behavior State Machines

14.6.15.2

Specializations

A_preCondition_protocolTransition

14.6.15.3

Owned Ends

•

transition : Transition [0..1]{subsets Constraint::context} (opposite Transition::guard)

14.6.16

A_incoming_target_vertex [Association]

14.6.16.1

Diagrams

Behavior State Machines

14.6.16.2

Member Ends

 

• Vertex::incoming
 
•

Transition::target
 
 

14.6.17

A_outgoing_source_vertex [Association]

14.6.17.1

Diagrams

Behavior State Machines

14.6.17.2

Member Ends

 

• Vertex::outgoing
 
•

Transition::source
 
 

14.6.18

A_postCondition_owningTransition [Association]

14.6.18.1

Diagrams

Protocol State Machines

Unified Modeling Language 2.5

365

14.6.18.2

Owned Ends

•

owningTransition : ProtocolTransition [0..1]{subsets Constraint::context} (opposite 
ProtocolTransition::postCondition)

14.6.19

A_preCondition_protocolTransition [Association]

14.6.19.1

Diagrams

Protocol State Machines

14.6.19.2

Generalizations

A_guard_transition

14.6.19.3

Owned Ends

•

protocolTransition : ProtocolTransition [0..1]{redefines A_guard_transition::transition} (opposite 
ProtocolTransition::preCondition)

14.6.20

A_redefinedState_state [Association]

14.6.20.1

Diagrams

State Machine Redefinition

14.6.20.2

Owned Ends

•

state : State [0..*]{subsets A_redefinedElement_redefinableElement::redefinableElement} (opposite 
State::redefinedState)

14.6.21

A_redefinedTransition_transition [Association]

14.6.21.1

Diagrams

State Machine Redefinition

14.6.21.2

Owned Ends

•

transition : Transition [0..*]{subsets A_redefinedElement_redefinableElement::redefinableElement} (opposite 
Transition::redefinedTransition)

14.6.22

A_redefinitionContext_region [Association]

14.6.22.1

Diagrams

State Machine Redefinition

14.6.22.2

Generalizations

A_redefinitionContext_redefinableElement

366

Unified Modeling Language 2.5

14.6.22.3

Owned Ends

•

region : Region [0..*]{subsets A_redefinitionContext_redefinableElement::redefinableElement} (opposite 
Region::redefinitionContext)

14.6.23

A_redefinitionContext_state [Association]

14.6.23.1

Diagrams

State Machine Redefinition

14.6.23.2

Generalizations

A_redefinitionContext_redefinableElement

14.6.23.3

Owned Ends

•

state : State [0..*]{subsets A_redefinitionContext_redefinableElement::redefinableElement} (opposite 
State::redefinitionContext)

14.6.24

A_redefinitionContext_transition [Association]

14.6.24.1

Diagrams

State Machine Redefinition

14.6.24.2

Generalizations

A_redefinitionContext_redefinableElement

14.6.24.3

Owned Ends

•

transition : Transition [0..*]{subsets A_redefinitionContext_redefinableElement::redefinableElement} 
(opposite Transition::redefinitionContext)

14.6.25

A_referred_protocolTransition [Association]

14.6.25.1

Diagrams

Protocol State Machines

14.6.25.2

Owned Ends

•

protocolTransition : ProtocolTransition [0..*] (opposite ProtocolTransition::referred)

14.6.26

A_region_state [Association]

14.6.26.1

Diagrams

Behavior State Machines

14.6.26.2

Member Ends

•

State::region
 
 

Unified Modeling Language 2.5

367

• Region::state
 

 

14.6.27

A_region_stateMachine [Association]

14.6.27.1

Diagrams

Behavior State Machines

14.6.27.2

Member Ends

•

StateMachine::region
 
 
• Region::stateMachine

 

 

14.6.28

A_stateInvariant_owningState [Association]

14.6.28.1

Diagrams

Behavior State Machines

14.6.28.2

Owned Ends

•

owningState : State [0..1]{subsets Constraint::context} (opposite State::stateInvariant)

14.6.29

A_submachineState_submachine [Association]

14.6.29.1

Diagrams

Behavior State Machines

14.6.29.2

Member Ends

•

•

StateMachine::submachineState
 

 

State::submachine
 
 

14.6.30

A_subvertex_container [Association]

14.6.30.1

Diagrams

Behavior State Machines

14.6.30.2

Member Ends

 

• Region::subvertex
 
• Vertex::container

 

 

14.6.31

A_transition_container [Association]

14.6.31.1

Diagrams

Behavior State Machines

368

Unified Modeling Language 2.5

14.6.31.2

Member Ends

 

• Region::transition
 
•

Transition::container
 
 

14.6.32

A_trigger_transition [Association]

14.6.32.1

Diagrams

Behavior State Machines

14.6.32.2

Owned Ends

•

transition : Transition [0..1]{subsets Element::owner} (opposite Transition::trigger)

Unified Modeling Language 2.5

369

15 Activities
Summary
15.1
An Activity is a kind of Behavior (see sub clause 13.2) that is specified as a graph of nodes interconnected by edges. A 
subset of the nodes are executable nodes that embody lower-level steps in the overall Activity. Object nodes hold data 
that is input to and output from executable nodes, and moves across object flow edges. Control nodes specify 
sequencing of executable nodes via control flow edges. Activities are essentially what are commonly called “control and 
data flow” models. Such models of computation are inherently concurrent, as any sequencing of activity node execution 
is modeled explicitly by activity edges, and no ordering is mandated for any computation not explicitly sequenced.
Activities may describe procedural computation, forming hierarchies of Activities invoking other Activities, or, in an 
object-oriented model, they may be invoked indirectly as methods bound to Operations that are directly invoked. 
Activities may be applied to organizational modeling for business process engineering and workflow. In this context, 
events often originate from inside the system, such as the finishing of a task, but also from outside the system, such as a 
customer call. Activities can also be used for information system modeling to specify system level processes.
The remainder of this clause describes how activity models are structured and various kinds of object and control nodes. 
The only kind of executable nodes in UML are Actions, which are fully described in Clause 16. Actions are required for 
any significant capabilities of Activities. Actions invoke other Behaviors and Operations (see above), access and modify 
objects, as well as link them together, and perform more advanced coordination of other Actions (Structured Actions). 
They are central to the “data flow” aspects of Activities, introducing a specialized form of object node (Pins) for object 
flows to get and provide data to Actions. Most of the examples of Activity data flow appear in Clause 16. The concrete 
syntax for Actions is a subset of the concrete syntax for Activities (Action notation only appears in Activity diagrams), 
and some concrete syntax for Actions is specified in this clause. This clause uses executable nodes to provide some 
independence from Actions but must still be read in conjunction with Clause 16.

Activities
Summary

15.2
15.2.1
An Activity is a Behavior specified as sequencing of subordinate units, using a control and data flow model. 
Subordinate behaviors coordinated by these models may be initiated because other behaviors in the model finish 
executing, because objects and data become available or because events occur externally to the flow. The flow of 
execution is modeled as ActivityNodes connected by ActivityEdges. An ExecutableNode can be the execution of a 
subordinate behavior, such as an arithmetic computation, a call to an operation, or manipulation of object contents (see 
Clause 16 on Actions for details). ActivityNodes also include flow-of-control constructs, such as synchronization, 
decision, and concurrency control.
This sub clause describes the basic structure and flow semantics of an activity model as a graph of nodes and edges. 
Subsequent sub clauses then describe the various kinds of ActivityNodes that an Activity may contain and how those 
nodes may be grouped within the Activity.

Unified Modeling Language 2.5

371

15.2.2

Abstract Syntax

Behavior

ConnectableElement

MultiplicityElement

Activity

+ isReadOnly : Boolean = false
+ isSingleExecution : Boolean = false

{subsets namespace}

+ activityScope
0..1

{subsets ownedMember}
+ variable
*

Variable

RedefinableElement

0..1 + activity

0..1

+ activity

{subsets owner}

{subsets owner}

RedefinableElement

+ activityNode

{subsets redefinedElement}

*

ActivityNode

*

*

+ redefinedNode

{subsets redefinableElement}

ValueSpecification

{subsets ownedElement}

+ node

+ target
1

+ source
1

{subsets ownedElement}

+ guard

0..1
0..1
+ weight
{subsets ownedElement}

{subsets ownedElement}

+ edge

*

+ incoming
*

+ outgoing
*

{subsets owner}
+ activityEdge
0..1
0..1
+ activityEdge
{subsets owner}

+ transformation

+ objectFlow

ActivityEdge

{subsets redefinableElement}

+ activityEdge

*

*

+ redefinedEdge
{subsets redefinedElement}

Behavior

0..1
0..1

*

*

ObjectFlow

+ isMulticast : Boolean = false
+ isMultireceive : Boolean = false

ControlFlow

+ selection

+ objectFlow

Figure 15.1  Activities

15.2.3

15.2.3.1

Semantics

Activities

The execution of one ActivityNode within an Activity may affect, and may be affected by, the execution of other 
ActivityNodes in the Activity. Such edges are represented by ActivityEdges that interconnect the ActivityNodes. The 
effect of one ActivityNode on another is specified by the flow of tokens over the ActivityEdges between the 
ActivityNodes.
Tokens are not explicitly modeled in an Activity, but are used for describing the execution of an Activity. An object 
token is a container for a value that flows over ObjectFlow edges (some object tokens can flow over ControlFlow edges, 
as specified by the modeler, see isControlType for ObjectNodes in sub clause 15.4). An object token with no value in it is 
called a null token. A control token affects execution of ActivityNodes, but does not carry any data, and flows only over 
ControlFlow edges. Each token is distinct from any other, even if it contains the same value as another.
ActivityEdges are directed, with tokens flowing from the source ActivityNode to the target ActivityNode. However, 
tokens offered to an ActivityEdge by the source ActivityNode may not immediately flow along the edge. Instead, the 
tokens only move when the offer is accepted by the ActivityEdge, which requires at least the target ActivityNode to 
accept them also, which in turn might depend on acceptance of cascading offers of the same tokens to edges and nodes 
further downstream of the target. As described below, object tokens shall only be accepted by ObjectNodes while control 
tokens shall only be accepted by ExecutableNodes (with a modeler-specified exception for some object tokens accepted 
by ExecutableNodes, see isControlType for ObjectNodes in sub clause 15.4). ControlNodes are used to control the routing 
of offers through a network of ActivityEdges, controlling the flow of accepted tokens.
ActivityNodes and ActivityEdges may be named, however, the nodes and edges of an Activity are not required to have 
unique names within that Activity. This allows, for example, similar nodes within an Activity (such as multiple 
invocations of other Behavior) to be given the same name. Even though an Activity is a Namespace (a Behavior is a 
Class, which is a Classifier, which is a Namespace), and the members of a Namespace are required to be distinguishable 

372

Unified Modeling Language 2.5

(see sub clause 7.4), this constraint does not affect the naming of Activity nodes and edges because the nodes and edges 
of an Activity are ownedElements but not ownedMembers of the Activity.
NOTE. Activities are Classes (see sub clause 13.2) and may support Properties, such as how long the process has been 
executing or how much it costs; Associations specifying links to objects, such as the performer of the execution, who to 
report completion to, or resources being used; Operations for managing execution of their instances, such as starting, 
stopping, aborting, and so on; and StateMachines specifying states of execution such as started, suspended, and so on. 
Profiles may include class libraries with standard Classes that are used as root classes for activities in the user model 
and vendors may define their own libraries, or support user defined features on Activity Classes.

15.2.3.2

Activity Nodes

ActivityNodes are used to model the individual steps in the behavior specified by an Activity.
An ActivityNode is enabled to begin execution when specified conditions are satisfied on the tokens offered to it on 
incoming ActivityEdges; the conditions depend on the kind of node. When an ActivityNode begins execution, tokens are 
accepted from some or all of its incoming ActivityEdges and a token is placed on the node. When a node completes 
execution, a token is removed from the node and tokens are offered to some or all of its outgoing ActivityEdges. The 
actual effect of the node execution depends on the kind of the node, as detailed in subsequent sub clauses.
All restrictions on the relative execution order of two or more ActivityNodes are explicitly constrained by ActivityEdge 
relationships. If two ActivityNodes are not ordered by ActivityEdge relationships (directly or indirectly, e.g., by being 
separately contained in ordered StructuredActivityNodes; see sub clause 16.11), they may execute concurrently.
NOTE. As used here, concurrent execution simply means that there is no required order in which the nodes must be 
executed; a conforming execution of the Activity may execute the nodes sequentially in either order or may execute 
them in parallel.
As an ActivityNode may be the source for multiple ActivityEdges, the same token can be offered to multiple targets. 
However, the same token can only be accepted at one target at a time (unless it is copied, whereupon it is not the same 
token, see ForkNodes in sub clause 15.3 and ExecutableNodes in sub clause 15.5). If a token is offered to multiple 
ActivityNodes at the same time, it shall be accepted by at most one of them, but exactly which one is not completely 
determined by the Activity flow semantics. This means that an Activity model in which non-determinacy occurs may be 
subject to timing issues and race conditions. It is the responsibility of the modeler to avoid such conditions in the 
construction of the Activity model, if they are not desired.
There are three kinds of ActivityNodes:
1 ControlNodes act as “traffic switches” managing the flow of tokens across ActivityEdges. Tokens cannot “rest” at 

ControlNodes (with exceptions for InitialNodes and ForkNodes, see sub clause 15.3).

2 ObjectNodes hold object tokens accepted from incoming ObjectFlows and may subsequently offer them to outgoing 
ObjectFlows (with a modeler-specified exception for ControlFlows, see isControlType for ObjectNodes in sub clause
15.4).

3

ExecutableNodes actually carry out the desired behavior of an Activity. If an ExecutableNode has  incoming 
ControlFlows, then there must be tokens offered on all these flows that it accepts before beginning execution. 
While executing, an ExecutableNode is considered to hold a single control token indicating it is executing. When it 
completes execution, it offers control tokens on all outgoing ControlFlows. All incoming and outgoing ActivityEdges 
of an ExecutableNode must be ControlFlows. (Actions, which are the only kind of ExecutableNode, use special 
attached ObjectNodes called Pins to accept input and produce output object tokens; see Clause 16.)

Each of these kinds of ActivityNodes are described further in subsequent sub clauses.

15.2.3.3

Activity Edges

An ActivityEdge is a directed connection between two ActivityNodes along which tokens may flow, from the source 
ActivityNode to the target ActivityNode.

Unified Modeling Language 2.5

373

Tokens are offered to an ActivityEdge by the source ActivityNode of the edge. Offers propagate through ActivityEdges 
and ControlNodes, according to the rules associated with ActivityEdges (see below) and each kind of ControlNode (see 
sub clause 15.3) until they reach an ObjectNode (for object tokens) or an ExecutableNode (for control tokens and some 
object tokens as specified by modelers, see ObjectNodes in sub clause 15.4). Each kind of ObjectNode (see sub clause
15.4) and ExecutableNode (see sub clause 15.5 and Clause 16 on Actions) has rules for when offered tokens may be 
accepted. If an ObjectNode or ExecutableNode accepts an offered token, then that token flows from its original offering 
ActivityNode to the accepting ActivityNode. As described above, there may be contention between multiple nodes to 
which a token is offered – the concept of offers defines the semantics for managing such contention.
An ActivityEdge may have a guard, which is a ValueSpecification that is evaluated for each token offered to the edge. 
An offer shall only pass along an ActivityEdge if the guard for the edge evaluates to true for the offered token. An 
ActivityEdge without a guard is equivalent to one with a guard that evaluates to true for every token. (Guards are 
commonly used with DecisionNodes, as described in sub clause 15.3, but they are allowed on any ActivityEdge.)
Any number of tokens can pass along an ActivityEdge, in groups at one time, or individually at different times. The 
weight property dictates the minimum number of tokens that must traverse the edge at the same time. It is a 
ValueSpecification that is evaluated every time a new token is offered by the source ActivityNode. It must evaluate to a 
positive LiteralUnlimitedNatural and may be a constant. Once the minimum number of tokens are offered, all the tokens 
offered by the source are offered to the target all at once. The minimum number of tokens must then be accepted before 
any tokens shall traverse the edge. If the ActivityEdge has a guard, the guard must evaluate to true for each token offered 
to the edge that counts towards the minimum. If the guard fails for any of the tokens, and this reduces the number of 
tokens that can be offered to the target to less than the weight, then all the tokens fail to be offered. An unlimited weight 
means that all the tokens offered by the source must be accepted before any of them shall traverse the edge. (This can be 
combined with a JoinNode to take all of the tokens at the source when certain conditions hold; see examples in Figure 
15.21 and Figure 15.59). If a weight is not specified for an ActivityEdge, this is equivalent to specifying a weight of 1.
NOTE. A weaker but simpler alternative to weight is to group information into larger objects so that a single token 
carries all necessary data.
There are two kinds of ActivityEdges:
1 A ControlFlow is an ActivityEdge that only passes control tokens (and some object tokens as specified by 

modelers, see isControlType for ObjectNodes in sub clause 15.4). ControlFlows are used to explicitly sequence 
execution of ActivityNodes, as the target ActivityNode cannot receive a control token and start execution until the 
source ActivityNode completes execution and produces the token.

2 An ObjectFlow is an ActivityEdge that can have object tokens passing along it. ObjectFlows model the flow of 
values between ObjectNodes. Tokens are offered to the target ActivityNode in the same order as they are offered 
from the source. If multiple tokens are offered at the same time, then the tokens are offered in the same order as if 
they had been offered one at a time from the source. If the source is an ObjectNode with an ordering specified, then 
tokens from the source are offered to the ObjectFlow in that order and, consequently, are offered from the 
ObjectFlow to the target in the same order. (See also sub clause 15.4 on the offering of tokens from an ObjectNode.)

Unlike ControlFlows, ObjectFlows also provide additional support for multicast/receive, token selection from 
ObjectNodes and transformation of tokens, as described below.

15.2.3.4

Object Flows

Object tokens pass over ObjectFlows, carrying data through an Activity via their values, or carrying no data (null 
tokens). A null token can still be passed along an ObjectFlow and used like any other token. For example, an Action can 
output a null token to explicitly indicate that it did not produce an optional value, and a downstream DecisionNode (see 
sub clause 15.3) can test for this and branch accordingly.
An ObjectFlow may have a transformation Behavior that has a single input Parameter and a single output Parameter. If a 
transformation Behavior is specified, then the Behavior is invoked for each object token offered to the ObjectFlow, with 
the value in the token passed to the Behavior as input (for a null token, the behavior is invoked but no value is passed). 
The output of the Behavior is put in an object token that is offered to the target ActivityNode instead of the original 
object token. If the output parameter of the Behavior has a multiplicity upper bound greater than 1, and the Behavior 

374

Unified Modeling Language 2.5

produces multiple values, then each value is put in a separate object token, all of which are passed to the target 
ActivityNode (if the output Parameter is ordered, this ordering is preserved in the sequencing of the tokens). If the 
output Parameter has a multiplicity lower bound of 0 and the Behavior produces no value, then a null token is offered to 
the target ActivityNode.
An ObjectFlow may have a selection Behavior that has a single input Parameter and a single output Parameter. The input 
Parameter of the Behavior must be unordered, nonunique and have a multiplicity of 0..* (a “bag”), and the output 
Parameter must have a multiplicity upper bound of 1. If a selection Behavior is specified, then it is used to offer a token 
from a source ObjectNode to the ObjectFlow, rather than using the ObjectNode’s ordering. Whenever a new token is 
offered to the ObjectFlow, or an offer is withdrawn, the selection Behavior is invoked with the values from all the object 
tokens currently being offered to the ObjectFlow passed to the Behavior input Parameter. The selection Behavior should 
then select one of the input values and produce it as output. This output value is put in an object token and passed to the 
target ActivityNode. If the selection Behavior does not produce an output, then a null token is passed to the target 
ActivityNode.
If an ObjectFlow has both a transformation and a selection Behavior, then the transformation Behavior is invoked first when 
a new token is offered to the ObjectFlow and the resulting value is used in the invocation of the selection behavior.
Because a transformation or selection Behavior is used while offering tokens to the target node, it may be run many times 
on the same token before the token is accepted by the target node. This means the Behavior cannot have side effects. It 
shall not modify objects, but transformations may for example, navigate from one object to another, get an attribute 
value from an object, or replace a data value with another.
Multicasting and multireceiving are used in conjunction with ActivityPartitions (see sub clause 15.6) to model flows 
between Behaviors that are the responsibility of objects determined by a publish and subscribe facility. However, the 
particular publish/subscribe semantics used are not specified in this standard. (To support execution, a model must, 
therefore, be refined to specify the particular publish/subscribe facility employed.) This is illustrated in Figure 15.7 in 
sub clause 15.2.5.

15.2.3.5

Variables

ObjectFlows provide the primary means for moving data within an Activity. Variables provide an alternate means for 
passing data indirectly.
During the execution of an Activity, each of the Variables of the Activity may hold one or more values. There are 
Actions to write values to Variables and to subsequently read values from those Variables (as described in sub clause 
16.9). The Variables of an Activity are ownedMembers of the Activity considered as a Namespace, but they are local to 
the Activity and are not visible outside it.
The use of a Variable effectively provides indirect data flow paths from the point at which a value is written to the 
Variable to all the points at which the value is read from the Variable. Because there is no predefined relationship 
between the Actions within an Activity that read from and write to Variables, these actions must be sequenced by 
control flows to prevent race conditions that may occur between Actions that read or write the same Variable.
A Variable is a kind of ConnectableElement (see sub clause 11.2) and, as such, is a TypedElement (see sub clause 7.5). 
Any values held by a Variable must conform to the Type of the Variable.
A Variable is also a MultiplicityElement (see sub clause 7.5). If the upper bound on a Variable is 1, then that Variable 
may only hold a single value. If the upper bound on a Variable is greater than 1, then it may hold multiple values up to 
the maximum number given by the upper bound (or an unbounded number, if the upper bound is “*”). If the lower bound 
on a Variable is anything other than 0, then the Variable should nominally always hold at least as many values as given 
by the lower bound. However, as the only way to write values into a Variable is through Actions within the Activity, it is 
not always possible to enforce such a multiplicity lower bound. (For further discussion of the semantics of Variable 
multiplicity, see the description of the Actions used to read from and write to Variables, in sub clause 16.9.)
NOTE. Variables are introduced to simplify translation of common programming languages into activity models for 
those applications that do not require object flow information to be readily accessible. However, source programs that 
set variables only once can be easily translated to use object flows from the action that determines the values to the 
actions that use them. Source programs that set variables more than once can be translated to object flows by 

Unified Modeling Language 2.5

375

introducing a local object containing properties for the variables, or one object per variable combined with data store 
nodes.

15.2.3.6

Activity Execution

An Activity may have precondition and postcondition Constraints, as inherited from Behavior (see sub clause 13.2). These 
apply globally to all invocations of the Activity. (Actions within an Activity may also have local pre- and 
postconditions, see sub clause 16.2.)
As a Behavior, an Activity may have Parameters (see sub clause 13.2). For each such Parameter, the Activity has a 
corresponding ActivityParameterNode (two in the case of an inout Parameter, one for input and one for output). An 
ActivityParameterNode is an ObjectNode that makes Parameter values accessible within the Activity. (See sub clause
15.4 for a full discussion of ActivityParameterNodes.)
When an Activity is invoked, any values passed to its input Parameters are put in object tokens and placed on the 
corresponding input ActivityParameterNodes for the Activity (if an input parameter has no value, a null token is placed 
on the corresponding ActivityParameterNode). These ActivityParameterNodes then offer their tokens to outgoing 
ActivityEdges.
When an Activity is first invoked, none of its nodes other than input ActivityParameterNodes will initially hold any 
tokens. However, nodes that do not have incoming edges and require no input data to execute are immediately enabled. 
A single control token is placed on each enabled node and they begin executing concurrently. Such nodes include 
ExecutableNodes (see sub clause 15.5) with no incoming ControlFlows and no mandatory input data and InitialNodes 
(see sub clause 15.3).
On each subsequent invocation of the Activity, the isSingleExecution property indicates whether the same execution of the 
Activity handles tokens for all invocations, or a separate execution of the Activity is created for each invocation. For 
example, an Activity that models a manufacturing plant might have a parameter for an order to fill. Each time the 
activity is invoked, a new order enters the flow. As there is only one plant, one execution of the Activity handles all 
orders. This applies even if the Activity is an Operation method (see sub clause 13.2), for example, on each order.
If a single execution of the Activity is used for all invocations, the modeler must consider the interactions between the 
multiple streams of tokens moving through the ActivityNodes and ActivityEdges. Tokens may reach bottlenecks waiting 
for other tokens ahead of them to move downstream, they may overtake each other due to variations in the execution 
time of invoked behaviors, and most importantly, may abort each other with constructs such as ActivityFinalNodes (see 
sub clause 15.3).
If a separate execution of the Activity is used for each invocation (this is the default), tokens from the various 
invocations do not interact. For example, an Activity that is a classifierBehavior is invoked when the Classifier is 
instantiated (see sub clause 13.2), and the modeler will usually want a separate execution of the Activity for each 
instance of the classifier. The same is true for modeling methods in common programming languages, which have 
separate stack frames for each method call.
However, if an Activity has streaming Parameters (see sub clause 13.2), then additional tokens may flow into and out of 
the Activity (via the corresponding ActivityParameterNodes) even during the course of a single execution. This may 
result in the same sorts of token interaction issues that result from using a single execution.
The execution of an Activity with no streaming Parameters completes when it has no nodes executing and no nodes 
enabled for execution, or when it is explicitly terminated using an ActivityFinalNode (see sub clause 15.3). The 
execution of an Activity with streaming input Parameters shall not terminate until the cumulative number of values 
posted to each of those input Parameters (by the invoker of the Activity) is at least equal to the Parameter multiplicity 
lower bound. The execution of an Activity with streaming output Parameters shall not terminate until the cumulative 
number of values posted to each of those output Parameters (by the Activity itself) is at least equal to the Parameter 
multiplicity lower bound.
When the execution of an Activity completes, all ActivityParameterNodes corresponding to non-streaming output 
Parameters shall hold at least as many non-null object tokens as given by the corresponding Parameter multiplicity 
lower bound. The values associated with the object tokens of each output ActivityParameterNode are then passed out of 
the Activity on the corresponding output Parameter and made available to the invoker of the Activity.

376

Unified Modeling Language 2.5

An output Parameter may also be identified as an exception Parameter by having isException=true (see sub clause 9.4). 
An output posted to an exception Parameter precludes outputs from being posted to other output Parameters of a 
Behavior. If an object token arrives at an output ActivityParameterNode associated with an exception Parameter, then 
the execution of the Activity is immediately terminated. The value on the token is then passed to the exception 
Parameter as usual, but any tokens on other output ActivityParameterNodes associated with non-streaming Parameters 
are lost and their values are not passed to the associated Parameters. Values posted to streaming output Parameters 
before the termination of the Activity are not affected.
Use exception Parameters on Activities only if it is desired to abort all flows in the Activity. For example, if the same 
execution of an activity is being used for all its invocations (i.e., isSingleExecution=true), then multiple streams of tokens 
will be flowing through the same Activity. In this case, it is probably not desired to abort all flows just because one 
reaches an exception output. Arrange for separate invocations of the Activity to use separate executions of the Activity 
(i.e., isSingleExecution=false) when employing exception Parameters, so flows from separate executions will not affect 
each other.

15.2.3.7

Activity Generalization

An Activity is a Classifier and, as such, may participate in Generalization relationships. A specialized Activity inherits 
the nodes and edges of its general Activities. ActivityNodes and ActivityEdges are RedefinableElements (see sub clause 
9.2) that may be redefined in a specialized Activity.
An ActivityNode in a specialized Activity that redefines an ActivityNode from a general Activity is considered to 
replace the redefined ActivityNode for any inherited ActivityEdges that had the redefined ActivityNode as a source or 
target. Similarly, an ActivityEdge that redefines an ActivityEdge from a general Activity is considered to replace the 
redefined ActivityEdge for any inherited ActivityNode that had the redefined ActivityEdge as an incoming or outgoing 
edge. If the redefined ActivityEdge is an incoming or outgoing edge for any ActivityNode that is not inherited but is 
itself redefined, then the ActivityEdge is replaced for the redefining ActivityNode.
The effective sets of nodes and edges used in executing a specialized Activity consists of the unions of the inherited 
nodes and edges (which do not include redefined nodes and edges) and any additional nodes and edges defined in the 
specialized Activity (including any redefining nodes and edges). The execution of the specialized Activity then proceeds 
as usual, but using a graph of nodes and edges constructed from the union sets.

Notation

15.2.4
This sub clause specifies a graphical notation for Activities. This notation is optional in that a conforming tool may use 
a textual concrete syntax instead. However, the notation given in this and subsequent notation sub clauses within this 
clause is the only graphical notation for Activities conformant with this specification.
The notation for an Activity is a combination of the notations of the ActivityNodes and ActivityEdges it contains, plus a 
border and name displayed in the upper left corner. ActivityParameterNodes are displayed on the border (see also the 
notation for ActivityParameterNode in sub clause 15.4). Pre- and post-condition constraints, inherited from Behavior, 
are shown as textual expressions with the keywords «precondition» and «postcondition», respectively. The keyword 
«singleExecution» is used for Activities isSingleExecution=true.

Figure 15.2  Activity notation

Unified Modeling Language 2.5

377

The round-cornered border of Figure 15.2 may be replaced with the frame notation described in Annex A. 
ActivityParameterNodes are displayed on the frame. The round-cornered border or frame may also be omitted 
completely, in which case ActivityParameterNodes may appear anywhere on the diagram.
The notation for Classes can be used for diagramming the features of an Activity as shown in Figure 15.3, with the 
keyword «activity». They can be shown in class diagrams with associations.

Figure 15.3  Activity class notation

The notations for ActivityNodes are illustrated below. This notation is discussed in more detail in the following sub 
clauses (and in Clause 16 for Actions).

Figure 15.4  ActivityNode notation

An ActivityEdge (whether a ControlFlow or ObjectFlow) is notated by an open arrowhead line connecting two 
ActivityNodes. If the edge has a name, it is notated near the arrow. Guards are shown as text in square brackets near tail 
of the line.

Figure 15.5  ActivityEdge notation

An ActivityEdge may also be notated using a connector, which is a small circle with the name of the edge in it. This is 
purely notational. It does not affect the underlying model. The circles and lines involved map to a single ActivityEdge in 
the model. Every connector with a given label must be paired with exactly one other with the same label on the same 
Activity diagram. One connector must have exactly one incoming edge and the other exactly one outgoing edge, each 
with the same type of flow, object or control.

Figure 15.6  ActivityEdge connector notation

The weight of an ActivityEdge may be shown in curly braces using the notation:

weight-annotation :: =‘{‘ ‘weight’ ‘=’ value-specification ‘}’

378

Unified Modeling Language 2.5

The weight is a value specification, which may be a constant, that evaluates to a non-zero unlimited natural value. An 
unlimited weight is notated as “*”. (See also the notation for ValueSpecifications in Clause 8.)
An interruptingEdge of an InterruptibleRegion can be notated with a lightning-bolt (see also the alternative notation for 
interruptingEdges in sub clause 15.6).

Figure 15.7  ActivityEdge notation

A control flow is notated by an arrowed line connecting two actions.

Figure 15.8  ControlFlow notation

An object flow is notated by an arrowed line. In Figure 15.9, upper right, the two object flow arrows denote a single 
object flow edge between two pins in the underlying model, as shown in the lower middle of the figure. (See other Pin 
notations in sub clause 16.2. The specific notational variant used shall be preserved when the diagram is interchanged, 
see Annex B.)

Figure 15.9  ObjectFlow notations

A selection Behavior is specified with the keyword «selection» placed in a note symbol and attached to the appropriate 
ObjectFlow symbol as illustrated in the figure below. A transformation Behavior is similarly specified using the 
keyword «transformation». The body of the note symbol may either contain a textual representation of the Behavior 
(e.g., the body of an OpaqueBehavior) or the name of a Behavior that is not represented textually.

Figure 15.10  Specifying selection behavior on an ObjectFlow

To reduce clutter in complex diagrams, Pins may be elided. The names of the Actions can suggest their Pins. Tools may 
support hyperlinking from the ObjectFlow lines to show the data flowing along them, and show a small square above 

Unified Modeling Language 2.5

379

the line to indicate that Pins are elided, as illustrated in the figure below. Any adornments that would normally be near 
the Pin, like effect, can be displayed at the ends of the flow lines.

Figure 15.11  Eliding objects flowing on the edge

Multicast and multireceive are specified by annotating an ObjectFlow with «multicast» or «multireceive», respectively, 
see sub clause 15.2.5 for examples.

Examples

15.2.5
Figure 15.12 illustrates the following kinds of ActivityNodes: ExecutableNodes (e.g., Receive Order, Fill Order), 
ObjectNodes (Invoice), and ControlNodes (the InitialNode before Receive Order, the DecisionNode after Receive 
Order, and the ForkNode and JoinNode around Ship Order, the MergeNode before Close Order and the 
ActivityFinalNode after Close Order).

Figure 15.12  Activity node example (where the arrowed lines are the only non-activity node symbols)

In Figure 15.13, the arrowed line connecting Fill Order to Ship Order is a ControlFlow edge. This means that when the 
Fill Order behavior is completed, control is passed to the Ship Order. Below it, the same ControlFlow is shown with an 
edge name. The one at the bottom left employs connectors, instead of a continuous line. On the upper right, the arrowed 
lines starting from Send Invoice and ending at Make Payment (with the Invoice object node in between) are ObjectFlow 
edges (at least in notation, see discussion of Figure 15.14). This indicates that the flow of Invoice objects goes from 
Send Invoice to Make Payment.

Figure 15.13  ActivityEdge examples

380

Unified Modeling Language 2.5

Both examples in Figure 15.14 indicate that order objects flow from Fill Order to Ship Order. The example on the left 
has two arrowed lines, one from Fill Order and the other to Ship Order. The example on the right has one arrowed line 
starting from a Fill Order OutputPin (an ObjectNode) and ends at a Ship Order InputPin. The underlying model of these 
examples is the same, with one object flow in the model shown as two arrows on the left, assuming the Order rectangle 
on the left does not represent a CentralBufferNode (see sub clause 15.4).

Figure 15.14  ObjectFlow example

The example on the left in Figure 15.15 shows that the Pick Materials activity provides an order along with its 
associated materials for assembly. On the right, the ObjectFlow has been simplified through eliding the ObjectFlow 
details.

Figure 15.15  Eliding objects flowing on the edge

Figure 15.16 illustrates examples of selection and transformation Behaviors. The example on the left indicates that the 
orders are to be shipped based on order priority—and those with the same priority should be filled on a first-in/first-out 
(FIFO) basis. The example on the right indicates that the result of Close Order produces closed order objects, but Send 
Customer Notice requires a customer object. The transformation specifies the invocation of a query operation that takes 
an Order and produces the associated customer object.

Figure 15.16  Specifying selection and transformation Behaviors on an ObjectFlow

Figure 15.18, the Requests for Quote (RFQs) are sent to multiple specific sellers (i.e., is multicast) for a quote response 
by each of the sellers. Some number of sellers then respond by returning their quote response. As multiple responses can 
be received, the edge is labeled for the multiple receive option. Publish/subscribe and other brokered mechanisms can 
be handled using the multicast and multireceive mechanisms.
NOTE. The swimlanes are an important feature for indicating senders and responders.
In Figure 15.17, the object node rectangle Order is linked to a class diagram that further defines the node. The class 
diagram shows that filling an order requires order, line item, and the customer’s trim-and-finish requirements. An Order 
token is the object flowing between the Accept and Fill activities, but linked to other objects. The activity without the 
class diagram provides a simplified view of the process. The link to an associated class diagram is used to show more 
detail.

Unified Modeling Language 2.5

381

Figure 15.17  Linking a class diagram to an object node

Figure 15.18  Specifying multicast and multireceive on the edge

In Figure 15.19, a connector is used to avoid drawing a long edge around one tine of the fork. If a problem is not a 
priority, the token going to the connector is sent to the merge instead of Evaluate Impact. The merge receives its token 
from Register Problem, via the decision, instead of from Revise Plan for priority one problems. This is equivalent to the 
activity shown in Figure 15.20, which has the same abstract syntax representation as Figure 15.19.

Figure 15.19  ActivityEdge connector example

Figure 15.20  Equivalent model

Figure 15.21 illustrates three examples of using the weight property. The Cricket example uses a constant weight to 
indicate that a cricket team cannot be formed until eleven players are present. The Task example uses a non-constant 
weight to indicate that an invoice for a particular job can only be sent when all of its tasks have been completed. The 
bottom example depicts an Activity for placing bids for a proposal, where many such bids can be placed. When the 

382

Unified Modeling Language 2.5

bidding period is over, the Ready to award bid event arrives, then Award Bid receives all the bids at once, and chooses 
one for the award.

Figure 15.21  ActivityEdge weight examples

The definition of Process Order in Figure 15.22 uses the border notation to indicate that it is an Activity with an 
ActivityParameterNode corresponding to a single input Parameter. It has pre- and postconditions on the requested order. 
All invocations of it use the same execution.

Figure 15.22  Example of an activity with input parameter

The diagram in Figure 15.23 is a standard part selection workflow within an airline design process. The Standards 
Engineer ensures that the substeps in Provide Required Part are performed in the order specified and under the 
conditions specified, but doesn’t necessarily perform the steps. Some of the substeps are performed by the Design 
Engineer even though the Standards Engineer is managing the process. The Expert Part Search behavior can result in a 
part found or not. When a part is not found, the Assign Standards Engineer behavior is invoked. Lastly, Specify Part 
Mod Workflow produces values that are instances of Activities representing work to be done. These are passed to 
subsequent actions for scheduling and execution (i.e., Schedule Part Mod Workflow, Execute Part Mod Workflow and 
Research Production Possibility). As Activities are Classes, instances of them can be passed in object tokens and then 
later be executed. This is an example of runtime Activity instantiation and execution.

Unified Modeling Language 2.5

383

Figure 15.23  Part selection workflow example

Figure 15.24 shows an example activity for a process to resolve a trouble ticket.

Figure 15.24  Trouble ticket workflow example

Figure 15.25 is an example of using class notation to show the class features of an activity.

384

Unified Modeling Language 2.5

Figure 15.25  Activity with attributes and operations

Control Nodes
Summary

15.3
15.3.1
A ControlNode is a kind of ActivityNode (see sub clause 15.2.2) used to manage the flow of tokens between other 
nodes in an Activity. This sub clause describes the various concrete kinds of ControlNodes, including InitialNodes, 
FinalNodes, ForkNodes, JoinNodes, MergeNodes, and DecisionNodes.

15.3.2

Abstract Syntax

ActivityNode

ControlNode

InitialNode

FinalNode

ForkNode

JoinNode

MergeNode

DecisionNode

+ isCombineDuplicate : Boolean = true
{subsets owner}
+ joinNode

0..1

+ decisionNode

*
0..1

+ decisionNode

{subsets ownedElement}
+ joinSpec

0..1

+ decisionInputFlow

0..1

0..1 + decisionInput

FlowFinalNode

ActivityFinalNode

ValueSpecification

ObjectFlow

Behavior

Figure 15.26  Control Nodes

15.3.3

15.3.3.1

Semantics

Initial Node

An InitialNode is a ControlNode that acts as a starting point for executing an Activity. An Activity may have more than 
one InitialNode. If an Activity has more than one InitialNode, then invoking the Activity starts multiple concurrent 
control flows, one for each InitialNode. (Additional concurrent flows may begin at input ActivityParameterNodes and 
enabled ExecutableNodes; see sub clauses 15.4.3 and 15.5.3.)
An InitialNode shall not have any incoming ActivityEdges, which means the InitialNodes owned by an Activity will 
always be enabled when the Activity begins execution and a single control token is placed on each such InitialNode 
when Activity execution starts. The outgoing ActivityEdges of an InitialNode must all be ControlFlows. The control 
token placed on an InitialNode is offered concurrently on all outgoing ControlFlows.

Unified Modeling Language 2.5

385

InitialNodes are an exception to the rule that ControlNodes cannot “hold” tokens, but only manage their flow. If the 
token offered by an InitialNode is not immediately accepted, or is otherwise blocked from moving downstream (for 
example by an ActivityEdge guard), then it remains on the InitialNode. (This is semantically equivalent to interposing a 
CentralBufferNode between the InitialNode and its outgoing edges; see sub clause 15.4.3 on the semantics of 
CentralBufferNodes.)

15.3.3.2

Final Nodes

A FinalNode is a ControlNode at which a flow in an Activity stops. A FinalNode shall not have outgoing ActivityEdges. 
A FinalNode accepts all tokens offered to it on its incoming ActivityEdges.
There are two kinds of FinalNode:
1 A FlowFinalNode is a FinalNode that terminates a flow. All tokens accepted by a FlowFinalNode are destroyed. 

This has no effect on other flows in the Activity.

2 An ActivityFinalNode is a FinalNode that stops all flows in an Activity (or StructuredActivityNode, see sub clause 
16.11). A token reaching an ActivityFinalNode owned by an Activity terminates the execution of that Activity. If an 
Activity owns more than one ActivityFinalNode, then the first one to accept a token (if any) terminates the 
execution of the Activity, including the execution of any other ActivityFinalNodes. The termination of Activity 
execution shall destroy all tokens held in any ObjectNodes other than output ActivityParameterNodes and shall 
terminate the execution of any behaviors synchronously called from the Activity. However, the execution of 
Behaviors invoked asynchronously from the Activity shall not be affected. Once the execution of the Activity has 
terminated, the invocation of the Activity completes as described in sub clause 15.2.3.

NOTE. If it is not desired to abort all flows in an Activity, use a FlowFinalNode, not an ActivityFinalNode. For 
example, if the same execution of an Activity is being used for all its invocations (isSingleExecution=true), then multiple 
flows of tokens will be flowing through that one execution. In this case, it is probably not desired to abort all flows just 
because one reaches a FinalNode. Using a FlowFinalNode will simply consume the tokens reaching it without aborting 
other flows. Alternatively, arrange for separate invocations of the Activity to use separate executions 
(isSingleExecution=false), so tokens from separate invocations will not affect each other.

15.3.3.3

Fork Nodes

A ForkNode is a ControlNode that splits a flow into multiple concurrent flows. A ForkNode shall have exactly one 
incoming ActivityEdge, though it may have multiple outgoing ActivityEdges. If the incoming edge is a ControlFlow, then 
all outgoing edges shall be ControlFlows and, if the incoming edge is an ObjectFlow, then all outgoing edges shall be 
ObjectFlows.
Tokens offered to a ForkNode are offered to all outgoing ActivityEdges of the node. If at least one of these offers is 
accepted, the offered tokens are removed from their original source and the acceptor receives a copy of the tokens. Any 
other offer that was not accepted on an outgoing edge due to the failure of the target to accept it remains pending from 
that edge and may be accepted by the target at a later time. These edges effectively accept separate copies of the offered 
tokens, and offers made to the edges shall stand to their targets in the order in which they were accepted by the edge 
(first in, first out). This is an exception to the rule that ActivityEdges cannot “hold” tokens if they are blocked from 
moving downstream. The ActivityEdges going out of ForkNodes continue to hold the tokens they accept until all 
pending offers have been accepted by their targets.
NOTE. Any outgoing ActivityEdges that fail to accept an offer due to the failure of their guard, rather than their target, 
shall not receive copies of those tokens.
NOTE. If guards are used on ActivityEdges outgoing from a ForkNode, the modeler should ensure that no downstream 
JoinNodes depend on the arrival of tokens passing through the guarded edge. If that cannot be avoided, then a 
DecisionNode should be introduced between the ForkNode and the edge with the guard, such that tokens may be 
shunted to the downstream JoinNode if the guard fails. (See also the example in Figure 15.20.)

386

Unified Modeling Language 2.5

15.3.3.4

Join Nodes

A JoinNode is a ControlNode that synchronizes multiple flows. A JoinNode shall have exactly one outgoing 
ActivityEdge but may have multiple incoming ActivityEdges. If any of the incoming edges of a JoinNode are 
ObjectFlows, the outgoing edge shall be an ObjectFlow. Otherwise the outgoing edge shall be a ControlFlow.
Join nodes may have a joinSpec, which is a ValueSpecification that determines the condition under which the join will 
emit a token. If a JoinNode has a joinSpec, then this ValueSpecification is evaluated whenever a new token is offered to 
the JoinNode on any incoming ActivityEdge. This evaluation shall not be interrupted by any new tokens offered during 
the evaluation, nor shall concurrent evaluations be started when new tokens are offered during an evaluation. The 
ValueSpecification shall evaluate to a Boolean value.
If the joinSpec ValueSpecification is given by a textual expression, then the names of the incoming edges may be used to 
denote a Boolean value indicating the presence (true) or absence (false) of an offer from a ControlFlow or to denote the 
value associated with an object token offered from an ObjectFlow (if any). Alternatively, the joinSpec may consist of an 
Expression with the name of a single Boolean operator and no operands specified. In this case, the value of the joinSpec 
shall be given by applying the given operator to Boolean values indicating the presence (true) or absence (false) of 
offers on each incoming edge (with the ordering of the operands not specified).
If a JoinNode does not have a joinSpec, then this is equivalent to a joinSpec Expression with the Boolean operator “and.” 
That is, the implicit default joinSpec condition is that there is at least one token offered on each incoming ActivityEdge.
If the (implicit or explicit) joinSpec of a JoinNode evaluates to true, then tokens are offered on the outgoing ActivityEdge 
of the JoinNode according to the following rules:

1

2

If all the tokens offered on the incoming edges are control tokens, then one control token is offered on the 
outgoing edge.

If some of the tokens offered on the incoming edges are control tokens and others are object tokens, then only 
the object tokens are offered on the outgoing edge. Tokens are offered on the outgoing edge in the same order 
they were offered to the join. If isCombinedDuplicate is true for the JoinNode, then before object tokens are 
offered to the outgoing edge, those containing objects with the same identity are combined into one token.

The above rules apply to all tokens offered to the JoinNode, including multiple tokens offered from the same incoming 
edge.
If any tokens are offered to the outgoing ActivityEdge of a JoinNode, they shall be accepted by the target or rejected for 
traversal over the edge (e.g., due to a failed guard) before any more tokens are offered to the  outgoing edge. If tokens are 
rejected for traversal, they shall no longer be offered to the outgoing edge. A conforming implementation may omit 
unnecessary joinSpec evaluations if the JoinNode is blocked from offering tokens on its outgoing edge.

15.3.3.5

Merge Nodes

A MergeNode is a control node that brings together multiple flows without synchronization. A MergeNode shall have 
exactly one outgoing ActivityEdge but may have multiple incoming ActivityEdges. If the outgoing edge of a MergeNode is 
a ControlFlow, then all incoming edges must be ControlFlows, and, if the outgoing edge is an ObjectFlow, then all 
incoming edges must be ObjectFlows.
All tokens offered on the incoming edges of a MergeNode are offered to the outgoing edge. There is no synchronization 
of flows or joining of tokens.

15.3.3.6

Decision Nodes

A DecisionNode is a ControlNode that chooses between outgoing flows. A DecisionNode shall have at least one and at 
most two incoming ActivityEdges, and at least one outgoing ActivityEdge. If it has two incoming edges, then one shall be 
identified as the decisionInputFlow, the other being called the primary incoming edge. If the DecisionNode has only one 
incoming edge, then it is the primary incoming edge. If the primary incoming edge of a DecisionNode is a ControlFlow, 

Unified Modeling Language 2.5

387

then all outgoing edges shall be ControlFlows and, if the primary incoming edge is an ObjectFlow, then all outgoing edges 
shall be ObjectFlows.
A DecisionNode accepts tokens on its primary incoming edge and offers them to all its outgoing edges. However, each 
token offered on the primary incoming edge shall traverse at most one outgoing edge. Tokens are not duplicated.
If any of the outgoing edges of a DecisionNode have guards, then these are evaluated for each incoming token. The order 
in which guards are evaluated is not defined and may be evaluated concurrently. If the primary incoming edge of a 
DecisionNode is an ObjectFlow, and the DecisionNode does not have a decisionInput or decisionInputFlow, then the value 
contained in an incoming object token may be used in the evaluation of the guards on outgoing ObjectFlows.
If a DecisionNode has a decisionInputFlow, then a token must be offered on both the primary incoming edge and the 
decisionInputFlow before the token from the primary incoming edge is offered to the outgoing edges. If the DecisionNode 
does not have a decisionInput, then the value contained in the object token on the decisionInputFlow is made available to the
guards on each outgoing edge, regardless of whether the primary incoming flow is a ControlFlow or an ObjectFlow.
If a DecisionNode has a decisionInput, then this must be a Behavior with a return Parameter and no other output 
Parameters. This Behavior is invoked for each incoming (control or object) token, and the result returned from the 
Behavior is available in the evaluation of the guards on outgoing edges. A decisionInput shall not have side effects. It shall 
not modify objects, but it may, for example, navigate from one object to another to get an attribute value from an object.
If the primary incoming edge of a DecisionNode is a ControlFlow, and the DecisionNode has a decisionInput but not a 
decisionInputFlow, then the decisionInput shall have no input Parameters. However, if the DecisionNode has both a 
decisionInput and a decisionInputFlow, then the decisionInput shall have a single in Parameter, and the value contained in the 
object token offered on the decisionInputFlow shall be passed via this Parameter when the Behavior is invoked.
If the primary incoming edge of a DecisionNode is an ObjectFlow, and the DecisionNode has a decisionInput but not a 
decisionInputFlow, then the decisionInput shall have an in Parameter and the value contained in an object token offered on 
the primary incoming edge is passed via this Parameter when the Behavior is invoked for the token. However, if the 
DecisionNode has both a decisionInputFlow and a decisionInput, then the decisionInput shall have two in Parameters, with the 
value contained in the object token offered on the primary incoming edge passed via the first Parameter and the value 
contained in the object token offered on the decisionInputFlow passed via the second Parameter when the Behavior is 
invoked.
A token offered on the primary incoming edge of a DecisionNode shall not traverse any outgoing edge for which the 
guard evaluates to false. If there are multiple outgoing edges that either have no guard or that have a guard that evaluates 
to true, then the incoming token shall traverse at most one of these edges. If exactly one target of an unblocked outgoing 
edge accepts the token, then the token traverses the corresponding edge and all other offers are withdrawn. If multiple 
targets accept the token simultaneously, then the token traverses only one of the edges corresponding to the accepting 
targets, but which one is not determined by this specification.
In order to avoid non-deterministic behavior, the modeler should arrange that at most one guard evaluate to true for each 
incoming token. If it can be ensured that only one guard will evaluate to true, a conforming implementation is not 
required to evaluate the guards on all outgoing edges once one has been found to evaluate to true.
For use only with DecisionNodes, a predefined guard “else” (represented as an Expression with “else” as its operator 
and no operands) may be used for at most one outgoing edge. This guard evaluates to true only if the token is not 
accepted by any other outgoing edge from the DecisionNode.

15.3.4

15.3.4.1

Notation

Initial and Final Nodes

InitialNodes are notated as a solid circle, as shown in Figure 15.27.

Figure 15.27  InitialNode notation

388

Unified Modeling Language 2.5

ActivityFinalNodes are notated as a solid circle within a hollow circle, as shown in Figure 15.28. This can be thought of 
as a goal notated as “bull’s eye,” or target. FlowFinalNodes are noted as a circle with an “X” cross inside it.

Figure 15.28  FinalNode notation

15.3.4.2

Fork and Join Nodes

The notation for both ForkNodes and JoinNodes is simply a line segment, as illustrated on the left side of Figure 15.29 
(not necessarily in that orientation).When used, however, a ForkNode must have a single incoming ActivityEdge and 
usually has two or more outgoing ActivityEdges, while a JoinNode usually has two or more incoming ActivityEdges and 
must have a single outgoing ActivityEdge.

Figure 15.29  ForkNode and JoinNode notation

A joinSpec on a JoinNode is shown in an annotation near the JoinNode symbol (see Figure 15.30):

join-spec-annotation ::= ‘{‘ ‘joinSpec’ ‘=’ value-specification ‘}’

See also Clause 8 on the notation for ValueSpecifications.

Figure 15.30  joinSpec notation

The functionality of a JoinNode and a ForkNode can be combined by using the same node symbol, as illustrated in
Figure 15.31. This notation maps to a model containing a JoinNode with all the incoming ActivityEdges shown in the 
diagram and one outgoing ActivityEdge to a ForkNode that has all the outgoing ActivityEdges shown in the diagram.

Figure 15.31  Combined JoinNode/ ForkNode notation

15.3.4.3

Merge Nodes and Decision Nodes

The notation for both MergeNodes and DecisionNodes is a diamond-shaped symbol, as shown on the left side of Figure 
15.32. When used, however, a MergeNode must have two or more incoming ActivityEdges and a single outgoing 
ActivityEdge, while a DecisionNode must have a single incoming ActivityEdge (other than a possible 
decisionInputFlow) and multiple outgoing ActivityEdges.

Unified Modeling Language 2.5

389

Figure 15.32  MergeNode notation

A decisionInput on a DecisionNode is notated in a note symbol attached to the DecisionNode symbol, with the keyword 
«decisionInput», as shown in Figure 15.33. A decisionInputFlow is identified by the keyword «decisionInputFlow» 
annotating that flow.

Figure 15.33  DecisionNode notation

The functionality of a MergeNode and a DecisionNode can be combined by using the same node symbol, as shown in
Figure 15.34. At most one of the incoming flows may be annotated as a decisionInputFlow. This notation maps to a model 
containing a MergeNode with all the incoming edges shown in the diagram and one outgoing edge to a DecisionNode that 
has all the outgoing edges shown in the diagram.

Figure 15.34  Combined MergeNode/DecisionNode notation

15.3.5

15.3.5.1

Examples

Initial Nodes

In Figure 15.35, the InitialNode passes control to the Receive Order ExecutableNode at the start of the execution of an 
Activity.

Figure 15.35  InitialNode example

15.3.5.2

Fork and Join Nodes

In Figure 15.36, the ForkNode passes control to both the Ship Order and Send Invoice nodes when Fill Order is 
completed.

390

Unified Modeling Language 2.5

Figure 15.36  ForkNode example

In Figure 15.37, a JoinNode is used to synchronize the processing of the Ship Order and Send Invoice nodes. Here, 
when both have been completed, control is passed to Close Order.

Figure 15.37  JoinNode example

Figure 15.38 illustrates how a joinSpec can be used to ensure that both a drink is selected and the correct amount of 
money has been inserted before the drink is dispensed. Names of the incoming edges are used in the join specification 
to refer to whether tokens are available on the edges.

Figure 15.38  joinSpec example

15.3.5.3

Merge and Decision Nodes

In Figure 15.39, either one or both of the nodes Buy Item or Make Item could have been executed. As each completes, 
control is passed to Ship Item. That is, if only one of Buy Item or Make Item completes, then Ship Item is executed only 
once; if both complete, Ship Item is executed twice.

Figure 15.39  MergeNode example

Figure 15.40 contains a DecisionNode that follows the Received Order node. The branching is based on whether order 
was rejected or accepted. An order accepted condition results in passing control to Fill Order and an order rejected 
condition results in passing control to Close Order.

Unified Modeling Language 2.5

391

Figure 15.40  DecisionNode example

Figure 15.41 illustrates an order process example. Here, an order item is pulled from stock and prepared for delivery. As 
the item has been removed from inventory, the reorder level should also be checked; and if the actual level falls below a 
pre-specified reorder point, more of the same type of item should be reordered.

Figure 15.41  DecisionNode example with decisionInput

15.3.5.4

Final Nodes

Figure 15.42 depicts that, when the Close Order node is completed, the Activity is terminated. This is indicated by 
passing control to an Activity FinalNode.

Figure 15.42  ActivityFinalNode example

Figure 15.43 is based on an example for an employee expense reimbursement process, illustrating two concurrent flows 
racing to complete. The first one to reach the ActivityFinalNode aborts the other. The two flows appear in the same 
Activity so they can share data, such as who to notify in the case of no action. A ForkNode is used to split the initial 
flow from the InitialNode and begin the two concurrent flows.

Figure 15.43  ActivityFinalNode example

392

Unified Modeling Language 2.5

In Figure 15.44, two ways to reach an ActivityFinalNode exist; but it is the result of exclusive “or” branching, not a 
“race” situation like the example in Figure 15.43. This example uses two Activity FinalNodes, which has the same 
semantics as using one with two incoming edges.
NOTE. Execution of the Notify of Modification node must not take longer than Publish Proposal or Notify of 
Rejection, or an ActivityFinalNode might kill it.

Figure 15.44  ActivityFinalNode example

In Figure 15.45, it is assumed that many components can be built and installed. Here, the Build Component node 
executes iteratively for each component. When the last component is built, the end of the building iteration is indicated 
with a FlowFinalNode. However, even though all component building has come to an end, other nodes are still 
executing (such as Install Component).

Figure 15.45  FlowFinalNode example

Figure 15.46 illustrates both kinds of FinalNode: FlowFinalNode and ActivityFinalNode. This example extends the 
model shown in Figure 15.45. In the extended model, when the last component has been installed, the application is 
delivered. When Deliver Application has completed, control is passed to an ActivityFinalNode—indicating that all 
processing in the Activity is terminated.

Figure 15.46  FlowFinalNode and ActivityFinalNode example

15.3.5.5

Various Control Nodes

Figure 15.47 contains examples of various kinds of ControlNodes. An InitialNode is depicted in the upper left as 
triggering the Receive Order node. A DecisionNode after Received Order illustrates branching based on order rejected 
or order accepted conditions. Fill Order is followed by a ForkNode that passes control both to Send Invoice and Ship 
Order.

Unified Modeling Language 2.5

393

The JoinNode indicates that control will be passed to the MergeNode when both Ship Order and Accept Payment are 
completed. As a MergeNode will just pass the token along, the Close Order node will be executed. (Control is also 
passed to Close Order whenever an order is rejected.) When Close Order is completed, control passes to an 
ActivityFinalNode.

Figure 15.47  ControlNode examples (with accompanying actions and control flows)

Object Nodes
Summary

15.4
15.4.1
An ObjectNode is a kind of ActivityNode (see sub clause 15.2.2) used to hold value-containing object tokens during the 
course of the execution of an Activity. This sub clause describes ObjectNodes in general, as well as three concrete kinds 
of ObjectNodes: ActivityParameterNodes, CentralBufferNodes and DataStoreNodes. A fourth kind of ObjectNode, 
Pins, are always associated with Actions and are described in Clause 16 on Actions (see also sub clause 15.2).

15.4.2

Abstract Syntax

TypedElement

ActivityNode

ObjectNode

+ objectNode

+ isControlType : Boolean = false
+ ordering : ObjectNodeOrderingKind = FIFO

*

+ selection

0..1

Behavior

{subsets owner}
+ objectNode

{subsets ownedElement}

+ upperBound

0..1

+ objectNode

*

ValueSpecification

0..1

+ inState

*

State

ActivityParameterNode

CentralBufferNode

+ activityParameterNode

+ parameter

*

1

Parameter

DataStoreNode

«enumeration»

ObjectNodeOrderingKind
unordered
ordered
LIFO
FIFO

Figure 15.48  Object Nodes

394

Unified Modeling Language 2.5

15.4.3

15.4.3.1

Semantics

Object Nodes

An ObjectNode holds object tokens during the course of the execution of an Activity. Except in the case of an input 
ActivityParameterNode (as discussed further below), the tokens held by an ObjectNode arrive from incoming 
ActivityEdges. Except in the case of an output ActivityParameterNode, tokens held by an ObjectNode may leave the 
node on outgoing ActivityEdges. A token may traverse only one of the outgoing edges. (See the discussion of Object 
Flows in sub clause 15.2.3, and below, for additional rules regarding when tokens may traverse the edges incoming to 
and outgoing from an ObjectNode.)
An ObjectNode may contain multiple object tokens with the same value. Such tokens are not normally combined (but 
see the special semantics for DataStoreNodes below).
ObjectNodes are TypedElements (see sub clause 7.3). If an ObjectNode has a type specified, then any object tokens held 
by the ObjectNode shall have values that conform to the type of the ObjectNode. If no type is specified, then the values 
may be of any type. Null tokens (object tokens without a value) satisfy the type of all object nodes.
ObjectNodes may also specify an inState set of States. If such a set is specified, then any object token held by the 
ObjectNode shall have a value with a type that has or inherits a StateMachine as its classifierBehavior that has all of the 
states in the inState set, and whose instance for the given value shall be in a state configuration containing all of the 
States specified in the inState set (see Clause 14 on the semantics of StateMachines).
An ObjectNode may not contain more tokens than specified by its upperBound, if any. If an ObjectNode has an 
upperBound, then this ValueSpecification shall evaluate to an UnlimitedNatural value. The upperBound is evaluated each 
time a token is offered to or removed from the ObjectNode. If the number of tokens already held by the ObjectNode is 
greater than or equal to the evaluated upperBound, then the ObjectNode shall not accept any further tokens until some of 
the ones it is holding are removed. If the removal of one or more tokens brings the number of tokens held below the 
evaluated upperBound, then the ObjectNode may accept any pending offers up to the limit of the upperBound. If the 
upperBound evaluates to *, then there is no limit on the number of tokens the ObjectNode may hold.
The ordering of an ObjectNode specifies the order in which tokens held by the node are offered to its outgoing 
ActivityEdges. This property has one of the following values:
•

unordered – The order in which tokens held by the ObjectNode are offered to outgoing edges is not defined.

•

•

•

FIFO – Tokens held by the ObjectNode are offered to outgoing edges in the order in which they were accepted by 
the ObjectNode (i.e., “First In First Out”). Tokens do not overtake each other as they pass through the node.

LIFO – Tokens held by the ObjectNode are offered to outgoing edges in the reverse order to which they were 
accepted by the ObjectNode (i.e., “Last In First Out”).

ordered – The ordering is modeler-defined using a selection Behavior (see below).

An ObjectNode shall have a selection Behavior if and only if ordering=ordered. A selection Behavior shall have one input 
Parameter and one output Parameter. The input Parameter must be have multiplicity 0..*, not ordered, and non-unique 
(i.e., a “Bag”), while the output Parameter must have multiplicity 1..1. If the ObjectNode is untyped, then the 
Parameters shall also be untyped. Otherwise, the input Parameter shall have either the same type as or a supertype of the 
ObjectNode, while the output Parameter shall have either the same type or a subtype of the ObjectNode.
The selection Behavior of an ObjectNode is executed whenever a token is to be offered to the outgoing edges of the node. 
The values contained in all the object tokens held by the Object Node are passed as input to the Behavior invocation. 
The Behavior should choose one of these values and return it. An object token containing this value is then offered to 
the outgoing edges of the ObjectNode.
The selection Behavior of an object node is overridden by any selection Behaviors on its outgoing ObjectFlows (see the 
discussion of ObjectFlow selection Behaviors in sub clause 15.2.3).

Unified Modeling Language 2.5

395

Note that tokens overtaking each other due to ordering is independent of the case where each invocation of an Activity is 
handled by a separate execution of the Activity (i.e., isSingleExecution=false). In this case, the tokens in separate 
executions have no interaction with each other, because they flow through separate executions of the Activity (see the 
discussion of Activity Execution in sub clause 15.2.3), but the separate executions can have multiple tokens (due to 
forks or results of executable nodes) that might overtake each other due to ordering.
If isControlType=true for an ObjectNode, ControlFlows may be incoming to and outgoing from the ObjectNode, objects 
tokens can come into or go out of the ObjectNode along ControlFlows, and these tokens can flow along ControlFlows 
reached downstream of the ObjectNode. The values on such object tokens may be used to affect the control of 
ExecutableNodes that are the targets of such ControlFlows, though the specific meaning of such values is not defined in 
this specification (see sub clause 15.5).

15.4.3.2

Activity Parameter Nodes

As a kind of Behavior, an Activity may have Parameters (see sub clause 13.2). When the Activity is invoked, values 
may be passed into the Activity execution on input Parameters (i.e., those with direction in or inout) and values may be 
passed out of the Activity execution on output Parameters (i.e., those with direction inout, out or return).
Within an Activity, inputs to and outputs from an Activity are handled using ActivityParameterNodes. Each 
ActivityParameterNode is associated with one Parameter of the Activity that owns the node. The type of an 
ActivityParameterNode shall be the same as the type of its associated Parameter.
An ActivityParameterNode shall have either all incoming or all outgoing ActivityEdges. An ActivityParameterNode with 
outgoing edges is an input ActivityParameterNode, while an ActivityParameterNode with incoming edges is an output 
ActivityParameterNode. (Note that whether an ActivityParameterNode is for input or output is not determined until at 
least one ActivityEdge is connected to it.)
An Activity shall have one ActivityParameterNode corresponding to each in, out, or return Parameter and two 
ActivityParameterNodes for each inout Parameter. An in Parameter shall not be associated with an output 
ActivityParameterNode and an out or return Parameter shall not be associated with an input ActivityParameterNode 
(though either may be associated with an ActivityParameterNode that does not have any edges connected). An inout 
Parameter shall be associated with at most one input ActivityParameterNode and at most one output 
ActivityParameterNode.
If an input ActivityParameterNode is associated with a non-streaming Parameter, then, when the containing Activity is 
invoked, any values passed on that Parameter are wrapped in object tokens and placed on the ActivityParameterNode at 
the start of the Activity execution. If the Parameter is ordered, the tokens are placed on the ActivityParameterNode in 
the order of the values in the Parameter; otherwise the order is undefined. The ActivityParameterNode then offers the 
tokens to all its outgoing edges.
During the course of the execution of an Activity, object tokens may flow into the output ActivityParameterNodes of the 
Activity. An output ActivityParameterNode accepts all tokens offered to it, which are then placed onto the node. If an 
output ActivityParameterNode is associated with a non-streaming Parameter, then, when the execution of the containing 
Activity completes, the values contained in the object tokens held by the ActivityParameterNode are passed out of the 
execution on the Parameter. If the Parameter is ordered, then the values are ordered corresponding to the  ordering of the 
tokens for the ActivityParameterNode.
If an input ActivityParameterNode is associated with a streaming Parameter, then, whenever a new value is posted to 
the Parameter, that value is wrapped in an object token, placed on the ActivityParameterNode and offered to all 
outgoing edges. If an output ActivityParameterNode is associated with a streaming Parameter, then, whenever a new 
object token is accepted by the ActivityParameterNode, the token is immediately removed from the 
ActivityParameterNode and the value it contains is immediately posted to the Parameter. (See also the description of the 
semantics of streaming Parameters in sub clause 13.2.)

15.4.3.3

Central Buffer Nodes

A CentralBufferNode acts as a buffer between incoming ObjectFlows and outgoing ObjectFlows. It accepts all object 
tokens offered to it on all incoming flows, which are then held by the node. Held object tokens are offered to outgoing 
flows according to the general ordering rules for ObjectNodes. When an offer for a token is accepted by a downstream 

396

Unified Modeling Language 2.5

object node, that token is removed from the CentralBufferNode and moved to the accepting object node, as for any 
object node.

15.4.3.4

Data Store Nodes

A DataStoreNode is a CentralBufferNode that holds its object tokens persistently while its activity is executing.
When an offer for an object token held by a DataStoreNode is accepted by a downstream object node, the offered token 
is removed from the DataStoreNode, per the usual CentralBufferNode semantics. However, a copy is made of the 
removed object token, with the same value, and this is immediately placed back onto the DataStoreNode. Thus, the 
values held by a DataStoreNode appear to persist for the duration of each execution of its containing activity, even as 
tokens move downstream from the node.
When a DataStoreNode accepts an object token, if that token contains an object with the same identity as an object 
contained in a token already held by the node, then the duplicate object token shall not be placed on the DataStoreNode. 
Unlike a regular CentralBufferNode, a DataStoreNode contains objects uniquely.
The selection and transformation Behaviors on outgoing ObjectFlows can be used to get information out of a 
DataStoreNode as if a query were being performed. For example, the selection Behavior can identify an object to retrieve 
and the transformation Behavior can get the value of an attribute on that object. Also, while tokens are always offered on 
the outgoing flows of a DataStoreNode, they can only actually flow when they are accepted by a downstream object 
node. This can be used to model pull semantics for data flow (for instance, see the example in Figure 15.59).

15.4.4

15.4.4.1

Notation

Object Nodes

ObjectNodes are notated as rectangles, as shown in Figure 15.49. A name labeling the node is placed inside the symbol, 
where the name indicates the type of the ObjectNode, or the name and type of the node in the format “name:type.” 
ObjectNodes whose type represents a collection may be labeled as such (as shown in Figure 15.49), though, since UML 
does not define standard collection types, the specific labeling of this form that is allowed is tool specific. An 
ObjectNode with a Signal as its type is shown with the symbol on the right of Figure 15.49.

Figure 15.49  ObjectNode notations

If an ObjectNode has an inState set of States, the names of the States in this set are written as a comma-separated list 
within brackets below the name of the ObjectNode, as shown on the left in Figure 15.50. Values for upperBound, ordering 
and isControlType are notated by placing an annotation with the following form beneath the ObjectNode symbol (as 
shown in Figure 15.50):

object-node-annotation ::= ‘{‘ object-node-property ( ‘,’ object-node-property )* ‘}’
object-node-property ::=  ‘upperBound’ ‘=’ value-specification | 

‘ordering’ ‘=’ object-node-ordering-kind | 
‘controlType’

object-node-ordering-kind ::= ‘unordered’ | ‘ordered’ | ‘FIFO’ | ‘LIFO’

Unified Modeling Language 2.5

397

Figure 15.50  ObjectNode annotations

The selection Behavior of an ObjectNode is specified within a note symbol with the keyword «selection», attached to 
the ObjectNode symbol as illustrated in Figure 15.51.

Figure 15.51  Specifying selection behavior on an ObjectNode

15.4.4.2

Activity Parameter Nodes

An ActivityParameterNode is notated as an ObjectNode, except that the full textual specification of the associated 
Parameter (see sub clause 9.4) may be used to label the ActivityParameterNode instead of the normal name/type label. 
If the containing Activity of the ActivityParameterNode is drawn with a border or frame, then the 
ActivityParameterNode symbol is drawn overlapping the border or frame (see Figure 15.2). If the Activity is drawn 
without a border or frame, then the ActivityParameterNode symbol may be placed anywhere on the diagram (though it 
is clearer if it is placed on the edge of the diagram in a similar location as it would be if a border or frame were present).
Figure 15.52 shows the annotations for an ActivityParameterNode associated with a streaming Parameter or an 
exception Parameter. If the ActivityParameterNode is associated with a streaming Parameter, then the annotation 
“{stream}” is placed close to the node symbol. If the ActivityParameterNode is associated with an exception Parameter, 
then the node symbol is annotated with a small triangle. (See also sub clause 13.2 on the semantics of streaming and 
exception Parameters.)

Figure 15.52  Notation for stream and exception parameters

The presentation option at the top of the Activity diagram below may be used as notation for a model corresponding to 
the notation at the bottom of the diagram.

398

Unified Modeling Language 2.5

Figure 15.53  Presentation option for flows between pins and parameter nodes

15.4.4.3

Central Buffer and Data Store Nodes

A CentralBufferNode symbol may optionally include the keyword «centralBuffer», as shown in Figure 15.54.

Figure 15.54  Optional CentralBufferNode notation

A DataStoreNode is notated as an ObjectNode with the keyword «datastore», as shown in Figure 15.55.

Figure 15.55  DataStoreNode notation

15.4.5

15.4.5.1

Examples

Activity Parameter Nodes

In Figure 15.56, production materials are fed into an Activity modeling the assembly of a computer. At the end of the 
Activity, the assembled computer is quality checked. A rejected computer is an exception.

Figure 15.56  Example of ActivityParameterNodes for regular and exception Parameters

Figure 15.57 shows a single Activity modeling the manufacturing of multiple computers, using streaming input and 
output Parameters. Production materials are streaming in to feed the ongoing printed circuit board fabrication, which 
then feeds the assembly of computers. After computers are assembled, they are quality checked and separated into 
accepted and rejected computers. Note that, in this case, the Rejected Computers output is not an exception Parameter, 

Unified Modeling Language 2.5

399

because a Parameter may not be both streaming and an exception and computers will continue to accumulate in both the 
accepted and rejected output collections without the Activity terminating.

Figure 15.57  Example of ActivityParameterNodes for streaming Parameters

15.4.5.2

Central Buffer and Data Store Nodes

In Figure 15.58, the Behaviors for making parts at two factories produce finished parts. The CentralBufferNode collects 
the parts, and Behaviors after it in the flow use them as needed. All the parts that are not used will be packed as spares, 
and vice versa, because each token can only be drawn from the CentralBufferNode by one outgoing edge. The choice in 
this example is non-deterministic.

Figure 15.58  CentralBufferNode example

Figure 15.59 is an example of using a DataStoreNode. Records for hired employees are persisted in the Personnel 
Database. If an employee has no assignment, then one is made using Assign Employee. Once a year, all employees have 
their performance reviewed. The JoinNode blocks the flow of tokens to Review Employee except when the 
AcceptEventAction (see sub clause 16.10) is triggered “Once a year”. When the AcceptEventAction generates its yearly 
control token, this satisfies the join condition on the JoinNode and, as the outgoing edge from the Personnel Database 
has “{weight=*}”, object tokens for all the persisted employee records can then flow to Review Employee.

Figure 15.59  DataStoreNode example

400

Unified Modeling Language 2.5

Executable Nodes
Summary

15.5
15.5.1
An ExecutableNode is a kind of ActivityNode that may be executed as a step in the overall desired behavior of the 
containing Activity. Generally, the ControlNodes and ObjectNodes in an Activity are largely there to control the 
sequencing and to manage the flow of data between the ExecutableNodes of the Activity.
All concrete kinds of ExecutableNodes are Actions, which are described in Clause 16. This sub clause discusses the 
general semantics of ExecutableNodes within an Activity and the capability for any ExecutableNode to have an 
ExceptionHandler attached to it.

15.5.2

Abstract Syntax

ActivityNode

Element

ExecutableNode

{subsets owner}
+ protectedNode

1

{subsets ownedElement}

+ handler

*

ExceptionHandler

*
+ exceptionHandler

+ exceptionInput
1

ObjectNode

+ handlerBody
1

+ exceptionHandler

*

*

+ exceptionType

+ exceptionHandler

1..*

Classifier

Figure 15.60  Executable Nodes

15.5.3

15.5.3.1

Semantics

Executable Nodes

An ExecutableNode is an ActivityNode that carries out a substantive behavioral step of the Activity that contains it. All 
the incoming and outgoing ActivityEdges of an ExecutableNode shall be ControlFlows. An ExecutableNode may also 
consume and produce data, but it must do so through related ObjectNodes (Actions use Pins for this purpose; see Clause
16.)
An ExecutableNode shall not execute until all incoming ControlFlows (if any) are offering tokens. That is, there is an 
implicit join on the incoming Control Flows. Specific kinds of ExecutableNodes may have additional prerequisites that 
must be satisfied before the node can execute.
Before an ExecutableNode begins executing, it accepts all tokens offered on incoming ControlFlows. If multiple tokens 
are being offered on a ControlFlow, they are all consumed. The effect of object tokens accepted from ControlFlows is 
not specified (see isControlType for ObjectNodes in sub clause 15.4), but the semantics above applies if the effect is to 
execute the ExecutableNode.
While the ExecutableNode is executing, it is considered to hold a single control indicating it is execution. In some 
cases, multiple concurrent executions of an ExecutableNode may be ongoing at one time (see the semantics of 
isLocallyReentrant=true for Actions in sub clause 16.2). In this case, the ExecutableNode holds one control token for each 
concurrent execution.
When an ExecutableNode completes an execution, the control token representing that execution is removed from the 
ExecutableNode and control tokens are offered on all outgoing ControlFlows of the ExecutableNode. That is, there is an 
implicit fork of the flow of control from the ExecutableNode to its outgoing ControlFlows.

Unified Modeling Language 2.5

401

15.5.3.2

Exceptions and Exception Handlers

An exception is a value used to identify a non-normal completion mode of an execution. If an exception is raised (e.g., 
using a RaiseExceptionAction; see sub clause 16.13) within the execution of an ExecutableNode and not handled within 
that execution, then the execution is terminated and the exception is propagated out of the ExecutableNode.
An ExecutableNode may have one or more ExceptionHandlers that are used to deal with exceptions that may be 
propagated out of the ExecutableNode, which is the protectedNode of those handlers. If an exception is propagated out of 
the protectedNode, then the set of handlers is examined for a handler that matches the exception. A handler matches if the 
type of the exception is the same as, or a (direct or indirect) subtype of, one of the exceptionTypes of the handler. If there is 
a match, the handler catches the exception. If there are multiple matches, exactly one handler catches the exception, but it 
is not defined which does.
If an ExceptionHandler catches an exception, the exception is wrapped in an object token that is placed on the 
exceptionInput ObjectNode for the handler. The handlerBody of the ExceptionHandler is then executed. The execution of 
the handlerBody may access the caught exception via the exceptionInput node.
When the handlerBody of an ExceptionHandler completes execution after an exception is caught, control tokens are 
offered on the outgoing ControlFlows of the protectedNode of the ExceptionHandler, in exactly the same way as if the 
protectedNode completed normally. If the protectedNode is an Action with OutputPins, then the handlerBody must also be 
an Action with matching OutputPins, and any tokens placed on the OutputPins of the handlerBody are transferred to the 
OutputPins of the protectedNode (see also sub clause 16.2 on Actions and Pins).
A handlerBody shall have no incoming or outgoing ActivityEdges. An ExecutableNode acting as a handlerBody is not 
enabled to execute in any case other than in response to an exception being caught by its handler.
The handlerBody of an ExceptionHandler shall have the same owner as the protectedNode of the ExceptionHandler and 
shall own the exceptionInput of the ExceptionHandler. The exceptionInput shall either be untyped or have a type that is 
either the same as or a (direct or indirect) generalization of all the exceptionTypes of the ExceptionHandler. Typically, the 
handlerBody will be a StructuredActivityNode and the exceptionInput will be an InputPin for it (see sub clause 16.11 on 
StructuredActivityNodes).
If an ExecutableNode propagates an exception and the node either has no handlers, or no handler matches the propagated 
exception, then the exception continues to propagate outward. If the exception is not caught at all within the execution 
of the containing Activity, then the Activity execution terminates and the exception is propagated out of the Activity. If 
the Activity was invoked synchronously, then the exception is propagated to the caller. If the Activity was invoked 
asynchronously, then the exception is lost and not propagated further.

15.5.4

15.5.4.1

Notation

Executable Nodes

An ExecutableNode is drawn generically as a rectangle with rounded corners, as shown in Figure 15.61. More 
specialized notations for various kinds of Actions are described in Clause 16.

Figure 15.61  ExecutableNode notation

15.5.4.2

Exception Handlers

The notation for ExceptionHandlers is illustrated in Figure 15.62. An ExceptionHandler is shown by drawing a 
“lightning bolt” symbol from the boundary of the protectedNode to a small square on the boundary of the 
ExceptionHandler. The name of the exceptionType is placed next to the lightning bolt. The small square is the 
exceptionInput node. Multiple ExceptionHandlers may be attached to the same protectedNode, each by its own lightning 
bolt.

402

Unified Modeling Language 2.5

Figure 15.62  ExceptionHandler notation

An option for notating an ExceptionHandler is a “zig-zag” adornment on a straight line, as shown in Figure 15.63.

Protected 
Node

HandlerBody 
Node

Figure 15.63  Alternative ExceptionHandler notation

Examples

15.5.5
Figure 15.64 shows a matrix calculation. First a matrix is inverted, and then it is multiplied by a vector to produce a 
vector. If the matrix is singular, the inversion will fail and a SingularMatrix exception is raised. This exception is 
handled by the ExceptionHandler for the exceptionType SingularMatrix, which executes the region containing the 
Substitute Vector1 Action. If an Overflow exception occurs during either the matrix inversion or the vector 
multiplication, the region containing the Substitute Vector2 Action is executed. Regardless of whether the matrix 
operations complete without exception or whether one of the ExceptionHandlers is triggered, the action Print Results is 
executed next.

Figure 15.64  ExceptionHandler example

Activity Groups
Summary

15.6
15.6.1
ActivityGoups are a grouping constructs for ActivityNodes and ActivityEdges. Nodes and edges can belong to more 
than one group. This sub clause describes two concrete kinds of ActivityGroups, ActivityPartitions and 
InterruptibleActivityRegions. StructuredActivityNodes are a third kind of ActivityGroup, but they are also Actions and 
are discussed in sub clause 16.11 of Clause 16 on Actions.

Unified Modeling Language 2.5

403

15.6.2

Abstract Syntax

{subsets inActivity}

+ activity

0..1

Activity

{subsets owner}

{subsets ownedElement}

+ inActivity

+ group

0..1

{readOnly, union, subsets
ownedElement}

+ /subgroup

*

NamedElement

ActivityGroup

Element

+ represents

0..1

+ activityPartition

*

*

0..1

+ /superGroup

{readOnly, union, subsets owner}

{subsets superGroup}

+ superPartition

0..1

*

{subsets group}
+ partition

*

ActivityPartition

+ isDimension : Boolean = false
+ isExternal : Boolean = false

+ subpartition
{subsets subgroup}

*
+ /inGroup
{readOnly, union}

*

+ /inGroup
{readOnly, union}

{readOnly, union}
+ /containedNode

*

{readOnly, union}
+ /containedEdge

*

ActivityNode

ActivityEdge

InterruptibleActivityRegion

{subsets inGroup}
+ inPartition

*

{subsets inGroup}

* + inPartition

{subsets inGroup}
+ inInterruptibleRegion

*

0..1 + interrupts

{subsets containedNode}

{subsets containedNode}

+ node

*

ActivityNode

+ node

*

{subsets containedEdge}

+ edge
*

+ interruptingEdge

ActivityEdge

*

Figure 15.65  ActivityGroups

15.6.3

15.6.3.1

Semantics

Activity Partitions

An ActivityPartition is a kind of ActivityGroup for identifying ActivityNodes that have some characteristics in 
common. ActivityPartitions can share contents. They often correspond to organizational units in a business model. They 
may be used to allocate characteristics or resources among the nodes of an Activity.
ActivityPartitions do not affect the token flow of the model. They constrain and provide a view on the Behaviors 
invoked due to the execution of the containedNodes and containedEdges of the partition, including Operation calls and 
Signal sends. This may be due not only to the execution of explicit InvocationActions (see sub clause 16.3) but also the 
implicit invocation of, e.g., transformation and specification Behaviors. Constraints vary according to the kind of element 
that the partition represents as listed below (These following constraints are normative).
•

Classifier. Behaviors invoked within the partition are the responsibility of instances of the Classifier that the 
partition represents. The context of all invoked Behaviors shall be the Classifier. Operation calls and Signal sends 
within the partition shall target objects at runtime that are instances of the Classifier.

•

404

InstanceSpecification. Behaviors invoked within the partition are the responsibility of the instance modeled by the 
InstanceSpecification that the partition represents. The context of all invoked Behaviors shall be a Classifier of the 
InstanceSpecification. Operation calls and Signal sends within the partition shall target the instances represented 
modeled by the InstanceSpecification.

Unified Modeling Language 2.5

•

Property. Behaviors invoked within the partition are the responsibility of the instance or instances held by the 
Property that the partition represents. The context of all invoked Behaviors shall be the type of the Property. 
Operation calls and Signal sends within the partition shall target an instance held by the Property at runtime. If the 
Property holds more than one value, the invocations are treated as if they were made concurrently on each value 
and the invocation does not complete until all the concurrent instances of it complete.

An ActivityPartition may represent other kinds of Elements than the above, but the semantics for these are not defined 
in this specification.
An ActivityPartition may have subpartitions. If an ActivityPartition has isDimension=true, then it is a dimension partition 
for its subpartitions. Dimension partitions shall not be contained in any other ActivityPartitions. For example, an Activity 
may have one dimension partition for the location at which invoked Behaviors are carried out (represented by each of 
the subpartitions) and another for the cost of performing them.
If an ActivityPartition represents a Property, and its subpartitions represent InstanceSpecifications, then the 
InstanceSpecifications shall model values held by that Property. Behaviors invoked in the subpartitions shall be consistent 
with the constraints required for both the InstanceSpecification of the subpartition and the Property of the containing 
ActivityPartition. For example, a partition may represent the location at which an invoked Behavior is carried out, and 
the subpartitions would represent specific values for that Property, such as Chicago. The location Property might be an 
attribute of the context BehavioredClassifier of the enclosing Activity or even of the Activity itself.
If an ActivityPartition represents a Property that is an attribute of a Classifier (see sub clause 9.2), and is contained by 
another partition, then the superPartition shall represent that Classifier or a Property whose type is that Classifier. All other 
non-external subpartitions in the superPartition shall also represent attributes of the Classifier. At runtime, the targets of 
invocations of Behaviors in the subpartitions shall be the values of the represented attribute of the same instance of the 
Classifier represented by the superPartition, including Operation calls and Signal sends. If the superPartition is a partition of 
an enclosing Activity that has the Classifier as its context, then, at runtime, the context object of the executing Activity 
shall be the same instance of the Classifier represented by the superPartition that are targets of invocations in the 
subpartitions.
If a non-external ActivityPartition represents a Classifier and is contained in another partition, then the superPartition 
shall also represent a Classifier, and the Classifier of the subpartition must be a nestedClassifier or ownedBehavior of the 
Classifier represented by the superPartition or be at the contained end of a composition Association with the Classifier 
represented by the superPartition. If the latter, then, at runtime, the target for invocations of Behaviors in the subpartition, 
including Operation calls and Signal sends, shall be considered to be an instance of the Classifier represented by the 
subpartition that is linked to an instance of the Classifier represented by the superPartition by the composition Association.
An external ActivityPartition is one with isExternal=true. External partitions are intentional exceptions to the rules for 
partition structure. For example, a dimension partition may have partitions showing the parts of a StructuredClassifier. It 
can then have an external partition that does not represent one of the parts, but a completely separate Classifier. In 
business modeling, external partitions can be used to model entities outside a business.
ActivityPartitions may be used in a way that provides enough information for review by high-level modelers, though 
not enough for execution. For example, if a partition represents a Classifier, then Behaviors invoked in that partition are 
the responsibility of instances of the Classifier, but the model may or may not say which instance in particular. Thus, an 
invocation of an Operation would be limited to an Operation on that Classifier, but an input ObjectFlow to the 
invocation might not be specified to tell which instance should be the target at runtime. The ObjectFlow could be 
specified in a later stage of development to support execution. Another option would be to use ActivationPartitions that 
represent parts. Then, when the Activity executes in the context of a particular object, the parts of that object at runtime 
will be used as targets for the Operation calls and Signal sends, as described above.

15.6.3.2

Interruptible Activity Regions

An InterruptibleActivityRegion is an ActivityGroup that supports termination of a portion of an Activity. An 
InterruptibleActivityRegion contains only ActivityNodes. It also identifies as interruptingEdges certain ActivityEdges that 
have their source within the region and their target outside the region. When a token offered along an interruptingEdge is 
accepted and traverses that edge, then the execution of all containedNodes of the region is terminated and all tokens are 
removed from them. However, the token traversing the interruptingEdge still arrives at its target and, further, any accepted 

Unified Modeling Language 2.5

405

tokens traversing non-interrupting edges from a source node within the region to a target node outside the region also 
still arrive at the target nodes, even if the interruption occurs during the traversal.
AcceptEventActions in the region that do not have incoming edges are enabled only when a token enters the region, even 
if the token is not directed at the AcceptEventAction (see sub clause 16.10 for a full description of 
AcceptEventActions).
Do not use an InterruptibleActivityRegion if it is not desired to abort all flows in the region in some cases. For example, 
if a single execution of an Activity is being used for all its invocations (i.e., isSingleExecution=true), then multiple streams 
of tokens will be flowing through the same Activity. In this case, it is probably not desired to abort all flows in a region 
just because one token leaves the region. Arrange for separate invocations of the Activity to use separate executions of 
the Activity (i.e., isSingleExecution=false) when employing InterruptibleActivityRegions, so tokens from different 
invocations will not affect each other.

15.6.4

15.6.4.1

Notation

Activity Partitions

An ActivityPartition is notated with two, usually parallel lines, either horizontal or vertical, and a name labeling the 
partition in a box at one end. Any ActivityNodes and ActivityEdges placed between these lines are considered to be 
contained within the partition. This notation for an ActivityPartition is colloquially known as a swimlane, as shown in
Figure 15.66(a). Swimlanes can express hierarchical partitioning by representing the subpartitions as further partitioning 
of the superpartition, as illustrated in Figure 15.66(b). Diagrams can also be partitioned multidimensionally, as depicted in
Figure 15.66(c), where each “swim cell” is an intersection of multiple partitions. The partitions within each dimension 
may be grouped into an enclosing activity partition with isDimension=true, whose name is the dimension name. Rather 
than being shown as a partition itself, however, the dimension is indicated by placing its name alongside the set of 
partitions in the dimension, as shown in Figure 15.66(c).

Figure 15.66  ActivityPartition notations

In some diagramming situations, using parallel lines to delineate ActivityPartitions is not practical. An alternative is to 
place the partition name in parenthesis above the ActivityNode name, as illustrated in Figure 15.67(a), below. (If it is 
not practical to place the name inside the ActivityNode symbol, such as in the case of a ControlNode, the node name 
and partition name may be placed outside the ActivityNode symbol, but along side it.) A comma-separated list of 
partition names means that the node is contained in more than one partition. A double colon within a partition name 
indicates that the partition is nested, with the superPartitions coming earlier in the name. An external partition (with 
isExternal=true) is labeled with the keyword «external», as illustrated in Figure 15.67(b). If an ActivityNode within a 
non-external swimlane is given a specific external partition name, as shown on the right in Figure 15.67(b), then the 
ActivityNode is considered to be contained in the named external partition, rather than the partition denoted by the 
swimlane.

406

Unified Modeling Language 2.5

Figure 15.67  ActivityPartition notations

When ActivityPartition swimlane notation is combined with the frame notation for Activity (see sub clause 15.2.4), the 
outside edges of the top level partition swimlanes can be merged with the Activity frame.

15.6.4.2

Interruptible Activity Regions

An InterruptibleActivityRegion is notated by a dashed, round-cornered rectangle drawn around the nodes contained by 
the region, as shown in Figure 15.68. An interruptingEdge is notated with a “lightning bolt” ActivityEdge.

Figure 15.68  InterruptableActivityRegion

An alternative option for notating an interruptingEdge is a “zig-zag” adornment on a straight line, as shown in Figure 
15.70.

Figure 15.69  InterruptableActivityRegion alternative notation

15.6.5

15.6.5.1

Examples

Activity Partitions

Figure 15.70 illustrates an example of partitioning an order processing Activity diagram into swimlanes. The top 
partition contains the portion of an Activity for which the Order Department is responsible; the middle partition, the 
Accounting Department, and the bottom the Customer. Accounting Department and Order Department are values of the 
performingDept attribute. Customer, on the other hand, is external to the domain.
NOTE. ActivityEdges that cross between partitions are not contained in any of the subpartitions.

Unified Modeling Language 2.5

407

t

p
e
D
g
n
m
r
o

i

f
r
e
p

t

n
e
m

t
r
a
p
e
D

 
r
e
d
r
O

t

n
e
m

t
r
a
p
e
D
g

 

t
c
c
A

»

l

a
n
r
e

t
x
e
«

r
e
m
o

t
s
u
C

Close
Order

Receive
Order

Fill
Order

[order
accepted]

Send
Invoice

Invoice

Make Payment

Ship
Order

Accept
Payment

Figure 15.70  ActivityPartitions using swimlane notation

Figure 15.71 shows the same partitioning as in Figure 15.70, but using annotated ActivityNodes rather than swimlanes.

Figure 15.71  ActivityPartitions using annotation

Figure 15.71 depicts multidimensional swimlanes. The Receive Order and Fill Order Behaviors are performed by an 
instance of the Order Processor class, situated in Seattle, but not necessarily the same instance for both Behaviors. Even 
though the Make Payment node is contained within the Seattle/Accounting Clerk swim cell, its performer and location 
are not specified by the containing swimlanes, because it has an overriding external partition annotation.

408

Unified Modeling Language 2.5

performingLocation

Seattle

Reno

Receive
Order

Fill
Order

[order
accepted]

Ship
Order

Close
Order

Send
Invoice

«external»
(Customer)
Make Payment

Accept
Payment

Invoice

g
n
i
s
s
e
c
o
r
P
 
r
e
d
r
O

 

k
r
e
l
C
g
n
i
t
n
u
o
c
c
A

Figure 15.72  ActivityPartitions using multidimensional swimlane notation

15.6.5.2

Interruptible Activity Regions

Figure 15.73 illustrates the use of an InterruptibleActivityRegion. When an order cancellation request is made while 
receiving, filling, or shipping orders, that flow is terminated and the Cancel Order node is executed.
NOTE. If this happens after Fill Order is finished, invoicing might have already been initiated (due to the ForkNode 
after Fill Order).
As this flow is outside the InterruptibleActivityRegion, it will not be terminated by an order cancellation request, even 
though Ship Order will be.

Figure 15.73  InterruptableActivityRegion example

15.7
15.7.1

Classifier Descriptions
Activity [Class]

15.7.1.1

Description

An Activity is the specification of parameterized Behavior as the coordinated sequencing of subordinate units.

Unified Modeling Language 2.5

409

15.7.1.2

Diagrams

Activities, Activity Groups, Structured Actions

15.7.1.3

Generalizations

Behavior

15.7.1.4

Attributes

•

•

isReadOnly : Boolean [1..1] = false
If true, this Activity must not make any changes to objects. The default is false (an Activity may make nonlocal 
changes). (This is an assertion, not an executable property. It may be used by an execution engine to optimize 
model execution. If the assertion is violated by the Activity, then the model is ill-formed.)

isSingleExecution : Boolean [1..1] = false
If true, all invocations of the Activity are handled by the same execution.

15.7.1.5

Association Ends

•

•

•

•

•

•

♦ edge : ActivityEdge [0..*]{subsets Element::ownedElement} (opposite ActivityEdge::activity)
ActivityEdges expressing flow between the nodes of the Activity.

♦ group : ActivityGroup [0..*]{subsets Element::ownedElement} (opposite ActivityGroup::inActivity)
Top-level ActivityGroups in the Activity.

♦ node : ActivityNode [0..*]{subsets Element::ownedElement} (opposite ActivityNode::activity)
ActivityNodes coordinated by the Activity.

partition : ActivityPartition [0..*]{subsets Activity::group} (opposite A_partition_activity::activity)
Top-level ActivityPartitions in the Activity.

♦ structuredNode : StructuredActivityNode [0..*]{subsets Activity::group, subsets Activity::node} (opposite 
StructuredActivityNode::activity)
Top-level StructuredActivityNodes in the Activity.

♦ variable : Variable [0..*]{subsets Namespace::ownedMember} (opposite Variable::activityScope)
Top-level Variables defined by the Activity.

15.7.1.6

Constraints

• maximum_one_parameter_node

A Parameter with direction other than inout must have exactly one ActivityParameterNode in an Activity.

inv: ownedParameter->forAll(p |
   p.direction <> ParameterDirectionKind::inout implies node->select(
       oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter = 
p)->size()= 1)

• maximum_two_parameter_nodes

A Parameter with direction inout must have exactly two ActivityParameterNodes in an Activity, at most one 
with incoming ActivityEdges and at most one with outgoing ActivityEdges.

inv: ownedParameter->forAll(p |

410

Unified Modeling Language 2.5

p.direction = ParameterDirectionKind::inout implies
let associatedNodes : Set(ActivityNode) = node->select(
       oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter = 
p) in
  associatedNodes->size()=2 and
  associatedNodes->select(incoming->notEmpty())->size()<=1 and
  associatedNodes->select(outgoing->notEmpty())->size()<=1
)

15.7.2

15.7.2.1

ActivityEdge [Abstract Class]

Description

An ActivityEdge is an abstract class for directed connections between two ActivityNodes.

15.7.2.2

Diagrams

Activities, Activity Groups, Information Flows, Structured Actions

15.7.2.3

Generalizations

RedefinableElement

15.7.2.4

Specializations

ControlFlow, ObjectFlow

15.7.2.5

15.7.2.6

Attributes

Association Ends

•

•

•

•

•

•

•

activity : Activity [0..1]{subsets Element::owner} (opposite Activity::edge)
The Activity containing the ActivityEdge, if it is directly owned by an Activity.

♦ guard : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_guard_activityEdge::activityEdge)
A ValueSpecification that is evaluated to determine if a token can traverse the ActivityEdge. If an ActivityEdge 
has no guard, then there is no restriction on tokens traversing the edge.

/inGroup : ActivityGroup [0..*]{union} (opposite ActivityGroup::containedEdge)
ActivityGroups containing the ActivityEdge.

inPartition : ActivityPartition [0..*]{subsets ActivityEdge::inGroup} (opposite ActivityPartition::edge)
ActivityPartitions containing the ActivityEdge.

inStructuredNode : StructuredActivityNode [0..1]{subsets ActivityEdge::inGroup, subsets Element::owner} 
(opposite StructuredActivityNode::edge)
The StructuredActivityNode containing the ActivityEdge, if it is owned by a StructuredActivityNode.

interrupts : InterruptibleActivityRegion [0..1] (opposite InterruptibleActivityRegion::interruptingEdge)
The InterruptibleActivityRegion for which this ActivityEdge is an interruptingEdge.

redefinedEdge : ActivityEdge [0..*]{subsets RedefinableElement::redefinedElement} (opposite 
A_redefinedEdge_activityEdge::activityEdge)
ActivityEdges from a generalization of the Activity containing this ActivityEdge that are redefined by this 
ActivityEdge.

Unified Modeling Language 2.5

411

•

•

•

source : ActivityNode [1..1] (opposite ActivityNode::outgoing)
The ActivityNode from which tokens are taken when they traverse the ActivityEdge.

target : ActivityNode [1..1] (opposite ActivityNode::incoming)
The ActivityNode to which tokens are put when they traverse the ActivityEdge.

♦ weight : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_weight_activityEdge::activityEdge)
The minimum number of tokens that must traverse the ActivityEdge at the same time. If no weight is specified, 
this is equivalent to specifying a constant value of 1.

15.7.2.7

Operations

•

isConsistentWith(redefiningElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isConsistentWith()}

body: redefiningElement.oclIsKindOf(ActivityEdge)

15.7.2.8

Constraints

•

source_and_target
If an ActivityEdge is directly owned by an Activity, then its source and target must be directly or indirectly 
contained in the same Activity.

inv: activity<>null implies source.containingActivity() = activity and 
target.containingActivity() = activity

15.7.3

15.7.3.1

ActivityFinalNode [Class]

Description

An ActivityFinalNode is a FinalNode that terminates the execution of its owning Activity or StructuredActivityNode.

15.7.3.2

Diagrams

Control Nodes

15.7.3.3

Generalizations

FinalNode

15.7.4

15.7.4.1

ActivityGroup [Abstract Class]

Description

ActivityGroup is an abstract class for defining sets of ActivityNodes and ActivityEdges in an Activity.

15.7.4.2

Diagrams

Activity Groups, Structured Actions

15.7.4.3

Generalizations

NamedElement

412

Unified Modeling Language 2.5

15.7.4.4

Specializations

ActivityPartition, InterruptibleActivityRegion, StructuredActivityNode

15.7.4.5

Association Ends

•

•

•

•

•

/containedEdge : ActivityEdge [0..*]{union} (opposite ActivityEdge::inGroup)
ActivityEdges immediately contained in the ActivityGroup.

/containedNode : ActivityNode [0..*]{union} (opposite ActivityNode::inGroup)
ActivityNodes immediately contained in the ActivityGroup.

inActivity : Activity [0..1]{subsets Element::owner} (opposite Activity::group)
The Activity containing the ActivityGroup, if it is directly owned by an Activity.

♦ /subgroup : ActivityGroup [0..*]{union, subsets Element::ownedElement} (opposite 
ActivityGroup::superGroup)
Other ActivityGroups immediately contained in this ActivityGroup.

/superGroup : ActivityGroup [0..1]{union, subsets Element::owner} (opposite ActivityGroup::subgroup)
The ActivityGroup immediately containing this ActivityGroup, if it is directly owned by another 
ActivityGroup.

15.7.4.6

Operations

•

containingActivity() : Activity [0..1]
The Activity that directly or indirectly contains this ActivityGroup.

body: if superGroup<>null then superGroup.containingActivity()
else inActivity
endif

15.7.4.7

Constraints

•

•

nodes_and_edges
All containedNodes and containedEdges of an ActivityGroup must be in the same Activity as the group.

inv: containedNode->forAll(activity = self.containingActivity()) and
containedEdge->forAll(activity = self.containingActivity())

not_contained
No containedNode or containedEdge of an ActivityGroup may be contained by its subgroups or its 
superGroups, transitively.

inv: subgroup->closure(subgroup).containedNode->excludesAll(containedNode) and
superGroup->closure(superGroup).containedNode->excludesAll(containedNode) and
subgroup->closure(subgroup).containedEdge->excludesAll(containedEdge) and
superGroup->closure(superGroup).containedEdge->excludesAll(containedEdge)

15.7.5

15.7.5.1

ActivityNode [Abstract Class]

Description

ActivityNode is an abstract class for points in the flow of an Activity connected by ActivityEdges.

Unified Modeling Language 2.5

413

15.7.5.2

Diagrams

Object Nodes, Activities, Activity Groups, Control Nodes, Executable Nodes, Structured Actions

15.7.5.3

Generalizations

RedefinableElement

15.7.5.4

Specializations

ControlNode, ExecutableNode, ObjectNode

15.7.5.5

15.7.5.6

Attributes

Association Ends

•

•

•

•

•

•

•

•

activity : Activity [0..1]{subsets Element::owner} (opposite Activity::node)
The Activity containing the ActivityNode, if it is directly owned by an Activity.

/inGroup : ActivityGroup [0..*]{union} (opposite ActivityGroup::containedNode)
ActivityGroups containing the ActivityNode.

inInterruptibleRegion : InterruptibleActivityRegion [0..*]{subsets ActivityNode::inGroup} (opposite 
InterruptibleActivityRegion::node)
InterruptibleActivityRegions containing the ActivityNode.

inPartition : ActivityPartition [0..*]{subsets ActivityNode::inGroup} (opposite ActivityPartition::node)
ActivityPartitions containing the ActivityNode.

inStructuredNode : StructuredActivityNode [0..1]{subsets Element::owner, subsets ActivityNode::inGroup} 
(opposite StructuredActivityNode::node)
The StructuredActivityNode containing the ActvityNode, if it is directly owned by a StructuredActivityNode.

incoming : ActivityEdge [0..*] (opposite ActivityEdge::target)
ActivityEdges that have the ActivityNode as their target.

outgoing : ActivityEdge [0..*] (opposite ActivityEdge::source)
ActivityEdges that have the ActivityNode as their source.

redefinedNode : ActivityNode [0..*]{subsets RedefinableElement::redefinedElement} (opposite 
A_redefinedNode_activityNode::activityNode)
ActivityNodes from a generalization of the Activity containining this ActivityNode that are redefined by this 
ActivityNode.

15.7.5.7

Operations

•

containingActivity() : Activity [0..1]
The Activity that directly or indirectly contains this ActivityNode.

body: if inStructuredNode<>null then inStructuredNode.containingActivity()
else activity
endif

414

Unified Modeling Language 2.5

•

isConsistentWith(redefiningElement : RedefinableElement) : Boolean {redefines 
RedefinableElement::isConsistentWith()}

body: redefiningElement.oclIsKindOf(ActivityNode)

15.7.6

15.7.6.1

ActivityParameterNode [Class]

Description

An ActivityParameterNode is an ObjectNode for accepting values from the input Parameters or providing values to the 
output Parameters of an Activity.

15.7.6.2

Diagrams

Object Nodes

15.7.6.3

Generalizations

ObjectNode

15.7.6.4

Association Ends

•

parameter : Parameter [1..1] (opposite A_parameter_activityParameterNode::activityParameterNode)
The Parameter for which the ActivityParameterNode will be accepting or providing values.

15.7.6.5

Constraints

•

•

•

•

•

no_outgoing_edges
An ActivityParameterNode with no outgoing ActivityEdges and one or more incoming ActivityEdges must 
have a parameter with direction out, inout, or return.

inv: (incoming->notEmpty() and outgoing->isEmpty()) implies

(parameter.direction = ParameterDirectionKind::out or
 parameter.direction = ParameterDirectionKind::inout or
 parameter.direction = ParameterDirectionKind::return)

has_parameters
The parameter of an ActivityParameterNode must be from the containing Activity.

inv: activity.ownedParameter->includes(parameter)

same_type
The type of an ActivityParameterNode is the same as the type of its parameter.

inv: type = parameter.type

no_incoming_edges
An ActivityParameterNode with no incoming ActivityEdges and one or more outgoing ActivityEdges must 
have a parameter with direction in or inout.

inv: (outgoing->notEmpty() and incoming->isEmpty()) implies

(parameter.direction = ParameterDirectionKind::_'in' or
 parameter.direction = ParameterDirectionKind::inout)

no_edges
An ActivityParameterNode may have all incoming ActivityEdges or all outgoing ActivityEdges, but it must not 
have both incoming and outgoing ActivityEdges.

Unified Modeling Language 2.5

415

inv: incoming->isEmpty() or outgoing->isEmpty()

15.7.7

15.7.7.1

ActivityPartition [Class]

Description

An ActivityPartition is a kind of ActivityGroup for identifying ActivityNodes that have some characteristic in common.

15.7.7.2

Diagrams

Activity Groups

15.7.7.3

Generalizations

ActivityGroup

15.7.7.4

Attributes

•

•

isDimension : Boolean [1..1] = false
Indicates whether the ActivityPartition groups other ActivityPartitions along a dimension.

isExternal : Boolean [1..1] = false
Indicates whether the ActivityPartition represents an entity to which the partitioning structure does not apply.

15.7.7.5

Association Ends

•

•

•

•

•

edge : ActivityEdge [0..*]{subsets ActivityGroup::containedEdge} (opposite ActivityEdge::inPartition)
ActivityEdges immediately contained in the ActivityPartition.

node : ActivityNode [0..*]{subsets ActivityGroup::containedNode} (opposite ActivityNode::inPartition)
ActivityNodes immediately contained in the ActivityPartition.

represents : Element [0..1] (opposite A_represents_activityPartition::activityPartition)
An Element represented by the functionality modeled within the ActivityPartition.

♦ subpartition : ActivityPartition [0..*]{subsets ActivityGroup::subgroup} (opposite 
ActivityPartition::superPartition)
Other ActivityPartitions immediately contained in this ActivityPartition (as its subgroups).

superPartition : ActivityPartition [0..1]{subsets ActivityGroup::superGroup} (opposite 
ActivityPartition::subpartition)
Other ActivityPartitions immediately containing this ActivityPartition (as its superGroups).

15.7.7.6

Constraints

•

represents_classifier
If a non-external ActivityPartition represents a Classifier and has a superPartition, then the superPartition must 
represent a Classifier, and the Classifier of the subpartition must be nested (nestedClassifier or 
ownedBehavior) in the Classifier represented by the superPartition, or be at the contained end of a composition 
Association with the Classifier represented by the superPartition.

inv: (not isExternal and represents.oclIsKindOf(Classifier) and superPartition->notEmpty()) 
implies
(
   let representedClassifier : Classifier = represents.oclAsType(Classifier) in

416

Unified Modeling Language 2.5

     superPartition.represents.oclIsKindOf(Classifier) and
      let representedSuperClassifier : Classifier = 
superPartition.represents.oclAsType(Classifier) in
       (representedSuperClassifier.oclIsKindOf(BehavioredClassifier) and 
representedClassifier.oclIsKindOf(Behavior) and
        representedSuperClassifier.oclAsType(BehavioredClassifier).ownedBehavior-
>includes(representedClassifier.oclAsType(Behavior)))
       or
       (representedSuperClassifier.oclIsKindOf(Class) and  
representedSuperClassifier.oclAsType(Class).nestedClassifier-
>includes(representedClassifier))
       or
       (Association.allInstances()->exists(a | a.memberEnd->exists(end1 | end1.isComposite 
and end1.type = representedClassifier and
                                                                      a.memberEnd-
>exists(end2 | end1<>end2 and end2.type = representedSuperClassifier))))
)

represents_property_and_is_contained
If an ActivityPartition represents a Property and has a superPartition, then the Property must be of a Classifier 
represented by the superPartition, or of a Classifier that is the type of a Property represented by the 
superPartition.

inv: (represents.oclIsKindOf(Property) and superPartition->notEmpty()) implies
(
  (superPartition.represents.oclIsKindOf(Classifier) and represents.owner = 
superPartition.represents) or
  (superPartition.represents.oclIsKindOf(Property) and represents.owner = 
superPartition.represents.oclAsType(Property).type)
)

represents_property
If an ActivityPartition represents a Property and has a superPartition representing a Classifier, then all the other 
non-external subpartitions of the superPartition must represent Properties directly owned by the same 
Classifier.

inv: (represents.oclIsKindOf(Property) and superPartition->notEmpty() and 
superPartition.represents.oclIsKindOf(Classifier)) implies
(
  let representedClassifier : Classifier = superPartition.represents.oclAsType(Classifier)
  in
    superPartition.subpartition->reject(isExternal)->forAll(p |
       p.represents.oclIsKindOf(Property) and p.owner=representedClassifier)
)

dimension_not_contained
An ActvivityPartition with isDimension = true may not be contained by another ActivityPartition.

•

•

•

inv: isDimension implies superPartition->isEmpty()

15.7.8

15.7.8.1

CentralBufferNode [Class]

Description

A CentralBufferNode is an ObjectNode for managing flows from multiple sources and targets.

15.7.8.2

Diagrams

Object Nodes

15.7.8.3

Generalizations

ObjectNode

Unified Modeling Language 2.5

417

15.7.8.4

Specializations

DataStoreNode

15.7.9

15.7.9.1

ControlFlow [Class]

Description

A ControlFlow is an ActivityEdge traversed by control tokens or object tokens of control type, which are use to control 
the execution of ExecutableNodes.

15.7.9.2

Diagrams

Activities

15.7.9.3

Generalizations

ActivityEdge

15.7.9.4

Constraints

•

object_nodes
ControlFlows may not have ObjectNodes at either end, except for ObjectNodes with control type.

inv: (source.oclIsKindOf(ObjectNode) implies source.oclAsType(ObjectNode).isControlType) and
(target.oclIsKindOf(ObjectNode) implies target.oclAsType(ObjectNode).isControlType)

15.7.10

ControlNode [Abstract Class]

15.7.10.1

Description

A ControlNode is an abstract ActivityNode that coordinates flows in an Activity.

15.7.10.2

Diagrams

Control Nodes

15.7.10.3

Generalizations

ActivityNode

15.7.10.4

Specializations

DecisionNode, FinalNode, ForkNode, InitialNode, JoinNode, MergeNode

15.7.11

DataStoreNode [Class]

15.7.11.1

Description

A DataStoreNode is a CentralBufferNode for persistent data.

15.7.11.2

Diagrams

Object Nodes

15.7.11.3

Generalizations

CentralBufferNode

418

Unified Modeling Language 2.5

15.7.12

DecisionNode [Class]

15.7.12.1

Description

A DecisionNode is a ControlNode that chooses between outgoing ActivityEdges for the routing of tokens.

15.7.12.2

Diagrams

Control Nodes

15.7.12.3

Generalizations

ControlNode

15.7.12.4

Association Ends

•

•

decisionInput : Behavior [0..1] (opposite A_decisionInput_decisionNode::decisionNode)
A Behavior that is executed to provide an input to guard ValueSpecifications on ActivityEdges outgoing from 
the DecisionNode.

decisionInputFlow : ObjectFlow [0..1] (opposite A_decisionInputFlow_decisionNode::decisionNode)
An additional ActivityEdge incoming to the DecisionNode that provides a decision input value for the guards 
ValueSpecifications on ActivityEdges outgoing from the DecisionNode.

15.7.12.5

Constraints

•

•

•

•

zero_input_parameters
If the DecisionNode has no decisionInputFlow and an incoming ControlFlow, then any decisionInput Behavior 
has no in parameters.

inv: (decisionInput<>null and decisionInputFlow=null and incoming-
>exists(oclIsKindOf(ControlFlow))) implies
   decisionInput.inputParameters()->isEmpty()

edges
The ActivityEdges incoming to and outgoing from a DecisionNode, other than the decisionInputFlow (if any), 
must be either all ObjectFlows or all ControlFlows.

inv: let allEdges: Set(ActivityEdge) = incoming->union(outgoing) in
let allRelevantEdges: Set(ActivityEdge) = if decisionInputFlow->notEmpty() then allEdges-
>excluding(decisionInputFlow) else allEdges endif in
allRelevantEdges->forAll(oclIsKindOf(ControlFlow)) or allRelevantEdges-
>forAll(oclIsKindOf(ObjectFlow))

decision_input_flow_incoming
The decisionInputFlow of a DecisionNode must be an incoming ActivityEdge of the DecisionNode.

inv: incoming->includes(decisionInputFlow)

two_input_parameters
If the DecisionNode has a decisionInputFlow and a second incoming ObjectFlow, then any decisionInput has 
two in Parameters, the first of which has a type that is the same as or a supertype of the type of object tokens 
offered on the non-decisionInputFlow and the second of which has a type that is the same as or a supertype of 
the type of object tokens offered on the decisionInputFlow.

inv: (decisionInput<>null and decisionInputFlow<>null and incoming-
>forAll(oclIsKindOf(ObjectFlow))) implies

decisionInput.inputParameters()->size()=2

Unified Modeling Language 2.5

419

•

•

•

•

incoming_outgoing_edges
A DecisionNode has one or two incoming ActivityEdges and at least one outgoing ActivityEdge.

inv: (incoming->size() = 1 or incoming->size() = 2) and outgoing->size() > 0

incoming_control_one_input_parameter
If the DecisionNode has a decisionInputFlow and an incoming ControlFlow, then any decisionInput Behavior 
has one in Parameter whose type is the same as or a supertype of the type of object tokens offered on the 
decisionInputFlow.

inv: (decisionInput<>null and decisionInputFlow<>null and incoming-
>exists(oclIsKindOf(ControlFlow))) implies

decisionInput.inputParameters()->size()=1

parameters
A decisionInput Behavior has no out parameters, no inout parameters, and one return parameter.

inv: decisionInput<>null implies
  (decisionInput.ownedParameter->forAll(par |
     par.direction <> ParameterDirectionKind::out and
     par.direction <> ParameterDirectionKind::inout ) and
   decisionInput.ownedParameter->one(par |
     par.direction <> ParameterDirectionKind::return))

incoming_object_one_input_parameter
If the DecisionNode has no decisionInputFlow and an incoming ObjectFlow, then any decisionInput Behavior 
has one in Parameter whose type is the same as or a supertype of the type of object tokens offered on the 
incoming ObjectFlow.

inv: (decisionInput<>null and decisionInputFlow=null and incoming-
>forAll(oclIsKindOf(ObjectFlow))) implies

decisionInput.inputParameters()->size()=1

15.7.13

ExceptionHandler [Class]

15.7.13.1

Description

An ExceptionHandler is an Element that specifies a handlerBody ExecutableNode to execute in case the specified 
exception occurs during the execution of the protected ExecutableNode.

15.7.13.2

Diagrams

Executable Nodes

15.7.13.3

Generalizations

Element

15.7.13.4

Association Ends

•

•

420

exceptionInput : ObjectNode [1..1] (opposite A_exceptionInput_exceptionHandler::exceptionHandler)
An ObjectNode within the handlerBody. When the ExceptionHandler catches an exception, the exception 
token is placed on this ObjectNode, causing the handlerBody to execute.

exceptionType : Classifier [1..*] (opposite A_exceptionType_exceptionHandler::exceptionHandler)
The Classifiers whose instances the ExceptionHandler catches as exceptions. If an exception occurs whose 
type is any exceptionType, the ExceptionHandler catches the exception and executes the handlerBody.

Unified Modeling Language 2.5

•

•

handlerBody : ExecutableNode [1..1] (opposite A_handlerBody_exceptionHandler::exceptionHandler)
An ExecutableNode that is executed if the ExceptionHandler catches an exception.

protectedNode : ExecutableNode [1..1]{subsets Element::owner} (opposite ExecutableNode::handler)
The ExecutableNode protected by the ExceptionHandler. If an exception propagates out of the protectedNode 
and has a type matching one of the exceptionTypes, then it is caught by this ExceptionHandler.

15.7.13.5

Constraints

•

•

•

•

•

•

handler_body_edges
The handlerBody has no incoming or outgoing ActivityEdges and the exceptionInput has no incoming 
ActivityEdges.

inv: handlerBody.incoming->isEmpty() and handlerBody.outgoing->isEmpty() and 
exceptionInput.incoming->isEmpty()

output_pins
If the protectedNode is an Action with OutputPins, then the handlerBody must also be an Action with the same 
number of OutputPins, which are compatible in type, ordering, and multiplicity to those of the protectedNode.

inv: (protectedNode.oclIsKindOf(Action) and protectedNode.oclAsType(Action).output-
>notEmpty()) implies
(
  handlerBody.oclIsKindOf(Action) and
  let protectedNodeOutput : OrderedSet(OutputPin) = protectedNode.oclAsType(Action).output,
        handlerBodyOutput : OrderedSet(OutputPin) =  handlerBody.oclAsType(Action).output in
    protectedNodeOutput->size() = handlerBodyOutput->size() and
    Sequence{1..protectedNodeOutput->size()}->forAll(i |
    
    
    
)

handlerBodyOutput->at(i).type.conformsTo(protectedNodeOutput->at(i).type) and
handlerBodyOutput->at(i).isOrdered=protectedNodeOutput->at(i).isOrdered and
handlerBodyOutput->at(i).compatibleWith(protectedNodeOutput->at(i)))

one_input
The handlerBody is an Action with one InputPin, and that InputPin is the same as the exceptionInput.

inv: handlerBody.oclIsKindOf(Action) and
let inputs: OrderedSet(InputPin) = handlerBody.oclAsType(Action).input in
inputs->size()=1 and inputs->first()=exceptionInput

edge_source_target
An ActivityEdge that has a source within the handlerBody of an ExceptionHandler must have its target in the 
handlerBody also, and vice versa.

inv: let nodes:Set(ActivityNode) = handlerBody.oclAsType(Action).allOwnedNodes() in
nodes.outgoing->forAll(nodes->includes(target)) and
nodes.incoming->forAll(nodes->includes(source))

handler_body_owner
The handlerBody must have the same owner as the protectedNode.

inv: handlerBody.owner=protectedNode.owner

exception_input_type
The exceptionInput must either have no type or every exceptionType must conform to the exceptionInput type.

inv: exceptionInput.type=null or
exceptionType->forAll(conformsTo(exceptionInput.type.oclAsType(Classifier)))

Unified Modeling Language 2.5

421

15.7.14

ExecutableNode [Abstract Class]

15.7.14.1

Description

An ExecutableNode is an abstract class for ActivityNodes whose execution may be controlled using ControlFlows and 
to which ExceptionHandlers may be attached.

15.7.14.2

Diagrams

Executable Nodes, Actions, Structured Actions

15.7.14.3

Generalizations

ActivityNode

15.7.14.4

Specializations

Action

15.7.14.5

Association Ends

•

♦ handler : ExceptionHandler [0..*]{subsets Element::ownedElement} (opposite 
ExceptionHandler::protectedNode)
A set of ExceptionHandlers that are examined if an exception propagates out of the ExceptionNode.

15.7.15

FinalNode [Abstract Class]

15.7.15.1

Description

A FinalNode is an abstract ControlNode at which a flow in an Activity stops.

15.7.15.2

Diagrams

Control Nodes

15.7.15.3

Generalizations

ControlNode

15.7.15.4

Specializations

ActivityFinalNode, FlowFinalNode

15.7.15.5

Constraints

•

no_outgoing_edges
A FinalNode has no outgoing ActivityEdges.

inv: outgoing->isEmpty()

15.7.16

FlowFinalNode [Class]

15.7.16.1

Description

A FlowFinalNode is a FinalNode that terminates a flow by consuming the tokens offered to it.

422

Unified Modeling Language 2.5

15.7.16.2

Diagrams

Control Nodes

15.7.16.3

Generalizations

FinalNode

15.7.17

ForkNode [Class]

15.7.17.1

Description

A ForkNode is a ControlNode that splits a flow into multiple concurrent flows.

15.7.17.2

Diagrams

Control Nodes

15.7.17.3

Generalizations

ControlNode

15.7.17.4

Constraints

•

•

edges
The ActivityEdges incoming to and outgoing from a ForkNode must be either all ObjectFlows or all 
ControlFlows.

inv: let allEdges : Set(ActivityEdge) = incoming->union(outgoing) in
allEdges->forAll(oclIsKindOf(ControlFlow)) or allEdges->forAll(oclIsKindOf(ObjectFlow))

one_incoming_edge
A ForkNode has one incoming ActivityEdge.

inv: incoming->size()=1

15.7.18

InitialNode [Class]

15.7.18.1

Description

An InitialNode is a ControlNode that offers a single control token when initially enabled.

15.7.18.2

Diagrams

Control Nodes

15.7.18.3

Generalizations

ControlNode

15.7.18.4

Constraints

•

no_incoming_edges
An InitialNode has no incoming ActivityEdges.

inv: incoming->isEmpty()

Unified Modeling Language 2.5

423

•

control_edges
All the outgoing ActivityEdges from an InitialNode must be ControlFlows.

inv: outgoing->forAll(oclIsKindOf(ControlFlow))

15.7.19

InterruptibleActivityRegion [Class]

15.7.19.1

Description

An InterruptibleActivityRegion is an ActivityGroup that supports the termination of tokens flowing in the portions of an 
activity within it.

15.7.19.2

Diagrams

Activity Groups

15.7.19.3

Generalizations

ActivityGroup

15.7.19.4

Association Ends

•

•

interruptingEdge : ActivityEdge [0..*] (opposite ActivityEdge::interrupts)
The ActivityEdges leaving the InterruptibleActivityRegion on which a traversing token will result in the 
termination of other tokens flowing in the InterruptibleActivityRegion.

node : ActivityNode [0..*]{subsets ActivityGroup::containedNode} (opposite 
ActivityNode::inInterruptibleRegion)
ActivityNodes immediately contained in the InterruptibleActivityRegion.

15.7.19.5

Constraints

•

interrupting_edges
The interruptingEdges of an InterruptibleActivityRegion must have their source in the region and their target 
outside the region, but within the same Activity containing the region.

inv: interruptingEdge->forAll(edge |
  node->includes(edge.source) and node->excludes(edge.target) and 
edge.target.containingActivity() = inActivity)

15.7.20

JoinNode [Class]

15.7.20.1

Description

A JoinNode is a ControlNode that synchronizes multiple flows.

15.7.20.2

Diagrams

Control Nodes

15.7.20.3

Generalizations

ControlNode

424

Unified Modeling Language 2.5

15.7.20.4

Attributes

•

isCombineDuplicate : Boolean [1..1] = true
Indicates whether incoming tokens having objects with the same identity are combined into one by the 
JoinNode.

15.7.20.5

Association Ends

•

♦ joinSpec : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_joinSpec_joinNode::joinNode)
A ValueSpecification giving the condition under which the JoinNode will offer a token on its outgoing 
ActivityEdge. If no joinSpec is specified, then the JoinNode will offer an outgoing token if tokens are offered 
on all of its incoming ActivityEdges (an "and" condition).

15.7.20.6

Constraints

•

•

one_outgoing_edge
A JoinNode has one outgoing ActivityEdge.

inv: outgoing->size() = 1

incoming_object_flow
If one of the incoming ActivityEdges of a JoinNode is an ObjectFlow, then its outgoing ActivityEdge must be 
an ObjectFlow. Otherwise its outgoing ActivityEdge must be a ControlFlow.

inv: if incoming->exists(oclIsKindOf(ObjectFlow)) then outgoing-
>forAll(oclIsKindOf(ObjectFlow))
else outgoing->forAll(oclIsKindOf(ControlFlow))
endif

15.7.21 MergeNode [Class]

15.7.21.1

Description

A merge node is a control node that brings together multiple alternate flows. It is not used to synchronize concurrent 
flows but to accept one among several alternate flows.

15.7.21.2

Diagrams

Control Nodes

15.7.21.3

Generalizations

ControlNode

15.7.21.4

Constraints

•

•

one_outgoing_edge
A MergeNode has one outgoing ActivityEdge.

inv: outgoing->size()=1

edges
The ActivityEdges incoming to and outgoing from a MergeNode must be either all ObjectFlows or all 
ControlFlows.

Unified Modeling Language 2.5

425

inv: let allEdges : Set(ActivityEdge) = incoming->union(outgoing) in
allEdges->forAll(oclIsKindOf(ControlFlow)) or allEdges->forAll(oclIsKindOf(ObjectFlow))

15.7.22 ObjectFlow [Class]

15.7.22.1

Description

An ObjectFlow is an ActivityEdge that is traversed by object tokens that may hold values. Object flows also support 
multicast/receive, token selection from object nodes, and transformation of tokens.

15.7.22.2

Diagrams

Activities, Control Nodes

15.7.22.3

Generalizations

ActivityEdge

15.7.22.4

Attributes

•

•

isMulticast : Boolean [1..1] = false
Indicates whether the objects in the ObjectFlow are passed by multicasting.

isMultireceive : Boolean [1..1] = false
Indicates whether the objects in the ObjectFlow are gathered from respondents to multicasting.

15.7.22.5

Association Ends

•

•

selection : Behavior [0..1] (opposite A_selection_objectFlow::objectFlow)
A Behavior used to select tokens from a source ObjectNode.

transformation : Behavior [0..1] (opposite A_transformation_objectFlow::objectFlow)
A Behavior used to change or replace object tokens flowing along the ObjectFlow.

15.7.22.6

Constraints

•

•

•

426

input_and_output_parameter
A selection Behavior has one input Parameter and one output Parameter. The input Parameter must have the 
same as or a supertype of the type of the source ObjectNode, be non-unique and have multiplicity 0..*. The 
output Parameter must be the same or a subtype of the type of source ObjectNode. The Behavior cannot have 
side effects.

inv: selection<>null implies

selection.inputParameters()->size()=1 and
selection.inputParameters()->forAll(not isUnique and is(0,*)) and
selection.outputParameters()->size()=1

no_executable_nodes
ObjectFlows may not have ExecutableNodes at either end.

inv: not (source.oclIsKindOf(ExecutableNode) or target.oclIsKindOf(ExecutableNode))

transformation_behavior
A transformation Behavior has one input Parameter and one output Parameter. The input Parameter must be the 
same as or a supertype of the type of object token coming from the source end. The output Parameter must be 
the same or a subtype of the type of object token expected downstream. The Behavior cannot have side effects.

Unified Modeling Language 2.5

inv: transformation<>null implies

transformation.inputParameters()->size()=1 and
transformation.outputParameters()->size()=1

selection_behavior
An ObjectFlow may have a selection Behavior only if it has an ObjectNode as its source.

inv: selection<>null implies source.oclIsKindOf(ObjectNode)

compatible_types
ObjectNodes connected by an ObjectFlow, with optionally intervening ControlNodes, must have compatible 
types. In particular, the downstream ObjectNode type must be the same or a supertype of the upstream 
ObjectNode type.

Cannot be expressed in OCL

same_upper_bounds
ObjectNodes connected by an ObjectFlow, with optionally intervening ControlNodes, must have the same 
upperBounds.

Cannot be expressed in OCL

target
An ObjectFlow with a constant weight may not target an ObjectNode, with optionally intervening 
ControlNodes, that has an upper bound less than the weight.

Cannot be expressed in OCL

is_multicast_or_is_multireceive
isMulticast and isMultireceive cannot both be true.

•

•

•

•

•

inv: not (isMulticast and isMultireceive)

15.7.23 ObjectNode [Abstract Class]

15.7.23.1

Description

An ObjectNode is an abstract ActivityNode that may hold tokens within the object flow in an Activity. ObjectNodes 
also support token selection, limitation on the number of tokens held, specification of the state required for tokens being 
held, and carrying control values.

15.7.23.2

Diagrams

Object Nodes, Executable Nodes, Actions, Expansion Regions

15.7.23.3

Generalizations

TypedElement, ActivityNode

15.7.23.4

Specializations

ActivityParameterNode, CentralBufferNode, ExpansionNode, Pin

Unified Modeling Language 2.5

427

15.7.23.5

Attributes

•

•

isControlType : Boolean [1..1] = false
Indicates whether the type of the ObjectNode is to be treated as representing control values that may traverse 
ControlFlows.

ordering : ObjectNodeOrderingKind [1..1] = FIFO
Indicates how the tokens held by the ObjectNode are ordered for selection to traverse ActivityEdges outgoing 
from the ObjectNode.

15.7.23.6

Association Ends

•

•

•

inState : State [0..*] (opposite A_inState_objectNode::objectNode)
The States required to be associated with the values held by tokens on this ObjectNode.

selection : Behavior [0..1] (opposite A_selection_objectNode::objectNode)
A Behavior used to select tokens to be offered on outgoing ActivityEdges.

♦ upperBound : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_upperBound_objectNode::objectNode)
The maximum number of tokens that may be held by this ObjectNode. Tokens cannot flow into the 
ObjectNode if the upperBound is reached. If no upperBound is specified, then there is no limit on how many 
tokens the ObjectNode can hold.

15.7.23.7

Constraints

•

•

•

input_output_parameter
A selection Behavior has one input Parameter and one output Parameter. The input Parameter must have the 
same type as or a supertype of the type of ObjectNode, be non-unique, and have multiplicity 0..*. The output 
Parameter must be the same or a subtype of the type of ObjectNode. The Behavior cannot have side effects.

inv: selection<>null implies

selection.inputParameters()->size()=1 and
selection.inputParameters()->forAll(p | not p.isUnique and p.is(0,*) and 

self.type.conformsTo(p.type)) and

selection.outputParameters()->size()=1 and

selection.inputParameters()->forAll(p | self.type.conformsTo(p.type))

selection_behavior
If an ObjectNode has a selection Behavior, then the ordering of the object node is ordered, and vice versa.

inv: (selection<>null) = (ordering=ObjectNodeOrderingKind::ordered)

object_flow_edges
If isControlType=false, the ActivityEdges incoming to or outgoing from an ObjectNode must all be 
ObjectFlows.

inv: (not isControlType) implies incoming->union(outgoing)->forAll(oclIsKindOf(ObjectFlow))

15.7.24 ObjectNodeOrderingKind [Enumeration]

15.7.24.1

Description

ObjectNodeOrderingKind is an enumeration indicating queuing order for offering the tokens held by an ObjectNode.

428

Unified Modeling Language 2.5

15.7.24.2

Diagrams

• Object Nodes

 

 

15.7.24.3

Literals

•

•

•

•

unordered
Indicates that tokens are unordered.

ordered
Indicates that tokens are ordered.

LIFO
Indicates that tokens are queued in a last in, first out manner.

FIFO
Indicates that tokens are queued in a first in, first out manner.

15.7.25

Variable [Class]

15.7.25.1

Description

A Variable is a ConnectableElement that may store values during the execution of an Activity. Reading and writing the 
values of a Variable provides an alternative means for passing data than the use of ObjectFlows. A Variable may be 
owned directly by an Activity, in which case it is accessible from anywhere within that activity, or it may be owned by a 
StructuredActivityNode, in which case it is only accessible within that node.

15.7.25.2

Diagrams

Activities, Variable Actions, Structured Actions

15.7.25.3

Generalizations

ConnectableElement, MultiplicityElement

15.7.25.4

Attributes

15.7.25.5

Association Ends

•

•

activityScope : Activity [0..1]{subsets NamedElement::namespace} (opposite Activity::variable)
An Activity that owns the Variable.

scope : StructuredActivityNode [0..1]{subsets NamedElement::namespace} (opposite 
StructuredActivityNode::variable)
A StructuredActivityNode that owns the Variable.

15.7.25.6

Operations

•

isAccessibleBy(a : Action) : Boolean
A Variable is accessible by Actions within its scope (the Activity or StructuredActivityNode that owns it).

body: if scope<>null then scope.allOwnedNodes()->includes(a)
else a.containingActivity()=activityScope
endif

Unified Modeling Language 2.5

429

15.8
15.8.1

Association Descriptions
A_containedEdge_inGroup [Association]

15.8.1.1

Diagrams

Activity Groups

15.8.1.2

Member Ends

 

• ActivityGroup::containedEdge
• ActivityEdge::inGroup
 

 

 

15.8.2

15.8.2.1

A_containedNode_inGroup [Association]

Diagrams

Activity Groups

15.8.2.2

Member Ends

 

• ActivityGroup::containedNode
• ActivityNode::inGroup
 

 

 

15.8.3

15.8.3.1

A_decisionInputFlow_decisionNode [Association]

Diagrams

Control Nodes

15.8.3.2

Owned Ends

•

decisionNode : DecisionNode [0..1] (opposite DecisionNode::decisionInputFlow)

15.8.4

15.8.4.1

A_decisionInput_decisionNode [Association]

Diagrams

Control Nodes

15.8.4.2

Owned Ends

•

decisionNode : DecisionNode [0..*] (opposite DecisionNode::decisionInput)

15.8.5

15.8.5.1

A_edge_activity [Association]

Diagrams

Activities

430

Unified Modeling Language 2.5

15.8.5.2

Member Ends

 

• Activity::edge
 
• ActivityEdge::activity
 

 

15.8.6

15.8.6.1

A_edge_inPartition [Association]

Diagrams

Activity Groups

15.8.6.2

Member Ends
• ActivityPartition::edge
 
• ActivityEdge::inPartition
 

 

 

15.8.7

15.8.7.1

A_exceptionInput_exceptionHandler [Association]

Diagrams

Executable Nodes

15.8.7.2

Owned Ends

•

exceptionHandler : ExceptionHandler [0..*] (opposite ExceptionHandler::exceptionInput)

15.8.8

15.8.8.1

A_exceptionType_exceptionHandler [Association]

Diagrams

Executable Nodes

15.8.8.2

Owned Ends

•

exceptionHandler : ExceptionHandler [0..*] (opposite ExceptionHandler::exceptionType)

15.8.9

15.8.9.1

A_group_inActivity [Association]

Diagrams

Activity Groups

15.8.9.2

Member Ends

 

• Activity::group
 
• ActivityGroup::inActivity
 

 

Unified Modeling Language 2.5

431

15.8.10

A_guard_activityEdge [Association]

15.8.10.1

Diagrams

Activities

15.8.10.2

Owned Ends

•

activityEdge : ActivityEdge [0..1]{subsets Element::owner} (opposite ActivityEdge::guard)

15.8.11

A_handlerBody_exceptionHandler [Association]

15.8.11.1

Diagrams

Executable Nodes

15.8.11.2

Owned Ends

•

exceptionHandler : ExceptionHandler [0..*] (opposite ExceptionHandler::handlerBody)

15.8.12

A_handler_protectedNode [Association]

15.8.12.1

Diagrams

Executable Nodes

15.8.12.2

Member Ends

•

•

ExecutableNode::handler
 

 

ExceptionHandler::protectedNode
 

 

15.8.13

A_inInterruptibleRegion_node [Association]

15.8.13.1

Diagrams

Activity Groups

15.8.13.2

Member Ends

 

• ActivityNode::inInterruptibleRegion
•

InterruptibleActivityRegion::node
 
 

 

15.8.14

A_inPartition_node [Association]

15.8.14.1

Diagrams

Activity Groups

15.8.14.2

Member Ends
• ActivityNode::inPartition
 

 

432

Unified Modeling Language 2.5

• ActivityPartition::node
 

 

15.8.15

A_inState_objectNode [Association]

15.8.15.1

Diagrams

Object Nodes

15.8.15.2

Owned Ends

•

objectNode : ObjectNode [0..*] (opposite ObjectNode::inState)

15.8.16

A_incoming_target_node [Association]

15.8.16.1

Diagrams

Activities

15.8.16.2

Member Ends
• ActivityNode::incoming
 
• ActivityEdge::target

 

 

 

15.8.17

A_interruptingEdge_interrupts [Association]

15.8.17.1

Diagrams

Activity Groups

15.8.17.2

Member Ends

•

InterruptibleActivityRegion::interruptingEdge
 

 

• ActivityEdge::interrupts
 

 

15.8.18

A_joinSpec_joinNode [Association]

15.8.18.1

Diagrams

Control Nodes

15.8.18.2

Owned Ends

•

joinNode : JoinNode [0..1]{subsets Element::owner} (opposite JoinNode::joinSpec)

15.8.19

A_node_activity [Association]

15.8.19.1

Diagrams

Activities

Unified Modeling Language 2.5

433

15.8.19.2

Member Ends

 

• Activity::node
 
• ActivityNode::activity
 

 

15.8.20

A_outgoing_source_node [Association]

15.8.20.1

Diagrams

Activities

15.8.20.2

Member Ends
• ActivityNode::outgoing
 
• ActivityEdge::source

 

 

 

15.8.21

A_parameter_activityParameterNode [Association]

15.8.21.1

Diagrams

Object Nodes

15.8.21.2

Owned Ends

•

activityParameterNode : ActivityParameterNode [0..*] (opposite ActivityParameterNode::parameter)

15.8.22

A_partition_activity [Association]

15.8.22.1

Diagrams

Activity Groups

15.8.22.2

Owned Ends

•

activity : Activity [0..1]{subsets ActivityGroup::inActivity} (opposite Activity::partition)

15.8.23

A_redefinedEdge_activityEdge [Association]

15.8.23.1

Diagrams

Activities

15.8.23.2

Owned Ends

•

activityEdge : ActivityEdge [0..*]{subsets A_redefinedElement_redefinableElement::redefinableElement} 
(opposite ActivityEdge::redefinedEdge)

434

Unified Modeling Language 2.5

15.8.24

A_redefinedNode_activityNode [Association]

15.8.24.1

Diagrams

Activities

15.8.24.2

Owned Ends

•

activityNode : ActivityNode [0..*]{subsets A_redefinedElement_redefinableElement::redefinableElement} 
(opposite ActivityNode::redefinedNode)

15.8.25

A_represents_activityPartition [Association]

15.8.25.1

Diagrams

Activity Groups

15.8.25.2

Owned Ends

•

activityPartition : ActivityPartition [0..*] (opposite ActivityPartition::represents)

15.8.26

A_selection_objectFlow [Association]

15.8.26.1

Diagrams

Activities

15.8.26.2

Owned Ends

•

objectFlow : ObjectFlow [0..*] (opposite ObjectFlow::selection)

15.8.27

A_selection_objectNode [Association]

15.8.27.1

Diagrams

Object Nodes

15.8.27.2

Owned Ends

•

objectNode : ObjectNode [0..*] (opposite ObjectNode::selection)

15.8.28

A_structuredNode_activity [Association]

15.8.28.1

Diagrams

, Structured Actions

15.8.28.2

StructuredActivityNode::activity
 

 

Member Ends
• Activity::structuredNode
•

 

 

Unified Modeling Language 2.5

435

15.8.29

A_subgroup_superGroup [Association]

15.8.29.1

Diagrams

Activity Groups

15.8.29.2

Member Ends
• ActivityGroup::subgroup
 
• ActivityGroup::superGroup

 

 

 

15.8.30

A_subpartition_superPartition [Association]

15.8.30.1

Diagrams

Activity Groups

15.8.30.2

Member Ends

 

• ActivityPartition::subpartition
 
• ActivityPartition::superPartition
 

 

15.8.31

A_transformation_objectFlow [Association]

15.8.31.1

Diagrams

Activities

15.8.31.2

Owned Ends

•

objectFlow : ObjectFlow [0..*] (opposite ObjectFlow::transformation)

15.8.32

A_upperBound_objectNode [Association]

15.8.32.1

Diagrams

Object Nodes

15.8.32.2

Owned Ends

•

objectNode : ObjectNode [0..1]{subsets Element::owner} (opposite ObjectNode::upperBound)

15.8.33

A_variable_activityScope [Association]

15.8.33.1

Diagrams

Activities

15.8.33.2

Member Ends

• Activity::variable
 

 

436

Unified Modeling Language 2.5

• Variable::activityScope

 

 

15.8.34

A_weight_activityEdge [Association]

15.8.34.1

Diagrams

Activities

15.8.34.2

Owned Ends

•

activityEdge : ActivityEdge [0..1]{subsets Element::owner} (opposite ActivityEdge::weight)

Unified Modeling Language 2.5

437

16 Actions
Summary
16.1
An Action is the fundamental unit of behavior specification in UML. An Action may take a set of inputs and produce a 
set of outputs, though either or both of these sets may be empty. Some Actions may modify the state of the system in 
which the Action executes.
Actions are contained in Behaviors, specifically Activities (as ExecutableNodes, see Clause 15) and Interactions (see 
Clause 17). These Behaviors determine when Actions execute and what inputs they have. However, the abstract syntax 
and semantics of Actions are very dependent on Activities, because they specialize elements and semantics from 
Activities to accept inputs and provide outputs and to define Actions that coordinate other Actions (Structured Actions, 
see sub clause 16.11). In addition, the concrete syntax for Actions only appears in Activity diagrams (all the examples in 
this Clause use Activity notation), and some of the notation for Actions is specified in Clause 15. This Clause focuses on 
the syntax and semantics of Actions specifically, rather than the Behaviors that contain them, but must be read in 
conjunction with Clause 15.

16.1.1.1

Concrete Syntax

The UML specification provides a relatively minimal set of graphical notations for Actions. However, conforming tools 
may provide tool-specific graphical or textual representations that map into the standard Action abstract syntax. Such 
representations are referred to as concrete syntaxes. For example, a textual concrete syntax may be used to notate 
Actions in Behaviors attached to Transitions in StateMachines (see sub clause 14.2.4). Concrete syntaxes generally 
encompass both primitive Actions and the control mechanisms provided by Behaviors.
Concrete syntaxes can map higher-level constructs to the Actions specified in the UML abstract syntax. For example, 
creating an object may involve initializing attribute values or creating objects for mandatory Associations. The UML 
specification defines the CreateObjectAction to only create the object and requires further Actions to initialize attribute 
values and create objects for mandatory Associations. A concrete syntax can support a creation operation including 
initialization as a single unit as a shorthand for several underlying Actions. In general, concrete syntaxes can implement 
each Action one-to-one, or define higher-level, composite constructs to offer the modeler more power and convenience. 
This specification provides abstract syntax and semantics for primitive behavioral concepts that are simple to 
understand and implement. Modelers can work in terms of higher-level constructs as provided by their chosen concrete 
syntax.
The most primitive Actions in this specification are defined to enable the maximum range of concrete syntax mappings. 
Specifically, a primitive Action either carries out a computation or accesses object memory, but never both. This 
approach enables clean mappings to a physical implementation, even those with data organizations different from that 
suggested by the specification. In addition, any re-organization of the data structure will leave the specification of the 
computation unaffected.

16.1.1.2

Execution Engines

An execution engine is a tool that executes UML Actions. Actions are defined to enable the construction of various 
execution engines with different performance characteristics. An execution engine can optimize the execution of a 
model to meet specific performance requirements, so long as the engine stays within the semantics specified for Actions 
in UML. For example, one execution engine might operate fully sequentially within a single task, while another might 
assign classes to different processors based on how much they interact, and yet others might assign classes in a client-
server, or even a three-tier architecture. These are all valid execution engines for UML if they are optimized only to the 
extent allowed by UML semantics.
Modelers can provide “hints” to the execution engine when they have special knowledge of the domain solution that 
could be of value in optimizing the execution. For example, instances could—by design—be partitioned to match the 
assignment of classes, so tests based on this partitioning can be optimized on each processor. An execution engine is not 
required to check or enforce such hints. It can either assume that the modeler is correct, or just ignore it. An execution 
engine is not required to verify that the modeler’s assertion is true.

Unified Modeling Language 2.5

439

When the execution of Actions violates aspects of UML structural semantics that constrain runtime behavior, the 
semantics of the Actions are left undefined. For example, linking an instance to multiple owners via composite 
Associations is undefined – some concrete syntaxes may make this Action illegal, others may allow it until a single 
owner is established. The semantics are also left undefined in situations that require Classes as values at runtime. 
However, in the execution of Actions the lower multiplicity bound is ignored and the semantics is still as defined. 
Otherwise, it is impossible to use Actions to pass through intermediate stages necessary to construct object 
configurations that satisfy multiplicity constraints. The modeler must determine the points at which minimum 
multiplicity will be enforced, and these points cannot be everywhere or the object configuration would not be able to 
change.

Actions
Summary

16.2
16.2.1
This sub clause defines the basic abstract syntax for Actions and Pins, where Pins are used to specify the inputs and 
outputs for Actions. Other than OpaqueAction, the various concrete kinds of Actions are described in subsequent sub 
clauses.

16.2.2

Abstract Syntax

{subsets ownedElement}

+ fromAction
1

Action

+ isLocallyReentrant : Boolean = false

+ /action

{readOnly, union, subsets owner}

0..1

ExecutableNode

+ action

*

+ action

{subsets owner}

{readOnly}
+ /context

0..1

*

Classifier

+ localPrecondition

{subsets ownedElement}

Constraint

{subsets owner}

*
+ localPostcondition

{subsets ownedElement}

0..1

+ action
0..1

+ /action

{readOnly, union, subsets owner}

0..1

OpaqueAction

+ body : String [*] {ordered, nonunique}
+ language : String [*] {ordered}

{subsets action}
0..1 + opaqueAction

{subsets action}
0..1 + opaqueAction

{ordered, readOnly,
union, subsets
ownedElement}

{subsets input}

* + inputValue

{subsets output}

* + outputValue

+ /input

*

InputPin

OutputPin

*

+ /output
{ordered, readOnly,
union, subsets
ownedElement}

{subsets owner}
+ actionInputPin

0..1

ActionInputPin

ValuePin

Pin

+ isControl : Boolean = false

{subsets owner}
+ valuePin

0..1

{subsets ownedElement}

+ value

1

Figure 16.1  Actions

ValueSpecification

ObjectNode

MultiplicityElement

440

Unified Modeling Language 2.5

16.2.3

16.2.3.1

Semantics

Actions

An Action is a fundamental unit of executable functionality contained, directly or indirectly, within a Behavior. The 
execution of an Action represents some transformation or processing in the modeled system, be it a computer system or 
otherwise. However, an Action execution may also result in the invocation of another Behavior (see sub clause 16.3 on 
Invocation Actions). An Action is therefore simple from the point of view of the Behavior containing it but may be 
complex in its effect and not atomic.
If the Behavior containing an Action has a context BehavioredClassifier (see sub clause 13.2), then that 
BehavioredClassifier is also the context Classifier for the Action. When the Action executes, it executes in the context of 
an instance of the context Classifier or, if there is no context Classifier, then directly in the context of the execution 
instance of the Behavior. (See also the discussion of context objects under BehavioredClassifiers in sub clause 13.2.3.)
An Action may accept inputs and produce outputs, as specified by InputPins and OutputPins of the Action, respectively. 
Each Pin on an Action specifies the type and multiplicity for a specific input or output of that Action.
The time at which an Action executes and what inputs are accepted by each execution are determined by the kind of 
Action it is, characteristics of its InputPins, and the Behavior in which it is used. Once it has been determined that an 
Action will execute, the general steps for that execution are as follows:

1

The Action execution consumes input data on all InputPins on the Action up to the upper multiplicity for each 
InputPin. For structured Actions (StructuredActivityNodes, see sub clause 16.11), data can remain on InputPins 
during Action execution, otherwise they are immediately removed from the InputPins by the ActionExecution. 
If the Action is an invocation of a Behavior with streaming Parameters (see sub clause 13.2.3), then the Action 
execution may consume additional data supplied to InputPins corresponding to streaming input Parameters 
(see sub clause 16.3.3 on the semantics of InvocationActions). Otherwise, once an Action execution has 
started, any additional data on InputPins has no effect on it.

2 An Action continues executing until it has completed. The detailed semantics of the execution of an Action and 

the definition of its completion depend on the particular kind of Action being executed.

3 When completed, an Action execution provides any output data on the OutputPins of the Action, and it 

terminates. However, if the Action is an invocation of a Behavior with streaming Parameters (see sub clause 
13.2.3), then the Action execution may also post data to OutputPins corresponding to streaming output 
Parameters before completion of the execution (see sub clause 16.3.3 on the semantics of InvocationActions).

NOTE. After the execution of an Action has terminated, any resources used in executing it may be reclaimed 
by an execution engine implementing its execution. However, the details of resource management are 
implementation-specific and not defined in this specification.

In the specification of semantics for Actions, Behaviors may reuse the same kind of Action multiple times, and the 
semantics of the Action applies to each usage separately. For example, Activities may have multiple nodes that are 
instances of the same Action metaclass, and each instance has its own values for the properties described below, 
affecting the execution of that particular usage of the Action only. The same applies to Interactions with multiple actions 
that are instances of the same Action metaclass. The phrase “an Action” or “the Action” in this specification refers to a 
single instance of an Action metaclass used in a Behavior, separate from the other instances of the same Action 
metaclass that may be used in the Behavior or other Behaviors.
If an Action is not locally reentrant (isLocallyReentrant=false, the default), then no more than one execution of it may 
exist at any given time within a single execution of the containing Behavior. Even if the Action would normally begin 
executing, the new execution may not start if there is already one ongoing within the same Behavior execution, but the 
new execution may start when the current execution of the Action terminates. On the other hand, if an Action is locally 
reentrant (isLocallyReentrant=true), then a new execution of it may begin any time the normal rules above allow it, even if 
there are one or more executions already ongoing within the same Behavior execution. This means that there may be, 

Unified Modeling Language 2.5

441

within any one execution of the containing Behavior, more than one concurrent execution of the Action ongoing at any 
given time.
A CallAction for a non-reentrant Behavior (isReentrant=true) will also act as if the CallAction were locally non-
reentrant, whatever the value of the isLocallyReentrant property for the action. Moreover, such an Action will not execute 
if there is any currently running execution for the Behavior, whether invoked by this Action or any other within the 
same containing Behavior or in any other (see the semantics of isReentrant in sub clause 13.2.3 and of CallAction in sub 
clause 16.3.3).
The localPrecondition and localPostcondition for an Action are Constraints that should hold when an execution of an 
Action starts and completes, respectively. As a localPrecondition or localPostcondition is a modeler-defined Constraint, 
violations do not mean that the UML semantics of the Action execution are undefined. They only mean that the 
execution trace for the Behavior containing the Action does not conform to the modeler’s intention (although in most 
cases this indicates a serious modeling error that calls into question the validity of the model). Specifically how a 
localPrecondition or localPostcondition is enforced is not defined in this specification. An execution engine may detect 
violations statically, if possible, or at runtime. The runtime effect of a violation may be an error that stops execution, 
just a warning, or no effect at all, as determined by the execution engine.

16.2.3.2

Opaque Actions

An OpaqueAction is an Action whose specification may be given in a textual concrete syntax other than UML. An 
OpaqueAction may also be used as a temporary placeholder before some other kind of Action is chosen.
An OpaqueAction has a body that consists of a sequence of text Strings representing alternative means of specifying the 
behavior of the Action. A corresponding sequence of language Strings may be used to specify the languages in which 
each of the body Strings is to be interpreted. Languages are matched to body Strings by order. The UML specification 
does not define how body Strings are interpreted relative to any language, though other specifications may define 
specific language Strings to be used to indicate interpretation with respect to those specifications. It is not required to 
specify the languages. If they are unspecified, then the interpretation of any body Strings shall be determined implicitly 
from the form of the bodies or how the OpaqueAction is used.
If an OpaqueAction has more than one body String, then any one of the bodies can be used to determine the behavior of 
the OpaqueAction. The UML specification does not determine how this choice is made.

16.2.3.3

Pins

A Pin represents an input to an Action or an output from an Action. An InputPin represents an input, while an OutputPin 
represents an output. Each of the sets of inputs and outputs owned by an Action are ordered. The InputPins and 
OutputPins of an Action are determined by the kind of Action it is.
A Pin is a kind of ObjectNode (see sub clause 15.4), so it holds object tokens that contain values of a specified Type 
(see sub clause 15.2 about tokens). Values held in the tokens of the InputPins of an Action provide the input data for 
executions of the Action, and the output data from Action executions are placed on the OutputPins of the Action 
wrapped in object tokens. A Pin is also a MultiplicityElement. The multiplicity bounds on a Pin constrain the total 
number of values that may be input or output by a single execution of an Action, not the number of tokens it contains 
(see the upperBound property inherited from ObjectNode). A Pin may hold null tokens that contain no values. Pin 
multiplicity is not unique because it may hold multiple tokens with the same value.
Pin inherits both an ordering attribute from ObjectNode and an isOrdered attribute from MultiplicityElement. The values 
of these attributes may be set independently. However, if isOrdered is true, then the ordering of values on the Pin 
considered as a MultiplicityElement is the order in which the values were placed onto the Pin. The value of the ordering 
attribute, however, determines the order in which values are taken from the Pin. For example, if isOrdered is true and the 
ordering is FIFO, then values will be taken from the Pin in the same order as the MultiplicityElement ordering. However, 
if the ordering is LIFO, then values will be taken from the pin in reverse order to the MultiplicityElement ordering. On 
the other hand, if isOrdered is false, then the order in which values are placed on the pin is indeterminate, and the effect 
of different orderings is not defined.
An InputPin is a Pin that holds input values to be consumed by its Action. An Action cannot start execution if one of its 
InputPins has fewer values than the lower multiplicity of that InputPin. The upper multiplicity determines the maximum 

442

Unified Modeling Language 2.5

number of values that can be consumed from an InputPin by a single execution of its Action. Tokens consumed by an 
Action are immediately removed from its InputPins when the action begins an execution (except in some cases for 
StructuredActivityNodes, where tokens may remain on InputPins during the Action execution – see sub clause 16.11).
An OutputPin is a Pin that holds output values produced by an Action. For each execution, an Action cannot terminate 
itself unless it can put at least as many values into its outputs as required by the multiplicity lower bounds on those 
OutputPins. Values that may remain on the OutputPins from previous executions are not included in meeting this 
minimum multiplicity requirement. An Action may not put more values into an output in a single execution than the 
multiplicity of that OutputPin.
ValuePins and ActionInputPins are InputPins, but are not used in the determination of whether an Action is enabled for 
execution. If an Action has no other way to start execution, simply having ValuePins or ActionInputPins for its inputs 
will not enable execution of the Action. When the Action is enabled by other means, values are computed as specified 
for the ValuePins and ActionInputPins owned by an Action, and the results are provided as inputs to the Action when it 
begins execution.
A ValuePin provides a value by evaluating a ValueSpecification (e.g., this may be used as a simple way to specify 
constant inputs to an Action.) When the Action is enabled by other means, the ValueSpecifiation of the ValuePin is 
evaluated, and the result is provided as an input to the Action when it begins execution
An ActionInputPin provides values by executing another Action. When an Action is enabled by other means, the 
fromActions on any ActionInputPins owned by the Action are also enabled. The fromActions must execute before the 
Action owning the ActionInputPins, and the outputs of the fromActions are placed in the corresponding ActionInputPins. 
The process recurs on any ActionInputPins of the fromActions. In the case that ActionInputPins are used for all inputs, 
this forms a tree structure that is an Action model of nested expressions, bottoming out at Actions that have no inputs 
(such as ReadVariableActions or ReadSelfActions).

16.2.3.4

Actions and Pins in Activities

If an Action (and so its Pins) are contained in an Activity, when tokens move in and out of the Pins and when the Action 
executes are determined by the semantics of Activities as well as Actions. For example, Activities include ControlFlows 
between ExecutableNodes (a generalization of Actions, see sub clause 15.5), which affects when Actions may execute, 
and Pins are ObjectNodes that may hold tokens accepted and offered according to the semantics of ObjectFlows 
between ObjectNodes (see sub clause 15.4).
Executing an Action in an Activity requires all of its InputPins to be offered all necessary tokens, as specified by their 
minimum multiplicity (except for the special cases of ActionInputPins and ValuePins, as discussed above). When the 
Action begins executing, all the InputPins accept tokens offered to them at once, up to the maximum multiplicity 
allowed on each InputPin. (InputPins cannot accept more tokens than will be consumed immediately by their Actions 
during a single execution. This ensures that InputPins on separate Actions competing for the same tokens do not accept 
any tokens they cannot immediately consume, causing deadlock or starvation as Actions wait for tokens accepted by the 
InputPins of other Actions but not used.) Tokens accepted by the InputPins of one Action cannot be consumed by any 
other Action.
When an Action in an Activity completes execution, object tokens for output data placed on its OutputPins may be 
offered on any outgoing ObjectFlows from those Pins (per the semantics of ObjectNodes, see sub clause 15.4). In 
addition, control tokens shall be offered on any outgoing ControlFlows from the Action (per the semantics of 
ExecutableNodes, see sub clause 15.5).
If an Action is not locally reentrant (isLocallyReentrant=false), then once it starts executing, the Action and its InputPins 
do not accept any tokens offered to them until the execution has finished. At this point, if the required tokens are still 
available, the Action may accept the offers and begin a new execution. On the other hand, if the Action is locally 
reentrant (isLocallyReentrant=true), then it may begin a new execution any time the above rules allow it.
A control Pin (with isControl=true) must have a control type (isControlType=true), so that they may be used with 
ControlFlows. Control Pins are ignored in the constraints that Actions place on Pins (including matching to parameters 
for InvocationActions – see sub clause 16.3). Tokens arriving at a control InputPin have the same semantics as control 
tokens arriving at the Action, except that control tokens can be buffered in control Pins. Tokens are placed on control 
OutputPins according to the same semantics as tokens placed on ControlFlows coming out of an Actions.

Unified Modeling Language 2.5

443

Notation

16.2.4
This sub clause specifies a graphical notation for the Actions used within Activities. This notation is optional, in that a 
conforming tool may use a textual concrete syntax instead. However, the notation given in this and subsequent notation 
sub clauses within this clause is the only graphical notation for Actions conformant with this specification.

16.2.4.1

Actions

Actions are notated as round-cornered rectangles, as shown in Figure 16.2. The name of the action or other description 
of it may appear in the symbol. (Specialized notations for certain specific kinds of Actions are described in subsequent 
sub clauses.)

Figure 16.2  Action

Local pre- and post-conditions are shown as notes attached to the invocation with the keywords «localPrecondition» 
and «localPostcondition», respectively, as shown in Figure 16.3.

Figure 16.3  Local pre- and post-conditions

16.2.4.2

Pins

As ObjectNodes, Pins are notated as rectangles (see sub clause 15.4.4). However, Pin rectangles may be notated as 
small rectangles that are attached to the symbol for the Action that owns them (see Figure 16.4). The name of the Pin 
may be displayed near the pin. The name is not restricted, but it often just shows the type of object or data that flows 
through the Pin. Both the name and type may be shown for a pin using a label of the form “name: type”. The label may 
also be a full specification of the Parameter corresponding to a Pin for InvocationActions, using the same textual 
notation as for the Parameters for BehavioralFeatures on Classes (see sub clause 16.3.4). The Pins of an Action may be 
elided in the notation for the Action, even though they are present in the model.

Figure 16.4  Pin notations

When ActivityEdges are not present to distinguish InputPins and OutputPins, an optional arrow may be placed inside 
the Pin rectangle, as shown below. InputPins have the arrow pointing toward the Action and OutputPins have the arrow 
pointing away from the Action.

444

Unified Modeling Language 2.5

Figure 16.5  Pin notations, with arrows

The situation in which the OutputPin of one Action is connected to the InputPin of the same name in another Action via 
an ObjectFlow may be shown by the optional notations of Figure 16.6. The standalone Pin in the notation maps to an 
OutputPin and an InputPin and one ObjectFlow edge between them in the underlying model. This form should be 
avoided if the Pins are not of the same type. Multiple arrows coming out of a standalone Pin rectangle is an optional 
notation for multiple edges coming out of an OutputPin. (See other ObjectFlow and Pin notations in sub clause 15.2. 
The specific notational variant used shall be preserved when the diagram is interchanged, see Annex B.)

Figure 16.6  Standalone Pin notations

Control Pins are shown with the textual annotation {control} placed near the Pin symbol.
A ValuePin is notated as an InputPin with the ValueSpecification written beside it (see sub clause 8.2.4 on textual 
notation for ValueSpecifications).

16.2.5

16.2.5.1

Examples

Actions

Figure 16.7 illustrates two actions. These perform behaviors called Send Payment and Accept Payment. (See other 
examples in sub clause 15.2.)

Figure 16.7  Examples of Actions

Figure 16.8 is an example of an action expressed using a tool-specific concrete syntax:

Figure 16.8  Example of action using a tool-specific concrete syntax

Figure 16.9 below illustrates local pre- and postconditions for the Action of a drink-dispensing machine. This is 
considered “local” because a drink-dispensing machine is constrained to operate under these conditions for this 
particular Action. For a machine technician scenario, the situation would be different. Here, a machine technician would 
have a key to open up the machine, and therefore no money need be inserted to dispense the drink, nor change need be 

Unified Modeling Language 2.5

445

given. In such a situation, the global pre- and post-conditions on the underlying Dispense Drink Behavior called by this 
action would be all that is required. For example, a global pre-condition for a Dispense Drink Behavior could be “A 
drink is selected that the vending machine dispenses.” The post-condition, then, would be “The vending machine 
dispensed the drink that was selected.” In other words, there is no global requirement for money and correct change.

Figure 16.9  Example of an action with local pre- and post-conditions

16.2.5.2

Pins

In Figure 16.10, the Pin named “Order” represents Order objects. In this example at the upper left, Fill Order produces 
filled orders and Ship Order consumes them. The Fill Order Action must complete for Ship Order to begin. The pin 
symbols have been elided from the action symbols; both pins are represented by the single Order rectangle. The 
example on the upper right shows the same thing with explicit Pin symbols on the Actions. The example at the bottom 
of the figure illustrates the use of multiple pins. (See other examples in sub clause 15.2.)

Figure 16.10  Pin examples

Figure 16.11 shows two examples of ObjectNode selection behavior (see sub clause 15.4) as applied to Pins. Both 
examples indicate that orders are to be shipped based or order priority—and those with the same priority should be 
filled on a first-in/first-out (FIFO) basis.

446

Unified Modeling Language 2.5

Figure 16.11  Specifying selection behavior on an ObjectFlow

For an example of the use of ActionInputPins, consider the abstract syntax mapping for the following expression in a 
textual concrete syntax: self.foo->bar(self.baz) (while this notation is OCL-like, it is not intended to be normative). 
The meaning of this expression is to get the value of the foo attribute of self, then send a bar signal to that value with an 
argument that is the value of the baz attribute of self. Figure 16.12 shows a UML abstract syntax representation for this 
expression.
NOTE. Subexpressions are linked using ActionInputPins.

Figure 16.12  Example abstract syntax model showing the use of ActionInputPins

Unified Modeling Language 2.5

447

Invocation Actions
Summary

16.3
16.3.1
An InvocationAction is an Action that results, directly or indirectly, in the invocation of a Behavior (see sub clause 
13.2). InvocationActions include the CallActions for calling Operations or Behaviors and for starting Behaviors that 
have been previously instantiated. Additional kinds of InvocationActions allow for the targeted sending of signals and 
other objects and the ability for broadcasting signals to available receivers.

16.3.2

Abstract Syntax

{subsets input}

+ object

1

InputPin

{ordered, subsets input}
+ argument
*

{subsets action}
+ invocationAction

0..1

InvocationAction

+ invocationAction
*

+ onPort

0..1

Port

Action

{ordered,
subsets output}

+ result

{subsets action}
+ callAction

CallAction

*

0..1

+ isSynchronous : Boolean = true

OutputPin

SendObjectAction

SendSignalAction

BroadcastSignalAction

+ startObjectBehaviorAction
{subsets action}

0..1

StartObjectBehaviorAction

CallBehaviorAction

CallOperationAction

{redefines invocationAction}

+ sendObjectAction

0..1

0..1

{subsets action}
+ sendSignalAction
{subsets action}
+ sendObjectAction

{subsets action}
+ callOperationAction

0..1

0..1

* + sendSignalAction

* + broadcastSignalAction

1 + signal

1 + signal

Signal

+ callBehaviorAction

+ behavior

*

1

+ callOperationAction

+ operation

*

1

Behavior

Operation

{subsets input}

+ target

1

{redefines
argument}
+ request

1

1

InputPin

{subsets input}
+ target
1
+ target
{subsets input}

Figure 16.13  Invocation Actions

16.3.3

16.3.3.1

Semantics

Call Actions

A CallAction is an InvocationAction that calls a Behavior or an Operation. There are three kinds of CallActions:

1 A CallBehaviorAction is a CallAction that invokes a Behavior directly, rather than calling a BehavioralFeature 

that, in turn, results in the invocation of a Behavior.

2 A CallOperationAction is a CallAction that transmits an Operation call request message to the target object, 

where it may cause the invocation of an associated Behavior. The target object is taken from the target InputPin 
of the CallOperationAction. The handling of an Operation call request by the target object is described under 
Behavioral Features and Methods in sub clause 13.2.3 and Message Event in sub clause 13.3.3.

3 A StartObjectBehaviorAction is a CallAction that starts the execution either of a directly instantiated Behavior 

or of the classifierBehavior of an object. The object to be started is taken from the object InputPin. If the input 
object is an instantiated Behavior that is not already executing, then it begins executing. If the input object has 
a classifierBehavior that is not already executing, then it is instantiated and started. In either case, if the identified 
Behavior is already executing, then the StartObjectBehavior has no effect.

NOTE. If the input object is not an instantiated Behavior, then it must have a classifierBehavior. If the input 
object is an instantiated Behavior, then it may also have a classifierBehavior, which is also started. If this 
classifierBehavior itself has a classifierBehavior, then this is also recursively started, and so on.

448

Unified Modeling Language 2.5

A CallAction may result in either a synchronous or asynchronous Behavior invocation, either directly or through an 
Operation call.

•

•

If the call is synchronous (isSynchronous=true), then the execution of the Action does not complete until the 
execution of the invoked Behavior completes, normally or otherwise. (If the Behavior execution does not 
complete normally but, instead, raises an exception, then that exception is propagated out of the CallAction, 
(see sub clauses 15.5.3 and 16.13 on exceptions and how they are handled).

If the call is asynchronous (isSynchronous=false), then the execution of the Action completes as soon as the 
Behavior has been invoked. When an asynchronous call is complete, execution of the Behavior containing the 
CallAction proceeds independently of and concurrently with the execution of the invoked Behavior, including 
the handling of any exceptional conditions that occur while the Behavior is executing.

If the Behavior invoked by a CallAction is not reentrant, then no more than one execution of it shall exist at any given 
time (see sub clause 13.2.2). An invocation of a non-reentrant Behavior may not start a new execution of the Behavior 
when the Behavior is already executing, but may start a new execution when the current execution terminates. An 
invocation of a reentrant Behavior may start a new execution of the Behavior, even if the Behavior is already executing. 
However, a CallAction with isLocallyReentrant=false shall not start a new execution of the Behavior if there is a Behavior 
execution ongoing that was started by the same Action within the same containing Behavior execution, but may start it 
when the current execution terminates (see also sub clause 16.2.3).
Behaviors and Operations have totally ordered lists of owned Parameters, and these Parameters are matched to Pins on a 
CallAction using that ordering. The argument Pins of a CallAction are matched, in order, to the sublist of input 
Parameters, while the result Pins are matched, in order, to the sublist of output Parameters. The type, ordering, and 
multiplicity of the argument and result pins of a CallAction shall be the same as the corresponding Parameters.
When a CallAction executes, it passes the values on its argument Pins to the invoked Behavior or Operation on the 
corresponding input Parameters. If the call is synchronous, then values returned on output Parameters are placed in 
tokens on the corresponding result Pins of the CallAction. If an output Parameter has no values, then a null token is 
placed on the corresponding result Pin. If the call is asynchronous, then result values cannot be returned.
If any of the Parameters are streaming (isStreaming=true), then the call must be synchronous (see also the discussion of 
streaming Behavior parameters in sub clause 13.2.3). In this case, while the invoked Behavior executes, the CallAction 
continues to accept tokens offered to the argument Pins corresponding to streaming input Parameters, up to the upper 
multiplicity of each Pin, which are consumed by the Action and posted to the executing Behavior as they arrive. Values 
posted to streaming output Parameters are offered on the corresponding result Pins (which can only be accepted up to 
the upper multiplicity of each Pin). In effect, streaming Parameters give the invoked Behavior access to token flows to 
and from the invoking CallAction while the Behavior is executing.
In addition to the execution rules given in sub clause 16.2.3 for Actions, the following rules also apply to a CallAction 
invoking a Behavior or Operation with streaming Parameters:

• All InputPins for the CallAction shall have been offered a number of values equal to or greater than the lower 
multiplicity of each Pin before the CallAction can execute, per the usual rules. If all the argument Pins of the 
CallAction are for streaming Parameters with a lower multiplicity greater than 0, then at least one shall have an 
offered value before the CallAction can execute.

• A number of values equal to or greater than the lower multiplicity of each argument Pin of the CallAction 
corresponding to a streaming Parameter must be accepted before the CallAction can complete execution 
normally.

•

Before an invoked Behavior execution completes normally (no exception raised, see sub clause 16.13, and no 
values for any exception Parameters, isException=true), a number of values equal to at least the lower 
multiplicity of each result Pin of the CallAction shall be posted by the time the execution completes. (Values 
may be posted to result Pins corresponding to streaming output Parameters before the execution completes.) If 
the invoked Behavior does not complete normally, however, then result Pins may have a smaller number of 
values posted to them than their lower multiplicity.

Unified Modeling Language 2.5

449

Special rules also apply to a CallAction invoking a Behavior or Operation with Parameters grouped into ParameterSets.

•

•

If the Behavior or Operation has input ParameterSets, then the rules from sub clause 16.2.3 on when the 
CallAction may execute are applied separately to the (possibly overlapping) sets of InputPins corresponding to 
the Parameters in each input ParameterSet. If data is available to one of these input sets sufficient to allow the 
CallAction to execute, then the CallAction may execute accepting tokens only on the InputPins in that input 
set, and the invoked Behavior or Operation is passed this data on Parameters only from the corresponding 
ParameterSet. If sufficient data is available to more than one input set, then one is chosen non-
deterministically.

If the Behavior or Operation has output Parameter sets, and the CallAction completes normally, the Call Action 
shall produce output on only the OutputPins corresponding to one output ParameterSet, sufficient to meet the 
lower multiplicity of those OutputPins, and object tokens are offered to ActivityEdges outgoing from those 
OutputPins. No object tokens are offered from any other OutputPins, not even null tokens.

16.3.3.2

Send Actions

A send Action is an action that transmits an object asynchronously to one or more target objects. As a send Action is 
always asynchronous, it may have argument inputs, but it has no result outputs. The Action completes as soon as the 
object is sent, whether or not it has been received yet.
There are three kinds of send Actions:

1 A SendSignalAction is an InvocationAction that creates a Signal instance and transmits the instance to the 

object given on its target InputPin. A SendSignalAction must have argument InputPins corresponding, in order, 
to each of the (owned and inherited) Properties of the Signal being sent, with the same type, ordering and 
multiplicity as the corresponding attribute. The values of each Property of the transmitted Signal instance are 
taken from the argument InputPin corresponding to the Property. The handling of the Signal instance by the 
target object is described under Behavioral Features and Methods in sub clause 13.2.3 and Message Events in 
sub clause 13.3.3.

2 A BroadcastSignalAction is an InvocationAction that creates a Signal instance using values from its argument 
InputPins, similarly to a SendSignalAction. However, instead of sending the Signal instance to a single target 
object, it transmits the instance potentially to all available target objects in the system. The manner of 
identifying the exact set of objects that are broadcast targets is not defined in this specification, however, and 
may be limited to some subset of all the objects that exist.

3 A SendObjectAction is an Invocation action that transmits any kind of object to the object given on its target 
InputPin. The object to be transmitted is given on the single request InputPin of the SendObjectAction. If the 
object is a Signal instance, then it may be handled by the target object in the same way as an instance sent from 
a SendSignalAction or BroadcastSignalAction. Otherwise, the reception of the object can only be handled 
using an AnyReceiveEvent (as described under Message Events in sub clause 13.3.3).

For SendSignalActions and BroadcastSignalActions, argument InputPins are matched to Properties of the Signal being 
sent by order. The owned Properties of a Signal are ordered, but a Signal may also inherit Properties from other Signals 
due to Generalization relationships. In this case, the Properties of a Signal are ordered such that all owned Properties 
come before any inherited Properties. Further, if two ancestors of the Signal are related directly or indirectly by 
Generalization relationships, then the owned Properties of the more specific Signal are ordered before the owned 
Properties of the more general Signal. However, in the presence of multiple Generalization, some ancestors of the 
Signal may not have any such transitive Generalization relationship, and no standard ordering is defined between the 
Properties of such ancestors.
The target object(s) of a send Action may be local or remote. The transmitted object may be copied during transmission, 
so identity may not be preserved. The manner of transmitting the object, the amount of time required to transmit it, the 
order in which the transmissions reach various target objects and the path for reaching the target objects are all 
undefined.

450

Unified Modeling Language 2.5

16.3.3.3

Invocation Actions and Ports

A CallOperationAction, SendSignalAction, or SendObjectAction may send a request through a Port by targeting an 
object having the Port and identifying the Port with the Action’s onPort attribute. Other kinds of InvocationActions shall 
not have a value for the onPort attribute.
If onPort is given, then the Port shall be an owned or inherited feature of the type of the target InputPin of the Action. 
When the Action executes, rather than sending a message to the target object itself, it sends the message through the 
given Port of the target object, which is then handled as described in sub clause 11.3.3. Such a message may be sent into
the target object from the outside, through a provided Interface of the Port, or it may be sent out of the target object from 
the inside, through a required Interface of the Port.
An Action is said to execute inside an object if the context object of the Behavior execution within which the Action is 
executing is either the same as or is directly or indirectly owned (in the sense of transitive composition links) by the 
given object. This includes, for example, when the Action is executed in a method or classifierBehavior of the given object 
or in a method or classifierBehavior of a part of that object.
In the case of a CallOperationAction, a provided or required Interface of the given Port shall have the called Operation as 
a feature. In the case of a SendSignalAction or a SendObjectAction whose object InputPin has a Signal as its type, a 
provided or required Interface of the given Port may have a Reception for the identified Signal, but this is not required. In 
either case, the relevant Operation or Reception (if any) is referred to as the invoked BehavioralFeature in the following 
rules.
•

If the invoked BehavioralFeature is on a provided Interface but not on any required Interface, then, when the 
InvocationAction is executed, the invocation is made into the object given on the target InputPin through the 
given Port, and its reception is handled as described in sub clause 11.3.3.

•

•

NOTE. This allows an InvocationAction executed inside its target object to potentially send a message back 
into the target object through a provided Interface of one of its own Ports.
If the invoked BehavioralFeature is on a required Interface but not on any provided Interface, then, if the 
InvocationAction is being executed inside the object given on the target InputPin, the invocation is forwarded 
out of the target object through the given Port as described in sub clause 11.3.3. If the InvocationAction is 
being executed other than inside the given target object, the semantics are undefined.

If the invoked BehavioralFeature is on both a provided and a required Interface or if there is no invoked 
BehavioralFeature, then, if the InvocationAction is being executed inside the object given on the target 
InputPin, the invocation is made out of the target object through the given Port. Otherwise the invocation is 
made into the target object through the given Port.

NOTE. In this case, if the InvocationAction executes inside its target object, it cannot send a message back 
into the target object, because such a message would go out through the required Interface. However, the same 
effect can be achieved by having a Connector that loops from the Port in question back to that same Port.

It is also possible to use an “interaction point” object (that is, an object instantiated in a Port) as the target object for a 
CallOperationAction, SendSignalAction, or SendObjectAction without specifying onPort. In this case, the request is 
sent directly to the interaction point and is then routed internally within the owner of the Port (as also described in sub 
clause 11.3.3). The request goes into the owner of the interaction point through one of the provided Interfaces of the 
Port.

Notation

16.3.4
The value of onPort is shown by the phrase “via <port>” in the name string of the symbol denoting the particular 
InvocationAction.

Unified Modeling Language 2.5

451

16.3.4.1

Call Behavior Actions

A CallBehaviorAction shall be notated as an Action with the name of the invoked Behavior placed inside the Action 
symbol (see Figure 16.14). If the name of the Action is non-empty and different than the Behavior name, then the Action
name shall appear in the symbol instead. preconditions and postconditions of the Behavior can be shown similarly to Figure 
16.3, but using the keywords «precondition» and «postcondition».

Figure 16.14  Calling a Behavior

The call of an Activity is indicated by placing a rake-style symbol within the Action symbol (see Figure 16.15, left). The 
rake resembles a miniature hierarchy, indicating that this invocation starts another Activity that represents a further 
decomposition. An alternative notation in the case of an invoked Activity is to show the contents of the invoked Activity 
inside a large round-cornered rectangle symbol (see Figure 16.15, right). The ActivityParameterNodes are shown on the 
border of the invoked Activity. ObjectFlows are shown as linked to the ActivityParameterNodes in the called Activity 
corresponding to the Pins of the CallBehaviorAction, even though they still link to Pins in the abstract syntax. The 
abstract syntax is the same regardless of the choice of notation. (The specific notational variant used shall be preserved 
when the diagram is interchanged, see Annex B.)

Figure 16.15  Calling an Activity

16.3.4.2

Call Operation Actions

A CallOperationAction is notated as an Action with the name of the invoked Operation placed inside the Action symbol 
(see Figure 16.16). If the name of the Action is non-empty and different than the Operation name, then the Action name 
shall appear in the symbol instead. preconditions and postconditions on the Operation can be shown similarly to Figure 
16.3, but using the keywords «precondition» and «postcondition».

Figure 16.16  Calling an Operation

The name of the owner of the Operation may optionally appear below the name of the Operation, in parentheses postfixed 
by a double colon (see Figure 16.17, left). If the Action name is shown instead of the Operation name, then the Operation
name may be shown after the double colon.

Figure 16.17  Calling an Operation, showing the owner name

452

Unified Modeling Language 2.5

16.3.4.3

Send Signal and Send Object Actions

A SendSignalAction is notated as a convex pentagon with the name of the Signal placed inside it.

Figure 16.18  Sending a Signal

If a SendObjectAction is used in a way that will always result in the sending of a Signal (e.g., the type of the object 
InputPin is a Signal), then the SendSignalAction notation can be used for the SendObjectAction.

16.3.4.4

Pin Annotations

Pins corresponding to Parameters with isException=true are shown with a small triangle annotating the source end of the 
edge that comes out of the exception pin. The annotation is the same if the standalone ObjectNode notation is used. (See
Figure 16.19.)

Figure 16.19  Exception Pin annotations

If the Parameter corresponding to a Pin has an effect specified, this is shown by placing the effect in braces near the edge 
leading to or from the Pin (see Figure 16.20).

Figure 16.20  Effect Pin annotations

Whether the Parameter corresponding to a Pin has isStreaming=true or false is shown by placing a textual annotation 
near the Pin symbol: {stream} or {nonstream}, respectively (see Figure 16.21). The annotation is the same if the 
standalone ObjectNode notation is used. {nonstream} is the default where the annotation is omitted.

Figure 16.21  Stream Pin annotations

Unified Modeling Language 2.5

453

Additional emphasis may be added for streaming Parameters by using a graphical notation instead of the textual 
adornment. A standalone Pin can be connected with arrows having filled arrowheads to indicate streaming. Otherwise, 
Pins corresponding to streaming parameters can be shown as filled rectangles. When combined with the “pins with 
arrows inside” option above, the arrows inside are shown using the color of the inside of an unfilled Pin rectangle. (See
Figure 16.22.)

Figure 16.22  Stream Pin annotations, with filled arrows and rectangles

16.3.4.5

Parameter Sets

Multiple ObjectFlows entering or leaving the Pins of an InvocationAction are typically treated as “and” conditions. 
However, sometimes one group of flows is permitted to the exclusion of another. This is modeled with ParameterSets 
and notated as rectangles surrounding one or more pins. The notation shown in Figure 16.23 expresses a disjunctive 
normal form for the inputs where one group of “and” flows are separated by “or” groupings.

Figure 16.23  Alternative input/outputs using ParameterSet notation

16.3.5

16.3.5.1

Examples

Call Behavior Actions

Figure 16.24 is an example of invoking an activity called FillOrder.

Figure 16.24  Invoking an Activity

16.3.5.2

Send Signal Actions

Figure 16.25 shows part of an order-processing workflow in which two Signals are sent. An order is created (in 
response to some previous request that is not shown in the example). A Signal is sent to the warehouse to fill and ship 
the order. Then an invoice is created and sent to the customer.

454

Unified Modeling Language 2.5

Figure 16.25  Sending Signals

16.3.5.3

Pin Annotations

In Figure 16.26, Order Filling is a continuous Behavior that periodically emits (streams out) filled-order objects, 
without necessarily completing. Order Shipping is also a continuous Behavior that periodically receives filled-order 
objects as they are produced. Order Shipping is invoked when the first order arrives and does not terminate, processing 
orders as they arrive.

Figure 16.26  Streaming Pin examples

Figure 16.27 shows an example of exception notation. Accept Payment normally completes with a payment as being 
accepted and the account is then credited. However, when something goes wrong in the acceptance process, an 
exception can be returned that the payment is not valid, and the payment is rejected.

Figure 16.27  Exception Pin examples

Figure 16.28 depicts a Place Order Action that creates orders and a Fill Order Action that reads these placed orders and 
fills them.

Figure 16.28  Pin example with effects

16.3.5.4

Parameter Sets

In Figure 16.29, the Ship Item activity begins whenever it receives a bought item or a made item.

Figure 16.29  Alternative input/outputs using ParameterSets

Unified Modeling Language 2.5

455

Object Actions
Summary

16.4
16.4.1
Object Actions deal with the creation, destruction and comparison of instances of Classifiers. They also include Actions 
to read the instances of a given Classifier, check how an instance is classified, and to change the classification of an 
instance.

16.4.2

Abstract Syntax

Action

CreateObjectAction

DestroyObjectAction
+ isDestroyLinks : Boolean = false
+ isDestroyOwnedObjects : Boolean = false

TestIdentityAction

ReadSelfAction

ValueSpecificationAction

+ createObjectAction

*

{subsets action}

{subsets action}
+ destroyObjectAction

0..1 + createObjectAction

0..1

{subsets action}
+ testIdentityAction

0..1

{subsets action}
+ testIdentityAction

{subsets action}

0..1 + testIdentityAction

0..1

{subsets action}
0..1 + readSelfAction

{subsets action}
+ valueSpecificationAction

{subsets owner}

0..1 + valueSpecificationAction

0..1

+ classifier

1

{subsets output}

+ result

1

{subsets input}

+ target

1

{subsets input}
+ first

1

{subsets input}
+ second

{subsets output}
+ result

1

1

1

Classifier

OutputPin

InputPin

OutputPin

{subsets output}
+ result

1
+ result
{subsets output}

{subsets ownedElement}

1 + value

ValueSpecification

Action

{subsets action}
+ reclassifyObjectAction

0..1

ReclassifyObjectAction

+ isReplaceAll : Boolean = false

ReadIsClassifiedObjectAction
+ isDirect : Boolean = false

ReadExtentAction

{subsets action}
+ readIsClassifiedObjectAction

StartClassifierBehaviorAction

0..1

{subsets action}

0..1 + startClassifierBehaviorAction

{subsets action}

0..1 + readIsClassifiedObjectAction

{subsets output}

1 + result
OutputPin

{subsets input}
+ object

1

InputPin

1

+ object
{subsets input}

{subsets action}
+ readExtentAction

{subsets output}
+ result

0..1

1

0..1 + readExtentAction

+ reclassifyObjectAction

*

* + reclassifyObjectAction

{subsets input}
+ object

1

+ readIsClassifiedObjectAction

*

* + newClassifier
1

Classifier

+ classifier

OutputPin

InputPin

+ oldClassifier

*

+ classifier

1

Figure 16.30  Object Actions

16.4.3

16.4.3.1

Semantics

Create Object Actions

A CreateObjectAction is an Action that creates a direct instance of a given Classifier and places the new instance on its 
result OutputPin. The Action has no other effect. In particular, no Behaviors are executed, no default value expressions 
are evaluated, and no StateMachine transitions are triggered. The new instance has no values for its StructuralFeatures 
and participates in no links.
If the Classifier being instantiated is a Behavior, then the instantiated object is an execution of that Behavior. However, 
this execution does not start automatically on instantiation. It must be explicitly started using a 
StartObjectBehaviorAction (see sub clause 16.3.3).

16.4.3.2

Destroy Object Actions

A DestroyObjectAction is an Action that destroys the object on its target InputPin. The object may be a link object, in 
which case the semantics of DestroyLinkAction also applies (see sub clause 16.6). When an object is destroyed, it is no 
longer classified under any Classifier. Other than the options described below for isDestroyLinks and 
isDestroyOwnedObjects, the Action has no other effect. In particular, no behaviors are executed, no state machine 
transitions are triggered, and references to the destroyed objects are unchanged (except see  isDestroyLinks below). The 
result of referencing an object that has been destroyed is not defined in this specification.

456

Unified Modeling Language 2.5

If isDestroyLinks is true, links in which the object participates are destroyed along with the object according to the 
semantics of DestroyLinkAction, except for link objects, which are destroyed according to the semantics of 
DestroyObjectAction with the same attribute values as the original DestroyObjectAction. If isDestroyOwnedObjects is 
true, objects owned by the object through composite aggregation are destroyed according to the semantics of 
DestroyObjectAction with the same attribute values as the original DestroyObjectAction.
Destroying an object that is already destroyed has no effect.

16.4.3.3

Test Identity Actions

A TestIdentityAction is an action that tests if the two values given on its InputPins are identical objects. If the two 
values represent the same object, the Boolean value true is placed on the result OutputPin. Otherwise the value false is 
placed on the result OutputPin.
If an object is classified solely as an instance of one or more Classes, then testing whether it is the “same object” as 
another object is based on the identity of the object, independent of the current values for its StructuralFeatures or any 
links in which it participates (see sub clause 11.4.2).
If an object is classified solely as an instance of one or more DataTypes, then testing whether it is the “same object” as 
another object is based on whether it has the same value (see sub clause 10.2.3). For a PrimitiveType, equality of value 
is determined by the definition of the type, outside of UML. For an Enumeration, an EnumerationLiteral is equal to 
another value if it is the same EnumerationLiteral. Otherwise, an instance of a DataType is equal to another value if it is 
a direct instance of the same DataType with identical values for corresponding attributes (with “identical values” 
determined recursively as in a Test Identity Action).
The result of a TestIdentityAction for objects that are classified by both Classes and DataTypes, or by other kinds of 
Classifiers, is not defined, but, in all cases the Action produces a Boolean result.

16.4.3.4

Read Self Actions

A ReadSelfAction is an Action that places the context object of the Action execution on its result OutputPin. (See sub 
clause 16.2.3 about context objects.)
For example, if a ReadSelfAction is contained in a Behavior that is the method of an Operation, then the context object 
it returns will be the instance of the owning Classifier of the Operation that was the target of the Operation invocation. 
However, if the ReadSelfAction is contained in a Behavior not owned by any BehavioredClassifier, then the context 
object will be the instance of the Behavior in which the Action is executing.

16.4.3.5

Value Specification Actions

A ValueSpecificationAction is an Action that evaluates a ValueSpecification and places the resulting value on its result 
OutputPin. See Clause 8 on the semantics of evaluating ValueSpecifications. In particular, a LiteralSpecification may be 
used in a ValueSpecificationAction to produce a constant value. Also see sub clause 9.8 on the semantics of evaluating 
InstanceValues to produce instances of Classifiers. Using an InstanceValue in a ValueSpecificationAction is similar to 
creating an instance using a CreateObjectAction, except that values may be given for the StructuralFeatures of the 
instance using slots on the InstanceSpecification of the InstanceValue.

16.4.3.6

Read Extent Actions

A ReadExtentAction is an Action that retrieves the objects in the current extent of a Classifier and places them on its 
result OutputPin. The extent of a classifier is the set of all instances of a Classifier (including instances of any 
specializations) that exist at any one time.
It is not generally practical for implementations of ReadExtentAction to produce all the instances of the Classifier that 
exist everywhere. An execution engine typically manages only a limited subset of the instances of any Classifier, 
usually corresponding to those instances within the model execution scope (see sub clause 6.3.1), but it may manage 
multiple distributed extents for any one Classifier. It is not defined which managed extent is actually read by a 
ReadExtentAction.

Unified Modeling Language 2.5

457

16.4.3.7

Reclassify Object Actions

A ReclassifyObjectAction is an Action that changes which Classifiers classify the object given on its object InputPin. It 
may both add and remove Classifiers from the object. Multiple Classifiers may be added and removed at one time.
After the Action completes, the input object is classified by each newClassifier and no oldClassifier. If the object was 
previously classified by any Classifier that is not an oldClassifier, then it is still classified by that Classifier. Neither 
specifying a newClassifier that duplicates an already existing Classifier, specifying an oldClassifier that is not classifying 
the input object, nor specifying a Classifier as both a newClassifier and an oldClassifier has any effect. A newClassifier shall 
not be abstract.
The identity of the input object is preserved, no behaviors are executed, and no default value expressions are evaluated. 
The newClassifiers replace existing classifiers in an atomic step, so that structural feature values and links are not lost 
during the reclassification when the oldClassifiers and newClassifiers have structural features and associations in 
common.
If isReplaceAll is true, then all existing Classifiers for the object are removed before the newClassifiers are added, except 
if a newClassifier already classifies the input object, in which case this Classifier is not removed.
The effect of removing all Classifiers from an object and not adding any new ones is not defined.

16.4.3.8

Read-Is-Classified-Object Actions

A ReadIsClassifiedObjectAction is an Action that determines whether the object given on its object InputPin is classified 
by a given Classifier. If it is so classified, then a Boolean true value is placed on the result OutputPin. Otherwise a false 
value is placed on the result OutputPin.
If isDirect is true, then the test is whether the object is directly classified by the specified Classifier and not by any 
specializations of it. If isDirect is false, then the object may be classified by the specified Classifier or any (direct or 
indirect) specialization of it.

16.4.3.9

Start Classifier Behavior Actions

A StartClassifierBehaviorAction is an Action that starts the execution of the classifierBehavior of the object given on its 
object InputPin. The Action completes as soon as the execution of the Behavior has started, after which the Behavior 
executes asynchronously. If the Behavior is already executing, or if the given object is not classified by a Classifier with 
a classifierBehavior, the StartClassifierBehaviorAction has no effect.
NOTE. StartClassifierBehaviorAction is provided for compatibility with older versions of UML. It is generally 
preferable to use a StartObjectBehaviorAction instead of a StartClassifierBehaviorAction, as a 
StartObjectBehaviorAction allows for the passing of Parameter values and for synchronous invocation (see sub clause
16.3).

Notation

16.4.4
A ValueSpecificationAction is labeled with its ValueSpecification, as shown in Figure 16.31.

Figure 16.31  ValueSpecificationAction notation

There is no specific notation defined for other kinds of object actions.

Examples

16.4.5
Figure 16.32 shows ValueSpecificationActions used to output a constant from an activity.

458

Unified Modeling Language 2.5

Figure 16.32  ValueSpecificationActions

Link End Data
Summary

16.5
16.5.1
Links (instances of Associations) that are not link objects (instances of AssociationClasses) cannot be passed as runtime 
values to or from an Action. Instead, a link is identified by the values on its ends. LinkEndData is a specification of such 
values for one end of a link, used in the identification of links by LinkActions (as further described in sub clause 16.6).

16.5.2

Abstract Syntax

Element

+ value

1

InputPin

+ value
0..1

0..1 + qualifierValue

+ linkEndData

0..1

QualifierValue

{subsets ownedElement}
+ qualifier

*

* + qualifierValue

{subsets owner}
+ linkEndData
1

LinkEndData

+ linkEndData

*

+ qualifier

1

Property

+ end
1

LinkEndCreationData

LinkEndDestructionData

+ isReplaceAll : Boolean = false

+ isDestroyDuplicates : Boolean = false

+ linkEndCreationData

0..1

0..1

+ linkEndDestructionData

+ insertAt

0..1

InputPin

+ destroyAt

0..1

Figure 16.33  Link End Data

16.5.3

16.5.3.1

Semantics

Link End Data

LinkEndData is an Element that specifies the inputs to be used to match the values on one end of a link. Each 
Association end is identified separately with a LinkEndData element.
Each LinkEndData element has three parts:

Unified Modeling Language 2.5

459

1

Identification of the end of the link that is being matched. This Property must be a memberEnd of an Association 
(see sub clause 11.4).

2 A value InputPin providing the value that is expected on the given end of the link. This InputPin has the same 
type as the given end and multiplicity 1..1. Having a value InputPin is optional, to allow for the specification of 
an “open end” on a ReadLinkAction (see sub clause 16.6).

3 Optional QualifierValues identifying InputPins that provide the expected value of qualifiers of the given end of 
the link. The qualifier Properties must be qualifiers of the end Property (see sub clause 9.5). The InputPin has the 
same type as the given qualifier and multiplicity 1..1.

16.5.3.2

Link End Creation Data

LinkEndCreationData is a specialized kind of LinkEndData used to identify one end of a link to be created by 
CreateLinkAction (see sub clause 16.6). In addition to what is included in regular LinkEndData, LinkEndCreationData 
includes the following:

• An isReplaceAll option that, if true, specifies that the new link replaces all links that previously matched the 

values at this end.

•

If the given end is ordered, then an insertAt InputPin, with a type of UnlimitedNatural and a multiplicity of 1..1, 
must be specified to provide the insertion point of the new link in the ordered values on this end. (See sub 
clause 16.6 for more about insertAt.)

16.5.3.3

Link End Destruction Data

LinkEndDestructionData is a specialized kind of LinkEndData used to identify one end of a link to be destroyed by 
DestroyLinkAction (see sub clause 16.6). In addition to what is included in regular LinkEndData, 
LinkEndDestructionData includes the following:

• An isDestroyDuplicates option that, if true, specifies that all links matching the values on this end shall be 

destroyed.

•

If the given end is ordered and non-unique, and isDestroyDuplicates=false, then a destroyAt InputPin, with a type 
of UnlimitedNatural and a multiplicity of 1..1, must be specified to provide a value for the position in this end 
of the link to be destroyed. (See sub clause 16.6 for more about destroyAt.)

Notation

16.5.4
There is no specific notation for LinkEndData.

Examples

16.5.5
None.

Link Actions
Summary

16.6
16.6.1
LinkActions (and ClearAssociationAction) operate on Associations and their instances, links. This includes 
Associations that are AssociationClasses (but see also sub clause 16.7 for LinkObjectActions that operate specifically 
on instances of AssociationClasses).

460

Unified Modeling Language 2.5

16.6.2

Abstract Syntax

Action

{subsets ownedElement}

LinkEndData

+ endData

2..*

{subsets owner}
+ linkAction

LinkAction

ClearAssociationAction

+ clearAssociationAction

1

{subsets action}
+ linkAction

0..1

0..1
{subsets action}

0..1 + clearAssociationAction

ReadLinkAction

WriteLinkAction

+ inputValue
{subsets input}

1..*

{subsets input}
+ object

1

1 + association

InputPin

Association

{subsets action}
+ readLinkAction

0..1

{subsets output}
+ result

1

OutputPin

CreateLinkAction

DestroyLinkAction

{redefines linkAction}
+ createLinkAction

1

{redefines endData}
+ endData

2..*

{redefines linkAction}

1 + destroyLinkAction

{redefines endData}

2..* + endData

LinkEndCreationData

LinkEndDestructionData

Figure 16.34  Link Actions

16.6.3

16.6.3.1

Semantics

Link Actions

A LinkAction is an Action that reads, creates, or destroys links of an Association, which may be an AssociationClass. 
The links acted on are identified using LinkEndData, which specifies the values expected on the ends of those links (see 
sub clause 16.5). All the ends of the LinkEndData elements of a LinkAction must be memberEnds of the same 
Association. All the InputPins identified in the LinkEndData elements of a LinkAction must be inputValue InputPins of 
the LinkAction. The semantics are undefined for Associations that have an end with isStatic=true.

16.6.3.2

Read Link Actions

A ReadLinkAction is a LinkAction that retrieves values on one end of an Association (given the values on all the other 
ends) and places them on its result OutputPin. The end being read is called the open end for the ReadLinkAction. 
Exactly one endData element for a ReadLinkAction must not have a value InputPin identified, and its corresponding end 
is the open end. The semantics are undefined for reading a link whose open end is not navigable or is not visible from 
the context Classifier of the ReadLinkAction or from the containing Behavior, if there is no context Classifier (see sub 
clause 16.2.3 about context objects).
When a ReadLinkAction executes, it identifies the subset of all existing links of the Association that match the endData 
object values and qualifier values for all ends other than the open end and any qualifier values given for the open end. 
The values placed on the result OutputPin are the ones on the open end of this subset of links. If the open end is ordered, 
then values are placed onto the result OutputPin in order. If there are no matching links, then the ReadLinkAction 
produces a single null token on its result OutputPin.
The result OutputPin of a ReadLinkAction must have the same type and ordering as the open end. The multiplicity of 
the open end must be compatible with that of the OutputPin, but they do not have to be the same. For example, a 
modeler can set the multiplicity of the result Pin to support multiple values even when the open end only allows a single 
value (this way, the ReadLinkAction as modeled will be unaffected by changes in the multiplicity of the open end).

Unified Modeling Language 2.5

461

16.6.3.3

Create Link Action

A CreateLinkAction is a LinkAction for creating links. It has no OutputPin, because links are not necessarily values that 
can be passed to and from Actions. A CreateLinkAction may also be used to create a link object, though there is no 
output value in this case, either. (The CreateLinkAction does not need to be changed if the Association is changed to an 
AssociationClass, or vice versa.) The semantics of CreateLinkObjectAction applies to creating link objects with 
CreateLinkAction (see sub clause 16.7).
CreateLinkAction uses a specialization of LinkEndData called LinkEndCreationData. It supports the destruction of 
existing links of the Association that connect any of the objects of the new link. When the link is created, this 
isReplaceAll option is available on an end-by-end basis, and causes all links of the association from the specified ends to 
be destroyed before the new link is created. If the link being created already exists, then it is not destroyed under this 
option. If all the Association ends are unordered and unique, creating a link between objects that are already linked by 
the same Association has no effect.
Associations with ordered ends are supported with an insertion point specified at runtime by an additional insertAt 
InputPin on LinkEndCreationData, which is required for ordered Association ends when isReplaceAll is false and omitted 
for unordered ends.
NOTE. Association ends may be ordered even if the upper multiplicity is 1.
The insertAt Pin is of type UnlimitedNatural with multiplicity of 1..1. An insertion point that is a positive integer less than 
or equal to the current number of links means to insert the new link at that position in the sequence of existing links, 
with the integer 1 meaning the new link will be first in the sequence. A value of unlimited (“*”) for the insertion point 
means to insert the new link at the end of the sequence. The semantics are undefined for a value of 0 and for an integer 
greater than the number of existing links. Reinserting an existing link at a new position in an ordered, unique end moves 
the link to that position.
The semantics is undefined for creating a link for an Association that is abstract. The semantics is undefined for creating 
a link that violates the upper multiplicity of one of its Association ends. A new link violates the upper multiplicity of an 
end if the cardinality of that end after the link is created would be greater than the upper multiplicity of that end. The 
cardinality of an end is defined in 11.5.3.
The semantics is undefined for creating a link that has an Association end with isReadOnly=true after initialization of the 
other end objects, unless the link being created already exists (in which case the CreateLinkAction has no effect). Links 
may be created as long as the objects that will participate in the new links across from all read-only ends are still being 
initialized. This means that Associations with two or more read-only ends cannot have links created unless all the 
objects to be linked are being initialized.

16.6.3.4

Destroy Link Actions

A DestroyLinkAction is an Action that destroys links matching specified LinkEndData. If there are no matching links, 
then the DestroyLinkAction has no effect.
A DestroyLinkAction may also be used to destroy link objects, though the objects to destroy are still specified in the 
same way, using LinkEndData. (The DestroyLinkAction thus does not need to be changed if the Association is changed 
to an AssociationClass, or vice versa.) The semantics of DestroyObjectAction applies to destroying a link object with 
DestroyLinkAction.
DestroyLinkAction uses a specialization of LinkEndData called LinkEndDestructionData. It supports destruction of 
duplicate links of Association on ends that are non-unique. This isDestroyDuplicates option is available on an end-by-end 
basis, and causes all duplicate links of the Association from the specified ends to be destroyed.
Associations with ordered, non-unique ends are supported by a deletion position specified at runtime by an additional 
destroyAt InputPin on LinkEndDestructionData, which is required for ordered, non-unique Association ends when 
isDestroyDuplicates is false, and omitted for other ends. The destroyAt Pin is of type UnlimitedNatural with multiplicity of 
1..1. A deletion position that is a positive integer less than or equal to the current number of links means to destroy the 
link at that position in the sequence of existing links, with the integer 1 meaning the first link in the sequence. The 
semantics are undefined for a value of 0,an integer greater than the number existing links, and unlimited (“*”).

462

Unified Modeling Language 2.5

The semantics are undefined for destroying a link that has an Association end with isReadOnly = true after initialization 
of the other end objects, unless no link matches the endData (in which case the DestroyLinkAction has no effect). Links 
may be destroyed as long as the objects participating in the links across from all read-only ends are still being 
initialized. This means links with two or more read-only ends cannot be destroyed, unless all the participating objects 
are being initialized.

16.6.3.5

Clear Association Actions

A ClearAssociationAction is an Action that destroys all links of an Association in which a particular object participates, 
including link objects of an AssociationClass. The Association to be cleared is statically specified. The 
ClearAssociationAction has an InputPin for a runtime object that must be of the same or more specialized type as at 
least one of the memberEnds of the Association. All links of the Association that have the given object on any end are 
destroyed, even when this violates the minimum multiplicity of any of the Association ends. The semantics of 
DestroyObjectAction applies to destroying link objects with ClearAssociationAction.

Notation

16.6.4
No specialized notation is defined for LinkActions or ClearAssociationActions.

Examples

16.6.5
None.

Link Object Actions
Summary

16.7
16.7.1
Link object Actions operate on link objects, which are instances of AssociationClasses. LinkActions also operate on link 
objects, but identify them differently (see sub clause 16.7).

Unified Modeling Language 2.5

463

16.7.2

Abstract Syntax

Action

+ readLinkObjectEndAction
0..1

ReadLinkObjectEndAction

ReadLinkObjectEndQualifierAction

+ readLinkObjectEndQualifierAction

0..1

{subsets action}
+ readLinkObjectEndAction

0..1

+ end

1

Property

{subsets action}

{subsets action}
+ readLinkObjectEndQualifierAction

0..1

{subsets action}

0..1 + readLinkObjectEndQualifierAction

1 + qualifier

Property

0..1 + readLinkObjectEndAction

{subsets input}
+ object
1

{subsets output}
+ result
1

InputPin

1

OutputPin

{subsets input}
+ object

{subsets output}
+ result
1

{subsets output}

1 + result

{subsets action}

0..1 + createLinkObjectAction

CreateLinkObjectAction

CreateLinkAction

Figure 16.35  Link Object Actions

16.7.3

16.7.3.1

Semantics

Read Link Object End Actions

A ReadLinkObjectEndAction is an action that retrieves an end object from a link object. The AssociationClass end from 
which to retrieve the object is specified statically. The link object to be read is given on the object InputPin. The value of 
the specified end of the link object is placed on the result OutputPin.
NOTE. This is not the same as reading links of the link object’s Association with the specified end as the open end (as 
described for ReadLinkAction in sub clause 16.6). The link object being read is identified like any other object, rather 
than by the values of link ends, as in in ReadLinkAction. There is exactly one object at each end of a link object, even if 
the multiplicity of the end is different from 1..1 in the Association. This is why the result OutputPin of a 
ReadLinkObjectEndAction always has a multiplicity of 1..1.

16.7.3.2

Read Link Object End Qualifier Actions

A ReadLinkObjectEndQualifierAction is an action that retrieves a qualifier end value from a link object. The qualifier 
whose value is to be retrieved is specified statically. The owner of the qualifier must be an end of an AssociationClass. 
The link object to be read is given on the object InputPin. The value of the specified qualifier for the given link object is 
placed in the result OutputPin.

16.7.3.3

Create Link Object Actions

A CreateLinkObjectAction is a specialized CreateLinkAction (see sub clause 16.6) for creating a link object (an 
instance of an AssocationClass). A CreateLinkObjectAction has the same semantics for link creation as a 
CreateLinkAction, except that its endData must be for an AssociationClass and the new link is a link object that is placed 
on the result OutputPin. If a link object matching the given endData already exists, and all the Association ends are 
unique, then this is placed on the result OutputPin, and no new link object is created.

464

Unified Modeling Language 2.5

Notation

16.7.4
No specialized notation is defined for Actions that operate on link objects.

Examples

16.7.5
None.

Structural Feature Actions
Summary

16.8
16.8.1
StructuralFeatureActions support the reading and writing of StructuralFeatures.

16.8.2

Abstract Syntax

StructuralFeature

1

+ structuralFeature

*
+ structuralFeatureAction

Action

StructuralFeatureAction

{subsets action}
+ structuralFeatureAction
0..1

{subsets input}
+ object
1

InputPin

ReadStructuralFeatureAction

+ writeStructuralFeatureAction
0..1

WriteStructuralFeatureAction

{subsets action}
+ readStructuralFeatureAction

0..1

{subsets action}

{subsets output}
+ result

1

OutputPin

AddStructuralFeatureValueAction
+ isReplaceAll : Boolean = false

{subsets action}

0..1 + addStructuralFeatureValueAction

{subsets input}
+ value

0..1

{subsets input}

0..1 + insertAt

{subsets action}
+ writeStructuralFeatureAction

0..1

ClearStructuralFeatureAction

{subsets action}

0..1 + clearStructuralFeatureAction

{subsets output}
+ result
0..1

{subsets output}

0..1 + result

OutputPin

InputPin

+ removeAt
0..1

{subsets input}

0..1
+ removeStructuralFeatureValueAction
{subsets action}

RemoveStructuralFeatureValueAction
+ isRemoveDuplicates : Boolean = false

Figure 16.36  Structural Feature Actions

16.8.3

16.8.3.1

Semantics

Structural Feature Actions

A StructuralFeatureAction is given a statically-specified StructuralFeature of a Classifier, and an object on which to act 
on its object InputPin. This object is either an instance (direct or indirect) of the Classifier that owns the 
StructuralFeature or, if the StructuralFeature is an ownedEnd of a binary Association, an instance of the type of the 
opposite end of the Association. If the StructuralFeature is an Association end, then a StructuralFeatureAction has the 
same semantics as a LinkAction on an Association that has the StructuralFeature as an end (see specializations of 
StructuralFeatureAction). The semantics are undefined if the StructuralFeature is not visible from the context Classifier 
of the StructuralFeatureAction or from the containing Behavior, if there is no context Classifier (see sub clause 16.2.3 
about context objects), or if the StructuralFeature has isStatic=true.
The StructuralFeatures and Associations in which an object participates may change over time due to dynamic 
classification (see ReclassifyObjectAction in sub clause 16.4). However, the type of the object InputPin of a 
StructuralFeatureAction is a single Classifier, and the semantics are defined only when the object passed to the Action is 
classified by that Classifier (directly or indirectly) at the time the Action accepts it and while the Action is executing. 
The StructuralFeature is referenced from a StructuralFeatureAction as a model Element, so it is uniquely identified, 
even if there are other StructuralFeatures of the same name on other Classifiers.

Unified Modeling Language 2.5

465

A ReadStructuralFeatureAction reads the values of a StructuralFeature and places these values on its result OutputPin. 
The other kinds of StructuralFeatureActions, WriteStructuralFeatureActions (including 
AddStructuralFeatureValueActions and RemoveStructuralFeatureValueActions) and ClearStructuralFeatureActions 
modify the values of a StructuralFeature. These Actions may optionally have a result OutputPin. If a result OutputPin is 
provided, then the input object, as modified, is placed on this OutputPin. If the input object is a data value (an instance 
of a DataType), then a copy of the input data value is placed on the output pin, but with the appropriate structural feature 
modified. As a data value does not have an independent identity, the only way to obtain the modified data value is 
through the use of the result OutputPin.

16.8.3.2

Read Structural Feature Actions

A ReadStructuralFeatureAction is a StructuralFeatureAction that retrieves the values of a StructuralFeature and places 
them on its result OutputPin. If the StructuralFeature is ordered, then the values are placed on the OutputPin in order. If 
the StructuralFeature is an Association end, the semantics are the same as a ReadLinkAction with the StructuralFeature 
as the open end (see sub clause 16.6). If there are no retrieved values (that is, the StructuralFeature is empty), then a 
ReadStructuralFeatureAction produces a single null token on its result OutputPin.
The type and ordering of the result OutputPin are the same as those of the StructuralFeature. The multiplicity of the 
StructuralFeature must be compatible with the multiplicity of the result OutputPin, but does not have to be the same. For 
example, the modeler can set the multiplicity of this OutputPin to support multiple values even when the 
StructuralFeature only allows a single value (this way, the ReadStructuralFeatureAction as modeled will be unaffected 
by changes in the multiplicity of the StructuralFeature).

16.8.3.3

Add Structural Feature Value Actions

An AddStructuralFeatureValueAction is a StructuralFeatureAction for adding a value to a StructuralFeature of an 
object. The value to be added is given on the value InputPin, which is required. This InputPin has the same type as the 
StructuralFeature and a multiplicity of 1..1 (that is, a single value is added). If the StructuralFeature is an Association 
end, the semantics are the same as for a CreateLinkAction (see sub clause 16.6), where the participants in the link are 
the object being acted on and the new value.
If isReplaceAll is true, then the existing values of the StructuralFeature are removed before the new value is added, except 
if the StructuralFeature already contains the new value, in which case it is not removed under this option. The 
StructuralFeature always has a single value when the Action completes, even if the lower multiplicity of the 
StructuralFeature is greater than 1. If isReplaceAll is false and the StructuralFeature is unordered and unique, then adding 
a value that is already contained in the StructuralFeature has no effect.
Adding a value to an ordered StructuralFeature requires an insertion point for the new value given in the insertAt 
InputPin, which is required for ordered StructuralFeatures when isReplaceAll is false and omitted for unordered 
StructuralFeatures.
NOTE. Values of StructuralFeatures may be ordered even if the upper multiplicity is 1.
If the insertAt InputPin is present, it has type UnlimitedNatural and multiplicity 1..1. An insertion point that is a positive 
integer less than or equal to the current number of values means to insert the new value at that position in the sequence 
of existing values, with the integer 1 meaning the new value will be first in the sequence. A value of unlimited (“*”) for 
the insertion point means to insert the new value at the end of the sequence. The semantics are undefined for a value of 
0 or an integer greater than the number of existing values. Reinserting an existing value at a new position in an ordered, 
unique StructuralFeature moves the value to that position (this works because such StructuralFeature values are ordered 
sets). The insertion point is ignored if it is used when isReplaceAll=true.
The semantics are undefined for adding a value that violates the upper multiplicity of the StructuralFeature, and for 
adding a new value to a StructuralFeature with isReadonly=true after initialization of the object that would have the 
value.

466

Unified Modeling Language 2.5

16.8.3.4

Remove Structural Feature Value Actions

A RemoveStructuralFeatureValueAction is a StructuralFeatureAction for removing a value from a StructuralFeature of 
an object. If the feature is an Association end, the semantics are the same as for DestroyLinkAction, where the 
participants in the link are the object and the value being removed.
Except as given below, the value to be removed is given on the value InputPin, which has the same type as the 
StructuralFeature and a multiplicity of 1..1. The value is removed even when this results in a violation of the lower 
multiplicity of the StructuralFeature. Removing a value that is not contained in the StructuralFeature has no effect. The 
isRemoveDuplicates option indicates whether to remove all duplicates of the specified value in non-unique 
StructuralFeatures.
If isRemoveDuplicates is false and the StructuralFeature is ordered and non-unique, then there is no value InputPin, and 
the value to be removed is instead specified by giving its position on the removeAt InputPin, which has type 
UnlimitedNatural and a multiplicity of 1..1. A removal position that is a positive integer less than or equal to the current 
number of values means to remove the value at that position in the sequence of existing values, with the integer 1 
meaning the first value in the sequence. The semantics are undefined for 0, an integer greater than the number of 
existing values, and unlimited (“*”).
The semantics are undefined for removing an existing value of a StructuralFeature with readOnly=true after initialization 
of the owning object.

16.8.3.5

Clear Structural Feature Actions

A ClearStructuralFeatureAction is a StructuralFeatureAction that removes all values of a StructuralFeature, even if 
lower multiplicity of the StructuralFeature is greater than 0. The action has no effect if the StructuralFeature has no 
values. If the StructuralFeature is an Association end, the semantics are the same as for a ClearAssociationAction on the 
given object.
The semantics are undefined for a StructuralFeature with isReadOnly = true after initialization of the object owning the 
StructuralFeature, unless the StructuralFeature has no values.

Notation

16.8.4
No specialized notation is defined for StructuralFeatureActions.

Examples

16.8.5
None.

Variable Actions
Summary

16.9
16.9.1
VariableActions support the reading and writing of Variables.

Unified Modeling Language 2.5

467

16.9.2

Abstract Syntax

Action

ReadVariableAction

{subsets action}

0..1 + readVariableAction

{subsets output}
+ result

1

OutputPin

VariableAction

+ variableAction

*

+ variable
1

Variable

{subsets action}
+ writeVariableAction
0..1

WriteVariableAction

ClearVariableAction

AddVariableValueAction

RemoveVariableValueAction

+ isReplaceAll : Boolean = false

+ isRemoveDuplicates : Boolean = false

{subsets action}

0..1 + addVariableValueAction

{subsets action}

0..1 + removeVariableValueAction

{subsets input}

0..1 + insertAt

InputPin

{subsets input}
+ removeAt

0..1

{subsets input}
+ value
0..1

Figure 16.37  Variable Actions

16.9.3

16.9.3.1

Semantics

Variable Action

A VariableAction operates on a statically-specified Variable. The Variable must be one that is defined either by an 
Activity (see sub clause 15.2) or a StructuredActivityNode (see sub clause 16.11) containing the VariableAction.

16.9.3.2

Read Variable Actions

A ReadVariableAction is a VariableAction that retrieves the values of a Variable and places them on its  result OutputPin. 
If the Variable is ordered, then the values are placed on the OutputPin in order. If there are no retrieved values (that is, 
the Variable is empty), then a ReadVariableAction produces a single null token on its result OutputPin.
The type and ordering of the result OutputPin are the same as those of the Variable. The multiplicity of the Variable must 
be compatible with the multiplicity of the result OutputPin, but does not have to be the same. For example, the modeler 
can set the multiplicity of this OutputPin to support multiple values even when the Variable only allows a single value 
(this way, the ReadVariableAction as modeled will be unaffected by changes in the multiplicity of the Variable).

16.9.3.3

Add Variable Value Action

An AddVariableValueAction is a VariableAction for adding a value to a Variable. The value to be added is given on the 
value InputPin, which is required. This InputPin has the same type as the Variable and a multiplicity of 1..1 (that is, a 
single value is added).

468

Unified Modeling Language 2.5

If isReplaceAll is true, then the existing values of the Variable are removed before the new value is added, except if the 
Variable already contains the new value, in which case it is not removed under this option. The Variable always has a 
single value when the Action completes, even if the lower multiplicity of the Variable is greater than 1. If isReplaceAll is 
false and the Variable is unordered and unique, then adding a value that is already contained in the Variable has no 
effect.
Adding a value to an ordered Variable requires an insertion point for the new value using the insertAt InputPin, which is 
required for ordered Variable when isReplaceAll is false and omitted for unordered Variable (values of a Variable may be 
ordered or unordered, even if the multiplicity upper bound is 1.) If the insertAt InputPin is present, it has type 
UnlimitedNatural and multiplicity 1..1. An insertion point that is a positive integer less than or equal to the current 
number of values means to insert the new value at that position in the sequence of existing values, with the integer 1 
meaning the new value will be first in the sequence. A value of unlimited (“*”) for the insertion point means to insert 
the new value at the end of the sequence. The semantics are undefined for a value of 0 or an integer greater than the 
number of existing values. Reinserting an existing value at a new position in an ordered, unique Variable moves the 
value to that position (this works because such Variable values are ordered sets). The insertion point is ignored if it is 
used when isReplaceAll=true.
The semantics are undefined for adding a value that violates the upper multiplicity of the Variable.

16.9.3.4

Remove Variable Value Actions

A RemoveVariableValueAction is a VariableAction for removing a value from a Variable.
The value to be removed is given on the value InputPin, which has the same type as the Variable and a multiplicity of 
1..1. The value is removed even when this results in a violation of the lower multiplicity of the Variable. Attempting to 
remove a value that is not contained in the Variable has no effect. The isRemoveDuplicates option indicates whether to 
remove all duplicates of the specified value in non-unique Variables.
If isRemoveDuplicates is false and the Variable is ordered and non-unique, then there is no value InputPin, and the value to 
be removed is specified by giving its position on the removeAt InputPin, which has type UnlimitedNatural and a 
multiplicity of 1..1. A removal position that is a positive integer less than or equal to the current number of values 
means to remove the value at that position in the sequence of existing values, with the integer 1 meaning the first value 
in the sequence. The semantics are undefined for 0, an integer greater than the number of existing values, and unlimited 
(“*”).

16.9.3.5

Clear Variable Actions

A ClearVariableAction is a VariableAction that removes all values of a Variable, even if the lower multiplicity of the 
Variable is greater than 0. The action has no effect if the Variable has no values.

Notation

16.9.4
The presentation option at the top of Figure 16.38 may be used as notation for abstract syntax corresponding to the 
notation at the bottom of the figure. If the AddVariableValueAction has isReplaceAll=true, this can be shown with the 
textual annotation {replaceAll} near the variable name.

Figure 16.38  Presentation option for AddVariableValueAction

Unified Modeling Language 2.5

469

Examples

16.9.5
None.

Summary

16.10  Accept Event Actions
16.10.1
An AcceptEventAction waits for the occurrence of one or more Events. If an accepted Event occurrence is for a 
CallEvent, then a ReplyAction may be used to reply to it. If an accepted Event occurrence is for a SignalEvent, then the 
received Signal instance may either be unmarshalled immediately into its attribute values, or this may be done later 
using an UnmarshallAction.

16.10.2

Abstract Syntax

Action

0..1

AcceptEventAction

{subsets owner}
+ acceptEventAction

+ isUnmarshall : Boolean = false

0..1

+ replyAction
0..1

+ acceptEventAction
{subsets action}

{subsets ownedElement}

AcceptCallAction

+ trigger
1..*

{subsets action}
0..1 + acceptCallAction

Trigger

{ordered,
subsets output}
+ result

*

{subsets output}

1 + returnInformation

OutputPin

{ordered, subsets output}
+ result

1..*

Figure 16.39  Accept Event Actions

16.10.3

Semantics

16.10.3.1

Accept Event Action

ReplyAction

UnmarshallAction

{subsets action}
+ unmarshallAction

{subsets action}
+ replyAction

0..1

{subsets action}

0..1 + replyAction

0..1

* + unmarshallAction

{subsets action}
+ unmarshallAction

0..1

+ replyToCall
1

{ordered,
subsets input}
+ replyValue

*

1

{subsets input}
+ returnInformation

InputPin

1
+ object
{subsets input}

1 + unmarshallType

Classifier

AcceptEventAction is an Action with Triggers for one or more Events. When an AcceptEventAction is executed, it 
waits for an Event occurrence to be dispatched from the event pool of the context object for its execution that matches 
one of its Triggers. The context object for an AcceptEventAction is the context object of the Behavior execution within 
which the AcceptEventAction is executing (which may be the Behavior execution itself, see sub clause 13.2.3). An 
AcceptEventAction is a wait point in the sense discussed in sub clause 13.3.3
 , except only the AcceptEventAction 
waits, rather than the whole Activity (Activities can have other Actions executing while AcceptEventActions are 
waiting).
If a matching Event occurrence for an AcceptEventAction is dispatched from the event pool, then the 
AcceptEventAction is enabled to continue. However, if the containing Behavior execution has more than one waiting 
Trigger that matches the Event occurrence, only one of them will be selected to actually trigger. If the Trigger on the 
AcceptEventAction is chosen, then it completes and produces output on any result OutputPins.
An AcceptEventAction with a trigger for a SignalEvent is informally called an accept signal action. If an accept signal 
action has isUnmarshall=false, then it must have a single result OutputPin on which the Signal instance associated with an 

 

470

Unified Modeling Language 2.5

accepted SignalEvent occurrence is placed. If it has isUnmarshall=true, then it must have result OutputPins corresponding 
to each of the attributes of the Signal of the SignalEvent (in order), and the attribute values of the Signal instance 
associated with an accepted SignalEvent occurrence are placed on these OutputPins.
An AcceptEventAction with a trigger for a TimeEvent is informally called a wait time action. A wait time action must 
have a single result OutputPin. When it accepts a TimeEvent occurrence, then the time value of when the occurrence 
transpired is placed on the result OutputPin.
If the triggers of an AcceptEventAction are all for ChangeEvents and/or CallEvents, then the AcceptEventAction has no 
result OutputPins (unless the AcceptEventAction is an AcceptCallAction, see below). If the triggers include 
SignalEvents and/or TimeEvents along with ChangeEvents and/or CallEvents, then the AcceptEventAction must have 
isUnmarshall=false and a single result OutputPin, on which a null token is placed in the case of the acceptance of an 
occurrence of a ChangeEvent or a CallEvent.
NOTE. While an AcceptEventAction can, in general, contain triggers for CallEvents, it cannot accept synchronous calls 
unless it is an AcceptCallAction (see below).
If one of the triggers of an AcceptEventAction is an AnyReceiveEvent, and the Event occurrence is for a message that is 
not matched by a SignalEvent or CallEvent trigger on the same AcceptEventAction, then the Event occurrence matches 
the trigger for the AnyReceiveEvent (see also the discussion under Message Events in sub clause 13.3.3).
If an AcceptEventAction is used in an Activity, there are special rules for when it is enabled (see sub clause 13.2.3 for a 
general discussion of the enabling of ActivityNodes). If the AcceptEventAction has no incoming edges, by the usual 
rules, it is enabled when its immediately containing Activity (or StructuredActivityNode) begins execution. However, in 
addition, an AcceptEventAction with no incoming edges remains enabled after it accepts an Event occurrence. That is, it 
does not terminate after accepting an Event occurrence and outputting any values (as described above), but continues to 
wait for another Event occurrence. Such an AcceptEventAction is terminated when its immediately containing Activity 
(or StructuredActivityNode) is terminated.

16.10.3.2

Accept Call Actions

An AcceptCallAction is an AcceptEventAction specialized for the handling of CallEvent occurrences. An 
AcceptCallAction must have a single Trigger that is for a CallEvent. It has result OutputPins corresponding to each of 
the in and inout ownedParameters of the Operation identified in the CallEvent, in order. In addition, it has a 
returnInformation OutputPin that provides the information necessary to return from a synchronous call.
An AcceptCallAction is triggered in the same way as a normal AcceptEventAction on matching CallEvent occurrences. 
The argument values associated with the call message are then placed on the result OutputPins. In addition, information 
sufficient to perform a subsequent ReplyAction (see below) is placed on the returnInformation OutputPin. The contents of 
the return information value is not defined by this specification and may only be used by a ReplyAction.
An AcceptCallAction triggered by an asynchronous call will still produce a value on its returnInformation OutputPin, but a 
ReplyAction accepting the value will complete immediately when given a return information value for an asynchronous 
call, with no effect.
NOTE. Operation referenced in the CallEvent of an AcceptCallAction should not have an associated method Behavior. 
Otherwise, a call to the Operation will have the immediate effect of executing the method and will not be placed into the 
event pool for the context object. Thus, a call to the Operation will never be dispatched to the AcceptCallAction. (See 
also the discussion of Event Dispatching in sub clause 13.3.3).

16.10.3.3

Reply Actions

A ReplyAction is an Action that completes the handling of a call that was accepted by a previous AcceptCallAction (see 
above). The two are connected by a return information value, which is produced by the AcceptCallAction in its 
returnInformation OutputPin and placed on the returnInformation InputPin of the ReplyAction by the containing Behavior 
(for example, with an ObjectFlow in an Activity). The ReplyAction also identifies a Trigger, which should be the same 
CallEvent Trigger owned by the AcceptCallAction that the ReplyAction is getting its return information value from. 
The replyValue InputPins of the ReplyAction shall correspond, in order, to the out, inout, and return ownedParameters of 
the Operation identified by the CallEvent.

Unified Modeling Language 2.5

471

When a ReplyAction executes, it generates a reply message to the original call request message, using the values from 
its replyValue InputPins. For a synchronous call, the value on its returnInformation InputPin is used to identify the caller to 
which the reply message is sent. However, if the return information value is the result of an asynchronous call, then no 
reply message is sent and the ReplyAction completes with no effect. The details of transmitting call requests, encoding 
return information, and transmitting replies are not defined in this specification.
Return information may be copied, stored in objects, and passed around, but it may only be used in a ReplyAction once. 
The semantics are undefined if the same return information value is supplied to a second ReplyAction. The semantics 
are also undefined if the return information value is not for a call to the same Operation as identified by the replyToCall 
Trigger of the ReplyAction. However, it is not intended that any profile or execution engine give any meaning to these 
undefined cases other than errors.
NOTE. If a ReplyAction is never executed on the return information from a synchronous call, then the caller will never 
receive a reply and, therefore, will never complete execution. This is not illegal, but it is usually undesirable.

16.10.3.4

Unmarshall Actions

An UnmarshallAction is an Action that retrieves the values of the StructuralFeatures of an object and places them on 
OutputPins. The object is given on the object InputPin, which has the type given by the unmarshallType Classifier and a 
multiplicity of 1..1. The UnmarshallAction then has result OutputPins that correspond, in order, to each of the Properties 
of the unmarshallType (which must have at least one attribute).
The owned Properties of a Signal are ordered, but a Classifier may also inherit Properties from other Classifiers due to 
Generalization relationships. In this case, the Properties of the unmarshallType are ordered such that all owned Properties 
come before any inherited Properties. Further, if two ancestors of the unmarshallType are related directly or indirectly by 
Generalization relationships, then the owned Properties of the more specific Classifier are ordered before the owned 
Properties of the more general Classifier. However, in the presence of multiple Generalization, some ancestors of the 
unmarshallType may not have any such transitive Generalization relationship, and no standard ordering is defined 
between the Properties of such ancestors.
When an UnmarshallAction executes, it takes the object from its InputPin, retrieves the values of the Properties of the 
unmarshallType from the object and places these values on the corresponding OutputPins. If a Property is ordered and has 
multiple values, then those values are placed in order on the corresponding OutputPin.
An UnmarshallAction is useful, for example, to obtain the attribute values of a Signal instance produced by an 
AcceptEventAction with isUnmarshall=false.

Notation

16.10.4
An AcceptEventAction in general is notated with a concave pentagon symbol (see Figure 16.40, left). The name of the 
Action may be placed within the symbol. A wait time action (i.e., an AcceptEventAction with a single TimeEvent trigger) 
is notated with an hour glass symbol (see Figure 16.40, right). The name of the Action may be placed below the symbol.

Figure 16.40  AcceptEventAction notations

16.10.5

Examples

16.10.5.1

Accept Event Actions

Figure 16.41 is an example of an accept signal action (i.e., an AcceptEventAction with a single SignalEvent trigger) that 
accepts a Signal indicating the cancellation of an order. The acceptance of the Signal causes an invocation of a 
cancellation behavior. This Action is enabled on entry to the Activity containing it, therefore it has no incoming 
ControlFlow.

472

Unified Modeling Language 2.5

Figure 16.41  Implicitly enabled AcceptEventAction

In Figure 16.42, a request payment Signal is sent after an order is processed (see sub clause 16.3.4 on the notation used 
for a SendSignalAction). The Activity then waits to receive a payment confirmed Signal. Acceptance of the payment 
confirmed Signal is enabled only after the request for payment is sent; no confirmation is accepted until then. When the 
confirmation is received, the order is shipped.

Figure 16.42  Explicitly enabled AcceptEventAction

In Figure 16.43, the end-of-month wait time action (i.e., an AcceptEventAction with a single TimeEvent trigger) 
executes at the end of the month. As there are no incoming edges to the time event action, it is enabled as long as its 
containing Activity (or StructuredActivityNode) is. It will execute at the end of every month.

Figure 16.43  Repetitive time event

16.10.5.2

Unmarshall Actions

In Figure 16.44, an order is unmarshalled into the values of its name, shipping address, and product attributes.

Figure 16.44  UnmarshallAction

 Structured Actions
Summary

16.11
16.11.1
A StructuredActivityNode is an Action that is also an ActivityGroup (see sub clause 15.6). That is, it contains 
ActivityNodes and ActivityEdges that define its behavior when executed. In addition, specialized kinds of 
StructuredActivityNodes – ConditionalNodes, LoopNodes and SequenceNodes – define specific control semantics on 
how ExecutableNodes within them are executed. sub clause 16.12 defines one further kind of StructuredActivityNode, 
the ExpansionRegion.

Unified Modeling Language 2.5

473

16.11.2

Abstract Syntax

Activity

{redefines inActivity,
redefines activity}
+ activity

0..1

{subsets ownedElement,
subsets containedNode}

ActivityNode

+ node

*

{subsets containedEdge,
subsets ownedElement}

ActivityEdge

+ edge

*

Namespace

Action

ActivityGroup

{subsets group,
subsets node}

+ structuredNode

StructuredActivityNode

+ mustIsolate : Boolean = false

*

{subsets owner,
subsets inGroup}
+ inStructuredNode

0..1

{subsets inGroup,
subsets owner}
+ inStructuredNode

0..1

{subsets namespace}

+ scope

0..1

{subsets ownedMember}

+ variable
*

Variable

0..1

{subsets input}
+ structuredNodeInput

+ structuredActivityNode
{subsets action}

*

0..1

{subsets output}
+ structuredNodeOutput

+ structuredActivityNode
{subsets action}

*

InputPin

OutputPin

{ordered, redefines
structuredNodeInput}
+ loopVariableInput

InputPin

*

{subsets
structuredActivityNode}

+ loopNode
0..1

LoopNode

SequenceNode

+ isTestedFirst : Boolean = false

{subsets inStructuredNode}

0..1 + sequenceNode

{ordered, redefines
structuredNodeOutput}

ConditionalNode

+ isAssured : Boolean = false
+ isDeterminate : Boolean = false

0..1
+ conditionalNode

{subsets owner}
+ conditionalNode

1

{subsets
structuredActivityNode}

+ result

*

{subsets ownedElement}
+ clause

1..*

Element

+ predecessorClause

Clause

*

*

+ clause

0..1

+ decider

1

+ clause

{ordered}
+ bodyOutput

+ successorClause

0..1 + clause

*
0..1 + clause

*

{ordered, subsets ownedElement}

OutputPin

+ loopVariable
*

0..1
+ loopNode
{subsets owner}

+ decider

+ loopNode

1

0..1

{ordered}
+ bodyOutput

*

+ loopNode
*

{ordered, redefines
structuredNodeOutput}
+ result
*
{subsets structuredActivityNode}
+ loopNode

+ loopNode

0..1

1..* + test

+ body

*

+ setupPart

*

+ test

1..*

* + bodyPart

ExecutableNode

Figure 16.45  Structured Actions

16.11.3

Semantics

16.11.3.1

Structured Activity Nodes

+ loopNode

0..1

0..1 + loopNode

0..1

{ordered,
redefines node}
+ executableNode

*

A StructuredActivityNode is an Action that is also an ActivityGroup (see sub clause 15.6) and whose behavior is 
specified by the ActivityNodes and ActivityEdges it so contains. Unlike other kinds of ActivityGroup, a 
StructuredActivityNode owns the ActivityNodes and ActivityEdges it contains, and so a node or edge can only be 
directly contained in one StructuredActivityNode. StructuredActivityNodes may be nested (as a 
StructuredActivityNode, as an Action, is also an ActivityNode), however, so an edge or node may be indirectly 
contained in a number of nested StructuredActivityNodes.
A StructuredActivityNode may also include the definition of Variables. These Variables may be operated on only by 
VariableActions (see sub clause 16.9) within the StructuredActivityNode and any nested StructuredActivityNodes, in 
addition to any Variables defined in any surrounding StructuredActivityNode or Activity. When a 
StructuredActivityNode begins executing, all its Variables are initially empty.
The immediately following discussion under this heading is for the semantics of a StructuredActivityNode that is not an 
instance of one of the specializations of StructuredActivityNodes. The semantics for specialized kinds of 
StructuredActivityNodes are then described in subsequent sections of this sub clause (and in sub clause 16.9 for 
ExpansionRegions).
A StructuredActivityNode is enabled and begins executing following the normal rules for an Action (see sub clause
16.2.3). None of the nodes within a StructuredActivityNode are enabled until the containing StructuredActivityNode 
begins executing (including InitialNodes and AcceptEventActions). At that point, which nodes are enabled is determined 
in the same way as for the nodes of an Activity when it begins execution (see sub clause 15.2.3). Execution then 
proceeds per the semantics of Activity models, as described in Clause 15.

474

Unified Modeling Language 2.5

The InputPins of a StructuredActivityNode may be the sources for ActivityEdges contained in the 
StructuredActivityNode. This allows tokens placed on those InputPins to be made available to ActivityNodes within the 
StructuredActivityNode. The InputPins offer their tokens on outgoing flows when the StructuredActivityNode begins 
execution.
Similarly, the OutputPins of a StructuredActivityNode may be the targets of ActivityEdges contained in the 
StructuredActivityNode. This allows tokens produced within the StructuredActivityNode to be made available as 
outputs. An OutputPin accepts tokens offered to it according to the general rules for ObjectNodes.
An ActivityEdge contained by a StructuredActivityNode must have both its source and target either be contained 
(directly or indirectly) in the StructuredActivityNode or be a Pin owned by the StructuredActivityNode. Conversely, an 
ActivityEdge that is not contained by a StructuredActivityNode may not have both its source and target contained in the 
StructuredActivityNode. ActivityEdges that cross into and out of a StructuredActivityNode are owned by a container, 
direct or indirect, of the StructuredActivityNode.
If an ActivityEdge has a source outside a StructuredActivityNode and a target within it, then any offers made on that 
edge remain pending until the StructuredActivityNode begins execution. While the StructuredActivityNode is 
executing, the target of the ActivityEdge may accept any offers pending from before the execution of the 
StructuredActivityNode, as well as any additional offers made while the StructuredActivityNode is executing, per the 
usual semantics of ActivityNodes.
If an ActivityEdge has a source inside a StructuredActivityNode and a target outside it, then no offers can be made on 
that edge unless the StructuredActivityNode is executing. During the execution of the StructuredActivityNode, any 
offers made from the ActivityEdge are immediately propagated out of the StructuredActivityNode and handled by the 
target of the edge per the usual semantics of ActivityNodes.
A StructuredActivityNode completes execution according to the same rules as for the completion of the execution of an 
Activity (see sub clause 15.2.3), including terminating execution due to an ActivityFinalNode (see sub clause 15.3.3). 
However, an ActivityFinalNode contained in a StructuredActivityNode will terminate only the immediately containing 
StructuredActivityNode and its contents, not any Activity or other StructuredActivityNodes in which that may be 
contained.
When a StructuredActivityNode completes its execution, all executions ongoing within it are terminated and all tokens 
contained in it are destroyed, except those on OutputPins of the StructuredActivityNode, which are offered on any 
outgoing edges. Tokens may accumulate on the OutputPins during the execution of the StructuredActivityNode, but they 
are only offered on outgoing edges once the execution completes. Any OutputPins that do not hold any tokens when the 
StructuredActivityNode completes offer null tokens on their outgoing edges.

16.11.3.2

Isolation

Because of the concurrent nature of the execution of Actions within and across Behaviors, it can be difficult to 
guarantee consistent access and modification of object memory. In order to avoid race conditions or other concurrency-
related problems, it is sometimes necessary to isolate the effects of a group of Actions from the effects of Actions 
outside the group. This may be indicated by setting the mustIsolate attribute to true on a StructuredActivityNode 
(including any of the specialized kinds of StructuredActivityNode).
If the mustIsolate flag is true for a StructuredActivityNode, then any access to an object by an Action within the node 
must not conflict with access to the object by an Action outside the node. A conflict is defined as an attempt to write to 
the object by one or both of the Actions. If such a conflict potentially exists, then no such access by an Action outside 
the isolated StructuredActivityNode may be interleaved with the execution of the StructuredActivityNode. This 
specification does not define the ways in which this rule may be enforced. An execution engine may achieve isolation 
using a locking mechanism, or it may simply sequentialize execution to avoid concurrency conflicts, or it may use some 
other method. If it is impossible to execute a model in accordance with these rules, then it is ill-formed.
NOTE. Isolation is different from the property of “atomicity,” which is the guarantee that a group of Actions either all 
complete successfully or have no effect at all. Atomicity generally requires a rollback mechanism to prevent committing 
partial results.

Unified Modeling Language 2.5

475

16.11.3.3

Conditional Nodes

A ConditionalNode is a StructuredActivityNode that chooses one among some number of alternative collections of 
ExecutableNodes to execute. A ConditionalNode consists of one or more Clauses, each of which represents a single 
branch of the conditional. A Clause consists of a test section and a body section, which identify disjoint subsets of the 
ExecutableNodes contained in the ConditionalNode. Any ExecutableNode in the ConditionalNode must be included in 
the test section or body section of exactly one Clause.
When a ConditionalNode begins execution, any InitialNodes within it are immediately enabled. An ExecutableNode 
contained in the ConditionalNode, however, can only become enabled when the test section or body section that contains 
it is executed, as described below. When a test or body section is executed, any ExecutableNode in the section that has 
no mandatory input data and no incoming ControlFlow with a source in the same section is enabled and receives a 
single control token. Execution then proceeds according to the usual semantics of Activities, except that any offers 
made to an ExecutableNode in a section that is not executing are not immediately delivered but remain pending. The 
target ExecutableNode may accept any pending offers if it eventually executes as part of a later execution of the section 
that contains it.
Once a ConditionalNode is executing, the test sections of any of its Clauses that have no predecessorClauses are executed 
(whether serially or concurrently or some combination is not defined). Each test section has an Action owning the 
decider OutputPin with type Boolean identified by the Clause. The result of a test section is the value placed on the 
decider OutputPin. If one or more test sections result in a true value, then the corresponding body sections are enabled for 
execution. Next, any Clauses for which all predecessorClauses have test sections that did not result in a true value have 
their test sections executed. This process continues until there are no more test sections to be executed.
NOTE. Where the execution of test sections is specified as being “concurrent” above, this means that the model does 
not impose any order on their execution. In general, such test sections may be executed in any order, including 
simultaneously (if the execution engine supports this). To enforce ordering of execution, predecessor/successor 
constraints may be specified among the Clauses of a ConditionalNode. One frequent case is a total ordering of the 
Clauses, in which case the test section execution order is determinate. If it is impossible for more than one test section to 
simultaneously result in true, then the result is deterministic anyway and it is unnecessary to order the Clauses, as 
ordering might impose undesirable and unnecessary restrictions on the implementation.
If isAssured is true for a ConditionalNode, this asserts that at least one test section will yield a true value. If isDeterminate 
is true, this asserts that at most one test section will yield a true value (the predecessorClause relationship may be used to 
enforce this assertion).
NOTE. It is impossible to automatically verify these assertions in general and it is not required to enforce them, but 
they may provide useful information to an execution engine. If the assertions are violated, then the model is ill formed.
Once the process of executing test sections finishes, if there is exactly one body section enabled for execution, that body 
section is executed. If more than one body section is enabled, only one is actually executed, but the choice of which one 
is non-deterministic. If there is no body section enabled for execution, then the execution of the ConditionalNode 
completes with no additional effect.
An “else” Clause is a Clause that is a successor to all other clauses in the ConditionalNode and whose test section 
always results in true. The body section for such a Clause will be enabled if and only if no other body section in the 
ConditionalNode is enabled. This ensures that at least one body will always be executed for the ConditionalNode.
Whenever a body section becomes enabled for execution, it may actually be executed before the completion of any 
further test section executions. In this case, any ongoing test section executions are terminated and no further test 
sections are executed. (If some test sections have external effects, terminating them may be a source of indeterminacy. 
Although test sections are permitted to have side effects, avoiding side effects in the tests reduces the chance of logical 
errors and race conditions.)
A ConditionalNode has an ordered set of result OutputPins. Each Clause of the ConditionalNode must have a matching 
set of bodyOutput OutputPins, which must identify OutputPins owned by Actions in the body section of the Clause. Every 
Clause must have a bodyOutput for each one of the result OutputPins. If the body section of a Clause is executed, then, 
once that execution completes, any tokens on the bodyOutputs of the Clause are moved to the corresponding result 
OutputPins of the ConditionalNode. The execution of the ConditionalNode then completes, and the tokens on its 

476

Unified Modeling Language 2.5

OutputPins are offered to any outgoing edges. Any OutputPins that do not hold any tokens when the 
StructuredActivityNode completes offer null tokens on their outgoing edges. If no test section of a ConditionalNode 
results in a true value, then no body section is executed, no tokens are placed on any result OutputPins, and null tokens 
are offered from all these OutputPins.
Once a ConditionalNode completes execution, all executions ongoing within it are terminated and all tokens within it 
are destroyed. If a ConditionalNode directly contains an ActivityFinalNode that accepts a token during execution of the 
ConditionalNode, then the ConditionalNode immediately completes. Only the immediately containing ConditionalNode 
is terminated in this case, not any Activity or other StructuredActivityNodes containing the ConditionalNode, per the 
rules for ActivityFinalNodes in StructuredActivityNodes.
A ConditionalNode may not have InputPins. However, ActivityEdges may cross into and out of a ConditionalNode, as 
for StructuredActivityNodes in general, and the semantics are the same (see above), except that the execution of 
ExecutableNodes within the ConditionalNode is specified by the ConditionalNode semantics described under this 
heading.

16.11.3.4

Loop Nodes

A LoopNode is a StructuredActivityNode that represents an iterative loop. A LoopNode consists of a setupPart, a test and 
a bodyPart, which identify subsets of the ExecutableNodes contained in the LoopNode. Any ExecutableNode in the 
LoopNode must be included in the setupPart, test or bodyPart for the LoopNode.
When a LoopNode begins execution, any InitialNodes within it are immediately enabled. An ExecutableNode contained 
in the LoopNode, however, can only become enabled when the setupPart, test or bodyPart section that contains it is 
executed (as described below). When a section is executed, any ExecutableNode in the section that has no mandatory 
input data and no incoming ControlFlow with a source in the same section is enabled and receives a single control 
token. Execution then proceeds according to the usual semantics of Activities, except that any offers made to an 
ExecutableNode in a section that is not executing are not immediately delivered but remain pending. The target 
ExecutableNode may accept any pending offers if it eventually executes as part of a later execution of the section that 
contains it.
The setupPart of a LoopNode is executed first. When the setupPart has completed execution, the iterative execution of the 
loop begins. Execution of the test section may precede or follow execution of the bodyPart, depending on whether 
isTestFirst is true or false, respectively. The following description assumes that the test section is executed first 
(isTestFirst=true). If the bodyPart is executed first (isTestFirst=false), it is always executed at least once, after which the 
following description applies to subsequent iterations.
The test section has an Action owning the decider OutputPin with type Boolean identified by the LoopNode. When the 
test section has completed execution, if the value on the decider OutputPin is true, then the bodyPart is executed. 
Otherwise, execution of the LoopNode is complete.
After each execution of the bodyPart, the test section is executed again, for the next iteration of the loop.
A LoopNode may also define a set of loopVariable OutputPins used to hold intermediate values during each loop 
iteration. These OutputPins may have outgoing ActivityEdges, in order to make the values they hold available within 
the test and bodyPart sections of a loop during an iteration. If a LoopNode has loopVariable OutputPins, then it must also 
have matching sets of loopVariableInput InputPins, bodyOutput OutputPins (owned by Actions within the bodyPart), and 
result OutputPins.
When the LoopNode begins executing, the tokens on the loopVariableInput InputPins are moved to the corresponding 
loopVariable OutputPins before the first iteration of the loop. After the completion of each execution of the bodyPart of the 
LoopNode, any remaining tokens on the loopVariable OutputPins are destroyed and tokens on the bodyOutput OutputPins 
are copied to the corresponding loopVariable OutputPins so that they are available for the next iteration. Once the test 
fails and the loop is completed, the tokens on the bodyOutput OutputPins from the last iteration are moved to the result 
OutputPins and offered on any edges outgoing from those OutputPins.
A LoopNode may not have any other InputPins or OutputPins than those described above. However, ActivityEdges may 
cross into and out of a LoopNode, as for StructuredActivityNodes in general, and the semantics are the same (see 
above), except that the execution of ExecutableNodes within the LoopNode is specified by the iterative looping 

Unified Modeling Language 2.5

477

semantics described above. In particular, a token accepted from an ActivityEdge crossing into a LoopNode on one 
iteration will be consumed and will not be available on the next iteration.

16.11.3.5

Sequence Nodes

A SequenceNode defines a complete, sequential ordering of all the ActivityNodes it contains, which must all be 
ExecutableNodes. When the SequenceNode executes, each of the nodes within it are executed in sequential order. The 
SequenceNode may also contain ActivityEdges between its nodes, and ActivityEdges may cross into and out of the 
SequenceNode. The semantics are equivalent to a general StructuredActivityNode containing the same nodes and edges, 
but with ControlFlows added to sequentially order the nodes as specified for the SequenceNode.

Notation

16.11.4
A StructuredActivityNode is notated with a dashed round cornered rectangle enclosing its nodes and edges, with the 
keyword «structured» at the top.

Figure 16.46  Notation for StructuredActivityNode

No standard notation is defined for ConditionalNodes, LoopNodes or SequenceNodes.

Examples

16.11.5
None.

16.12  Expansion Regions
16.12.1
An ExpansionRegion is a StructuredActivityNode that executes its contained elements multiple times corresponding to 
elements of an input collection.

Summary

16.12.2

Abstract Syntax

StructuredActivityNode

ObjectNode

ExpansionRegion

+ mode : ExpansionKind = iterative

0..1

ExpansionNode

1..*

+ regionAsInput

+ inputElement

+ regionAsOutput

+ outputElement

0..1

*

«enumeration»
ExpansionKind
parallel
iterative
stream

Figure 16.47  Expansion Regions

478

Unified Modeling Language 2.5

Semantics

16.12.3
An ExpansionRegion is a StructuredActivityNode that takes as input one or more collections of values and executes its 
contained ActivityNodes and ActivityEdges on each value in those collections. If the computation produces results, 
these may be collected into output collections. The number of output collections can differ from the number of input 
collections.
An ExpansionNode is an ObjectNode used to indicate a flow across the boundary of an ExpansionRegion. From 
“outside” of the region, the values on these nodes appear as collections. From “inside” the region the values appear as 
elements of the collections. A “collection” is defined to be any construct supported by an execution engine that may be 
treated either as a whole or as a well-defined set of element values.
An execution engine may define various kinds of collection types that it supports (sets, bags, and so on), individual 
instances of which may be constructed from element values and from which those element values may later be obtained. 
Such a collection instance is passed as a single value on a single token. An execution engine may alternatively support 
collections implicitly as the set of values passed in a group of tokens placed together on an ExpansionNode.
If an ExpansionRegion has multiple input ExpansionNodes, then each one must handle the same kind of collection (set, 
bag, or so on), although the types of the elements in different collections may vary. If the kind of collection is 
represented as a collection type, then this is used as the type of the ExpansionNodes. Otherwise, the type of the 
ExpansionNodes reflects the type of the elements in the collections.
An ExpansionRegion begins executing according to the normal rules for an Action (see sub clause 16.2.3). In addition, 
if the input ExpansionNodes for the ExpansionRegion have collection types, then a collection instance must be placed 
on each ExpansionNode before the ExpansionRegion may begin executing. Otherwise, there is no constraint on whether 
any input ExpansionNode contains any tokens (as an ExpansionNode with no token is interpreted as the empty 
collection in this case). When the ExpansionRegion starts executing it removes all tokens in its input ExpansionNodes.
Then the group of ActivityNodes and ActivityEdges contained in the ExpansionRegion is executed once for each 
element of the input collections. These will be referred to as the expansion executions for the ExpansionRegion. If the 
collections have different numbers of elements, then the number of expansion executions is equal to the size of the 
smallest collection (except in the case of mode=stream, in which case there is only one expansion execution, as 
discussed later). Each of the expansion executions proceeds independently from the other executions, with the same 
semantics as the execution of a general StructureActivityNode, except for the following special rules:

• Within each expansion execution, a single token is offered on each ActivityEdge with an input ExpansionNode 
as its source and its target inside the ExpansionRegion. This token contains as its value an individual element of 
the collection on the input ExpansionNode. For each collection on each such input ExpansionNode, a different 
element is offered for each expansion execution. If the collection is not a set (non-unique), duplicate values are 
considered to be different elements. If the collections are ordered, then the elements from each collection are 
aligned in order for each execution (one execution gets all elements from position 1 in the input collections, 
another gets all elements from position 2, and so on), up to the number of executions (this provides an effective 
ordering of the expansion executions). If the collections are not ordered, then it is undefined which individual 
elements of a collection are delivered to which execution (except that no element is delivered to more than one 
execution).

•

Each expansion execution may result in tokens offered to an ActivityEdge with its source inside the 
ExpansionRegion and with an output ExpansionNode as its target. Such tokens are immediately accepted by the 
ExpansionNode and inserted into the output collection for that ExpansionNode. If the input and output 
collections are both ordered, then the values provided by each execution are concatenated in the same order as 
is induced on the executions by the input collections. If each execution produces a single value, then the output 
collection will have the same number of elements as the smallest input collection, and, if the output collection 
is ordered, it will have an output at each position corresponding to the input at the same position of the input 
collections. On the other hand, if each execution may or may not produce a value, then the output collection 
will have fewer elements than the input collections and the ExpansionRegion will act as a kind of filter. 
Finally, if each execution can produce more than one value, then the output collection may end up with a 
greater number of elements than the input collections.

Unified Modeling Language 2.5

479

•

•

Tokens placed on the InputPins of an ExpansionRegion are duplicated for each expansion execution, so that 
each execution is offered a different copy of the tokens on outgoing ActivityEdges from the InputPins. In this 
way, tokens consumed from an InputPin in one expansion execution do not affect the tokens available from the 
InputPin in other executions (the tokens on the InputPin effectively appear to be “constant” across the 
executions). Similarly, tokens offered on ActivityEdges that cross into an ExpansionRegion from outside it 
(other than those to or from ExpansionNodes of the ExpansionRegion) are duplicated for each expansion 
execution (the target of each ActivityEdge is offered a separate copy of the tokens within each expansion 
execution).

ExpansionRegions may also have OutputPins and ActivityEdges that cross out of the ExpansionRegion from 
inside it. However, the semantics are undefined for offering tokens to such OutputPins or ActivityEdges from 
within the expansion executions of the ExpansionRegion (other than for ActivityEdges to or from 
ExpansionNodes of the ExpansionRegion).

When the ExpansionRegion completes all expansion executions, it offers the output collections on its output 
ExpansionNodes on any ActivityEdges outgoing from those nodes (they are not offered during the execution of the 
ExpansionRegion). If the ExpansionRegion contains an ActivityFinalNode immediately within it, then, if the 
ActivityFinalNode accepts a token within any expansion execution, all currently ongoing expansion executions are 
terminated and the ExpansionRegion as a whole completes its execution. In this case, output collections are still offered 
from the output ExpansionNodes, though the collections may only be partially filled.
The mode of an ExpansionRegion controls how its expansion executions proceed.

•

•

•

If the value is parallel, the expansion executions proceed concurrently. This allows an execution engine to run 
the executions in parallel, or otherwise overlapping in time, but this is not required. However, if the executions 
are run sequentially, then the order in which they are run is not defined.

If the value is iterative, the expansion executions must occur in an iterative sequence, with one completing 
before another can begin. The first expansion execution begins immediately when the ExpansionRegion starts 
executing, with subsequent executions starting when the previous execution is completed. If the input 
collections are ordered, then the expansion executions are sequenced in the order induced by the input 
collection. Otherwise, the order of the expansion executions is not defined.

If the value is stream, there is exactly one expansion execution, and element values are offered to this 
execution in a stream from each collection. That is, each element of a collection on an input ElementNode is 
offered separately as a token, one by one, on all outgoing ActivityEdges from the ExpansionRegion (up to a 
number of tokens equal to the size of the smallest input collection). If the input collections are ordered, then 
this sequence of offers is made in the same order as the elements of each collection; otherwise the order is not 
defined. During the course of the single expansion execution, multiple tokens may be accepted by each output 
ExpansionNode in order to construct the output collections from the ExpansionRegion. If an output collection 
is ordered, then the elements of the collection are ordered corresponding to the order in which tokens are 
received by the ExpansionNode.

Notation

16.12.4
An ExpansionRegion is shown as a dashed rounded box with one of the keywords «parallel», «iterative» or «stream» in 
the upper left corner (see Figure 16.48). Input and output ExpansionNodes are drawn as small rectangles divided by 
vertical bars into small compartments. (The symbol is meant to suggest a list of elements.) The ExpansionNode symbols 
are placed on the boundary of the dashed box. Usually, ActivityEdge arrows inside and outside the ExpansionRegion 
will distinguish input and output expansion nodes. If not, then a small arrow can be used as with Pins (Figure 16.5).

480

Unified Modeling Language 2.5

Figure 16.48  Expansion Region

As a shorthand notation, the ExpansionNode “list box” notation may be placed directly on an Action symbol, replacing 
the pins of the action (Figure 16.49). This indicates an expansion region containing a single Action. The equivalent full 
form is shown in Figure 16.50. In the shorthand notation, there must be one input ExpansionNode corresponding to 
each in or inout parameter of the behavior (which must have at least one such parameter) and one output 
ExpansionNode corresponding to each out, inout, or return parameter of the behavior.

Figure 16.49  Shorthand notation for expansion region containing single node

Figure 16.50  Full form of previous shorthand notation

Figure 16.51 shows a further shorthand for an ExpansionRegion that contains a single CallBehaviorAction. This is 
shown using the shorthand notation of Figure 16.49, but, instead of using a mode keyword, a “*” is placed in the upper 
right-hand corner of the symbol (this is intended to indicate “multiple execution.” The notation maps to an expansion 
region containing the CallBehaviorAction (as in Figure 16.50) with mode=parallel.

Figure 16.51  Notation for expansion region with one behavior invocation

Unified Modeling Language 2.5

481

Examples

16.12.5
Figure 16.52 shows an ExpansionRegion with two inputs and one output that is executed in parallel. Execution of the 
ExpansionRegion does not begin until both input collections are available. Both collections are expected to have the 
same number of elements. The interior of the ExpansionRegion is executed once for each element in the input 
collections. During each execution of the region, a pair of values, one from each collection, is available to the interior 
from the input ExpansionNodes. Each expansion execution produces a result value on the output ExpansionNode. All of 
the result values are formed into a collection of the same size as the input collections. This output collection is available 
outside the ExpansionRegion on the output ExpansionNode after all the parallel expansionexecutions have completed.

Figure 16.52  Expansion region with two inputs and one output

Figure 16.53 shows a fragment of a Fast Fourier Transform (FFT) computation containing an ExpansionRegion. 
Outside the ExpansionRegion, there are operations on arrays of complex numbers. S, Slower, Supper, and V are arrays. 
Cut and shuffle are operations on arrays. Inside the region, two arithmetic operations are performed on elements of the 
three input arrays, yielding two output arrays. Different positions in the arrays do not interact, therefore the 
ExpansionRegion can be executed in parallel on all positions.

482

Unified Modeling Language 2.5

Figure 16.53  Expansion Region

Figure 16.54 shows a use of the shorthand notation for an ExpansionRegion with a single Action. In this example, the 
Specify Trip Route action outputs sets of flights and sets of hotels to book. The hotels may be booked independently 
and in parallel with each other and with booking the flight.

Figure 16.54  Examples of expansion region shorthand

In Figure 16.55, Specify Trip Route can result in multiple flight segments, each of which must be booked separately. 
The Book Flight action will invoke the Book Flight Behavior multiple times, once for each flight segment in the set 
passed to Book Flight.

Unified Modeling Language 2.5

483

Figure 16.55  Shorthand notation for expansion region

16.13  Other Actions
16.13.1
This sub clause covers to additional kinds of Actions: ReduceActions for repeatedly invoking a Behavior to reduce a 
collection of values to a single value, and RaiseExceptionAction for raising exceptions.

Summary

16.13.2

Abstract Syntax

Behavior

+ reducer

1

+ reduceAction
*
{subsets action}
+ reduceAction

0..1

0..1

ReduceAction

+ isOrdered : Boolean = false

Action

RaiseExceptionAction

{subsets action}
+ reduceAction

{subsets action}

0..1 + raiseExceptionAction

{subsets output}
+ result

1

OutputPin

{subsets input}

1

1

{subsets input}
+ exception

+ collection

InputPin

Figure 16.56  Other Actions

16.13.3

Semantics

16.13.3.1

Reduce Actions

A ReduceAction is an Action that reduces a collection to a single value by combining the elements of the collection. 
The input collection is given on the collection InputPin. The reducer Behavior must have two in parameters and a single 
out or return parameter, with the same type as the elements of the collection. It has a single result OutputPin which also 
has the collection element type.
An execution engine may define various kinds of collection types that it supports (set, bag, and so on), individual 
instances of which may be constructed from element values and from which those element values may later be obtained. 
Such a collection instance is passed as a single value on a single token. In this case, the collection InputPin of a 
ReduceAction should have a collection type as its type and a multiplicity of 1..1.
Alternatively, an execution engine may support collections implicitly as the set of values passed in a group of tokens 
placed together on an InputPin. In this case, the collection InputPin of a ReduceAction should have the same type as the 
elements of the collection and an upper multiplicity greater than 1 (usually *).
A ReduceAction executes by repeatedly invoking the reducer Behavior on an intermediate copy of the input collection. 
For each invocation of the reducer, two elements are removed from the intermediate collection to act as arguments for 
the invocation. The value returned from the invocation is then inserted into the intermediate collection, so its size is 
reduced by one from before the invocation, and the reducer Behavior is invoked again. This process continues until the 
collection has only one element. This element is then placed on the result OutputPin and the ReduceAction execution 
completes.
If the input collection is unordered, or if isOrdered for the InputPin is false, it is indeterminate which elements of the 
intermediate collection are selected as arguments for the reducer invocation. If the input collection is ordered, or if 

484

Unified Modeling Language 2.5

isOrdered for the InputPin is true, then the first two elements of the intermediate collection are always used as the 
arguments of the reducer invocation, and the result of the invocation is always inserted as the first element of the 
collection.
If the reducer Behavior is a commutative and associative operation, then an unordered collection or isOrdered=false will 
not normally affect the result of a ReduceAction, giving greater freedom in how the reduction computation may be 
carried out. For example, addition is commutative (a + b = b + a) and associative ((a + b) + c = a + (b + c)), so reducing 
a collection using addition will produce the same result regardless of how elements are paired at each reducer 
invocation. If the reducer Behavior is not a commutative and associative operation (as, for example, with matrix 
multiplication), the order in which elements of the intermediate collection are selected will affect the result of the 
reduction computation. If it is desired to avoid nondeterminacy in this case, collections may be ordered or isOrdered set 
to true, so the reducer Behavior will be applied to adjacent pairs according to the collection order.
If the reducer Behavior has side effects such that invocations of it may affect each other, then the result a ReduceAction 
with isOrdered=false may be unpredictable.

16.13.3.2

Raise Exception Actions

A RaiseExceptionAction is an Action that causes an exception to occur. A RaiseExceptionAction always completes by 
raising an exception, rather than normally. The value given on the exception InputPin is raised as the exception.
If the RaiseExceptionAction itself has an ExceptionHandler (see sub clause 15.5) that matches the raised exception, 
then the exception is caught by that handler. Otherwise, the exception propagates outward to the innermost containing 
StructuredActivityNode of the RaiseExceptionAction. If this StructuredActivityNode has an ExceptionHandler that 
matches the raised exception, then the exception is caught by that handler, otherwise the exception continues to be 
propagated outward.
When an exception is propagated out of a StructuredActivityNode (including being caught by an ExceptionHandler on 
the node), the StructuredActivityNode is terminated. If the exception is caught by an ExceptionHandler on the 
StructuredActivityNode, then after execution of the handler, control and object tokens are offered from the 
StructuredActivityNode as described in sub clause 15.5.3. Otherwise, the StructuredActivityNode does not offer any 
control tokens and its OutputPins do not offer any object tokens.
If the exception is not caught by any ExceptionHandler at some level within the Behavior in which the 
RaiseExceptionAction was executed, then the execution of the Behavior is terminated. If the Behavior was invoked 
synchronously, then the exception is propagated to the caller of the Behavior, out from that invocation (see also the 
discussion in sub clause 16.3.3 of exceptions raised by CallActions making synchronous calls). If the Behavior was 
invoked asynchronously, then the exception propagation ends with the termination of the Behavior execution.

Notation

16.13.4
No specialized notation is defined for ReduceActions and RaiseExceptionActions.

Examples

16.13.5
A ReduceAction can be used to reduce a list of numbers to the sum of the numbers. Such a ReduceAction has one 
InputPin for a collection of numbers, one OutputPin for a number and an addition function as the reducer Behavior. For 
example, suppose the input collection has four integers: (2, 7, 5, 3). The result of applying the ReduceAction to this 
collection with an addition function is 11. With the default of isOrdered=false, this can be computed in a number of 
ways, for example, ( ( (2+7) + 5) + 3), (2 + (7 + (5 + 3))), ((2 + 7) + (5 + 3)).

Unified Modeling Language 2.5

485

16.14 Classifier Descriptions
AcceptCallAction [Class]
16.14.1

16.14.1.1

Description

An AcceptCallAction is an AcceptEventAction that handles the receipt of a synchronous call request. In addition to the 
values from the Operation input parameters, the Action produces an output that is needed later to supply the information 
to the ReplyAction necessary to return control to the caller. An AcceptCallAction is for synchronous calls. If it is used 
to handle an asynchronous call, execution of the subsequent ReplyAction will complete immediately with no effect.

16.14.1.2

Diagrams

Accept Event Actions

16.14.1.3

Generalizations

AcceptEventAction

16.14.1.4

Association Ends

•

♦ returnInformation : OutputPin [1..1]{subsets Action::output} (opposite 
A_returnInformation_acceptCallAction::acceptCallAction)
An OutputPin where a value is placed containing sufficient information to perform a subsequent ReplyAction 
and return control to the caller. The contents of this value are opaque. It can be passed and copied but it cannot 
be manipulated by the model.

16.14.1.5

Constraints

•

•

•

result_pins
The number of result OutputPins must be the same as the number of input (in and inout) ownedParameters of 
the Operation specified by the trigger Event. The type, ordering and multiplicity of each result OutputPin must 
be consistent with the corresponding input Parameter.

inv: let parameter: OrderedSet(Parameter) = trigger.event->asSequence()-
>first().oclAsType(CallEvent).operation.inputParameters() in
result->size() = parameter->size() and
Sequence{1..result->size()}->forAll(i |

parameter->at(i).type.conformsTo(result->at(i).type) and
parameter->at(i).isOrdered = result->at(i).isOrdered and
parameter->at(i).compatibleWith(result->at(i)))

trigger_call_event
The action must have exactly one trigger, which must be for a CallEvent.

inv: trigger->size()=1 and
trigger->asSequence()->first().event.oclIsKindOf(CallEvent)

unmarshall
isUnmarshall must be true for an AcceptCallAction.

inv: isUnmarshall = true

486

Unified Modeling Language 2.5

16.14.2

AcceptEventAction [Class]

16.14.2.1

Description

An AcceptEventAction is an Action that waits for the occurrence of one or more specific Events.

16.14.2.2

Diagrams

Accept Event Actions

16.14.2.3

Generalizations

Action

16.14.2.4

Specializations

AcceptCallAction

16.14.2.5

Attributes

•

isUnmarshall : Boolean [1..1] = false
Indicates whether there is a single OutputPin for a SignalEvent occurrence, or multiple OutputPins for attribute 
values of the instance of the Signal associated with a SignalEvent occurrence.

16.14.2.6

Association Ends

•

•

♦ result : OutputPin [0..*]{ordered, subsets Action::output} (opposite 
A_result_acceptEventAction::acceptEventAction)
OutputPins holding the values received from an Event occurrence.

♦ trigger : Trigger [1..*]{subsets Element::ownedElement} (opposite 
A_trigger_acceptEventAction::acceptEventAction)
The Triggers specifying the Events of which the AcceptEventAction waits for occurrences.

16.14.2.7

Constraints

•

•

•

one_output_pin
If isUnmarshall=false and any of the triggers are for SignalEvents or TimeEvents, there must be exactly one 
result OutputPin with multiplicity 1..1.

inv: not isUnmarshall and trigger->exists(event.oclIsKindOf(SignalEvent) or 
event.oclIsKindOf(TimeEvent)) implies

output->size() = 1 and output->first().is(1,1)

no_input_pins
AcceptEventActions may have no input pins.

inv: input->size() = 0

no_output_pins
There are no OutputPins if the trigger events are only ChangeEvents and/or CallEvents when this action is an 
instance of AcceptEventAction and not an instance of a descendant of AcceptEventAction (such as 
AcceptCallAction).

inv: (self.oclIsTypeOf(AcceptEventAction) and
   (trigger->forAll(event.oclIsKindOf(ChangeEvent) or

Unified Modeling Language 2.5

487

•

•

                             event.oclIsKindOf(CallEvent))))
implies output->size() = 0

unmarshall_signal_events
If isUnmarshall is true (and this is not an AcceptCallAction), there must be exactly one trigger, which is for a 
SignalEvent. The number of result output pins must be the same as the number of attributes of the signal. The 
type and ordering of each result output pin must be the same as the corresponding attribute of the signal. The 
multiplicity of each result output pin must be compatible with the multiplicity of the corresponding attribute.

inv: isUnmarshall and self.oclIsTypeOf(AcceptEventAction) implies

trigger->size()=1 and
trigger->asSequence()->first().event.oclIsKindOf(SignalEvent) and
let attribute: OrderedSet(Property) = trigger->asSequence()-

>first().event.oclAsType(SignalEvent).signal.allAttributes() in

attribute->size()>0 and result->size() = attribute->size() and
Sequence{1..result->size()}->forAll(i |

result->at(i).type = attribute->at(i).type and
result->at(i).isOrdered = attribute->at(i).isOrdered and
result->at(i).includesMultiplicity(attribute->at(i)))

conforming_type
If isUnmarshall=false and all the triggers are for SignalEvents, then the type of the single result OutputPin 
must either be null or all the signals must conform to it.

inv: not isUnmarshall implies

result->isEmpty() or
let type: Type = result->first().type in
type=null or

(trigger->forAll(event.oclIsKindOf(SignalEvent)) and
 trigger.event.oclAsType(SignalEvent).signal->forAll(s | s.conformsTo(type)))

16.14.3

Action [Abstract Class]

16.14.3.1

Description

An Action is the fundamental unit of executable functionality. The execution of an Action represents some 
transformation or processing in the modeled system. Actions provide the ExecutableNodes within Activities and may 
also be used within Interactions.

16.14.3.2

Diagrams

Actions, Invocation Actions, Link Actions, Link Object Actions, Structural Feature Actions, Accept Event 
Actions, Other Actions, Variable Actions, Structured Actions, Object Actions, Interactions, Occurrences

16.14.3.3

Generalizations

ExecutableNode

16.14.3.4

Specializations

ValueSpecificationAction, VariableAction, AcceptEventAction, ClearAssociationAction, CreateObjectAction, 
DestroyObjectAction, InvocationAction, LinkAction, OpaqueAction, RaiseExceptionAction, 
ReadExtentAction, ReadIsClassifiedObjectAction, ReadLinkObjectEndAction, 
ReadLinkObjectEndQualifierAction, ReadSelfAction, ReclassifyObjectAction, ReduceAction, ReplyAction, 
StartClassifierBehaviorAction, StructuralFeatureAction, StructuredActivityNode, TestIdentityAction, 
UnmarshallAction

488

Unified Modeling Language 2.5

16.14.3.5

Attributes

•

isLocallyReentrant : Boolean [1..1] = false
If true, the Action can begin a new, concurrent execution, even if there is already another execution of the 
Action ongoing. If false, the Action cannot begin a new execution until any previous execution has completed.

16.14.3.6

Association Ends

•

•

•

•

•

/context : Classifier [0..1]{} (opposite A_context_action::action)
The context Classifier of the Behavior that contains this Action, or the Behavior itself if it has no context.

♦ /input : InputPin [0..*]{ordered, union, subsets Element::ownedElement} (opposite A_input_action::action)
The ordered set of InputPins representing the inputs to the Action.

♦ localPostcondition : Constraint [0..*]{subsets Element::ownedElement} (opposite 
A_localPostcondition_action::action)
A Constraint that must be satisfied when execution of the Action is completed.

♦ localPrecondition : Constraint [0..*]{subsets Element::ownedElement} (opposite 
A_localPrecondition_action::action)
A Constraint that must be satisfied when execution of the Action is started.

♦ /output : OutputPin [0..*]{ordered, union, subsets Element::ownedElement} (opposite 
A_output_action::action)
The ordered set of OutputPins representing outputs from the Action.

16.14.3.7

Operations

•

•

•

•

context() : Classifier [0..1]
The derivation for the context property.

body: let behavior: Behavior = self.containingBehavior() in
if behavior=null then null
else if behavior._'context' = null then behavior
else behavior._'context'
endif
endif

allActions() : Action [0..*]
Returns this Action and all Actions contained directly or indirectly in it. By default only the Action itself is 
returned, but the operation is overridden for StructuredActivityNodes.

body: self->asSet()

allOwnedNodes() : ActivityNode [0..*]
Returns all the ActivityNodes directly or indirectly owned by this Action. This includes at least all the Pins of 
the Action.

body: input.oclAsType(Pin)->asSet()->union(output->asSet())

containingBehavior() : Behavior [0..1]

body: if inStructuredNode<>null then inStructuredNode.containingBehavior()
else if activity<>null then activity
else interaction

Unified Modeling Language 2.5

489

endif
endif

16.14.4

ActionInputPin [Class]

16.14.4.1

Description

An ActionInputPin is a kind of InputPin that executes an Action to determine the values to input to another Action.

16.14.4.2

Diagrams

Actions

16.14.4.3

Generalizations

InputPin

16.14.4.4

Association Ends

•

♦ fromAction : Action [1..1]{subsets Element::ownedElement} (opposite 
A_fromAction_actionInputPin::actionInputPin)
The Action used to provide the values of the ActionInputPin.

16.14.4.5

Constraints

•

•

•

input_pin
The fromAction of an ActionInputPin must only have ActionInputPins as InputPins.

inv: fromAction.input->forAll(oclIsKindOf(ActionInputPin))

one_output_pin
The fromAction of an ActionInputPin must have exactly one OutputPin.

inv: fromAction.output->size() = 1

no_control_or_object_flow
The fromAction of an ActionInputPin cannot have ActivityEdges coming into or out of it or its Pins.

inv: fromAction.incoming->union(outgoing)->isEmpty() and
fromAction.input.incoming->isEmpty() and
fromAction.output.outgoing->isEmpty()

16.14.5

AddStructuralFeatureValueAction [Class]

16.14.5.1

Description

An AddStructuralFeatureValueAction is a WriteStructuralFeatureAction for adding values to a StructuralFeature.

16.14.5.2

Diagrams

Structural Feature Actions

16.14.5.3

Generalizations

WriteStructuralFeatureAction

490

Unified Modeling Language 2.5

16.14.5.4

Attributes

•

isReplaceAll : Boolean [1..1] = false
Specifies whether existing values of the StructuralFeature should be removed before adding the new value.

16.14.5.5

Association Ends

•

♦ insertAt : InputPin [0..1]{subsets Action::input} (opposite 
A_insertAt_addStructuralFeatureValueAction::addStructuralFeatureValueAction)
The InputPin that gives the position at which to insert the value in an ordered StructuralFeature. The type of 
the insertAt InputPin is UnlimitedNatural, but the value cannot be zero. It is omitted for unordered 
StructuralFeatures.

16.14.5.6

Constraints

•

•

required_value
A value InputPin is required.

inv: value<>null

insertAt_pin
AddStructuralFeatureActions adding a value to ordered StructuralFeatures must have a single InputPin for the 
insertion point with type UnlimitedNatural and multiplicity of 1..1 if isReplaceAll=false, and must have no 
Input Pin for the insertion point when the StructuralFeature is unordered.

inv: if not structuralFeature.isOrdered then insertAt = null
else
  not isReplaceAll implies
  insertAt<>null and
  insertAt->forAll(type=UnlimitedNatural and is(1,1.oclAsType(UnlimitedNatural)))
endif

16.14.6

AddVariableValueAction [Class]

16.14.6.1

Description

An AddVariableValueAction is a WriteVariableAction for adding values to a Variable.

16.14.6.2

Diagrams

Variable Actions

16.14.6.3

Generalizations

WriteVariableAction

16.14.6.4

Attributes

•

isReplaceAll : Boolean [1..1] = false
Specifies whether existing values of the Variable should be removed before adding the new value.

16.14.6.5

Association Ends

•

♦ insertAt : InputPin [0..1]{subsets Action::input} (opposite 
A_insertAt_addVariableValueAction::addVariableValueAction)
The InputPin that gives the position at which to insert a new value or move an existing value in ordered 

Unified Modeling Language 2.5

491

Variables. The type of the insertAt InputPin is UnlimitedNatural, but the value cannot be zero. It is omitted for 
unordered Variables.

16.14.6.6

Constraints

•

•

required_value
A value InputPin is required.

inv: value <> null

insertAt_pin
AddVariableValueActions for ordered Variables must have a single InputPin for the insertion point with type 
UnlimtedNatural and multiplicity of 1..1 if isReplaceAll=false, otherwise the Action has no InputPin for the 
insertion point.

inv: if not variable.isOrdered then insertAt = null
else
  not isReplaceAll implies
  insertAt<>null and
  insertAt->forAll(type=UnlimitedNatural and is(1,1.oclAsType(UnlimitedNatural)))
endif

16.14.7

BroadcastSignalAction [Class]

16.14.7.1

Description

A BroadcastSignalAction is an InvocationAction that transmits a Signal instance to all the potential target objects in the 
system. Values from the argument InputPins are used to provide values for the attributes of the Signal. The requestor 
continues execution immediately after the Signal instances are sent out and cannot receive reply values.

16.14.7.2

Diagrams

Invocation Actions

16.14.7.3

Generalizations

InvocationAction

16.14.7.4

Association Ends

•

signal : Signal [1..1] (opposite A_signal_broadcastSignalAction::broadcastSignalAction)
The Signal whose instances are to be sent.

16.14.7.5

Constraints

•

•

492

number_of_arguments
The number of argument InputPins must be the same as the number of attributes in the signal.

inv: argument->size() = signal.allAttributes()->size()

type_ordering_multiplicity
The type, ordering, and multiplicity of an argument InputPin must be the same as the corresponding attribute 
of the signal.

inv: let attribute: OrderedSet(Property) = signal.allAttributes() in
Sequence{1..argument->size()}->forAll(i |

argument->at(i).type.conformsTo(attribute->at(i).type) and
argument->at(i).isOrdered = attribute->at(i).isOrdered and

Unified Modeling Language 2.5

argument->at(i).compatibleWith(attribute->at(i)))

•

no_onport
A BroadcaseSignalAction may not specify onPort.

inv: onPort=null

16.14.8

CallAction [Abstract Class]

16.14.8.1

Description

CallAction is an abstract class for Actions that invoke a Behavior with given argument values and (if the invocation is 
synchronous) receive reply values.

16.14.8.2

Diagrams

Invocation Actions

16.14.8.3

Generalizations

InvocationAction

16.14.8.4

Specializations

CallBehaviorAction, CallOperationAction, StartObjectBehaviorAction

16.14.8.5

Attributes

•

isSynchronous : Boolean [1..1] = true
If true, the call is synchronous and the caller waits for completion of the invoked Behavior. If false, the call is 
asynchronous and the caller proceeds immediately and cannot receive return values.

16.14.8.6

Association Ends

•

♦ result : OutputPin [0..*]{ordered, subsets Action::output} (opposite A_result_callAction::callAction)
The OutputPins on which the reply values from the invocation are placed (if the call is synchronous).

16.14.8.7

Operations

•

•

inputParameters() : Parameter [0..*]{ordered}
Return the in and inout ownedParameters of the Behavior or Operation being called. (This operation is abstract 
and should be overridden by subclasses of CallAction.)

outputParameters() : Parameter [0..*]{ordered}
Return the inout, out and return ownedParameters of the Behavior or Operation being called. (This operation is 
abstract and should be overridden by subclasses of CallAction.)

16.14.8.8

Constraints

•

argument_pins
The number of argument InputPins must be the same as the number of input (in and inout) ownedParameters of 
the called Behavior or Operation. The type, ordering and multiplicity of each argument InputPin must be 
consistent with the corresponding input Parameter.

inv: let parameter: OrderedSet(Parameter) = self.inputParameters() in

Unified Modeling Language 2.5

493

argument->size() = parameter->size() and
Sequence{1..argument->size()}->forAll(i |

argument->at(i).type.conformsTo(parameter->at(i).type) and
argument->at(i).isOrdered = parameter->at(i).isOrdered and
argument->at(i).compatibleWith(parameter->at(i)))

result_pins
The number of result OutputPins must be the same as the number of output (inout, out and return) 
ownedParameters of the called Behavior or Operation. The type, ordering and multiplicity of each result 
OutputPin must be consistent with the corresponding input Parameter.

inv: let parameter: OrderedSet(Parameter) = self.outputParameters() in
result->size() = parameter->size() and
Sequence{1..result->size()}->forAll(i |

parameter->at(i).type.conformsTo(result->at(i).type) and
parameter->at(i).isOrdered = result->at(i).isOrdered and
parameter->at(i).compatibleWith(result->at(i)))

synchronous_call
Only synchronous CallActions can have result OutputPins.

inv: result->notEmpty() implies isSynchronous

•

•

16.14.9

CallBehaviorAction [Class]

16.14.9.1

Description

A CallBehaviorAction is a CallAction that invokes a Behavior directly. The argument values of the CallBehaviorAction 
are passed on the input Parameters of the invoked Behavior. If the call is synchronous, the execution of the 
CallBehaviorAction waits until the execution of the invoked Behavior completes and the values of output Parameters of 
the Behavior are placed on the result OutputPins. If the call is asynchronous, the CallBehaviorAction completes 
immediately and no results values can be provided.

16.14.9.2

Diagrams

Invocation Actions

16.14.9.3

Generalizations

CallAction

16.14.9.4

Association Ends

•

behavior : Behavior [1..1] (opposite A_behavior_callBehaviorAction::callBehaviorAction)
The Behavior being invoked.

16.14.9.5

Operations

•

•

494

outputParameters() : Parameter [0..*]{ordered} {redefines CallAction::outputParameters()}
Return the inout, out and return ownedParameters of the Behavior being called.

body: behavior.outputParameters()

inputParameters() : Parameter [0..*]{ordered} {redefines CallAction::inputParameters()}
Return the in and inout ownedParameters of the Behavior being called.

body: behavior.inputParameters()

Unified Modeling Language 2.5

16.14.9.6

Constraints

•

no_onport
A CallBehaviorAction may not specify onPort.

inv: onPort=null

16.14.10 CallOperationAction [Class]

16.14.10.1

Description

A CallOperationAction is a CallAction that transmits an Operation call request to the target object, where it may cause 
the invocation of associated Behavior. The argument values of the CallOperationAction are passed on the input 
Parameters of the Operation. If call is synchronous, the execution of the CallOperationAction waits until the execution 
of the invoked Operation completes and the values of output Parameters of the Operation are placed on the result 
OutputPins. If the call is asynchronous, the CallOperationAction completes immediately and no results values can be 
provided.

16.14.10.2

Diagrams

Invocation Actions

16.14.10.3

Generalizations

CallAction

16.14.10.4

Association Ends

•

•

operation : Operation [1..1] (opposite A_operation_callOperationAction::callOperationAction)
The Operation being invoked.

♦ target : InputPin [1..1]{subsets Action::input} (opposite A_target_callOperationAction::callOperationAction)
The InputPin that provides the target object to which the Operation call request is sent.

16.14.10.5

Operations

•

•

outputParameters() : Parameter [0..*]{ordered} {redefines CallAction::outputParameters()}
Return the inout, out and return ownedParameters of the Operation being called.

body: operation.outputParameters()

inputParameters() : Parameter [0..*]{ordered} {redefines CallAction::inputParameters()}
Return the in and inout ownedParameters of the Operation being called.

body: operation.inputParameters()

16.14.10.6

Constraints

•

type_target_pin
If onPort has no value, the operation must be an owned or inherited feature of the type of the target InputPin, 
otherwise the Port given by onPort must be an owned or inherited feature of the type of the target InputPin, and 
the Port must have a required or provided Interface with the operation as an owned or inherited feature.

inv: if onPort=null then target.type.oclAsType(Classifier).allFeatures()-
>includes(operation)

Unified Modeling Language 2.5

495

else target.type.oclAsType(Classifier).allFeatures()->includes(onPort) and onPort.provided-
>union(onPort.required).allFeatures()->includes(operation)
endif

16.14.11 Clause [Class]

16.14.11.1

Description

A Clause is an Element that represents a single branch of a ConditionalNode, including a test and a body section. The 
body section is executed only if (but not necessarily if) the test section evaluates to true.

16.14.11.2

Diagrams

Structured Actions

16.14.11.3

Generalizations

Element

16.14.11.4

Association Ends

•

•

•

•

•

•

body : ExecutableNode [0..*] (opposite A_body_clause::clause)
The set of ExecutableNodes that are executed if the test evaluates to true and the Clause is chosen over other 
Clauses within the ConditionalNode that also have tests that evaluate to true.

bodyOutput : OutputPin [0..*]{ordered} (opposite A_bodyOutput_clause::clause)
The OutputPins on Actions within the body section whose values are moved to the result OutputPins of the 
containing ConditionalNode after execution of the body.

decider : OutputPin [1..1] (opposite A_decider_clause::clause)
An OutputPin on an Action in the test section whose Boolean value determines the result of the test.

predecessorClause : Clause [0..*] (opposite Clause::successorClause)
A set of Clauses whose tests must all evaluate to false before this Clause can evaluate its test.

successorClause : Clause [0..*] (opposite Clause::predecessorClause)
A set of Clauses that may not evaluate their tests unless the test for this Clause evaluates to false.

test : ExecutableNode [1..*] (opposite A_test_clause::clause)
The set of ExecutableNodes that are executed in order to provide a test result for the Clause.

16.14.11.5

Constraints

•

•

496

body_output_pins
The bodyOutput Pins are OutputPins on Actions in the body of the Clause.

inv: _'body'.oclAsType(Action).allActions().output->includesAll(bodyOutput)

decider_output
The decider Pin must be on an Action in the test section of the Clause and must be of type Boolean with 
multiplicity 1..1.

inv: test.oclAsType(Action).allActions().output->includes(decider) and
decider.type = Boolean and
decider.is(1,1)

Unified Modeling Language 2.5

•

test_and_body
The test and body parts of a ConditionalNode must be disjoint with each other.

inv: test->intersection(_'body')->isEmpty()

16.14.12 ClearAssociationAction [Class]

16.14.12.1

Description

A ClearAssociationAction is an Action that destroys all links of an Association in which a particular object participates.

16.14.12.2

Diagrams

Link Actions

16.14.12.3

Generalizations

Action

16.14.12.4

Association Ends

•

•

association : Association [1..1] (opposite A_association_clearAssociationAction::clearAssociationAction)
The Association to be cleared.

♦ object : InputPin [1..1]{subsets Action::input} (opposite 
A_object_clearAssociationAction::clearAssociationAction)
The InputPin that gives the object whose participation in the Association is to be cleared.

16.14.12.5

Constraints

• multiplicity

The multiplicity of the object InputPin is 1..1.

inv: object.is(1,1)

•

same_type
The type of the InputPin must conform to the type of at least one of the memberEnds of the association.

inv: association.memberEnd->exists(self.object.type.conformsTo(type))

16.14.13 ClearStructuralFeatureAction [Class]

16.14.13.1

Description

A ClearStructuralFeatureAction is a StructuralFeatureAction that removes all values of a StructuralFeature.

16.14.13.2

Diagrams

Structural Feature Actions

16.14.13.3

Generalizations

StructuralFeatureAction

Unified Modeling Language 2.5

497

16.14.13.4

Association Ends

•

♦ result : OutputPin [0..1]{subsets Action::output} (opposite 
A_result_clearStructuralFeatureAction::clearStructuralFeatureAction)
The OutputPin on which is put the input object as modified by the ClearStructuralFeatureAction.

16.14.13.5

Constraints

•

type_of_result
The type of the result OutputPin is the same as the type of the inherited object InputPin.

inv: result<>null implies result.type = object.type

• multiplicity_of_result

The multiplicity of the result OutputPin must be 1..1.

inv: result<>null implies result.is(1,1)

16.14.14 ClearVariableAction [Class]

16.14.14.1

Description

A ClearVariableAction is a VariableAction that removes all values of a Variable.

16.14.14.2

Diagrams

Variable Actions

16.14.14.3

Generalizations

VariableAction

16.14.15 ConditionalNode [Class]

16.14.15.1

Description

A ConditionalNode is a StructuredActivityNode that chooses one among some number of alternative collections of 
ExecutableNodes to execute.

16.14.15.2

Diagrams

Structured Actions

16.14.15.3

Generalizations

StructuredActivityNode

16.14.15.4

Attributes

•

•

498

isAssured : Boolean [1..1] = false
If true, the modeler asserts that the test for at least one Clause of the ConditionalNode will succeed.

isDeterminate : Boolean [1..1] = false
If true, the modeler asserts that the test for at most one Clause of the ConditionalNode will succeed.

Unified Modeling Language 2.5

16.14.15.5

Association Ends

•

•

♦ clause : Clause [1..*]{subsets Element::ownedElement} (opposite 
A_clause_conditionalNode::conditionalNode)
The set of Clauses composing the ConditionalNode.

♦ result : OutputPin [0..*]{ordered, redefines StructuredActivityNode::structuredNodeOutput} (opposite 
A_result_conditionalNode::conditionalNode)
The OutputPins that onto which are moved values from the bodyOutputs of the Clause selected for execution.

16.14.15.6

Operations

•

allActions() : Action [0..*] {redefines Action::allActions()}
Return only this ConditionalNode. This prevents Actions within the ConditionalNode from having their 
OutputPins used as bodyOutputs or decider Pins in containing LoopNodes or ConditionalNodes.

body: self->asSet()

16.14.15.7

Constraints

•

•

•

result_no_incoming
The result OutputPins have no incoming edges.

inv: result.incoming->isEmpty()

no_input_pins
A ConditionalNode has no InputPins.

inv: input->isEmpty()

one_clause_with_executable_node
No ExecutableNode in the ConditionNode may appear in the test or body part of more than one clause of a 
ConditionalNode.

inv: node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->forAll(n |

self.clause->select(test->union(_'body')->includes(n))->size()=1)

• matching_output_pins

Each clause of a ConditionalNode must have the same number of bodyOutput pins as the ConditionalNode has 
result OutputPins, and each clause bodyOutput Pin must be compatible with the corresponding result 
OutputPin (by positional order) in type, multiplicity, ordering, and uniqueness.

inv: clause->forAll(

bodyOutput->size()=self.result->size() and
Sequence{1..self.result->size()}->forAll(i |

bodyOutput->at(i).type.conformsTo(result->at(i).type) and
bodyOutput->at(i).isOrdered = result->at(i).isOrdered and
bodyOutput->at(i).isUnique = result->at(i).isUnique and
bodyOutput->at(i).compatibleWith(result->at(i))))

•

executable_nodes
The union of the ExecutableNodes in the test and body parts of all clauses must be the same as the subset of 
nodes contained in the ConditionalNode (considered as a StructuredActivityNode) that are ExecutableNodes.

inv: clause.test->union(clause._'body') = node-
>select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)

Unified Modeling Language 2.5

499

•

clause_no_predecessor
No two clauses within a ConditionalNode may be predecessorClauses of each other, either directly or 
indirectly.

inv: clause->closure(predecessorClause)->intersection(clause)->isEmpty()

16.14.16 CreateLinkAction [Class]

16.14.16.1

Description

A CreateLinkAction is a WriteLinkAction for creating links.

16.14.16.2

Diagrams

Link Actions, Link Object Actions

16.14.16.3

Generalizations

WriteLinkAction

16.14.16.4

Specializations

CreateLinkObjectAction

16.14.16.5

Association Ends

•

♦ endData : LinkEndCreationData [2..*]{redefines LinkAction::endData} (opposite 
A_endData_createLinkAction::createLinkAction)
The LinkEndData that specifies the values to be placed on the Association ends for the new link.

16.14.16.6

Constraints

•

association_not_abstract
The Association cannot be an abstract Classifier.

inv: not self.association().isAbstract

16.14.17 CreateLinkObjectAction [Class]

16.14.17.1

Description

A CreateLinkObjectAction is a CreateLinkAction for creating link objects (AssociationClasse instances).

16.14.17.2

Diagrams

Link Object Actions

16.14.17.3

Generalizations

CreateLinkAction

16.14.17.4

Association Ends

♦ result : OutputPin [1..1]{subsets Action::output} (opposite 
A_result_createLinkObjectAction::createLinkObjectAction)
The output pin on which the newly created link object is placed.

•

500

Unified Modeling Language 2.5

16.14.17.5

Constraints

• multiplicity

The multiplicity of the OutputPin is 1..1.

inv: result.is(1,1)

•

•

type_of_result
The type of the result OutputPin must be the same as the Association of the CreateLinkObjectAction.

inv: result.type = association()

association_class
The Association must be an AssociationClass.

inv: self.association().oclIsKindOf(AssociationClass)

16.14.18 CreateObjectAction [Class]

16.14.18.1

Description

A CreateObjectAction is an Action that creates an instance of the specified Classifier.

16.14.18.2

Diagrams

Object Actions

16.14.18.3

Generalizations

Action

16.14.18.4

Association Ends

•

•

classifier : Classifier [1..1] (opposite A_classifier_createObjectAction::createObjectAction)
The Classifier to be instantiated.

♦ result : OutputPin [1..1]{subsets Action::output} (opposite 
A_result_createObjectAction::createObjectAction)
The OutputPin on which the newly created object is placed.

16.14.18.5

Constraints

•

classifier_not_abstract
The classifier cannot be abstract.

inv: not classifier.isAbstract

• multiplicity

The multiplicity of the result OutputPin is 1..1.

inv: result.is(1,1)

•

classifier_not_association_class
The classifier cannot be an AssociationClass.

Unified Modeling Language 2.5

501

inv: not classifier.oclIsKindOf(AssociationClass)

•

same_type
The type of the result OutputPin must be the same as the classifier of the CreateObjectAction.

inv: result.type = classifier

16.14.19 DestroyLinkAction [Class]

16.14.19.1

Description

A DestroyLinkAction is a WriteLinkAction that destroys links (including link objects).

16.14.19.2

Diagrams

Link Actions

16.14.19.3

Generalizations

WriteLinkAction

16.14.19.4

Association Ends

•

♦ endData : LinkEndDestructionData [2..*]{redefines LinkAction::endData} (opposite 
A_endData_destroyLinkAction::destroyLinkAction)
The LinkEndData that the values of the Association ends for the links to be destroyed.

16.14.20 DestroyObjectAction [Class]

16.14.20.1

Description

A DestroyObjectAction is an Action that destroys objects.

16.14.20.2

Diagrams

Object Actions

16.14.20.3

Generalizations

Action

16.14.20.4

Attributes

•

•

isDestroyLinks : Boolean [1..1] = false
Specifies whether links in which the object participates are destroyed along with the object.

isDestroyOwnedObjects : Boolean [1..1] = false
Specifies whether objects owned by the object (via composition) are destroyed along with the object.

16.14.20.5

Association Ends

•

♦ target : InputPin [1..1]{subsets Action::input} (opposite 
A_target_destroyObjectAction::destroyObjectAction)
The InputPin providing the object to be destroyed.

502

Unified Modeling Language 2.5

16.14.20.6

Constraints

• multiplicity

The multiplicity of the target IinputPin is 1..1.

inv: target.is(1,1)

•

no_type
The target InputPin has no type.

inv: target.type= null

16.14.21 ExpansionKind [Enumeration]

16.14.21.1

Description

ExpansionKind is an enumeration type used to specify how an ExpansionRegion executes its contents.

16.14.21.2

Diagrams

•

Expansion Regions
 
 

16.14.21.3

Literals

•

•

•

parallel
The content of the ExpansionRegion is executed concurrently for the elements of the input collections.

iterative
The content of the ExpansionRegion is executed iteratively for the elements of the input collections, in the 
order of the input elements, if the collections are ordered.

stream
A stream of input collection elements flows into a single execution of the content of the ExpansionRegion, in 
the order of the collection elements if the input collections are ordered.

16.14.22 ExpansionNode [Class]

16.14.22.1

Description

An ExpansionNode is an ObjectNode used to indicate a collection input or output for an ExpansionRegion. A collection 
input of an ExpansionRegion contains a collection that is broken into its individual elements inside the region, whose 
content is executed once per element. A collection output of an ExpansionRegion combines individual elements 
produced by the execution of the region into a collection for use outside the region.

16.14.22.2

Diagrams

Expansion Regions

16.14.22.3

Generalizations

ObjectNode

Unified Modeling Language 2.5

503

16.14.22.4

Association Ends

•

•

regionAsInput : ExpansionRegion [0..1] (opposite ExpansionRegion::inputElement)
The ExpansionRegion for which the ExpansionNode is an input.

regionAsOutput : ExpansionRegion [0..1] (opposite ExpansionRegion::outputElement)
The ExpansionRegion for which the ExpansionNode is an output.

16.14.22.5

Constraints

•

region_as_input_or_output
One of regionAsInput or regionAsOutput must be non-empty, but not both.

inv: regionAsInput->notEmpty() xor regionAsOutput->notEmpty()

16.14.23 ExpansionRegion [Class]

16.14.23.1

Description

An ExpansionRegion is a StructuredActivityNode that executes its content multiple times corresponding to elements of 
input collection(s).

16.14.23.2

Diagrams

Expansion Regions

16.14.23.3

Generalizations

StructuredActivityNode

16.14.23.4

Attributes

• mode : ExpansionKind [1..1] = iterative

The mode in which the ExpansionRegion executes its contents. If parallel, executions are concurrent. If 
iterative, executions are sequential. If stream, a stream of values flows into a single execution.

16.14.23.5

Association Ends

•

•

inputElement : ExpansionNode [1..*] (opposite ExpansionNode::regionAsInput)
The ExpansionNodes that hold the input collections for the ExpansionRegion.

outputElement : ExpansionNode [0..*] (opposite ExpansionNode::regionAsOutput)
The ExpansionNodes that form the output collections of the ExpansionRegion.

16.14.24 InputPin [Class]

16.14.24.1

Description

An InputPin is a Pin that holds input values to be consumed by an Action.

16.14.24.2

Diagrams

Actions, Invocation Actions, Link End Data, Link Actions, Link Object Actions, Structural Feature Actions, 
Accept Event Actions, Other Actions, Variable Actions, Structured Actions, Object Actions

504

Unified Modeling Language 2.5

16.14.24.3

Generalizations

Pin

16.14.24.4

Specializations

ActionInputPin, ValuePin

16.14.24.5

Constraints

•

outgoing_edges_structured_only
An InputPin may have outgoing ActivityEdges only when it is owned by a StructuredActivityNode, and these 
edges must target a node contained (directly or indirectly) in the owning StructuredActivityNode.

inv: outgoing->notEmpty() implies

action<>null and
action.oclIsKindOf(StructuredActivityNode) and
action.oclAsType(StructuredActivityNode).allOwnedNodes()->includesAll(outgoing.target)

16.14.25 InvocationAction [Abstract Class]

16.14.25.1

Description

InvocationAction is an abstract class for the various actions that request Behavior invocation.

16.14.25.2

Diagrams

Invocation Actions

16.14.25.3

Generalizations

Action

16.14.25.4

Specializations

BroadcastSignalAction, CallAction, SendObjectAction, SendSignalAction

16.14.25.5

Association Ends

•

•

♦ argument : InputPin [0..*]{ordered, subsets Action::input} (opposite 
A_argument_invocationAction::invocationAction)
The InputPins that provide the argument values passed in the invocation request.

onPort : Port [0..1] (opposite A_onPort_invocationAction::invocationAction)
For CallOperationActions, SendSignalActions, and SendObjectActions, an optional Port of the target object 
through which the invocation request is sent.

16.14.26 LinkAction [Abstract Class]

16.14.26.1

Description

LinkAction is an abstract class for all Actions that identify the links to be acted on using LinkEndData.

16.14.26.2

Diagrams

Link Actions

Unified Modeling Language 2.5

505

16.14.26.3

Generalizations

Action

16.14.26.4

Specializations

WriteLinkAction, ReadLinkAction

16.14.26.5

Association Ends

•

•

♦ endData : LinkEndData [2..*]{subsets Element::ownedElement} (opposite 
A_endData_linkAction::linkAction)
The LinkEndData identifying the values on the ends of the links acting on by this LinkAction.

♦ inputValue : InputPin [1..*]{subsets Action::input} (opposite A_inputValue_linkAction::linkAction)
InputPins used by the LinkEndData of the LinkAction.

16.14.26.6

Operations

•

association() : Association
Returns the Association acted on by this LinkAction.

body: endData->asSequence()->first().end.association

16.14.26.7

Constraints

•

•

•

same_pins
The inputValue InputPins is the same as the union of all the InputPins referenced by the endData.

inv: inputValue->asBag()=endData.allPins()

same_association
The ends of the endData must all be from the same Association and include all and only the memberEnds of 
that association.

inv: endData.end = self.association().memberEnd->asBag()

not_static
The ends of the endData must not be static.

inv: endData->forAll(not end.isStatic)

16.14.27 LinkEndCreationData [Class]

16.14.27.1

Description

LinkEndCreationData is LinkEndData used to provide values for one end of a link to be created by a CreateLinkAction.

16.14.27.2

Diagrams

Link End Data, Link Actions

16.14.27.3

Generalizations

LinkEndData

506

Unified Modeling Language 2.5

16.14.27.4

Attributes

•

isReplaceAll : Boolean [1..1] = false
Specifies whether the existing links emanating from the object on this end should be destroyed before creating 
a new link.

16.14.27.5

Association Ends

•

insertAt : InputPin [0..1] (opposite A_insertAt_linkEndCreationData::linkEndCreationData)
For ordered Association ends, the InputPin that provides the position where the new link should be inserted or 
where an existing link should be moved to. The type of the insertAt InputPin is UnlimitedNatural, but the input 
cannot be zero. It is omitted for Association ends that are not ordered.

16.14.27.6

Operations

•

allPins() : InputPin [0..*]{nonunique} {redefines LinkEndData::allPins()}
Adds the insertAt InputPin (if any) to the set of all Pins.

body: self.LinkEndData::allPins()->including(insertAt)

16.14.27.7

Constraints

•

insertAt_pin
LinkEndCreationData for ordered Association ends must have a single insertAt InputPin for the insertion point 
with type UnlimitedNatural and multiplicity of 1..1, if isReplaceAll=false, and must have no InputPin for the 
insertion point when the association ends are unordered.

inv: if  not end.isOrdered
then insertAt = null
else

endif

not isReplaceAll=false implies
insertAt <> null and insertAt->forAll(type=UnlimitedNatural and is(1,1))

16.14.28 LinkEndData [Class]

16.14.28.1

Description

LinkEndData is an Element that identifies on end of a link to be read or written by a LinkAction. As a link (that is not a 
link object) cannot be passed as a runtime value to or from an Action, it is instead identified by its end objects and 
qualifier values, if any. A LinkEndData instance provides these values for a single Association end.

16.14.28.2

Diagrams

Link End Data, Link Actions

16.14.28.3

Generalizations

Element

16.14.28.4

Specializations

LinkEndCreationData, LinkEndDestructionData

Unified Modeling Language 2.5

507

16.14.28.5

Association Ends

•

•

•

end : Property [1..1] (opposite A_end_linkEndData::linkEndData)
The Association end for which this LinkEndData specifies values.

♦ qualifier : QualifierValue [0..*]{subsets Element::ownedElement} (opposite 
A_qualifier_linkEndData::linkEndData)
A set of QualifierValues used to provide values for the qualifiers of the end.

value : InputPin [0..1] (opposite A_value_linkEndData::linkEndData)
The InputPin that provides the specified value for the given end. This InputPin is omitted if the LinkEndData 
specifies the "open" end for a ReadLinkAction.

16.14.28.6

Operations

•

allPins() : InputPin [0..*]{nonunique}
Returns all the InputPins referenced by this LinkEndData. By default this includes the value and qualifier 
InputPins, but subclasses may override the operation to add other InputPins.

body: value->asBag()->union(qualifier.value)

16.14.28.7

Constraints

•

same_type
The type of the value InputPin conforms to the type of the Association end.

inv: value<>null implies value.type.conformsTo(end.type)

• multiplicity

The multiplicity of the value InputPin must be 1..1.

•

•

•

inv: value<>null implies value.is(1,1)

end_object_input_pin
The value InputPin is not also the qualifier value InputPin.

inv: value->excludesAll(qualifier.value)

property_is_association_end
The Property must be an Association memberEnd.

inv: end.association <> null

qualifiers
The qualifiers must be qualifiers of the Association end.

inv: end.qualifier->includesAll(qualifier.qualifier)

16.14.29 LinkEndDestructionData [Class]

16.14.29.1

Description

LinkEndDestructionData is LinkEndData used to provide values for one end of a link to be destroyed by a 
DestroyLinkAction.

508

Unified Modeling Language 2.5

16.14.29.2

Diagrams

Link End Data, Link Actions

16.14.29.3

Generalizations

LinkEndData

16.14.29.4

Attributes

•

isDestroyDuplicates : Boolean [1..1] = false
Specifies whether to destroy duplicates of the value in nonunique Association ends.

16.14.29.5

Association Ends

•

destroyAt : InputPin [0..1] (opposite A_destroyAt_linkEndDestructionData::linkEndDestructionData)
The InputPin that provides the position of an existing link to be destroyed in an ordered, nonunique 
Association end. The type of the destroyAt InputPin is UnlimitedNatural, but the value cannot be zero or 
unlimited.

16.14.29.6

Operations

•

allPins() : InputPin [0..*]{nonunique} {redefines LinkEndData::allPins()}
Adds the destroyAt InputPin (if any) to the set of all Pins.

body: self.LinkEndData::allPins()->including(destroyAt)

16.14.29.7

Constraints

•

destroyAt_pin
LinkEndDestructionData for ordered, nonunique Association ends must have a single destroyAt InputPin if 
isDestroyDuplicates is false, which must be of type UnlimitedNatural and have a multiplicity of 1..1. 
Otherwise, the action has no destroyAt input pin.

inv: if  not end.isOrdered or end.isUnique or isDestroyDuplicates
then destroyAt = null
else

destroyAt <> null and
destroyAt->forAll(type=UnlimitedNatural and is(1,1))

endif

16.14.30 LoopNode [Class]

16.14.30.1

Description

A LoopNode is a StructuredActivityNode that represents an iterative loop with setup, test, and body sections.

16.14.30.2

Diagrams

Structured Actions

16.14.30.3

Generalizations

StructuredActivityNode

Unified Modeling Language 2.5

509

16.14.30.4

Attributes

•

isTestedFirst : Boolean [1..1] = false
If true, the test is performed before the first execution of the bodyPart. If false, the bodyPart is executed once 
before the test is performed.

16.14.30.5

Association Ends

•

•

•

•

•

•

•

•

bodyOutput : OutputPin [0..*]{ordered} (opposite A_bodyOutput_loopNode::loopNode)
The OutputPins on Actions within the bodyPart, the values of which are moved to the loopVariable OutputPins 
after the completion of each execution of the bodyPart, before the next iteration of the loop begins or before 
the loop exits.

bodyPart : ExecutableNode [0..*] (opposite A_bodyPart_loopNode::loopNode)
The set of ExecutableNodes that perform the repetitive computations of the loop. The bodyPart is executed as 
long as the test section produces a true value.

decider : OutputPin [1..1] (opposite A_decider_loopNode::loopNode)
An OutputPin on an Action in the test section whose Boolean value determines whether to continue executing 
the loop bodyPart.

♦ loopVariable : OutputPin [0..*]{ordered, subsets Element::ownedElement} (opposite 
A_loopVariable_loopNode::loopNode)
A list of OutputPins that hold the values of the loop variables during an execution of the loop. When the test 
fails, the values are moved to the result OutputPins of the loop.

♦ loopVariableInput : InputPin [0..*]{ordered, redefines StructuredActivityNode::structuredNodeInput} 
(opposite A_loopVariableInput_loopNode::loopNode)
A list of InputPins whose values are moved into the loopVariable Pins before the first iteration of the loop.

♦ result : OutputPin [0..*]{ordered, redefines StructuredActivityNode::structuredNodeOutput} (opposite 
A_result_loopNode::loopNode)
A list of OutputPins that receive the loopVariable values after the last iteration of the loop and constitute the 
output of the LoopNode.

setupPart : ExecutableNode [0..*] (opposite A_setupPart_loopNode::loopNode)
The set of ExecutableNodes executed before the first iteration of the loop, in order to initialize values or 
perform other setup computations.

test : ExecutableNode [1..*] (opposite A_test_loopNode::loopNode)
The set of ExecutableNodes executed in order to provide the test result for the loop.

16.14.30.6

Operations

•

allActions() : Action [0..*] {redefines Action::allActions()}
Return only this LoopNode. This prevents Actions within the LoopNode from having their OutputPins used as 
bodyOutputs or decider Pins in containing LoopNodes or ConditionalNodes.

body: self->asSet()

510

Unified Modeling Language 2.5

•

sourceNodes() : ActivityNode [0..*] {redefines StructuredActivityNode::sourceNodes()}
Return the loopVariable OutputPins in addition to other source nodes for the LoopNode as a 
StructuredActivityNode.

body: self.StructuredActivityNode::sourceNodes()->union(loopVariable)

16.14.30.7

Constraints

•

•

•

•

•

result_no_incoming
The result OutputPins have no incoming edges.

inv: result.incoming->isEmpty()

input_edges
The loopVariableInputs must not have outgoing edges.

inv: loopVariableInput.outgoing->isEmpty()

executable_nodes
The union of the ExecutableNodes in the setupPart, test and bodyPart of a LoopNode must be the same as the 
subset of nodes contained in the LoopNode (considered as a StructuredActivityNode) that are 
ExecutableNodes.

inv: setupPart->union(test)->union(bodyPart)=node-
>select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->asSet()

body_output_pins
The bodyOutput pins are OutputPins on Actions in the body of the LoopNode.

inv: bodyPart.oclAsType(Action).allActions().output->includesAll(bodyOutput)

setup_test_and_body
The test and body parts of a ConditionalNode must be disjoint with each other.

inv: setupPart->intersection(test)->isEmpty() and
setupPart->intersection(bodyPart)->isEmpty() and
test->intersection(bodyPart)->isEmpty()

• matching_output_pins

A LoopNode must have the same number of bodyOutput Pins as loopVariables, and each bodyOutput Pin must 
be compatible with the corresponding loopVariable (by positional order) in type, multiplicity, ordering and 
uniqueness.

inv: bodyOutput->size()=loopVariable->size() and
Sequence{1..loopVariable->size()}->forAll(i |

bodyOutput->at(i).type.conformsTo(loopVariable->at(i).type) and
bodyOutput->at(i).isOrdered = loopVariable->at(i).isOrdered and
bodyOutput->at(i).isUnique = loopVariable->at(i).isUnique and
loopVariable->at(i).includesMultiplicity(bodyOutput->at(i)))

• matching_loop_variables

A LoopNode must have the same number of loopVariableInputs and loopVariables, and they must match in 
type, uniqueness and multiplicity.

inv: loopVariableInput->size()=loopVariable->size() and
loopVariableInput.type=loopVariable.type and
loopVariableInput.isUnique=loopVariable.isUnique and
loopVariableInput.lower=loopVariable.lower and
loopVariableInput.upper=loopVariable.upper

Unified Modeling Language 2.5

511

• matching_result_pins

A LoopNode must have the same number of result OutputPins and loopVariables, and they must match in type, 
uniqueness and multiplicity.

inv: result->size()=loopVariable->size() and
result.type=loopVariable.type and
result.isUnique=loopVariable.isUnique and
result.lower=loopVariable.lower and
result.upper=loopVariable.upper

•

loop_variable_outgoing
All ActivityEdges outgoing from loopVariable OutputPins must have targets within the LoopNode.

inv: allOwnedNodes()->includesAll(loopVariable.outgoing.target)

16.14.31 OpaqueAction [Class]

16.14.31.1

Description

An OpaqueAction is an Action whose functionality is not specified within UML.

16.14.31.2

Diagrams

Actions

16.14.31.3

Generalizations

Action

16.14.31.4

Attributes

•

•

body : String [0..*]
Provides a textual specification of the functionality of the Action, in one or more languages other than UML.

language : String [0..*]
If provided, a specification of the language used for each of the body Strings.

16.14.31.5

Association Ends

•

•

♦ inputValue : InputPin [0..*]{subsets Action::input} (opposite A_inputValue_opaqueAction::opaqueAction)
The InputPins providing inputs to the OpaqueAction.

♦ outputValue : OutputPin [0..*]{subsets Action::output} (opposite 
A_outputValue_opaqueAction::opaqueAction)
The OutputPins on which the OpaqueAction provides outputs.

16.14.31.6

Constraints

•

language_body_size
If the language attribute is not empty, then the size of the body and language lists must be the same.

inv: language->notEmpty() implies (_'body'->size() = language->size())

512

Unified Modeling Language 2.5

16.14.32 OutputPin [Class]

16.14.32.1

Description

An OutputPin is a Pin that holds output values produced by an Action.

16.14.32.2

Diagrams

Actions, Invocation Actions, Link Actions, Link Object Actions, Structural Feature Actions, Accept Event 
Actions, Other Actions, Variable Actions, Structured Actions, Object Actions

16.14.32.3

Generalizations

Pin

16.14.32.4

Constraints

•

incoming_edges_structured_only
An OutputPin may have incoming ActivityEdges only when it is owned by a StructuredActivityNode, and 
these edges must have sources contained (directly or indirectly) in the owning StructuredActivityNode.

inv: incoming->notEmpty() implies

action<>null and
action.oclIsKindOf(StructuredActivityNode) and
action.oclAsType(StructuredActivityNode).allOwnedNodes()->includesAll(incoming.source)

16.14.33 Pin [Abstract Class]

16.14.33.1

Description

A Pin is an ObjectNode and MultiplicityElement that provides input values to an Action or accepts output values from 
an Action.

16.14.33.2

Diagrams

Actions

16.14.33.3

Generalizations

ObjectNode, MultiplicityElement

16.14.33.4

Specializations

InputPin, OutputPin

16.14.33.5

Attributes

•

isControl : Boolean [1..1] = false
Indicates whether the Pin provides data to the Action or just controls how the Action executes.

16.14.33.6

Constraints

•

control_pins
A control Pin has a control type.

inv: isControl implies isControlType

Unified Modeling Language 2.5

513

•

not_unique
Pin multiplicity is not unique.

inv: not isUnique

16.14.34 QualifierValue [Class]

16.14.34.1

Description

A QualifierValue is an Element that is used as part of LinkEndData to provide the value for a single qualifier of the end 
given by the LinkEndData.

16.14.34.2

Diagrams

Link End Data

16.14.34.3

Generalizations

Element

16.14.34.4

Association Ends

•

•

qualifier : Property [1..1] (opposite A_qualifier_qualifierValue::qualifierValue)
The qualifier Property for which the value is to be specified.

value : InputPin [1..1] (opposite A_value_qualifierValue::qualifierValue)
The InputPin from which the specified value for the qualifier is taken.

16.14.34.5

Constraints

• multiplicity_of_qualifier

The multiplicity of the value InputPin is 1..1.

inv: value.is(1,1)

•

•

type_of_qualifier
The type of the value InputPin conforms to the type of the qualifier Property.

inv: value.type.conformsTo(qualifier.type)

qualifier_attribute
The qualifier must be a qualifier of the Association end of the linkEndData that owns this QualifierValue.

inv: linkEndData.end.qualifier->includes(qualifier)

16.14.35 RaiseExceptionAction [Class]

16.14.35.1

Description

A RaiseExceptionAction is an Action that causes an exception to occur. The input value becomes the exception object.

16.14.35.2

Diagrams

Other Actions

514

Unified Modeling Language 2.5

16.14.35.3

Generalizations

Action

16.14.35.4

Association Ends

•

♦ exception : InputPin [1..1]{subsets Action::input} (opposite 
A_exception_raiseExceptionAction::raiseExceptionAction)
An InputPin whose value becomes the exception object.

16.14.36 ReadExtentAction [Class]

16.14.36.1

Description

A ReadExtentAction is an Action that retrieves the current instances of a Classifier.

16.14.36.2

Diagrams

Object Actions

16.14.36.3

Generalizations

Action

16.14.36.4

Association Ends

•

•

classifier : Classifier [1..1] (opposite A_classifier_readExtentAction::readExtentAction)
The Classifier whose instances are to be retrieved.

♦ result : OutputPin [1..1]{subsets Action::output} (opposite A_result_readExtentAction::readExtentAction)
The OutputPin on which the Classifier instances are placed.

16.14.36.5

Constraints

•

type_is_classifier
The type of the result OutputPin is the classifier.

inv: result.type = classifier

• multiplicity_of_result

The multiplicity of the result OutputPin is 0..*.

inv: result.is(0,*)

16.14.37 ReadIsClassifiedObjectAction [Class]

16.14.37.1

Description

A ReadIsClassifiedObjectAction is an Action that determines whether an object is classified by a given Classifier.

16.14.37.2

Diagrams

Object Actions

Unified Modeling Language 2.5

515

16.14.37.3

Generalizations

Action

16.14.37.4

Attributes

•

isDirect : Boolean [1..1] = false
Indicates whether the input object must be directly classified by the given Classifier or whether it may also be 
an instance of a specialization of the given Classifier.

16.14.37.5

Association Ends

•

•

•

classifier : Classifier [1..1] (opposite 
A_classifier_readIsClassifiedObjectAction::readIsClassifiedObjectAction)
The Classifier against which the classification of the input object is tested.

♦ object : InputPin [1..1]{subsets Action::input} (opposite 
A_object_readIsClassifiedObjectAction::readIsClassifiedObjectAction)
The InputPin that holds the object whose classification is to be tested.

♦ result : OutputPin [1..1]{subsets Action::output} (opposite 
A_result_readIsClassifiedObjectAction::readIsClassifiedObjectAction)
The OutputPin that holds the Boolean result of the test.

16.14.37.6

Constraints

•

no_type
The object InputPin has no type.

inv: object.type = null

• multiplicity_of_output

The multiplicity of the result OutputPin is 1..1.

inv: result.is(1,1)

•

boolean_result
The type of the result OutputPin is Boolean.

inv: result.type = Boolean

• multiplicity_of_input

The multiplicity of the object InputPin is 1..1.

inv: object.is(1,1)

16.14.38 ReadLinkAction [Class]

16.14.38.1

Description

A ReadLinkAction is a LinkAction that navigates across an Association to retrieve the objects on one end.

516

Unified Modeling Language 2.5

16.14.38.2

Diagrams

Link Actions

16.14.38.3

Generalizations

LinkAction

16.14.38.4

Association Ends

•

♦ result : OutputPin [1..1]{subsets Action::output} (opposite A_result_readLinkAction::readLinkAction)
The OutputPin on which the objects retrieved from the "open" end of those links whose values on other ends 
are given by the endData.

16.14.38.5

Operations

•

openEnd() : Property [0..*]{ordered}
Returns the ends corresponding to endData with no value InputPin. (A well-formed ReadLinkAction is 
constrained to have only one of these.)

body: endData->select(value=null).end->asOrderedSet()

16.14.38.6

Constraints

•

•

•

•

•

type_and_ordering
The type and ordering of the result OutputPin are same as the type and ordering of the open Association end.

inv: self.openEnd()->forAll(type=result.type and isOrdered=result.isOrdered)

compatible_multiplicity
The multiplicity of the open Association end must be compatible with the multiplicity of the result OutputPin.

inv: self.openEnd()->first().compatibleWith(result)

visibility
Visibility of the open end must allow access from the object performing the action.

inv: let openEnd : Property = self.openEnd()->first() in
  openEnd.visibility = VisibilityKind::public or
  endData->exists(oed |
    oed.end<>openEnd and
    (_'context' = oed.end.type or
      (openEnd.visibility = VisibilityKind::protected and
        _'context'.conformsTo(oed.end.type.oclAsType(Classifier)))))

one_open_end
Exactly one linkEndData specification (corresponding to the "open" end) must not have a value InputPin.

inv: self.openEnd()->size() = 1

navigable_open_end
The open end must be navigable.

inv: self.openEnd()->first().isNavigable()

Unified Modeling Language 2.5

517

16.14.39 ReadLinkObjectEndAction [Class]

16.14.39.1

Description

A ReadLinkObjectEndAction is an Action that retrieves an end object from a link object.

16.14.39.2

Diagrams

Link Object Actions

16.14.39.3

Generalizations

Action

16.14.39.4

Association Ends

•

•

•

end : Property [1..1] (opposite A_end_readLinkObjectEndAction::readLinkObjectEndAction)
The Association end to be read.

♦ object : InputPin [1..1]{subsets Action::input} (opposite 
A_object_readLinkObjectEndAction::readLinkObjectEndAction)
The input pin from which the link object is obtained.

♦ result : OutputPin [1..1]{subsets Action::output} (opposite 
A_result_readLinkObjectEndAction::readLinkObjectEndAction)
The OutputPin where the result value is placed.

16.14.39.5

Constraints

•

property
The end Property must be an Association memberEnd.

inv: end.association <> null

• multiplicity_of_object

The multiplicity of the object InputPin is 1..1.

•

•

inv: object.is(1,1)

ends_of_association
The ends of the association must not be static.

inv: end.association.memberEnd->forAll(e | not e.isStatic)

type_of_result
The type of the result OutputPin is the same as the type of the end Property.

inv: result.type = end.type

• multiplicity_of_result

The multiplicity of the result OutputPin is 1..1.

inv: result.is(1,1)

518

Unified Modeling Language 2.5

•

•

type_of_object
The type of the object InputPin is the AssociationClass that owns the end Property.

inv: object.type = end.association

association_of_association
The association of the end must be an AssociationClass.

inv: end.association.oclIsKindOf(AssociationClass)

16.14.40 ReadLinkObjectEndQualifierAction [Class]

16.14.40.1

Description

A ReadLinkObjectEndQualifierAction is an Action that retrieves a qualifier end value from a link object.

16.14.40.2

Diagrams

Link Object Actions

16.14.40.3

Generalizations

Action

16.14.40.4

Association Ends

•

•

•

♦ object : InputPin [1..1]{subsets Action::input} (opposite 
A_object_readLinkObjectEndQualifierAction::readLinkObjectEndQualifierAction)
The InputPin from which the link object is obtained.

qualifier : Property [1..1] (opposite 
A_qualifier_readLinkObjectEndQualifierAction::readLinkObjectEndQualifierAction)
The qualifier Property to be read.

♦ result : OutputPin [1..1]{subsets Action::output} (opposite 
A_result_readLinkObjectEndQualifierAction::readLinkObjectEndQualifierAction)
The OutputPin where the result value is placed.

16.14.40.5

Constraints

• multiplicity_of_object

The multiplicity of the object InputPin is 1..1.

inv: object.is(1,1)

•

type_of_object
The type of the object InputPin is the AssociationClass that owns the Association end that has the given 
qualifier Property.

inv: object.type = qualifier.associationEnd.association

• multiplicity_of_qualifier

The multiplicity of the qualifier Property is 1..1.

inv: qualifier.is(1,1)

Unified Modeling Language 2.5

519

•

ends_of_association
The ends of the Association must not be static.

inv: qualifier.associationEnd.association.memberEnd->forAll(e | not e.isStatic)

• multiplicity_of_result

The multiplicity of the result OutputPin is 1..1.

inv: result.is(1,1)

•

•

•

same_type
The type of the result OutputPin is the same as the type of the qualifier Property.

inv: result.type = qualifier.type

association_of_association
The association of the Association end of the qualifier Property must be an AssociationClass.

inv: qualifier.associationEnd.association.oclIsKindOf(AssociationClass)

qualifier_attribute
The qualifier Property must be a qualifier of an Association end.

inv: qualifier.associationEnd <> null

16.14.41 ReadSelfAction [Class]

16.14.41.1

Description

A ReadSelfAction is an Action that retrieves the context object of the Behavior execution within which the 
ReadSelfAction execution is taking place.

16.14.41.2

Diagrams

Object Actions

16.14.41.3

Generalizations

Action

16.14.41.4

Association Ends

•

♦ result : OutputPin [1..1]{subsets Action::output} (opposite A_result_readSelfAction::readSelfAction)
The OutputPin on which the context object is placed.

16.14.41.5

Constraints

•

contained
A ReadSelfAction must have a context Classifier.

inv: _'context' <> null

• multiplicity

The multiplicity of the result OutputPin is 1..1.

520

Unified Modeling Language 2.5

•

•

inv: result.is(1,1)

not_static
If the ReadSelfAction is contained in a Behavior that is acting as a method, then the Operation of the method 
must not be static.

inv: let behavior: Behavior = self.containingBehavior() in
behavior.specification<>null implies not behavior.specification.isStatic

type
The type of the result OutputPin is the context Classifier.

inv: result.type = _'context'

16.14.42 ReadStructuralFeatureAction [Class]

16.14.42.1

Description

A ReadStructuralFeatureAction is a StructuralFeatureAction that retrieves the values of a StructuralFeature.

16.14.42.2

Diagrams

Structural Feature Actions

16.14.42.3

Generalizations

StructuralFeatureAction

16.14.42.4

Association Ends

•

♦ result : OutputPin [1..1]{subsets Action::output} (opposite 
A_result_readStructuralFeatureAction::readStructuralFeatureAction)
The OutputPin on which the result values are placed.

16.14.42.5

Constraints

• multiplicity

The multiplicity of the StructuralFeature must be compatible with the multiplicity of the result OutputPin.

inv: structuralFeature.compatibleWith(result)

•

type_and_ordering
The type and ordering of the result OutputPin are the same as the type and ordering of the StructuralFeature.

inv: result.type =structuralFeature.type and
result.isOrdered = structuralFeature.isOrdered

16.14.43 ReadVariableAction [Class]

16.14.43.1

Description

A ReadVariableAction is a VariableAction that retrieves the values of a Variable.

16.14.43.2

Diagrams

Variable Actions

Unified Modeling Language 2.5

521

16.14.43.3

Generalizations

VariableAction

16.14.43.4

Association Ends

•

♦ result : OutputPin [1..1]{subsets Action::output} (opposite 
A_result_readVariableAction::readVariableAction)
The OutputPin on which the result values are placed.

16.14.43.5

Constraints

•

•

type_and_ordering
The type and ordering of the result OutputPin are the same as the type and ordering of the variable.

inv: result.type =variable.type and
result.isOrdered = variable.isOrdered

compatible_multiplicity
The multiplicity of the variable must be compatible with the multiplicity of the output pin.

inv: variable.compatibleWith(result)

16.14.44 ReclassifyObjectAction [Class]

16.14.44.1

Description

A ReclassifyObjectAction is an Action that changes the Classifiers that classify an object.

16.14.44.2

Diagrams

Object Actions

16.14.44.3

Generalizations

Action

16.14.44.4

Attributes

•

isReplaceAll : Boolean [1..1] = false
Specifies whether existing Classifiers should be removed before adding the new Classifiers.

16.14.44.5

Association Ends

•

•

•

522

newClassifier : Classifier [0..*] (opposite A_newClassifier_reclassifyObjectAction::reclassifyObjectAction)
A set of Classifiers to be added to the Classifiers of the given object.

♦ object : InputPin [1..1]{subsets Action::input} (opposite 
A_object_reclassifyObjectAction::reclassifyObjectAction)
The InputPin that holds the object to be reclassified.

oldClassifier : Classifier [0..*] (opposite A_oldClassifier_reclassifyObjectAction::reclassifyObjectAction)
A set of Classifiers to be removed from the Classifiers of the given object.

Unified Modeling Language 2.5

16.14.44.6

Constraints

•

•

input_pin
The object InputPin has no type.

inv: object.type = null

classifier_not_abstract
None of the newClassifiers may be abstract.

inv: not newClassifier->exists(isAbstract)

• multiplicity

The multiplicity of the object InputPin is 1..1.

inv: object.is(1,1)

16.14.45 ReduceAction [Class]

16.14.45.1

Description

A ReduceAction is an Action that reduces a collection to a single value by repeatedly combining the elements of the 
collection using a reducer Behavior.

16.14.45.2

Diagrams

Other Actions

16.14.45.3

Generalizations

Action

16.14.45.4

Attributes

•

isOrdered : Boolean [1..1] = false
Indicates whether the order of the input collection should determine the order in which the reducer Behavior is 
applied to its elements.

16.14.45.5

Association Ends

•

•

•

♦ collection : InputPin [1..1]{subsets Action::input} (opposite A_collection_reduceAction::reduceAction)
The InputPin that provides the collection to be reduced.

reducer : Behavior [1..1] (opposite A_reducer_reduceAction::reduceAction)
A Behavior that is repreatedly applied to two elements of the input collection to produce a value that is of the 
same type as elements of the collection.

♦ result : OutputPin [1..1]{subsets Action::output} (opposite A_result_reduceAction::reduceAction)
The output pin on which the result value is placed.

16.14.45.6

Constraints

•

reducer_inputs_output
The reducer Behavior must have two input ownedParameters and one output ownedParameter, where the type 

Unified Modeling Language 2.5

523

of the output Parameter and the type of elements of the input collection conform to the types of the input 
Parameters.

inv: let inputs: OrderedSet(Parameter) = reducer.inputParameters() in
let outputs: OrderedSet(Parameter) = reducer.outputParameters() in
inputs->size()=2 and outputs->size()=1 and
inputs.type->forAll(t |

outputs.type->forAll(conformsTo(t)) and
-- Note that the following only checks the case when the collection is via multiple 

tokens.

collection.upperBound()>1 implies collection.type.conformsTo(t))

•

•

input_type_is_collection
The type of the collection InputPin must be a collection.

Cannot be expressed in OCL

output_types_are_compatible
The type of the output of the reducer Behavior must conform to the type of the result OutputPin.

inv: reducer.outputParameters().type->forAll(conformsTo(result.type))

16.14.46 RemoveStructuralFeatureValueAction [Class]

16.14.46.1

Description

A RemoveStructuralFeatureValueAction is a WriteStructuralFeatureAction that removes values from a 
StructuralFeature.

16.14.46.2

Diagrams

Structural Feature Actions

16.14.46.3

Generalizations

WriteStructuralFeatureAction

16.14.46.4

Attributes

•

isRemoveDuplicates : Boolean [1..1] = false
Specifies whether to remove duplicates of the value in nonunique StructuralFeatures.

16.14.46.5

Association Ends

•

♦ removeAt : InputPin [0..1]{subsets Action::input} (opposite 
A_removeAt_removeStructuralFeatureValueAction::removeStructuralFeatureValueAction)
An InputPin that provides the position of an existing value to remove in ordered, nonunique structural features. 
The type of the removeAt InputPin is UnlimitedNatural, but the value cannot be zero or unlimited.

16.14.46.6

Constraints

•

removeAt_and_value
RemoveStructuralFeatureValueActions removing a value from ordered, non-unique StructuralFeatures must 
have a single removeAt InputPin and no value InputPin, if isRemoveDuplicates is false. The removeAt 
InputPin must be of type Unlimited Natural with multiplicity 1..1. Otherwise, the Action has a value InputPin 
and no removeAt InputPin.

524

Unified Modeling Language 2.5

inv: if structuralFeature.isOrdered and not structuralFeature.isUnique and not 
isRemoveDuplicates then
  value = null and
  removeAt <> null and
  removeAt.type = UnlimitedNatural and
  removeAt.is(1,1)
else
  removeAt = null and value <> null
endif

16.14.47 RemoveVariableValueAction [Class]

16.14.47.1

Description

A RemoveVariableValueAction is a WriteVariableAction that removes values from a Variables.

16.14.47.2

Diagrams

Variable Actions

16.14.47.3

Generalizations

WriteVariableAction

16.14.47.4

Attributes

•

isRemoveDuplicates : Boolean [1..1] = false
Specifies whether to remove duplicates of the value in nonunique Variables.

16.14.47.5

Association Ends

•

♦ removeAt : InputPin [0..1]{subsets Action::input} (opposite 
A_removeAt_removeVariableValueAction::removeVariableValueAction)
An InputPin that provides the position of an existing value to remove in ordered, nonunique Variables. The 
type of the removeAt InputPin is UnlimitedNatural, but the value cannot be zero or unlimited.

16.14.47.6

Constraints

•

removeAt_and_value
ReadVariableActions removing a value from ordered, non-unique Variables must have a single removeAt 
InputPin and no value InputPin, if isRemoveDuplicates is false. The removeAt InputPin must be of type 
Unlimited Natural with multiplicity 1..1. Otherwise, the Action has a value InputPin and no removeAt 
InputPin.

inv: if variable.isOrdered and not variable.isUnique and not isRemoveDuplicates then
  value = null and
  removeAt <> null and
  removeAt.type = UnlimitedNatural and
  removeAt.is(1,1)
else
  removeAt = null and value <> null
endif

16.14.48 ReplyAction [Class]

16.14.48.1

Description

A ReplyAction is an Action that accepts a set of reply values and a value containing return information produced by a 
previous AcceptCallAction. The ReplyAction returns the values to the caller of the previous call, completing execution 
of the call.

Unified Modeling Language 2.5

525

16.14.48.2

Diagrams

Accept Event Actions

16.14.48.3

Generalizations

Action

16.14.48.4

Association Ends

•

•

•

replyToCall : Trigger [1..1] (opposite A_replyToCall_replyAction::replyAction)
The Trigger specifying the Operation whose call is being replied to.

♦ replyValue : InputPin [0..*]{ordered, subsets Action::input} (opposite 
A_replyValue_replyAction::replyAction)
A list of InputPins providing the values for the output (inout, out, and return) Parameters of the Operation. 
These values are returned to the caller.

♦ returnInformation : InputPin [1..1]{subsets Action::input} (opposite 
A_returnInformation_replyAction::replyAction)
An InputPin that holds the return information value produced by an earlier AcceptCallAction.

16.14.48.5

Constraints

•

•

pins_match_parameter
The replyValue InputPins must match the output (return, out, and inout) parameters of the operation of the 
event of the replyToCall Trigger in number, type, ordering, and multiplicity.

inv: let parameter:OrderedSet(Parameter) = 
replyToCall.event.oclAsType(CallEvent).operation.outputParameters() in
replyValue->size()=parameter->size() and
Sequence{1..replyValue->size()}->forAll(i |

replyValue->at(i).type.conformsTo(parameter->at(i).type) and
replyValue->at(i).isOrdered=parameter->at(i).isOrdered and
replyValue->at(i).compatibleWith(parameter->at(i)))

event_on_reply_to_call_trigger
The event of the replyToCall Trigger must be a CallEvent.

inv: replyToCall.event.oclIsKindOf(CallEvent)

16.14.49 SendObjectAction [Class]

16.14.49.1

Description

A SendObjectAction is an InvocationAction that transmits an input object to the target object, which is handled as a 
request message by the target object. The requestor continues execution immediately after the object is sent out and 
cannot receive reply values.

16.14.49.2

Diagrams

Invocation Actions

16.14.49.3

Generalizations

InvocationAction

526

Unified Modeling Language 2.5

16.14.49.4

Association Ends

•

•

♦ request : InputPin [1..1]{redefines InvocationAction::argument} (opposite 
A_request_sendObjectAction::sendObjectAction)
The request object, which is transmitted to the target object. The object may be copied in transmission, so 
identity might not be preserved.

♦ target : InputPin [1..1]{subsets Action::input} (opposite A_target_sendObjectAction::sendObjectAction)
The target object to which the object is sent.

16.14.49.5

Constraints

•

type_target_pin
If onPort is not empty, the Port given by onPort must be an owned or inherited feature of the type of the target 
InputPin.

inv: onPort<>null implies target.type.oclAsType(Classifier).allFeatures()->includes(onPort)

16.14.50 SendSignalAction [Class]

16.14.50.1

Description

A SendSignalAction is an InvocationAction that creates a Signal instance and transmits it to the target object. Values 
from the argument InputPins are used to provide values for the attributes of the Signal. The requestor continues 
execution immediately after the Signal instance is sent out and cannot receive reply values.

16.14.50.2

Diagrams

Invocation Actions

16.14.50.3

Generalizations

InvocationAction

16.14.50.4

Association Ends

•

•

signal : Signal [1..1] (opposite A_signal_sendSignalAction::sendSignalAction)
The Signal whose instance is transmitted to the target.

♦ target : InputPin [1..1]{subsets Action::input} (opposite A_target_sendSignalAction::sendSignalAction)
The InputPin that provides the target object to which the Signal instance is sent.

16.14.50.5

Constraints

•

type_ordering_multiplicity
The type, ordering, and multiplicity of an argument InputPin must be the same as the corresponding attribute 
of the signal.

inv: let attribute: OrderedSet(Property) = signal.allAttributes() in
Sequence{1..argument->size()}->forAll(i |

argument->at(i).type.conformsTo(attribute->at(i).type) and
argument->at(i).isOrdered = attribute->at(i).isOrdered and
argument->at(i).compatibleWith(attribute->at(i)))

Unified Modeling Language 2.5

527

•

•

number_order
The number and order of argument InputPins must be the same as the number and order of attributes of the 
signal.

inv: argument->size()=signal.allAttributes()->size()

type_target_pin
If onPort is not empty, the Port given by onPort must be an owned or inherited feature of the type of the target 
InputPin.

inv: not onPort->isEmpty() implies target.type.oclAsType(Classifier).allFeatures()-
>includes(onPort)

16.14.51 SequenceNode [Class]

16.14.51.1

Description

A SequenceNode is a StructuredActivityNode that executes a sequence of ExecutableNodes in order.

16.14.51.2

Diagrams

Structured Actions

16.14.51.3

Generalizations

StructuredActivityNode

16.14.51.4

Association Ends

•

♦ executableNode : ExecutableNode [0..*]{ordered, redefines StructuredActivityNode::node} (opposite 
A_executableNode_sequenceNode::sequenceNode)
The ordered set of ExecutableNodes to be sequenced.

16.14.52 StartClassifierBehaviorAction [Class]

16.14.52.1

Description

A StartClassifierBehaviorAction is an Action that starts the classifierBehavior of the input object.

16.14.52.2

Diagrams

Object Actions

16.14.52.3

Generalizations

Action

16.14.52.4

Association Ends

•

♦ object : InputPin [1..1]{subsets Action::input} (opposite 
A_object_startClassifierBehaviorAction::startClassifierBehaviorAction)
The InputPin that holds the object whose classifierBehavior is to be started.

528

Unified Modeling Language 2.5

16.14.52.5

Constraints

• multiplicity

The multiplicity of the object InputPin is 1..1

inv: object.is(1,1)

•

type_has_classifier
If the InputPin has a type, then the type or one of its ancestors must have a classifierBehavior.

inv: object.type->notEmpty() implies
   (object.type.oclIsKindOf(BehavioredClassifier) and 
object.type.oclAsType(BehavioredClassifier).classifierBehavior<>null)

16.14.53 StartObjectBehaviorAction [Class]

16.14.53.1

Description

A StartObjectBehaviorAction is an InvocationAction that starts the execution either of a directly instantiated Behavior 
or of the classifierBehavior of an object. Argument values may be supplied for the input Parameters of the Behavior. If 
the Behavior is invoked synchronously, then output values may be obtained for output Parameters.

16.14.53.2

Diagrams

Invocation Actions

16.14.53.3

Generalizations

CallAction

16.14.53.4

Association Ends

•

♦ object : InputPin [1..1]{subsets Action::input} (opposite 
A_object_startObjectBehaviorAction::startObjectBehaviorAction)
An InputPin that holds the object that is either a Behavior to be started or has a classifierBehavior to be started.

16.14.53.5

Operations

•

•

•

outputParameters() : Parameter [0..*]{ordered} {redefines CallAction::outputParameters()}
Return the inout, out and return ownedParameters of the Behavior being called.

body: self.behavior().outputParameters()

inputParameters() : Parameter [0..*]{ordered} {redefines CallAction::inputParameters()}
Return the in and inout ownedParameters of the Behavior being called.

body: self.behavior().inputParameters()

behavior() : Behavior [0..1]
If the type of the object InputPin is a Behavior, then that Behavior. Otherwise, if the type of the object InputPin 
is a BehavioredClassifier, then the classifierBehavior of that BehavioredClassifier.

body: if object.type.oclIsKindOf(Behavior) then
  object.type.oclAsType(Behavior)
else if object.type.oclIsKindOf(BehavioredClassifier) then

Unified Modeling Language 2.5

529

  object.type.oclAsType(BehavioredClassifier).classifierBehavior
else
  null
endif
endif

16.14.53.6

Constraints

• multiplicity_of_object

The multiplicity of the object InputPin must be 1..1.

inv: object.is(1,1)

•

•

type_of_object
The type of the object InputPin must be either a Behavior or a BehavioredClassifier with a classifierBehavior.

inv: self.behavior()<>null

no_onport
A StartObjectBehaviorAction may not specify onPort.

inv: onPort->isEmpty()

16.14.54 StructuralFeatureAction [Abstract Class]

16.14.54.1

Description

StructuralFeatureAction is an abstract class for all Actions that operate on StructuralFeatures.

16.14.54.2

Diagrams

Structural Feature Actions

16.14.54.3

Generalizations

Action

16.14.54.4

Specializations

WriteStructuralFeatureAction, ClearStructuralFeatureAction, ReadStructuralFeatureAction

16.14.54.5

Association Ends

•

•

♦ object : InputPin [1..1]{subsets Action::input} (opposite 
A_object_structuralFeatureAction::structuralFeatureAction)
The InputPin from which the object whose StructuralFeature is to be read or written is obtained.

structuralFeature : StructuralFeature [1..1] (opposite 
A_structuralFeature_structuralFeatureAction::structuralFeatureAction)
The StructuralFeature to be read or written.

16.14.54.6

Constraints

• multiplicity

The multiplicity of the object InputPin must be 1..1.

inv: object.is(1,1)

530

Unified Modeling Language 2.5

•

•

•

•

object_type
The structuralFeature must either be an owned or inherited feature of the type of the object InputPin, or it must 
be an owned end of a binary Association whose opposite end had as a type to which the type of the object 
InputPin conforms.

inv: object.type.oclAsType(Classifier).allFeatures()->includes(structuralFeature) or

object.type.conformsTo(structuralFeature.oclAsType(Property).opposite.type)

visibility
The visibility of the structuralFeature must allow access from the object performing the 
ReadStructuralFeatureAction.

inv: structuralFeature.visibility = VisibilityKind::public or
_'context'.allFeatures()->includes(structuralFeature) or
structuralFeature.visibility=VisibilityKind::protected and
_'context'.conformsTo(structuralFeature.oclAsType(Property).opposite.type.oclAsType(Classifi
er))

not_static
The structuralFeature must not be static.

inv: not structuralFeature.isStatic

one_featuring_classifier
The structuralFeature must have exactly one featuringClassifier.

inv: structuralFeature.featuringClassifier->size() = 1

16.14.55 StructuredActivityNode [Class]

16.14.55.1

Description

A StructuredActivityNode is an Action that is also an ActivityGroup and whose behavior is specified by the 
ActivityNodes and ActivityEdges it so contains. Unlike other kinds of ActivityGroup, a StructuredActivityNode owns 
the ActivityNodes and ActivityEdges it contains, and so a node or edge can only be directly contained in one 
StructuredActivityNode, though StructuredActivityNodes may be nested.

16.14.55.2

Diagrams

Structured Actions, Expansion Regions

16.14.55.3

Generalizations

Namespace, ActivityGroup, Action

16.14.55.4

Specializations

ConditionalNode, ExpansionRegion, LoopNode, SequenceNode

16.14.55.5

Attributes

• mustIsolate : Boolean [1..1] = false

If true, then any object used by an Action within the StructuredActivityNode cannot be accessed by any Action 
outside the node until the StructuredActivityNode as a whole completes. Any concurrent Actions that would 
result in accessing such objects are required to have their execution deferred until the completion of the 
StructuredActivityNode.

Unified Modeling Language 2.5

531

16.14.55.6

Association Ends

•

•

•

•

•

•

activity : Activity [0..1]{redefines ActivityGroup::inActivity, redefines ActivityNode::activity} (opposite 
Activity::structuredNode)
The Activity immediately containing the StructuredActivityNode, if it is not contained in another 
StructuredActivityNode.

♦ edge : ActivityEdge [0..*]{subsets ActivityGroup::containedEdge, subsets Element::ownedElement} 
(opposite ActivityEdge::inStructuredNode)
The ActivityEdges immediately contained in the StructuredActivityNode.

♦ node : ActivityNode [0..*]{subsets Element::ownedElement, subsets ActivityGroup::containedNode} 
(opposite ActivityNode::inStructuredNode)
The ActivityNodes immediately contained in the StructuredActivityNode.

♦ structuredNodeInput : InputPin [0..*]{subsets Action::input} (opposite 
A_structuredNodeInput_structuredActivityNode::structuredActivityNode)
The InputPins owned by the StructuredActivityNode.

♦ structuredNodeOutput : OutputPin [0..*]{subsets Action::output} (opposite 
A_structuredNodeOutput_structuredActivityNode::structuredActivityNode)
The OutputPins owned by the StructuredActivityNode.

♦ variable : Variable [0..*]{subsets Namespace::ownedMember} (opposite Variable::scope)
The Variables defined in the scope of the StructuredActivityNode.

16.14.55.7

Operations

•

•

•

•

allActions() : Action [0..*] {redefines Action::allActions()}
Returns this StructuredActivityNode and all Actions contained in it.

body: node->select(oclIsKindOf(Action)).oclAsType(Action).allActions()->including(self)-
>asSet()

allOwnedNodes() : ActivityNode [0..*] {redefines Action::allOwnedNodes()}
Returns all the ActivityNodes contained directly or indirectly within this StructuredActivityNode, in addition 
to the Pins of the StructuredActivityNode.

body: self.Action::allOwnedNodes()->union(node)->union(node-
>select(oclIsKindOf(Action)).oclAsType(Action).allOwnedNodes())->asSet()

sourceNodes() : ActivityNode [0..*]
Return those ActivityNodes contained immediately within the StructuredActivityNode that may act as sources 
of edges owned by the StructuredActivityNode.

body: node->union(input.oclAsType(ActivityNode)->asSet())->
  union(node->select(oclIsKindOf(Action)).oclAsType(Action).output)->asSet()

targetNodes() : ActivityNode [0..*]
Return those ActivityNodes contained immediately within the StructuredActivityNode that may act as targets 
of edges owned by the StructuredActivityNode.

body: node->union(output.oclAsType(ActivityNode)->asSet())->
  union(node->select(oclIsKindOf(Action)).oclAsType(Action).input)->asSet()

532

Unified Modeling Language 2.5

•

containingActivity() : Activity [0..1] {redefines ActivityGroup::containingActivity(), redefines 
ActivityNode::containingActivity()}
The Activity that directly or indirectly contains this StructuredActivityNode (considered as an Action).

body: self.Action::containingActivity()

16.14.55.8

Constraints

•

•

•

output_pin_edges
The outgoing ActivityEdges of the OutputPins of a StructuredActivityNode must have targets that are not 
within the StructuredActivityNode.

inv: output.outgoing.target->excludesAll(allOwnedNodes()-input)

edges
The edges of a StructuredActivityNode are all the ActivityEdges with source and target ActivityNodes 
contained directly or indirectly within the StructuredActivityNode and at least one of the source or target not 
contained in any more deeply nested StructuredActivityNode.

inv: edge=self.sourceNodes().outgoing->intersection(self.allOwnedNodes().incoming)->

union(self.targetNodes().incoming->intersection(self.allOwnedNodes().outgoing))->asSet()

input_pin_edges
The incoming ActivityEdges of an InputPin of a StructuredActivityNode must have sources that are not within 
the StructuredActivityNode.

inv: input.incoming.source->excludesAll(allOwnedNodes()-output)

16.14.56 TestIdentityAction [Class]

16.14.56.1

Description

A TestIdentityAction is an Action that tests if two values are identical objects.

16.14.56.2

Diagrams

Object Actions

16.14.56.3

Generalizations

Action

16.14.56.4

Association Ends

•

•

•

♦ first : InputPin [1..1]{subsets Action::input} (opposite A_first_testIdentityAction::testIdentityAction)
The InputPin on which the first input object is placed.

♦ result : OutputPin [1..1]{subsets Action::output} (opposite A_result_testIdentityAction::testIdentityAction)
The OutputPin whose Boolean value indicates whether the two input objects are identical.

♦ second : InputPin [1..1]{subsets Action::input} (opposite A_second_testIdentityAction::testIdentityAction)
The OutputPin on which the second input object is placed.

Unified Modeling Language 2.5

533

16.14.56.5

Constraints

• multiplicity

The multiplicity of the InputPins is 1..1.

inv: first.is(1,1) and second.is(1,1)

•

•

no_type
The InputPins have no type.

inv: first.type= null and second.type = null

result_is_boolean
The type of the result OutputPin is Boolean.

inv: result.type=Boolean

16.14.57 UnmarshallAction [Class]

16.14.57.1

Description

An UnmarshallAction is an Action that retrieves the values of the StructuralFeatures of an object and places them on 
OutputPins.

16.14.57.2

Diagrams

Accept Event Actions

16.14.57.3

Generalizations

Action

16.14.57.4

Association Ends

•

•

•

♦ object : InputPin [1..1]{subsets Action::input} (opposite A_object_unmarshallAction::unmarshallAction)
The InputPin that gives the object to be unmarshalled.

♦ result : OutputPin [1..*]{ordered, subsets Action::output} (opposite 
A_result_unmarshallAction::unmarshallAction)
The OutputPins on which are placed the values of the StructuralFeatures of the input object.

unmarshallType : Classifier [1..1] (opposite A_unmarshallType_unmarshallAction::unmarshallAction)
The type of the object to be unmarshalled.

16.14.57.5

Constraints

•

•

534

structural_feature
The unmarshallType must have at least one StructuralFeature.

inv: unmarshallType.allAttributes()->size() >= 1

number_of_result
The number of result outputPins must be the same as the number of attributes of the unmarshallType.

inv: unmarshallType.allAttributes()->size() = result->size()

Unified Modeling Language 2.5

•

type_ordering_and_multiplicity
The type, ordering and multiplicity of each attribute of the unmarshallType must be compatible with the type, 
ordering and multiplicity of the corresponding result OutputPin.

inv: let attribute:OrderedSet(Property) = unmarshallType.allAttributes() in
Sequence{1..result->size()}->forAll(i |

attribute->at(i).type.conformsTo(result->at(i).type) and
attribute->at(i).isOrdered=result->at(i).isOrdered and
attribute->at(i).compatibleWith(result->at(i)))

• multiplicity_of_object

The multiplicity of the object InputPin is 1..1

inv: object.is(1,1)

•

object_type
The type of the object InputPin conform to the unmarshallType.

inv: object.type.conformsTo(unmarshallType)

16.14.58 ValuePin [Class]

16.14.58.1

Description

A ValuePin is an InputPin that provides a value by evaluating a ValueSpecification.

16.14.58.2

Diagrams

Actions

16.14.58.3

Generalizations

InputPin

16.14.58.4

Association Ends

•

♦ value : ValueSpecification [1..1]{subsets Element::ownedElement} (opposite A_value_valuePin::valuePin)
The ValueSpecification that is evaluated to obtain the value that the ValuePin will provide.

16.14.58.5

Constraints

•

•

no_incoming_edges
A ValuePin may have no incoming ActivityEdges.

inv: incoming->isEmpty()

compatible_type
The type of the value ValueSpecification must conform to the type of the ValuePin.

inv: value.type.conformsTo(type)

Unified Modeling Language 2.5

535

16.14.59 ValueSpecificationAction [Class]

16.14.59.1

Description

A ValueSpecificationAction is an Action that evaluates a ValueSpecification and provides a result.

16.14.59.2

Diagrams

Object Actions

16.14.59.3

Generalizations

Action

16.14.59.4

Association Ends

•

•

♦ result : OutputPin [1..1]{subsets Action::output} (opposite 
A_result_valueSpecificationAction::valueSpecificationAction)
The OutputPin on which the result value is placed.

♦ value : ValueSpecification [1..1]{subsets Element::ownedElement} (opposite 
A_value_valueSpecificationAction::valueSpecificationAction)
The ValueSpecification to be evaluated.

16.14.59.5

Constraints

• multiplicity

The multiplicity of the result OutputPin is 1..1

inv: result.is(1,1)

•

compatible_type
The type of the value ValueSpecification must conform to the type of the result OutputPin.

inv: value.type.conformsTo(result.type)

16.14.60 VariableAction [Abstract Class]

16.14.60.1

Description

VariableAction is an abstract class for Actions that operate on a specified Variable.

16.14.60.2

Diagrams

Variable Actions

16.14.60.3

Generalizations

Action

16.14.60.4

Specializations

WriteVariableAction, ClearVariableAction, ReadVariableAction

536

Unified Modeling Language 2.5

16.14.60.5

Association Ends

•

variable : Variable [1..1] (opposite A_variable_variableAction::variableAction)
The Variable to be read or written.

16.14.60.6

Constraints

•

scope_of_variable
The VariableAction must be in the scope of the variable.

inv: variable.isAccessibleBy(self)

16.14.61 WriteLinkAction [Abstract Class]

16.14.61.1

Description

WriteLinkAction is an abstract class for LinkActions that create and destroy links.

16.14.61.2

Diagrams

Link Actions

16.14.61.3

Generalizations

LinkAction

16.14.61.4

Specializations

CreateLinkAction, DestroyLinkAction

16.14.61.5

Constraints

•

allow_access
The visibility of at least one end must allow access from the context Classifier of the WriteLinkAction.

inv: endData.end->exists(end |
  end.type=_'context' or
  end.visibility=VisibilityKind::public or
  end.visibility=VisibilityKind::protected and
  endData.end->exists(other |
    other<>end and _'context'.conformsTo(other.type.oclAsType(Classifier))))

16.14.62 WriteStructuralFeatureAction [Abstract Class]

16.14.62.1

Description

WriteStructuralFeatureAction is an abstract class for StructuralFeatureActions that change StructuralFeature values.

16.14.62.2

Diagrams

Structural Feature Actions

16.14.62.3

Generalizations

StructuralFeatureAction

Unified Modeling Language 2.5

537

16.14.62.4

Specializations

AddStructuralFeatureValueAction, RemoveStructuralFeatureValueAction

16.14.62.5

Association Ends

•

•

♦ result : OutputPin [0..1]{subsets Action::output} (opposite 
A_result_writeStructuralFeatureAction::writeStructuralFeatureAction)
The OutputPin on which is put the input object as modified by the WriteStructuralFeatureAction.

♦ value : InputPin [0..1]{subsets Action::input} (opposite 
A_value_writeStructuralFeatureAction::writeStructuralFeatureAction)
The InputPin that provides the value to be added or removed from the StructuralFeature.

16.14.62.6

Constraints

• multiplicity_of_result

The multiplicity of the result OutputPin must be 1..1.

inv: result <> null implies result.is(1,1)

•

type_of_value
The type of the value InputPin must conform to the type of the structuralFeature.

inv: value <> null implies value.type.conformsTo(structuralFeature.type)

• multiplicity_of_value

The multiplicity of the value InputPin is 1..1.

inv: value<>null implies value.is(1,1)

•

type_of_result
The type of the result OutputPin is the same as the type of the inherited object InputPin.

inv: result <> null implies result.type = object.type

16.14.63 WriteVariableAction [Abstract Class]

16.14.63.1

Description

WriteVariableAction is an abstract class for VariableActions that change Variable values.

16.14.63.2

Diagrams

Variable Actions

16.14.63.3

Generalizations

VariableAction

16.14.63.4

Specializations

AddVariableValueAction, RemoveVariableValueAction

538

Unified Modeling Language 2.5

16.14.63.5

Association Ends

•

♦ value : InputPin [0..1]{subsets Action::input} (opposite A_value_writeVariableAction::writeVariableAction)
The InputPin that gives the value to be added or removed from the Variable.

16.14.63.6

Constraints

•

value_type
The type of the value InputPin must conform to the type of the variable.

inv: value <> null implies value.type.conformsTo(variable.type)

• multiplicity

The multiplicity of the value InputPin is 1..1.

inv: value<>null implies value.is(1,1)

16.15 Association Descriptions
16.15.1

A_argument_invocationAction [Association]

16.15.1.1

Diagrams

Invocation Actions

16.15.1.2

Specializations

A_request_sendObjectAction

16.15.1.3

Owned Ends

•

invocationAction : InvocationAction [0..1]{subsets A_input_action::action} (opposite 
InvocationAction::argument)

16.15.2

A_association_clearAssociationAction [Association]

16.15.2.1

Diagrams

Link Actions

16.15.2.2

Owned Ends

•

clearAssociationAction : ClearAssociationAction [0..1] (opposite ClearAssociationAction::association)

16.15.3

A_behavior_callBehaviorAction [Association]

16.15.3.1

Diagrams

Invocation Actions

16.15.3.2

Owned Ends

•

callBehaviorAction : CallBehaviorAction [0..*] (opposite CallBehaviorAction::behavior)

Unified Modeling Language 2.5

539

16.15.4

A_bodyOutput_clause [Association]

16.15.4.1

Diagrams

Structured Actions

16.15.4.2

Owned Ends

•

clause : Clause [0..*] (opposite Clause::bodyOutput)

16.15.5

A_bodyOutput_loopNode [Association]

16.15.5.1

Diagrams

Structured Actions

16.15.5.2

Owned Ends

•

loopNode : LoopNode [0..*] (opposite LoopNode::bodyOutput)

16.15.6

A_bodyPart_loopNode [Association]

16.15.6.1

Diagrams

Structured Actions

16.15.6.2

Owned Ends

•

loopNode : LoopNode [0..1] (opposite LoopNode::bodyPart)

16.15.7

A_body_clause [Association]

16.15.7.1

Diagrams

Structured Actions

16.15.7.2

Owned Ends

•

clause : Clause [0..1] (opposite Clause::body)

16.15.8

A_classifier_createObjectAction [Association]

16.15.8.1

Diagrams

Object Actions

16.15.8.2

Owned Ends

•

createObjectAction : CreateObjectAction [0..*] (opposite CreateObjectAction::classifier)

540

Unified Modeling Language 2.5

16.15.9

A_classifier_readExtentAction [Association]

16.15.9.1

Diagrams

Object Actions

16.15.9.2

Owned Ends

•

readExtentAction : ReadExtentAction [0..1] (opposite ReadExtentAction::classifier)

16.15.10 A_classifier_readIsClassifiedObjectAction [Association]

16.15.10.1

Diagrams

Object Actions

16.15.10.2

Owned Ends

•

readIsClassifiedObjectAction : ReadIsClassifiedObjectAction [0..*] (opposite 
ReadIsClassifiedObjectAction::classifier)

16.15.11 A_clause_conditionalNode [Association]

16.15.11.1

Diagrams

Structured Actions

16.15.11.2

Owned Ends

•

conditionalNode : ConditionalNode [1..1]{subsets Element::owner} (opposite ConditionalNode::clause)

16.15.12 A_collection_reduceAction [Association]

16.15.12.1

Diagrams

Other Actions

16.15.12.2

Owned Ends

•

reduceAction : ReduceAction [0..1]{subsets A_input_action::action} (opposite ReduceAction::collection)

16.15.13 A_context_action [Association]

16.15.13.1

Diagrams

Actions

16.15.13.2

Owned Ends

•

action : Action [0..*] (opposite Action::context)

Unified Modeling Language 2.5

541

16.15.14 A_decider_clause [Association]

16.15.14.1

Diagrams

Structured Actions

16.15.14.2

Owned Ends

•

clause : Clause [0..1] (opposite Clause::decider)

16.15.15 A_decider_loopNode [Association]

16.15.15.1

Diagrams

Structured Actions

16.15.15.2

Owned Ends

•

loopNode : LoopNode [0..1] (opposite LoopNode::decider)

16.15.16 A_destroyAt_linkEndDestructionData [Association]

16.15.16.1

Diagrams

Link End Data

16.15.16.2

Owned Ends

•

linkEndDestructionData : LinkEndDestructionData [0..1] (opposite LinkEndDestructionData::destroyAt)

16.15.17 A_edge_inStructuredNode [Association]

16.15.17.1

Diagrams

Structured Actions

16.15.17.2

Member Ends

•

 

StructuredActivityNode::edge
 

 
• ActivityEdge::inStructuredNode

 

16.15.18 A_endData_createLinkAction [Association]

16.15.18.1

Diagrams

Link Actions

16.15.18.2

Generalizations

A_endData_linkAction

542

Unified Modeling Language 2.5

16.15.18.3

Owned Ends

•

createLinkAction : CreateLinkAction [1..1]{redefines A_endData_linkAction::linkAction} (opposite 
CreateLinkAction::endData)

16.15.19 A_endData_destroyLinkAction [Association]

16.15.19.1

Diagrams

Link Actions

16.15.19.2

Generalizations

A_endData_linkAction

16.15.19.3

Owned Ends

•

destroyLinkAction : DestroyLinkAction [1..1]{redefines A_endData_linkAction::linkAction} (opposite 
DestroyLinkAction::endData)

16.15.20 A_endData_linkAction [Association]

16.15.20.1

Diagrams

Link Actions

16.15.20.2

Specializations

A_endData_destroyLinkAction, A_endData_createLinkAction

16.15.20.3

Owned Ends

•

linkAction : LinkAction [1..1]{subsets Element::owner} (opposite LinkAction::endData)

16.15.21 A_end_linkEndData [Association]

16.15.21.1

Diagrams

Link End Data

16.15.21.2

Owned Ends

•

linkEndData : LinkEndData [0..*] (opposite LinkEndData::end)

16.15.22 A_end_readLinkObjectEndAction [Association]

16.15.22.1

Diagrams

Link Object Actions

16.15.22.2

Owned Ends

•

readLinkObjectEndAction : ReadLinkObjectEndAction [0..1] (opposite ReadLinkObjectEndAction::end)

Unified Modeling Language 2.5

543

16.15.23 A_exception_raiseExceptionAction [Association]

16.15.23.1

Diagrams

Other Actions

16.15.23.2

Owned Ends

•

raiseExceptionAction : RaiseExceptionAction [0..1]{subsets A_input_action::action} (opposite 
RaiseExceptionAction::exception)

16.15.24 A_executableNode_sequenceNode [Association]

16.15.24.1

Diagrams

Structured Actions

16.15.24.2

Owned Ends

•

sequenceNode : SequenceNode [0..1]{subsets ActivityNode::inStructuredNode} (opposite 
SequenceNode::executableNode)

16.15.25 A_first_testIdentityAction [Association]

16.15.25.1

Diagrams

Object Actions

16.15.25.2

Owned Ends

•

testIdentityAction : TestIdentityAction [0..1]{subsets A_input_action::action} (opposite 
TestIdentityAction::first)

16.15.26 A_fromAction_actionInputPin [Association]

16.15.26.1

Diagrams

Actions

16.15.26.2

Owned Ends

•

actionInputPin : ActionInputPin [0..1]{subsets Element::owner} (opposite ActionInputPin::fromAction)

16.15.27 A_inputElement_regionAsInput [Association]

16.15.27.1

Diagrams

Expansion Regions

16.15.27.2

Member Ends

ExpansionRegion::inputElement
 
 

ExpansionNode::regionAsInput
 

 

•

•

544

Unified Modeling Language 2.5

16.15.28 A_inputValue_linkAction [Association]

16.15.28.1

Diagrams

Link Actions

16.15.28.2

Owned Ends

•

linkAction : LinkAction [0..1]{subsets A_input_action::action} (opposite LinkAction::inputValue)

16.15.29 A_inputValue_opaqueAction [Association]

16.15.29.1

Diagrams

Actions

16.15.29.2

Owned Ends

•

opaqueAction : OpaqueAction [0..1]{subsets A_input_action::action} (opposite OpaqueAction::inputValue)

16.15.30 A_input_action [Association]

16.15.30.1

Diagrams

Actions

16.15.30.2

Owned Ends

•

/action : Action [0..1]{union, subsets Element::owner} (opposite Action::input)

16.15.31 A_insertAt_addStructuralFeatureValueAction [Association]

16.15.31.1

Diagrams

Structural Feature Actions

16.15.31.2

Owned Ends

•

addStructuralFeatureValueAction : AddStructuralFeatureValueAction [0..1]{subsets A_input_action::action} 
(opposite AddStructuralFeatureValueAction::insertAt)

16.15.32 A_insertAt_addVariableValueAction [Association]

16.15.32.1

Diagrams

Variable Actions

16.15.32.2

Owned Ends

•

addVariableValueAction : AddVariableValueAction [0..1]{subsets A_input_action::action} (opposite 
AddVariableValueAction::insertAt)

Unified Modeling Language 2.5

545

16.15.33 A_insertAt_linkEndCreationData [Association]

16.15.33.1

Diagrams

Link End Data

16.15.33.2

Owned Ends

•

linkEndCreationData : LinkEndCreationData [0..1] (opposite LinkEndCreationData::insertAt)

16.15.34 A_localPostcondition_action [Association]

16.15.34.1

Diagrams

Actions

16.15.34.2

Owned Ends

•

action : Action [0..1]{subsets Element::owner} (opposite Action::localPostcondition)

16.15.35 A_localPrecondition_action [Association]

16.15.35.1

Diagrams

Actions

16.15.35.2

Owned Ends

•

action : Action [0..1]{subsets Element::owner} (opposite Action::localPrecondition)

16.15.36 A_loopVariableInput_loopNode [Association]

16.15.36.1

Diagrams

Structured Actions

16.15.36.2

Owned Ends

•

loopNode : LoopNode [0..1]{subsets 
A_structuredNodeInput_structuredActivityNode::structuredActivityNode} (opposite 
LoopNode::loopVariableInput)

16.15.37 A_loopVariable_loopNode [Association]

16.15.37.1

Diagrams

Structured Actions

16.15.37.2

Owned Ends

•

546

loopNode : LoopNode [0..1]{subsets Element::owner} (opposite LoopNode::loopVariable)

Unified Modeling Language 2.5

16.15.38 A_newClassifier_reclassifyObjectAction [Association]

16.15.38.1

Diagrams

Object Actions

16.15.38.2

Owned Ends

•

reclassifyObjectAction : ReclassifyObjectAction [0..*] (opposite ReclassifyObjectAction::newClassifier)

16.15.39 A_node_inStructuredNode [Association]

16.15.39.1

Diagrams

Structured Actions

16.15.39.2

Member Ends

•

 

StructuredActivityNode::node
 

 
• ActivityNode::inStructuredNode

 

16.15.40 A_object_clearAssociationAction [Association]

16.15.40.1

Diagrams

Link Actions

16.15.40.2

Owned Ends

•

clearAssociationAction : ClearAssociationAction [0..1]{subsets A_input_action::action} (opposite 
ClearAssociationAction::object)

16.15.41 A_object_readIsClassifiedObjectAction [Association]

16.15.41.1

Diagrams

Object Actions

16.15.41.2

Owned Ends

•

readIsClassifiedObjectAction : ReadIsClassifiedObjectAction [0..1]{subsets A_input_action::action} (opposite
ReadIsClassifiedObjectAction::object)

16.15.42 A_object_readLinkObjectEndAction [Association]

16.15.42.1

Diagrams

Link Object Actions

16.15.42.2

Owned Ends

•

readLinkObjectEndAction : ReadLinkObjectEndAction [0..1]{subsets A_input_action::action} (opposite 
ReadLinkObjectEndAction::object)

Unified Modeling Language 2.5

547

16.15.43 A_object_readLinkObjectEndQualifierAction [Association]

16.15.43.1

Diagrams

Link Object Actions

16.15.43.2

Owned Ends

•

readLinkObjectEndQualifierAction : ReadLinkObjectEndQualifierAction [0..1]{subsets 
A_input_action::action} (opposite ReadLinkObjectEndQualifierAction::object)

16.15.44 A_object_reclassifyObjectAction [Association]

16.15.44.1

Diagrams

Object Actions

16.15.44.2

Owned Ends

•

reclassifyObjectAction : ReclassifyObjectAction [0..1]{subsets A_input_action::action} (opposite 
ReclassifyObjectAction::object)

16.15.45 A_object_startClassifierBehaviorAction [Association]

16.15.45.1

Diagrams

Object Actions

16.15.45.2

Owned Ends

•

startClassifierBehaviorAction : StartClassifierBehaviorAction [0..1]{subsets A_input_action::action} (opposite
StartClassifierBehaviorAction::object)

16.15.46 A_object_startObjectBehaviorAction [Association]

16.15.46.1

Diagrams

Invocation Actions

16.15.46.2

Owned Ends

•

startObjectBehaviorAction : StartObjectBehaviorAction [0..1]{subsets A_input_action::action} (opposite 
StartObjectBehaviorAction::object)

16.15.47 A_object_structuralFeatureAction [Association]

16.15.47.1

Diagrams

Structural Feature Actions

16.15.47.2

Owned Ends

•

548

structuralFeatureAction : StructuralFeatureAction [0..1]{subsets A_input_action::action} (opposite 
StructuralFeatureAction::object)

Unified Modeling Language 2.5

16.15.48 A_object_unmarshallAction [Association]

16.15.48.1

Diagrams

Accept Event Actions

16.15.48.2

Owned Ends

•

unmarshallAction : UnmarshallAction [0..1]{subsets A_input_action::action} (opposite 
UnmarshallAction::object)

16.15.49 A_oldClassifier_reclassifyObjectAction [Association]

16.15.49.1

Diagrams

Object Actions

16.15.49.2

Owned Ends

•

reclassifyObjectAction : ReclassifyObjectAction [0..*] (opposite ReclassifyObjectAction::oldClassifier)

16.15.50 A_onPort_invocationAction [Association]

16.15.50.1

Diagrams

Invocation Actions

16.15.50.2

Owned Ends

•

invocationAction : InvocationAction [0..*] (opposite InvocationAction::onPort)

16.15.51 A_operation_callOperationAction [Association]

16.15.51.1

Diagrams

Invocation Actions

16.15.51.2

Owned Ends

•

callOperationAction : CallOperationAction [0..*] (opposite CallOperationAction::operation)

16.15.52 A_outputElement_regionAsOutput [Association]

16.15.52.1

Diagrams

Expansion Regions

16.15.52.2

Member Ends

•

•

ExpansionRegion::outputElement
 
 

ExpansionNode::regionAsOutput
 

 

Unified Modeling Language 2.5

549

16.15.53 A_outputValue_opaqueAction [Association]

16.15.53.1

Diagrams

Actions

16.15.53.2

Owned Ends

•

opaqueAction : OpaqueAction [0..1]{subsets A_output_action::action} (opposite OpaqueAction::outputValue)

16.15.54 A_output_action [Association]

16.15.54.1

Diagrams

Actions

16.15.54.2

Owned Ends

•

/action : Action [0..1]{union, subsets Element::owner} (opposite Action::output)

16.15.55 A_predecessorClause_successorClause [Association]

16.15.55.1

Diagrams

Structured Actions

16.15.55.2

Member Ends

 

• Clause::predecessorClause
• Clause::successorClause

 

 

 

16.15.56 A_qualifier_linkEndData [Association]

16.15.56.1

Diagrams

Link End Data

16.15.56.2

Owned Ends

•

linkEndData : LinkEndData [1..1]{subsets Element::owner} (opposite LinkEndData::qualifier)

16.15.57 A_qualifier_qualifierValue [Association]

16.15.57.1

Diagrams

Link End Data

16.15.57.2

Owned Ends

•

qualifierValue : QualifierValue [0..*] (opposite QualifierValue::qualifier)

550

Unified Modeling Language 2.5

16.15.58 A_qualifier_readLinkObjectEndQualifierAction [Association]

16.15.58.1

Diagrams

Link Object Actions

16.15.58.2

Owned Ends

•

readLinkObjectEndQualifierAction : ReadLinkObjectEndQualifierAction [0..1] (opposite 
ReadLinkObjectEndQualifierAction::qualifier)

16.15.59 A_reducer_reduceAction [Association]

16.15.59.1

Diagrams

Other Actions

16.15.59.2

Owned Ends

•

reduceAction : ReduceAction [0..*] (opposite ReduceAction::reducer)

16.15.60 A_removeAt_removeStructuralFeatureValueAction [Association]

16.15.60.1

Diagrams

Structural Feature Actions

16.15.60.2

Owned Ends

•

removeStructuralFeatureValueAction : RemoveStructuralFeatureValueAction [0..1]{subsets 
A_input_action::action} (opposite RemoveStructuralFeatureValueAction::removeAt)

16.15.61 A_removeAt_removeVariableValueAction [Association]

16.15.61.1

Diagrams

Variable Actions

16.15.61.2

Owned Ends

•

removeVariableValueAction : RemoveVariableValueAction [0..1]{subsets A_input_action::action} (opposite 
RemoveVariableValueAction::removeAt)

16.15.62 A_replyToCall_replyAction [Association]

16.15.62.1

Diagrams

Accept Event Actions

16.15.62.2

Owned Ends

•

replyAction : ReplyAction [0..1] (opposite ReplyAction::replyToCall)

Unified Modeling Language 2.5

551

16.15.63 A_replyValue_replyAction [Association]

16.15.63.1

Diagrams

Accept Event Actions

16.15.63.2

Owned Ends

•

replyAction : ReplyAction [0..1]{subsets A_input_action::action} (opposite ReplyAction::replyValue)

16.15.64 A_request_sendObjectAction [Association]

16.15.64.1

Diagrams

Invocation Actions

16.15.64.2

Generalizations

A_argument_invocationAction

16.15.64.3

Owned Ends

•

sendObjectAction : SendObjectAction [0..1]{redefines A_argument_invocationAction::invocationAction} 
(opposite SendObjectAction::request)

16.15.65 A_result_acceptEventAction [Association]

16.15.65.1

Diagrams

Accept Event Actions

16.15.65.2

Owned Ends

•

acceptEventAction : AcceptEventAction [0..1]{subsets A_output_action::action} (opposite 
AcceptEventAction::result)

16.15.66 A_result_callAction [Association]

16.15.66.1

Diagrams

Invocation Actions

16.15.66.2

Owned Ends

•

callAction : CallAction [0..1]{subsets A_output_action::action} (opposite CallAction::result)

16.15.67 A_result_clearStructuralFeatureAction [Association]

16.15.67.1

Diagrams

Structural Feature Actions

552

Unified Modeling Language 2.5

16.15.67.2

Owned Ends

•

clearStructuralFeatureAction : ClearStructuralFeatureAction [0..1]{subsets A_output_action::action} (opposite
ClearStructuralFeatureAction::result)

16.15.68 A_result_conditionalNode [Association]

16.15.68.1

Diagrams

Structured Actions

16.15.68.2

Owned Ends

•

conditionalNode : ConditionalNode [0..1]{subsets 
A_structuredNodeOutput_structuredActivityNode::structuredActivityNode} (opposite 
ConditionalNode::result)

16.15.69 A_result_createLinkObjectAction [Association]

16.15.69.1

Diagrams

Link Object Actions

16.15.69.2

Owned Ends

•

createLinkObjectAction : CreateLinkObjectAction [0..1]{subsets A_output_action::action} (opposite 
CreateLinkObjectAction::result)

16.15.70 A_result_createObjectAction [Association]

16.15.70.1

Diagrams

Object Actions

16.15.70.2

Owned Ends

•

createObjectAction : CreateObjectAction [0..1]{subsets A_output_action::action} (opposite 
CreateObjectAction::result)

16.15.71 A_result_loopNode [Association]

16.15.71.1

Diagrams

Structured Actions

16.15.71.2

Owned Ends

•

loopNode : LoopNode [0..1]{subsets 
A_structuredNodeOutput_structuredActivityNode::structuredActivityNode} (opposite LoopNode::result)

Unified Modeling Language 2.5

553

16.15.72 A_result_readExtentAction [Association]

16.15.72.1

Diagrams

Object Actions

16.15.72.2

Owned Ends

•

readExtentAction : ReadExtentAction [0..1]{subsets A_output_action::action} (opposite 
ReadExtentAction::result)

16.15.73 A_result_readIsClassifiedObjectAction [Association]

16.15.73.1

Diagrams

Object Actions

16.15.73.2

Owned Ends

•

readIsClassifiedObjectAction : ReadIsClassifiedObjectAction [0..1]{subsets A_output_action::action} 
(opposite ReadIsClassifiedObjectAction::result)

16.15.74 A_result_readLinkAction [Association]

16.15.74.1

Diagrams

Link Actions

16.15.74.2

Owned Ends

•

readLinkAction : ReadLinkAction [0..1]{subsets A_output_action::action} (opposite ReadLinkAction::result)

16.15.75 A_result_readLinkObjectEndAction [Association]

16.15.75.1

Diagrams

Link Object Actions

16.15.75.2

Owned Ends

•

readLinkObjectEndAction : ReadLinkObjectEndAction [0..1]{subsets A_output_action::action} (opposite 
ReadLinkObjectEndAction::result)

16.15.76 A_result_readLinkObjectEndQualifierAction [Association]

16.15.76.1

Diagrams

Link Object Actions

16.15.76.2

Owned Ends

•

554

readLinkObjectEndQualifierAction : ReadLinkObjectEndQualifierAction [0..1]{subsets 
A_output_action::action} (opposite ReadLinkObjectEndQualifierAction::result)

Unified Modeling Language 2.5

16.15.77 A_result_readSelfAction [Association]

16.15.77.1

Diagrams

Object Actions

16.15.77.2

Owned Ends

•

readSelfAction : ReadSelfAction [0..1]{subsets A_output_action::action} (opposite ReadSelfAction::result)

16.15.78 A_result_readStructuralFeatureAction [Association]

16.15.78.1

Diagrams

Structural Feature Actions

16.15.78.2

Owned Ends

•

readStructuralFeatureAction : ReadStructuralFeatureAction [0..1]{subsets A_output_action::action} (opposite 
ReadStructuralFeatureAction::result)

16.15.79 A_result_readVariableAction [Association]

16.15.79.1

Diagrams

Variable Actions

16.15.79.2

Owned Ends

•

readVariableAction : ReadVariableAction [0..1]{subsets A_output_action::action} (opposite 
ReadVariableAction::result)

16.15.80 A_result_reduceAction [Association]

16.15.80.1

Diagrams

Other Actions

16.15.80.2

Owned Ends

•

reduceAction : ReduceAction [0..1]{subsets A_output_action::action} (opposite ReduceAction::result)

16.15.81 A_result_testIdentityAction [Association]

16.15.81.1

Diagrams

Object Actions

16.15.81.2

Owned Ends

•

testIdentityAction : TestIdentityAction [0..1]{subsets A_output_action::action} (opposite 
TestIdentityAction::result)

Unified Modeling Language 2.5

555

16.15.82 A_result_unmarshallAction [Association]

16.15.82.1

Diagrams

Accept Event Actions

16.15.82.2

Owned Ends

•

unmarshallAction : UnmarshallAction [0..1]{subsets A_output_action::action} (opposite 
UnmarshallAction::result)

16.15.83 A_result_valueSpecificationAction [Association]

16.15.83.1

Diagrams

Object Actions

16.15.83.2

Owned Ends

•

valueSpecificationAction : ValueSpecificationAction [0..1]{subsets A_output_action::action} (opposite 
ValueSpecificationAction::result)

16.15.84 A_result_writeStructuralFeatureAction [Association]

16.15.84.1

Diagrams

Structural Feature Actions

16.15.84.2

Owned Ends

• writeStructuralFeatureAction : WriteStructuralFeatureAction [0..1]{subsets A_output_action::action} (opposite

WriteStructuralFeatureAction::result)

16.15.85 A_returnInformation_acceptCallAction [Association]

16.15.85.1

Diagrams

Accept Event Actions

16.15.85.2

Owned Ends

•

acceptCallAction : AcceptCallAction [0..1]{subsets A_output_action::action} (opposite 
AcceptCallAction::returnInformation)

16.15.86 A_returnInformation_replyAction [Association]

16.15.86.1

Diagrams

Accept Event Actions

16.15.86.2

Owned Ends

•

556

replyAction : ReplyAction [0..1]{subsets A_input_action::action} (opposite ReplyAction::returnInformation)

Unified Modeling Language 2.5

16.15.87 A_second_testIdentityAction [Association]

16.15.87.1

Diagrams

Object Actions

16.15.87.2

Owned Ends

•

testIdentityAction : TestIdentityAction [0..1]{subsets A_input_action::action} (opposite 
TestIdentityAction::second)

16.15.88 A_setupPart_loopNode [Association]

16.15.88.1

Diagrams

Structured Actions

16.15.88.2

Owned Ends

•

loopNode : LoopNode [0..1] (opposite LoopNode::setupPart)

16.15.89 A_signal_broadcastSignalAction [Association]

16.15.89.1

Diagrams

Invocation Actions

16.15.89.2

Owned Ends

•

broadcastSignalAction : BroadcastSignalAction [0..*] (opposite BroadcastSignalAction::signal)

16.15.90 A_signal_sendSignalAction [Association]

16.15.90.1

Diagrams

Invocation Actions

16.15.90.2

Owned Ends

•

sendSignalAction : SendSignalAction [0..*] (opposite SendSignalAction::signal)

16.15.91 A_structuralFeature_structuralFeatureAction [Association]

16.15.91.1

Diagrams

Structural Feature Actions

16.15.91.2

Owned Ends

•

structuralFeatureAction : StructuralFeatureAction [0..*] (opposite StructuralFeatureAction::structuralFeature)

Unified Modeling Language 2.5

557

16.15.92 A_structuredNodeInput_structuredActivityNode [Association]

16.15.92.1

Diagrams

Structured Actions

16.15.92.2

Owned Ends

•

structuredActivityNode : StructuredActivityNode [0..1]{subsets A_input_action::action} (opposite 
StructuredActivityNode::structuredNodeInput)

16.15.93 A_structuredNodeOutput_structuredActivityNode [Association]

16.15.93.1

Diagrams

Structured Actions

16.15.93.2

Owned Ends

•

structuredActivityNode : StructuredActivityNode [0..1]{subsets A_output_action::action} (opposite 
StructuredActivityNode::structuredNodeOutput)

16.15.94 A_target_callOperationAction [Association]

16.15.94.1

Diagrams

Invocation Actions

16.15.94.2

Owned Ends

•

callOperationAction : CallOperationAction [0..1]{subsets A_input_action::action} (opposite 
CallOperationAction::target)

16.15.95 A_target_destroyObjectAction [Association]

16.15.95.1

Diagrams

Object Actions

16.15.95.2

Owned Ends

•

destroyObjectAction : DestroyObjectAction [0..1]{subsets A_input_action::action} (opposite 
DestroyObjectAction::target)

16.15.96 A_target_sendObjectAction [Association]

16.15.96.1

Diagrams

Invocation Actions

16.15.96.2

Owned Ends

•

558

sendObjectAction : SendObjectAction [0..1]{subsets A_input_action::action} (opposite 
SendObjectAction::target)

Unified Modeling Language 2.5

16.15.97 A_target_sendSignalAction [Association]

16.15.97.1

Diagrams

Invocation Actions

16.15.97.2

Owned Ends

•

sendSignalAction : SendSignalAction [0..1]{subsets A_input_action::action} (opposite 
SendSignalAction::target)

16.15.98 A_test_clause [Association]

16.15.98.1

Diagrams

Structured Actions

16.15.98.2

Owned Ends

•

clause : Clause [0..1] (opposite Clause::test)

16.15.99 A_test_loopNode [Association]

16.15.99.1

Diagrams

Structured Actions

16.15.99.2

Owned Ends

•

loopNode : LoopNode [0..1] (opposite LoopNode::test)

16.15.100 A_trigger_acceptEventAction [Association]

16.15.100.1 Diagrams

Accept Event Actions

16.15.100.2 Owned Ends

•

acceptEventAction : AcceptEventAction [0..1]{subsets Element::owner} (opposite 
AcceptEventAction::trigger)

16.15.101 A_unmarshallType_unmarshallAction [Association]

16.15.101.1 Diagrams

Accept Event Actions

16.15.101.2 Owned Ends

•

unmarshallAction : UnmarshallAction [0..*] (opposite UnmarshallAction::unmarshallType)

Unified Modeling Language 2.5

559

16.15.102 A_value_linkEndData [Association]

16.15.102.1 Diagrams

Link End Data

16.15.102.2 Owned Ends

•

linkEndData : LinkEndData [0..1] (opposite LinkEndData::value)

16.15.103 A_value_qualifierValue [Association]

16.15.103.1 Diagrams

Link End Data

16.15.103.2 Owned Ends

•

qualifierValue : QualifierValue [0..1] (opposite QualifierValue::value)

16.15.104 A_value_valuePin [Association]

16.15.104.1 Diagrams

Actions

16.15.104.2 Owned Ends

•

valuePin : ValuePin [0..1]{subsets Element::owner} (opposite ValuePin::value)

16.15.105 A_value_valueSpecificationAction [Association]

16.15.105.1 Diagrams

Object Actions

16.15.105.2 Owned Ends

•

valueSpecificationAction : ValueSpecificationAction [0..1]{subsets Element::owner} (opposite 
ValueSpecificationAction::value)

16.15.106 A_value_writeStructuralFeatureAction [Association]

16.15.106.1 Diagrams

Structural Feature Actions

16.15.106.2 Owned Ends

• writeStructuralFeatureAction : WriteStructuralFeatureAction [0..1]{subsets A_input_action::action} (opposite 

WriteStructuralFeatureAction::value)

560

Unified Modeling Language 2.5

16.15.107 A_value_writeVariableAction [Association]

16.15.107.1 Diagrams

Variable Actions

16.15.107.2 Owned Ends

• writeVariableAction : WriteVariableAction [0..1]{subsets A_input_action::action} (opposite 

WriteVariableAction::value)

16.15.108 A_variable_scope [Association]

16.15.108.1 Diagrams

Structured Actions

16.15.108.2 Member Ends

•

StructuredActivityNode::variable
 

 

• Variable::scope

 

 

16.15.109 A_variable_variableAction [Association]

16.15.109.1 Diagrams

Variable Actions

16.15.109.2 Owned Ends

•

variableAction : VariableAction [0..*] (opposite VariableAction::variable)

Unified Modeling Language 2.5

561

Interactions
Summary
Overview

17
17.1
17.1.1
Interactions are used in a number of different situations. They are used to get a better grip of an interaction situation for 
an individual designer or for a group that needs to achieve a common understanding of the situation. Interactions are 
also used during the more detailed design phase where the precise inter-process communication must be set up 
according to formal protocols. When testing is performed, the traces of the system can be described as interactions and 
compared with those of the earlier phases.
In this clause we use the term trace to mean “sequence of event occurrences,” which corresponds well with common 
use in the area of trace-semantics, which is a preferred way to describe the semantics of Interactions. We may denote 
this by <eventoccurrence1, eventoccurrence2, ...,eventoccurrence-n>. We are aware that other parts of the UML 
language definition use the term “trace” for other purposes.
Interaction specifications place partial ordering constraints on allowed and disallowed traces. A partial order restricts the 
order in which events can (or cannot) occur in any given system trace.
The Interaction package describes the concepts needed to express Interactions, depending on their purpose. An 
interaction can be displayed in several different types of diagrams: Sequence Diagrams, Interaction Overview 
Diagrams, and Communication Diagrams. Optional diagram types such as Timing Diagrams and Interaction Tables 
come in addition. Each type of diagram provides slightly different capabilities that make it more appropriate for certain 
situations.
Interactions are a common mechanism for describing systems that can be understood and produced, at varying levels of 
detail, by both professionals of computer systems design, as well as potential end users and stakeholders of (future) 
systems.
Typically when interactions are produced by designers or by running systems, the case is that the interactions do not tell 
the complete story. There are normally other legal and possible traces that are not contained within the described 
interactions. Some projects may, however, request that all possible traces of a system shall be documented through 
interactions in the form of sequence diagrams or similar notations.
The most visible aspects of an Interaction are the messages between lifelines. The sequence of the messages is 
considered important for the understanding of the situation. The data that the messages convey and the lifelines store 
may also be very important, but the Interactions do not focus on the manipulation of data even though data can be used 
to decorate the diagrams.
By interleaving we mean the merging of two or more traces such that the events from different traces may come in any 
order in the resulting trace, while events within the same trace retain their order. Interleaving semantics is different from 
a semantics where it is perceived that two events may occur at exactly the same time. To explain Interactions we apply 
an Interleaving Semantics.

Basic trace model

17.1.2
Clause 13, Common Behaviors, describes the general semantics of the execution of Behaviors. Interactions are kinds of 
Behaviors that model emergent behaviors, as defined in sub clause 13.1. As discussed in sub clause 13.2.3, the 
execution of a Behavior results in an execution trace. Such a trace is a sequence of event occurrences, which, in this 
clause, will be denoted <e1, e2, . . . , en>. Each event occurrence may also include information about the values of all 
relevant objects at the point of time of its occurrence.
The semantics of an Interaction are expressed in terms of a pair [P, I], where P is the set of valid traces and I is the set of 
invalid traces. P ! I need not be the whole universe of traces. Two Interactions are equivalent if their pairs of trace-sets 
are equal. The semantics of each construct of an Interaction (such as the various kinds of CombinedFragments) are 

Unified Modeling Language 2.5

563

expressed in terms of how they relate to a pair of sets of traces. For simplicity we normally refer only to the set of valid 
traces, as these traces are those mostly modeled.

Partial ordering constraints on valid and invalid traces

17.1.3
The set of valid traces is constrained by a partial ordering of the event occurrences in the traces. Likewise, the set of 
invalid traces is also constrained by a partial ordering of the event occurrences in the trace.
In an interaction diagram each vertical line describes the time-line for a process, where time increases down the page. 
The distance between two events on a time-line does not represent any literal measurement of time, only that non-zero 
time has passed.
The instances in an interaction in principle operate independently of each other. No global notion of time is assumed. 
The only dependencies between the timing of the instances come from the restriction that a message must be sent before 
it is received.
Along each instance axis the time is running from top to bottom, however, a proper time scale is not assumed. If no 
coregion or parallel operator is introduced, a total time ordering of events is assumed along each instance.
Events of different instances are ordered via messages, or via the generalized ordering mechanism. See 17.4.3 
(Message). A message must first be sent before it is consumed. With the generalized ordering mechanism "orderable 
events" on different instances (even in different interactions) can be ordered explicitly. No other ordering is prescribed. 
An interaction specification , therefore, imposes a partial ordering on the set of events being contained. A binary relation 
which is transitive, antisymmetric and irreflexive is called partial order.

Interaction Diagram Variants

17.1.4
Interaction diagrams come in different variants. A separate sub clause defines notation for each of the following 
Interaction Diagram variants:

•

•

•

•

17.8 Sequence Diagrams - The most common variant is the Sequence Diagram that focuses on the Message 
interchange between a number of Lifelines.

17.9 Communication Diagrams - Communication Diagrams show interactions through an architectural view 
where the arcs between the communicating Lifelines are decorated with description of the passed Messages 
and their sequencing.

17.10 Interaction Overview Diagrams - Interaction Overview Diagrams define interactions in a way that 
promotes overview of the control flow. Overview diagrams have notational elements that are similar to certain 
elements used in Activity diagrams (flow lines, forks, joins, etc.); however, although the notation and the 
general purpose of these elements is the same in both cases, their detailed semantics are quite different and 
modelers should not interpret Overview diagrams as if they were Activity diagrams.

17.11 Timing Diagrams - Timing Diagrams are used to show interactions when a primary purpose of the 
diagram is to reason about time. Conformant UML 2.5 tools are not required to implement Timing Diagrams.

In addition to the Interaction Diagram variants in this clause, there is also an optional notation using Interaction Tables 
(Annex D).

Interactions
Summary

17.2
17.2.1
The Interactions sub clause specifies the abstract syntax, semantics, and notation for the following metaclasses:

•

Interaction

564

Unified Modeling Language 2.5

•

InteractionFragment

• OccurrenceSpecification

•

•

ExecutionSpecification

StateInvariant

17.2.2

Abstract Syntax

NamedElement

Behavior

{ordered, subsets ownedMember}
+ fragment

InteractionFragment

*

{subsets namespace}
+ enclosingInteraction

0..1

Interaction

OccurrenceSpecification

ExecutionSpecification

StateInvariant

{subsets namespace}
+ interaction

0..1

0..1

+ interaction
{subsets owner}

{subsets
ownedMember}
+ formalGate

*

{subsets ownedElement}
+ action

*

Gate

Action

Figure 17.1  Interactions

17.2.3

17.2.3.1

Semantics

Interactions

{subsets owner}
+ stateInvariant

0..1

{subsets ownedElement}
+ invariant

1

Constraint

Interactions are units of behavior of an enclosing Classifier. Interactions focus on the passing of information with 
Messages between the ConnectableElements of the Classifier.
The semantics of an Interaction is given as a pair of sets of traces. The two trace sets represent valid traces and invalid 
traces. The union of these two sets need not necessarily cover the whole universe of traces. The traces that are not 
included are not described by this Interaction at all, and we cannot know whether they are valid or invalid.
A trace is a sequence of event occurrences, each of which is described by an OccurrenceSpecification in a model. The 
semantics of Interactions are compositional in the sense that the semantics of an Interaction is mechanically built from 
the semantics of its constituent InteractionFragments. The constituent InteractionFragments are ordered and combined 
by the seq operation (weak sequencing) as explained in 17.6.3 (Weak Sequencing)
The invalid set of traces is associated with the use of a Negative CombinedFragment or Assertion CombinedFragment. 
In the first case, the invalid set of traces is explicitly specified. The latter one implicitly specifies the set of invalid traces 
by explicitly specifying the only valid set of traces. For simplicity we describe only valid traces for all other constructs.
As Behavior an Interaction is generalizable and redefineable. Specializing an Interaction is simply to add more traces to 
those of the original. The traces defined by the specialization is combined with those of the inherited Interaction with a 
union.
The classifier owning an Interaction may be specialized, and in the specialization the Interaction may be redefined. 
Redefining an Interaction simply means to exchange the redefining Interaction for the redefined one, and this exchange 
takes effect also for InteractionUses within the supertype of the owner. This is similar to redefinition of other kinds of 
Behavior.

Unified Modeling Language 2.5

565

A formal Gate may be attached to the inner boundary of an Interaction to provide a link point to establish the concrete 
sender and receiver through an InteractionUse of that Interaction.

17.2.3.2

Interaction Fragments

The semantics of an InteractionFragment is a pair of set of traces. See 17.1.2 for explanation of how to calculate the 
traces.
An InteractionFragment may either be contained directly in an enclosing Interaction, or may be contained within an 
InteractionOperand of a CombinedFragment. As a CombinedFragment is itself an InteractionFragment, there may be 
multiple nesting levels of InteractionFragments within an Interaction.

17.2.3.3

Occurrence Specifications

The semantics of an OccurrenceSpecification is just the trace of that single OccurrenceSpecification.
The understanding and deeper meaning of the OccurrenceSpecification is dependent upon the associated Message and 
the information that it conveys.

17.2.3.4

Execution Specifications

The trace semantics of Interactions merely see an Execution as the trace <start, finish>. There may be occurrences 
between these. Typically the start occurrence and the finish occurrence will represent OccurrenceSpecifications such as 
a receive OccurrenceSpecification (of a Message) and the send OccurrenceSpecification (of a reply Message).

17.2.3.5

State Invariants

The Constraint is assumed to be evaluated during runtime. The Constraint is evaluated immediately prior to the 
execution of the next OccurrenceSpecification such that all actions that are not explicitly modeled have been executed. 
If the Constraint is true, the trace is a valid trace; if the Constraint is false, the trace is an invalid trace. In other words all 
traces that have a StateInvariant with a false Constraint are considered invalid.

17.2.4

17.2.4.1

Notation

Interaction

The notation for an Interaction in a Sequence Diagram is a solid-outline rectangle. A pentagon in the upper left corner of 
the rectangle contains ‘sd’ followed by the Interaction name and parameters. The notation within this rectangular frame 
comes in several forms: Sequence Diagrams, Communication Diagrams, Interaction Overview Diagrams, and Timing 
Diagrams.
The notation within the pentagon descriptor follows the general notation for the name of Behaviors. In addition the 
Interaction Overview Diagrams may include a list of Lifelines through a lifeline-clause as shown in Figure 17.27. The 
list of lifelines is simply a listing of the Lifelines involved in the Interaction. An Interaction Overview Diagram does not 
in itself show the involved lifelines even though the lifelines may occur explicitly within inline Interactions in the graph 
nodes.
An Interaction diagram may also include definitions of local attributes with the same syntax as attributes in general are 
shown within class symbol compartments. These attribute definitions may appear near the top of the diagram frame or 
within note symbols at other places in the diagram.

17.2.4.2

InteractionFragment

There is no general notation for an InteractionFragment. The specific subclasses of InteractionFragment define their 
own notation.

566

Unified Modeling Language 2.5

17.2.4.3

OccurrenceSpecification

OccurrenceSpecifications are merely syntactic points at the ends of Messages or at the beginning/end of an 
ExecutionSpecification.

17.2.4.4

ExecutionSpecification

ExecutionSpecifications are represented as thin rectangles (gray or white) on the lifeline (see 17.3.4 (Lifeline)).
We may also represent an ExecutionSpecification by a wider labeled rectangle, where the label usually identifies the 
action that was executed. An example of this can be seen in Figure 17.16.
For ExecutionSpecifications that refer to atomic actions such as reading attributes of a Signal (conveyed by the 
Message), the Action symbol may be associated with the reception OccurrenceSpecification with a line in order to 
emphasize that the whole Action is associated with only one OccurrenceSpecification (and start and finish associations 
refer to the very same OccurrenceSpecification).
Overlapping ExecutionSpecifications on the same lifeline are represented by overlapping rectangles as shown in Figure 
17.2.

Figure 17.2  Overlapping ExecutionSpecifications

17.2.4.5

StateInvariant

The possible associated Constraint is shown as text in curly brackets on the lifeline. See example in Figure 17.17.
A conforming tool may show a StateInvariant as a Note associated with an OccurrenceSpecification.
The state symbol represents the equivalent of a constraint that checks the state of the object represented by the Lifeline. 
This could be the internal state of the classifierBehavior of the corresponding Classifier, or it could be some external 
state based on a “black-box” view of the Lifeline. In the former case, and if the classifierBehavior is described by a state 
machine, the name of the state should match the hierarchical name of the corresponding state of the state machine.
The regions represent the orthogonal regions of states. The identifier need only define the state partially. The value of 
the constraint is true if the specified state information is true.
The example in Figure 17.17 also shows this presentation option.

17.2.4.6

Formal Gate

A formal Gate is just a point on the inside of the frame, as the end of a message. They may have an explicit name (see
Figure 17.4).

Unified Modeling Language 2.5

567

17.2.5

Examples

Figure 17.3  An example of an Interaction in the form of a Sequence Diagram

The example in Figure 17.3 shows three messages communicated between two (anonymous) lifelines of types User and 
ACSystem. The message CardOut overtakes the message OK in the way that the receiving event occurrences are in the 
opposite order of the sending OccurrenceSpecifications. Such communication may occur when the messages are 
asynchronous. Finally a fourth message is sent from the ACSystem to the environment through a formal gate with 
implicit name out_Unlock. The local attribute PIN of UserAccepted is declared near the diagram top. It could have been 
declared in a Note somewhere else in the diagram.
An example showing OccurrenceSpecification is shown in Figure 17.4.

Figure 17.4  OccurrenceSpecification

An example with a gate (labeled “Unlock”) is shown in Figure 17.5.

568

Unified Modeling Language 2.5

Figure 17.5  Sequence Diagram with time and timing concepts

The Sequence Diagram in Figure 17.5 shows how time and timing notation may be applied to describe time observation 
and timing constraints. The :User sends a message Code and the duration between its send and receive occurrences is 
measured. The :ACSystem will send two messages back to the :User. CardOut is constrained to last between 0 and 13 
time units. Furthermore the interval between the sending of Code and the reception of OK is constrained to last between 
d and 3*d where d is the measured duration of the Code signal. We also notice the observation of the time point t at the 
sending of OK and how this is used to constrain the time point of the reception of CardOut.

Lifelines
Summary

17.3
17.3.1
The Lifelines sub clause specifies the abstract syntax, semantics, and notation for the following metaclass:

•

Lifeline

Unified Modeling Language 2.5

569

17.3.2

Abstract Syntax

InteractionFragment

+ coveredBy

*

NamedElement

Interaction

OccurrenceSpecification

StateInvariant

{subsets namespace}
+ interaction

{subsets ownedMember}
+ lifeline

{ordered, subsets
coveredBy}

+ events

{redefines covered}
+ covered

*

1

1

*

{subsets coveredBy}
+ stateInvariant

{redefines covered}
+ covered

*

1

Lifeline

+ covered

*

+ lifeline

*

{subsets owner}
+ lifeline

+ represents

0..1

{subsets ownedElement}
+ selector

0..1

0..1

+ lifeline

1

+ decomposedAs

0..1

ConnectableElement

ValueSpecification

PartDecomposition

Figure 17.6  Lifelines

17.3.3

17.3.3.1

Semantics

Lifelines

In an interaction diagram a Lifeline describes the time-line for a process, where time increases down the page. The 
distance between two events on a time-line does not represent any literal measurement of time, only that non-zero time 
has passed.
Events on the same time-line are ordered linearly down the page, except where they occur within a parallel combined 
fragment, or along a lifeline within a “coregion”. See 17.6.3 (Parallel) and 17.6.4 (Parallel interactionOperator). Within 
a parallel combined fragment or a coregion, events are not locally ordered unless that is directly imposed by a general 
ordering construct. See 17.5.3 (General Ordering).
The order of OccurrenceSpecifications along a Lifeline is significant denoting the order in which these 
OccurrenceSpecifications will occur. The absolute distances between the OccurrenceSpecifications on the Lifeline are, 
however, irrelevant for the semantics.
The semantics of the Lifeline (within an Interaction) is the semantics of the Interaction selecting only 
OccurrenceSpecifications of this Lifeline.

17.3.4

17.3.4.1

Notation

Lifeline

A Lifeline is shown using a symbol that consists of a rectangle forming its “head” followed by a vertical line (which 
may be dashed) that represents the lifetime of the participant. Information identifying the lifeline is displayed inside the 
rectangle in the following format:

<lifelineident> ::= ([<connectable-element-name>[‘[‘ <selector> ‘]’]] [: <connectable-element-type>] 
[<decomposition>]) | ‘self’

570

Unified Modeling Language 2.5

<selector> ::= <expression>
<decomposition> ::= ‘ref’ <interactionident> [‘strict’]

where <connectable-element-type> refers to the name of the Type the ConnectableElement is typed with. Note that, 
although the syntax allows it, <lifelineident> cannot be empty.
The Lifeline head has a shape that is based on the classifier for the part that this lifeline represents. Often the head is a 
white rectangle containing the name.
If the name is ‘self’, then the Lifeline represents the object of the classifier that encloses the Interaction that owns the 
Lifeline. Ports of the encloser may be shown separately even when self is included.
To depict an ExecutionSpecification apply a thin gray or white rectangle that covers the Lifeline line.

Examples

17.3.5
See Figure 17.3 where the Lifelines are pointed to.
See Figure 17.14 to see notation for ExecutionSpecification.

17.4 Messages
Summary
17.4.1
The Messages sub clause specifies the abstract syntax, semantics, and notation for the following metaclasses:

• Message

• MessageEnd

• MessageOccurrenceSpecification

• MessageSort

• MessageKind

• DestructionOccurrenceSpecification

• Gate

Unified Modeling Language 2.5

571

17.4.2

Abstract Syntax

«enumeration»
MessageSort
synchCall
asynchCall
asynchSignal
createMessage
deleteMessage
reply

«enumeration»
MessageKind
complete
lost
found
unknown

Interaction

+ interaction
{subsets namespace}

{subsets ownedMember}
+ message

1

*

+ message

*

Message

+ signature

0..1

NamedElement

{subsets message}
+ endMessage

{subsets messageEnd}

+ sendEvent

MessageEnd

+ /messageKind : MessageKind {readOnly}
+ messageSort : MessageSort = synchCall

0..1

{subsets message}
+ endMessage

0..1

+ message
0..1

{subsets owner}

0..1 + message

* + message

{ordered, subsets
ownedElement}

* + argument

0..1 + connector

ValueSpecification

Connector

0..1

{subsets messageEnd}
+ receiveEvent

0..1

+ messageEnd
0..2

Gate

OccurrenceSpecification

MessageOccurrenceSpecification

DestructionOccurrenceSpecification

Figure 17.7  Messages

17.4.3

17.4.3.1

Semantics

Messages

The semantics of a complete Message is simply the trace <sendEvent, receiveEvent>.
A lost Message is a Message where the sending event occurrence is known, but there is no receiving event occurrence. 
We interpret this to be because the destination of the [lost]Message is outside the scope of the description. The 
semantics is simply the trace <sendEvent>.
A found Message is a Message where the receiving event occurrence is known, but there is no (known) sending event 
occurrence. We interpret this to be because the origin of the Message is outside the scope of the description. This may 
for example be noise or other activity that we do not want to describe in detail. The semantics is simply the trace 
<receiveEvent>.
The signature of a Message refers to either an Operation or a Signal. The name of the Message must be the same as the 
name of the referenced Operation or Signal.
NOTE. Lifelines cannot directly represent Types. However, any Lifeline representing a ConnectableElement with a 
Type having an Operation with isStatic = true, can accept Messages with a signature associated with that static Operation.
If the Message signature is an Operation, then the Message represents one of the following:
•

If the messageSort is either synchCall or asynchCall, then the Message represents the synchronous or asynchronous 
call to and start of execution of the Operation. The arguments of the Message correspond to the in and inout 
ownedParameters of the Operation, in the order of the ownedParameters.

•

572

If the messageSort is reply, then the Message represents the return from a synchronous call to the Operation. The 
arguments of the Message correspond to the out, inout and return ownedParameters of the Operation, in the order 
of the ownedParameters.

Unified Modeling Language 2.5

If the Message signature is a Signal, then the messageSort must be asynchSignal, and the Message represents the 
asynchronous sending and reception of an instance of the Signal. The arguments of the Message correspond to the 
attributes of the Signal.
An argument of a Message is a ValueSpecification. If the Message has a signature and it is not a reply Message, then its 
argument ValueSpecifications are considered to be evaluated at the point of the send event of the Message. Their results 
provide the values for the corresponding Operation input parameters or Signal attributes. However, an argument 
consisting of an Expression with no operands and the empty string as its symbol has a special interpretation as a 
wildcard, corresponding to an unspecified but legal value for the corresponding parameter or attribute. Otherwise, the 
type of the argument must conform to the type of the corresponding parameter or attribute.
If the Message is a reply, then each of its arguments must be an Expression with at most one operand. If an operand is 
given, it is considered to be evaluated at the point of the send event of the Message, and its result provides the returned 
value for the out, inout or return parameter corresponding to the argument. The type of the output parameter must 
conform to the type of the operand. If no operand is given, then no returned value is modeled by the reply Message for 
that argument.
The symbol of the argument Expression of a reply Message represents the assignment target for the argument, to which 
the returned value for the argument is to be assigned. The following values for such an assignment-target symbol have 
standard interpretations:
• Unknown. An empty string, which represents an unknown assignment target. An argument with unknown 

assignment target and no modeled returned value is an output wildcard.

•

•

Interaction Parameter. The unqualified name of an ownedParameter of the enclosing Interaction, which must be an 
out, inout or return Parameter. The type of the Operation Parameter corresponding to the argument must conform to 
the type of the target ownedParameter of the Interaction.

Attribute. The (possibly qualified) name of an attribute of the context Behavior of the enclosing interaction or of the 
receiving Lifeline of the Message (which is the lifeline that sent the original message to which this is a reply). If an 
Interaction does not have a context Behavior, then the Interaction itself is considered to be the context. The type of 
the output parameter corresponding to the argument must conform to the type of the attribute. (Note that a qualified 
name may be used to distinguish attributes of the context and the Lifeline with the same names, or an attribute from 
an Interaction Parameter with the same name.)

Other values are allowed for an assignment-target symbol (e.g., for use in a profile), but their interpretation is not 
defined in this specification.

17.4.3.2

Message Ends

Subclasses of MessageEnd define the specific semantics appropriate to the concept they represent.

17.4.3.3

Message Occurrence Specifications

A MessageOccurrenceSpecification represents a send event or a receive event associated with a message between two 
Lifelines.

17.4.3.4

Destruction Occurrence Specifications

A DestructionOccurrenceSpecification represents the destruction of the instance described by the lifeline that contains 
it. It may result in the subsequent destruction of other objects that this object owns by composition (see Clause 13) .

17.4.3.5

Gates

A Gate is a MessageEnd which is used on the boundary of an Interaction, or an InteractionUse, or a CombinedFragment 
to establish the concrete sender and receiver for every Message.

Unified Modeling Language 2.5

573

Gate instances, since they occur in a paired manner linking two Message instances, are also not themselves explicitly 
ordered. Gates are MessageEnds which provide a connection point between, either:

•

•

a Message instance outside of an InteractionUse and a Message instance inside the used Interaction, or;

a Message instance outside a CombinedFragment and a Message instance inside a InteractionOperand within 
the CombinedFragment.

MessageOccurrenceSpecifications are partially ordered by the following rules:

• MessageOccurrenceSpecification instances are ordered on their owned Lifeline, and;

• MessageOccurrenceSpecification instances are ordered across a Message instance, or across a pair of Message 

instances linked thru a pair of matched gates. In either case a sending MessageOccurrenceSpecification 
instance is ordered before the receiving MessageOccurenceSpecification instance.

Message instances themselves are not ordered.
Gate instances, since they occur in a paired manner linking two Message instances, are also not themselves explicitly 
ordered.
There are four kinds of Gate, distinguished by their associations:

1 A formal Gate associated with an Interaction to provide a link point attached to the inside boundary of that 

Interaction, to convey a Message inside that Interaction to or from a Message in another Interaction which has 
an actual Gate as a MessageEnd attached to the outside of an InteractionUse of that Interaction.

2 An actual Gate is associated with an InteractionUse to provide a link attached to the outside boundary of an 
InteractionUse to convey a Message outside the InteractionUse to or from a Message inside the Interaction 
referred to by the InteractionUse.

3 An inner CombinedFragment Gate is associated with a CombinedFragment to provide a link point attached to 

the inside boundary of a CombinedFragment to convey a Message with a MessageEnd inside that 
CombinedFragment to or from a Message with a MessageEnd outside that CombinedFragment.

4 An outer CombinedFragment Gate is associated with a CombinedFragment to provide a link point attached to 

the outside boundary of a CombinedFragment to convey a Message with a MessageEnd outside that 
CombinedFragment to or from a Message with a MessageEnd inside that CombinedFragment.

The gates are named either explicitly or implicitly. Gates may be identified either by name (if specified), or by a 
constructed identifier formed by concatenating the direction of the message and the message name (e.g., out_CardOut, 
in_CardOut).
Gates are matched by name, with a formal Gate matched with an actual Gate having the same name, and with an inner 
CombinedFragment Gate matched with an outer CombinedFragment Gate having the same name.
The Messages for matched Gates must correspond. Messages correspond if they have identical name, messageSort, and 
signature property values, as well as being in the same direction.

17.4.4

17.4.4.1

Notation

Message

A message is shown as a line from the sender MessageEnd to the receiver MessageEnd. The line must be such that 
every line fragment is either horizontal or downwards when traversed from send event to receive event. The send and 
receive events may both be on the same lifeline. The form of the line or arrowhead reflects properties of the message:

574

Unified Modeling Language 2.5

• An asynchronous Message (messageSort equals asynchCall or asynchSignal) has an open arrow head.

• A synchronous Message (messageSort equals synchCall) has a filled arrow head.

• A reply Message (messageSort equals reply) has a dashed line with either an open or filled arrow head.

• An object creation Message (messageSort equals createMessage) has a dashed line with an open arrow head.

• An object deletion Message (messageSort equals deleteMessage) must end in a 

DestructionOccurrenceSpecification.

• A lost Message is denoted with a small black circle at the arrow end of the Message.

• A found Message is denoted with a small black circle at the starting end of the Message.

• On Communication Diagrams, the Messages are decorated by a small arrow in the direction of the Message close to 

the Message name and sequence number along the line between the lifelines (See Table 17.4 and Figure 17.26).

The syntax for the Message label in a diagram is the following:

<message-label> ::= <request-message-label> | <reply-message-label> | ‘*’

A message-label equaling ‘*’ is a shorthand for a more complex alternative CombinedFragment to represent a message 
of any type. This is to match asterisk triggers in State Machines.
A request-message-label is used for all sorts of Message other than a reply. It has the following form:

<request-message-label> ::= <message-name> [‘(‘[<input-argument-list>] ’)’]
<input-argument-list> ::= <input-argument> [‘,’<input-argument>*]
<input-argument> ::= [<in-parameter-name> ‘=’] <value-specification> | ‘-’

The message-name appearing in a request-message-label is the name property of the Message. If the Message has a 
signature, this will be the name of the Operation or Signal referenced by the signature. Otherwise the name is 
unconstrained.
If a request-message-label includes an input-argument-list, then either all input-arguments must have an in-parameter-
name given or none may have one. If in-parameter-names are not given, then the input-arguments denote the arguments 
of the Message, in order, with a hyphen (‘-’) denoting a wildcard argument. If the Message has a signature, then the 
arguments are matched, by order, to the in and inout ownedParameters of an Operation or the attributes of a Signal. An 
argument must be provided for every such parameter or attribute.
A request-message-label may only have input-arguments with in-parameter-names if the Message has a signature. In 
this case, the input-arguments are matched by name to the in and inout ownedParameters of an Operation or the 
attributes of a Signal. Any such parameters or attributes that are not named are considered to have implicit wildcard 
arguments. The explicit wildcard notation (‘-’) is not used if in-parameter-names are given.
If a request-message-label does not include an input-argument-list and the Message has a signature, then this denotes 
that the Message has wildcard arguments corresponding to all in and inout ownedParameters of an Operation or 
attributes of a Signal (if any). Note that the parentheses are not considered part of the input-argument list, so a request-
message-label without an input-argument-list may still optionally include an empty set of parentheses (“()”) after the 
message-name.
A reply-message-label is used for reply Messages. It has the following form:

<reply-message-label> ::=  [<assignment-target> ‘=’] <message-name> 

[‘(’ [<output-argument-list>] ‘)’] [‘:’ <value-specification>]

Unified Modeling Language 2.5

575

<output-argument-list> ::= <output-argument> [‘,’<output-argument>]*
<output-argument> ::=  <out-parameter-name> ‘:’ <value-specification> | 

<assignment-target> ‘=’ <out-parameter-name> [‘:’ <value-specification>]

The message-name appearing in a reply-message-label is the name property of the Message. If the Message has a 
signature, this will be the name of the Operation referenced by the signature (which should be the Operation for whose 
call this is a reply). Otherwise the name is unconstrained.
A reply-message-label may optionally have an assignment-target given to the left of the message-name, with a 
corresponding returned value denoted by the optional value-specification given after a colon at the end of the reply-
message-label. If the Message has a signature that is an Operation with a return parameter, then this assignment-target 
and/or value-specification corresponds to the argument for that parameter (if no assignment-target is given, it is 
considered to be unknown). If the Message has a signature without a return parameter, then no assignment-target or 
value-specification may be given for the reply-message-label as a whole.
If a reply Message does not have a signature, then the only argument that may be specified for it is a return argument as 
specified above. However, if the Message has a signature that is an Operation with out or inout ownedParameters, then 
output-arguments may be provided for these parameters. An output-argument always explicitly names the parameter to 
which it is to be matched. Any parameters that are not named are considered to have implicit wildcard arguments. 
(There is thus no need for an explicit wildcard notation for output-arguments.)
If a reply-message-label does not include an output-argument-list and the Message has a signature, then this denotes that 
the Message has wildcard arguments corresponding to all out and inout ownedParameters of the signature Operation (if 
any). Note that the parentheses are not considered part of the output-argument list, so a reply-message-label without an 
output-argument-list may still optionally include an empty set of parentheses (“()”) after the message-name.
An output-argument with an explicit assignment-target given may also optionally include a value-specification. If a 
value-specification is given, then this denotes the returned value for the argument. Otherwise the argument has no 
modeled returned value. If an output-argument does not have an explicit assignment-target specified, it is considered to 
have an unknown assignment target. In this case, it is required to include a value-specification, which denotes the 
returned value for the argument.
If the identity of a reply Message is obvious (e.g., when its sendEvent is the only reply within the extent of an 
ExecutionOccurence where there is only one receipt of an Operation call message), the label may be omitted to simplify 
the diagram. If the reply Message has a signature, then wildcard arguments are provided for all return, out and inout 
ownedParameters of the signature Operation. See Figure 17.2 for an example.

17.4.4.2

DestructionOccurrenceSpecification

The DestructionOccurrenceSpecification is depicted by a cross in the form of an X at the bottom of a Lifeline. See
Figure 17.8.

Figure 17.8  DestructionOccurrenceSpecification symbol

17.4.4.3

Gate

Gates are just points on the frame, the ends of the messages. They may have an explicit name (see Figure 17.4).

Examples

17.4.5
In Figure 17.3 we see only asynchronous Messages. Such Messages may overtake each other.
In Figure 17.14 we see method calls that are synchronous accompanied by replies. We also see a Message that 
represents the creation of an object.

576

Unified Modeling Language 2.5

In Figure 17.26 we see how Messages are denoted in Communication Diagrams.
Examples of syntax:

mymessage(14, - , 3.14, “hello”) 
mymsg(myint=16) 

v=mymsg(w=myout:16):96 

// this is a request message; the second argument is a wildcard
// the is a request message; the input parameter ‘myint’ is given 
// the argument value 16
// this is a reply message assigning the return value 69 to ‘v’ and 
// the value 16 for the out parameter ‘myout to ‘w’.

See Figure 17.14 for a number of different applications of the textual syntax of message identification.

Occurrences
Summary

17.5
17.5.1
The Occurrences sub clause specifies the abstract syntax, semantics, and notation for the following metaclasses:

• ActionExecutionSpecificiation

•

•

BehaviorExecutionSpecification

ExecutionOccurrenceSpecification

• GeneralOrdering

Unified Modeling Language 2.5

577

17.5.2

Abstract Syntax

OccurrenceSpecification

+ before
1

+ after
1

+ start
1

+ finish
1

ExecutionOccurrenceSpecification

+ executionOccurrenceSpecification

0..2

NamedElement

InteractionFragment

{subsets owner}
+ interactionFragment

0..1

GeneralOrdering

+ toAfter
*

+ toBefore
*

*
+ generalOrdering
{subsets ownedElement}

ExecutionSpecification

+ executionSpecification
*

+ executionSpecification
*

+ execution
1

ActionExecutionSpecification

BehaviorExecutionSpecification

+ actionExecutionSpecification

*

+ behaviorExecutionSpecification

*

+ action

1

Action

+ behavior

0..1

Behavior

Figure 17.9  Occurrences

17.5.3

17.5.3.1

Semantics

Action Execution Specificiations

See 17.2.3 (Execution Specification).
ActionExecutionSpecification is used for interactions specifying messages that result from actions, which may be 
actions owned by other behaviors.

17.5.3.2

Behavior Execution Specifications

See 17.2.3 (Execution Specification).
BehaviorExecutionSpecification is used for interactions specifying messages that result from behaviors.

17.5.3.3

Execution Occurrence Specifications

An ExecutionOccurrenceSpecification represents, on a lifeline, the start event or the end event of an 
ExecutionSpecification.

17.5.3.4

General Orderings

A GeneralOrdering restricts the set of possible sequences. A partial order of OccurrenceSpecifications is constrained by 
a set of GeneralOrderings.

578

Unified Modeling Language 2.5

17.5.4

17.5.4.1

Notation

ActionExecutionSpecificiation

See 17.2.4 (ExecutionSpecification).

17.5.4.2

BehaviorExecutionSpecification

See 17.2.4 (ExecutionSpecification).

17.5.4.3

ExecutionOccurrenceSpecification

An ExecutionOccurrenceSpecification is represented by the start or finish endpoint of the vertical box for an 
ExecutionSpecification on a lifeline. See Figure 17.2.

17.5.4.4

GeneralOrdering

A GeneralOrdering is shown by a dotted line connecting the two OccurrenceSpecifications. The direction of the relation 
from the before to the after is given by an arrowhead placed somewhere in the middle of the dotted line (i.e., not at the 
endpoint).

Examples

17.5.5
An example showing a GeneralOrdering is shown in Figure 17.10

Figure 17.10  Example showing GeneralOrdering in a sequence diagram

Fragments
Summary

17.6
17.6.1
The Fragments sub clause specifies the abstract syntax, semantics, and notation for the following metaclasses:

•

•

•

•

•

•

InteractionOperand

InteractionConstraint

CombinedFragment

ConsiderIgnoreFragment

Continuation

InteractionOperatorKind

Unified Modeling Language 2.5

579

17.6.2

Abstract Syntax

Namespace

{subsets namespace}

0..1 + enclosingOperand

InteractionOperand

{subsets owner}
+ interactionOperand

1

{subsets ownedElement}
+ guard

0..1

InteractionConstraint

{ordered, subsets ownedMember}
+ fragment

*

InteractionFragment

{ordered, subsets
ownedElement}
+ operand

0..1

1..*

+ combinedFragment
{subsets owner}

CombinedFragment

Continuation

+ interactionOperator : InteractionOperatorKind = seq

+ setting : Boolean = true

{subsets owner}
+ interactionConstraint
0..1

{subsets owner}
+ interactionConstraint
0..1

ConsiderIgnoreFragment

+ considerIgnoreFragment

+ message

*

*

NamedElement

{subsets ownedElement}
+ maxint

0..1

{subsets ownedElement}

0..1 + minint

Constraint

ValueSpecification

Figure 17.11  Fragments

17.6.3

17.6.3.1

Semantics

Interaction Operands

{subsets owner}

0..1 + combinedFragment

{subsets ownedElement}
+ cfragmentGate

*

Gate

«enumeration»

InteractionOperatorKind
seq
alt
opt
break
par
strict
loop
critical
neg
assert
ignore
consider

An InteractionOperand is a region within a CombinedFragment, see 17.6.3 (Combined Fragment). Only 
InteractionOperands with true guards are included in the calculation of the semantics. If no guard is present, this is 
taken to mean a true guard.
The semantics of an InteractionOperand is given by its constituent InteractionFragments combined by the implicit seq 
operation. The seq operator is described in “17.6.3 (Combined Fragment).

17.6.3.2

Interaction Constraints

InteractionConstraints are always used in connection with CombinedFragments, see 17.6.3 (Combined Fragment).

17.6.3.3

Combined Fragments

The semantics of a CombinedFragment is dependent upon the interactionOperator, as explained below for each kind of 
interactionOperator.
The Gates associated with a CombinedFragment represent the syntactic interface between the CombinedFragment and 
its surroundings, which means the interface towards other InteractionFragments.

17.6.3.4

Consider Ignore Fragments

A ConsiderIgnoreFragment is a CombinedFragment with an Ignore or Consider interactionOperator value. See 17.6.3 
(Ignore / Consider).

17.6.3.5

Continuations

Continuations have semantics only in connection with Alternative CombinedFragments and (weak) sequencing.

580

Unified Modeling Language 2.5

If an InteractionOperand of an Alternative CombinedFragment ends in a Continuation with name (say) X, only 
InteractionFragments starting with the Continuation X (or no continuation at all) can be appended.

17.6.3.6

Interaction Operator Kind Values

The value of the interactionOperator is significant for the semantics of CombinedFragment, as specified below for each 
interactionOperator enumeration value.

17.6.3.7

Alternatives

The interactionOperator alt designates that the CombinedFragment represents a choice of behavior. At most one of the 
operands will be chosen. The chosen operand must have an explicit or implicit guard expression that evaluates to true at 
this point in the interaction. An implicit true guard is implied if the operand has no guard.
The set of traces that defines a choice is the union of the (guarded) traces of the operands.
An operand guarded by else designates a guard that is the negation of the disjunction of all other guards in the enclosing 
CombinedFragment.
If none of the operands has a guard that evaluates to true, none of the operands are executed and the remainder of the 
enclosing InteractionFragment is executed.
If an inner CombinedFragment Gate is used in any InteractionOperand of an alt CombinedFragment, a Gate with that 
same name must be used by every InteractionOperand of that alt CombinedFragment.

17.6.3.8

Option

The interactionOperator opt designates that the CombinedFragment represents a choice of behavior where either the 
(sole) operand happens or nothing happens. An option is semantically equivalent to an alternative CombinedFragment 
where there is one operand with non-empty content and the second operand is empty.

17.6.3.9

Break

The interactionOperator break designates that the CombinedFragment represents a breaking scenario in the sense that 
the operand is a scenario that is performed instead of the remainder of the enclosing InteractionFragment. A break 
operator with a guard is chosen when the guard is true and the rest of the enclosing Interaction Fragment is ignored. 
When the guard of the break operand is false, the break operand is ignored and the rest of the enclosing 
InteractionFragment is chosen. The choice between a break operand without a guard and the rest of the enclosing 
InteractionFragment is done non-deterministically.
A CombinedFragment with interactionOperator break should cover all Lifelines of the enclosing InteractionFragment.

17.6.3.10

Parallel

The interactionOperator par designates that the CombinedFragment represents a parallel merge between the behaviors 
of the operands. The OccurrenceSpecifications of the different operands can be interleaved in any way as long as the 
ordering imposed by each operand as such is preserved.
A parallel merge defines a set of traces that describes all the ways that OccurrenceSpecifications of the operands may be 
interleaved without obstructing the order of the OccurrenceSpecifications within the operand.

17.6.3.11

Weak Sequencing

The interactionOperator seq designates that the CombinedFragment represents a weak sequencing between the 
behaviors of the operands.
Weak sequencing is defined by the set of traces with these properties:

1

The ordering of OccurrenceSpecifications within each of the operands are maintained in the result.

Unified Modeling Language 2.5

581

2 OccurrenceSpecifications on different lifelines from different operands may come in any order.

3 OccurrenceSpecifications on the same lifeline from different operands are ordered such that an 

OccurrenceSpecification of the first operand comes before that of the second operand.

Thus weak sequencing reduces to a parallel merge when the operands are on disjunct sets of participants. Weak 
sequencing reduces to strict sequencing when the operands work on only one participant.

17.6.3.12

Strict Sequencing

The interactionOperator strict designates that the CombinedFragment represents a strict sequencing between the 
behaviors of the operands. The semantics of strict sequencing defines a strict ordering of the operands on the first level 
within the CombinedFragment with interactionOperator strict. Therefore OccurrenceSpecifications within contained 
CombinedFragment will not directly be compared with other OccurrenceSpecifications of the enclosing 
CombinedFragment.

17.6.3.13

Negative

The interactionOperator neg designates that the CombinedFragment represents traces that are defined to be invalid.
The set of traces that defined a CombinedFragment with interactionOperator negative is equal to the set of traces given 
by its (sole) operand, only that this set is a set of invalid rather than valid traces. All InteractionFragments that are 
different from Negative are considered positive meaning that they describe traces that are valid and should be possible.

17.6.3.14

Critical Region

The interactionOperator critical designates that the CombinedFragment represents a critical region. A critical region 
means that the traces of the region cannot be interleaved by other OccurrenceSpecifications (on those Lifelines covered 
by the region). This means that the region is treated atomically by the enclosing fragment when determining the set of 
valid traces. Even though enclosing CombinedFragments may imply that some OccurrenceSpecifications may 
interleave into the region, such as with par-operator, this is prevented by defining a region.
Thus the set of traces of enclosing constructs are restricted by critical regions.

17.6.3.15

Ignore / Consider

The interactionOperator ignore designates that there are some message types that are not shown within this combined 
fragment. These message types can be considered insignificant and are implicitly ignored if they appear in a 
corresponding execution. Alternatively, one can understand ignore to mean that the message types that are ignored can 
appear anywhere in the traces.
Conversely, the interactionOperator consider designates which messages should be considered within this combined 
fragment. This is equivalent to defining every other message to be ignored.

17.6.3.16

Assertion

The interactionOperator assert designates that the CombinedFragment represents an assertion. The sequences of the 
operand of the assertion are the only valid continuations. All other continuations result in an invalid trace. Assertions are 
often combined with Ignore or Consider as shown in Figure 17.17.

17.6.3.17

Loop

The interactionOperator loop designates that the CombinedFragment represents a loop. The loop operand will be 
repeated a number of times.
The Guard may include a lower and an upper number of iterations of the loop as well as a Boolean expression. The 
semantics is such that a loop will iterate minimum the ‘minint’ number of times (given by the iteration expression in the 
guard) and at most the ‘maxint’ number of times. After the minimum number of iterations have executed and the 

582

Unified Modeling Language 2.5

Boolean expression is false the loop will terminate. The loop construct represents a recursive application of the seq 
operator where the loop operand is sequenced after the result of earlier iterations.
If the loop contains a separate InteractionConstraint with a specification, the loop will only continue if that specification 
evaluates to true during execution regardless of the minimum number of iterations specified in the loop.

17.6.4

17.6.4.1

Notation

InteractionOperand

InteractionOperands are separated by a dashed horizontal line. The InteractionOperands together make up the framed 
CombinedFragment.
Within an InteractionOperand of a Sequence Diagram the order of the InteractionFragments are given simply by the 
topmost vertical position.

17.6.4.2

InteractionConstraint

An InteractionConstraint is shown in square brackets covering the lifeline where the first event occurrence will occur, 
positioned above that event, in the containing Interaction or InteractionOperand.

<interactionconstraint> ::= ‘[‘ (<Boolean-expression> | ‘else‘) ‘]’

When the InteractionConstraint is omitted, true is assumed.

17.6.4.3

CombinedFragment

The notation for a CombinedFragment in a Sequence Diagram is a solid-outline rectangle. The operator is shown in a 
pentagon in the upper left corner of the rectangle.
More than one operator may be shown in the pentagon descriptor. This is a shorthand for nesting CombinedFragments. 
This means that sd strict in the pentagon descriptor is the same as two CombinedFragments nested, the outermost with 
sd and the inner with strict.
The operands of a CombinedFragment are shown by tiling the graph region of the CombinedFragment using dashed 
horizontal lines to divide it into regions corresponding to the operands.

17.6.4.4

ConsiderIgnoreFragment

The notation for ConsiderIgnoreFragment is the same as for all CombinedFragments with consider or ignore indicating 
the operator. The list of messages follows the operand enclosed in a pair of braces (curly brackets) according to the 
following format:

(‘ignore’ | ‘consider’) ‘{‘ <message-name> [‘,’ <message-name>]* ‘}’

Note that ignore and consider can be combined with other types of operations in a single rectangle (as a shorthand for 
nested rectangles), such as assert consider {msgA, msgB}.

17.6.4.5

Continuation

Continuations are shown with the same symbol as States, but they may cover more than one Lifeline.
Continuations may also appear on flowlines of Interaction Overview Diagrams.
A continuation that is alone in an InteractionFragment is considered to be at the end of the enclosing 
InteractionFragment.

Unified Modeling Language 2.5

583

17.6.4.6

InteractionOperatorKind

The value of the InteractionOperandKind is given as text in a small compartment in the upper left corner of the 
CombinedFragment frame. There is specialized notation for some of the interactionOperator values, as defined below.

17.6.4.7

Strict interactionOperator

Notationally, this means that the vertical coordinate of the contained fragments is significant throughout the whole 
scope of the CombinedFragment and not only on one Lifeline. The vertical position of an OccurrenceSpecification is 
given by the vertical position of the corresponding point. The vertical position of other InteractionFragments is given by 
the topmost vertical position of its bounding rectangle.

17.6.4.8

Ignore / Consider interactionOperator

See 17.6.4 (ConsiderIgnoreFragment).

17.6.4.9

Loop interactionOperator

Textual syntax of the loop operand:

‘loop[‘(‘ <minint> [‘,’ <maxint> ] ‘)’]

<minint> ::= non-negative natural
<maxint> ::= non-negative natural (greater than or equal to <minint> | ‘*’
‘*’ means unlimited.
If only <minint> is present, this means that <minint> = <maxint> = <integer>.
If only loop, then this means a loop with unlimited upper bound and with 0 as lower bound.

17.6.4.10

Parallel interactionOperator

A conforming tool may use the shorthand notation of a “coregion area” within a single Lifeline.
A “coregion” is a notational shorthand for parallel combined fragments, used for the common situation where the order 
of event occurrences (or other nested fragments) on one Lifeline is insignificant. This means that in a given “coregion” 
area of a Lifeline all the directly contained fragments are considered separate operands of a parallel combined fragment. 
See example in Figure 17.23.

Examples

17.6.5
See Figure 17.14 for examples of InteractionOperand.
See examples of InteractionConstraints in Figure 17.14 and Figure 17.27.
Examples of CombinedFragments with various interactionOperators are shown in Figure 17.12, Figure 17.13, and
Figure 17.14.

584

Unified Modeling Language 2.5

Figure 17.12  Critical Region

The example, Figure 17.12, shows that the handling of a 911-call must be contiguously handled. The operator must 
make sure to forward the 911-call before doing anything else. The normal calls, however, can be freely interleaved.

Unified Modeling Language 2.5

585

Figure 17.13  - Loop CombinedFragment

Figure 17.14  CombinedFragment

Figure 17.17 shows an example of ConsiderIgnoreFragments.
The following are other examples of operator notation for consider and ignore iteractionOperators:

586

Unified Modeling Language 2.5

•

•

•

consider {m, s}: showing that only m and s messages are considered significant.

ignore {q,r}: showing that q and r messages are considered insignificant.

Ignore and consider operations are typically combined with other operations such as “assert consider {m, s}.”

Figure 17.15 shows and example with a continuation.

Figure 17.15  Continuation

The two diagrams in Figure 17.15 are together equivalent to the diagram in Figure 17.16.

Figure 17.16  Continuation interpretation

Unified Modeling Language 2.5

587

Figure 17.17  Ignore, consider, assert with StateInvariants

In Figure 17.17 we have an Interaction M, which considers message types other than t and r. This means that if this 
Interaction is used to specify a test of an existing system and when running that system a t or an r occurs, these 
messages will be ignored by this specification. t and r will of course be handled in some manner by the running system, 
but how they are handled is irrelevant for our Interaction shown here.
The State invariant given as a state “mystate” will be evaluated at runtime directly prior to whatever event occurs on Y 
after “mystate.” This may be the reception of q as specified within the assert-fragment, or it may be an event that is 
specified to be insignificant by the filters.
The assert fragment is nested in a consider fragment to mean that we expect a q message to occur once a v has occurred 
here. Any occurrences of messages other than v, w, and q will be ignored in a test situation. Thus the appearance of a w 
message after the v is an invalid trace.
The state invariant given in curly brackets will be evaluated prior to the next event occurrence after that on Y.

Interaction Uses
Summary

17.7
17.7.1
The Interaction Uses sub clause specifies the abstract syntax, semantics, and notation for the following metaclasses:

•

•

InteractionUse

PartDecomposition

588

Unified Modeling Language 2.5

17.7.2

Abstract Syntax

InteractionFragment

ValueSpecification

{subsets ownedElement}

+ returnValue
0..1

{subsets owner}
+ interactionUse
0..1

InteractionUse

+ interactionUse
*

+ refersTo
1

Interaction

*

+ argument
{ordered, subsets
ownedElement}

0..1

+ interactionUse
{subsets owner}

Lifeline

+ lifeline

1

+ decomposedAs

PartDecomposition

0..1

{subsets owner}
+ interactionUse
0..1

{subsets ownedElement}
+ actualGate
*

Gate

Figure 17.18  InteractionUses

17.7.3

17.7.3.1

Semantics

Interaction Uses

The semantics of the InteractionUse is the set of traces of the semantics of the referred Interaction where the gates have 
been resolved as well as all generic parts having been bound such as the arguments substituting the parameters.
An actual Gate may be attached to the outer boundary of an InteractionUse to provide a link point to establish the 
concrete sender and receiver in the Interaction referred to by that InteractionUse.

17.7.3.2

Part Decompositions

Decomposition of a lifeline within one Interaction by an Interaction (owned by the type of the Lifeline’s associated 
ConnectableElement), is interpreted exactly as an InteractionUse. The messages that go into (or go out from) the 
decomposed lifeline are interpreted as actual gates that are matched by corresponding formal gates on the 
decomposition.
As the decomposed Lifeline is interpreted as an InteractionUse, the semantics of a PartDecomposition is the semantics 
of the Interaction referenced by the decomposition where the gates and parameters have been matched.
That a CombinedFragment is extra-global depicts that there is a CombinedFragment with the same operator covering 
the decomposed Lifeline in its Interaction. The full understanding of that (higher level) CombinedFragment must be 
acquired through combining the operands of the decompositions operand by operand.

17.7.4

17.7.4.1

Notation

InteractionUse

The InteractionUse is shown as a CombinedFragment symbol where the operator is called ref. The complete syntax of 
the name (situated in the InteractionUse area) is:

<name> ::=[<attribute-name> ‘=’ ] [<collaboration-use> ‘.’] <interaction-name>

[‘(‘ <io-argument> [‘,’ <io-argument>]* ‘)’] [‘:’ <return-value>]

<io-argument> ::= <in-argument> | ‘out’ <out-argument>

The <attribute-name> refers to an attribute of one of the lifelines in the Interaction.
<collaboration-use> is an identification of a collaboration use that binds lifelines of a collaboration. The interaction 
name is in that case within that collaboration. See example of collaboration uses in Figure 17.24.

Unified Modeling Language 2.5

589

The io-arguments are most often arguments of IN-parameters. If there are OUT- or INOUT-parameters and the output 
value is to be described, this can be done following ‘out’.
The syntax of argument is explained in the notation sub clause of Messages 17.4.4 (Message).
If the InteractionUse returns a value, this may be described following a colon at the end of the clause.

17.7.4.2

PartDecomposition

PartDecomposition is designated by a referencing clause in the head of the Lifeline as can be seen in the notation sub 
clause 17.3.4 (Lifeline) (see also Figure 17.21).
If the part decomposition is denoted inline under the decomposed lifeline and the decomposition clause is “strict,” this 
indicates that the constructs on all sub lifelines within the inline decomposition are ordered in strict sequence (see
17.6.4 (Strict interactionOperator).
Extra global CombinedFragments have their rectangular frame go outside the boundaries of the decomposition 
Interaction.

Style Guidelines

17.7.4.2.1
The name of an Interaction that is involved in decomposition would benefit from including in the name, the name of the 
type of the Part being decomposed and the name of the Interaction originating the decomposition. This is shown in
Figure 17.21 where the decomposition is called AC_UserAccess where ‘AC’ refers to ACSystem, which is the type of 
the Lifeline and UserAccess is the name of the Interaction where the decomposed lifeline is contained.

17.7.5

Examples

Figure 17.19  InteractionUse

In Figure 17.19 we show an InteractionUse referring the Interaction EstablishAccess with (input) argument “Illegal 
PIN.” Within the optional CombinedFragment there is another InteractionUse without arguments referring OpenDoor.

590

Unified Modeling Language 2.5

Figure 17.20  InteractionUse with value return

In Figure 17.20 we have a more advanced Interaction that models a behavior returning a Verdict value. The return value 
from the Interaction is shown as a separate Lifeline a_op_b. Inside the Interaction there is an InteractionUse referring 
a_util_b with value return to the attribute xc of :xx with the value 9, and with inout parameter where the argument is w 
with returning out-value 12.

Figure 17.21  PartDecomposition - the decomposed part

In Figure 17.21 we see how ACSystem within UserAccess is to be decomposed to AC_UserAccess, which is an 
Interaction owned by class ACSystem.

Figure 17.22  PartDecomposition - the decomposition

Unified Modeling Language 2.5

591

In Figure 17.22 we see that AC_UserAccess has global constructs that match the constructs of UserAccess covering 
ACSystem.
In particular we notice the “extra global interaction group” that goes beyond the frame of the Interaction. This construct 
corresponds to a CombinedFragment of UserAccess. However, we want to indicate that the operands of extra global 
interaction groups are combined one-to-one with similar extra global interaction groups of other decompositions of the 
same original CombinedFragment.
As a notational shorthand, decompositions can also be shown “inline.” In Figure 17.22 we see that the inner 
ConnectableElements of :AccessPoint (p1 and p2) are represented by Lifelines already on this level.

Figure 17.23  Sequence Diagrams where two Lifelines refer to the same set of Parts (and Internal Structure)

The sequence diagrams shown in Figure 17.23 show a scenario where r sends m1 to s[k] (which is of type B), and s[k] 
sends m2 to s[u]. In the meantime independent of s[k] and s[u], r may have sent m3 towards the InteractionUse N 
through a gate. Following the m3 message into N we see that s[u] then sends another m3 message to s[k]. s[k] then 
sends m3 and then m2 towards s[u]. s[u] receives the two latter messages in any order (coregion). Having received these 
messages, we state an invariant on a variable x (most certainly owned by s[u]).

592

Unified Modeling Language 2.5

Figure 17.24  Describing Collaborations and their binding

The example in Figure 17.24 shows how collaboration uses are employed to make Interactions of a Collaboration 
available in another classifier.
The collaboration W has two parts x and y that are of types (classes) superA and superB respectively. Classes A and B 
are specializations of superA and superB respectively. The Sequence Diagram Q shows a simple Interaction that we will 
reuse in another environment. The class E represents this other environment. There are two anonymous parts :A and :B 
and the CollaborationUse w1 of Collaboration W binds x and y to :A and :B respectively. This binding is legal as :A 
and :B are parts of types that are specializations of the types of x and y.
In the Sequence Diagram P (owned by class E) we use the Interaction Q made available via the CollaborationUse w1.

Sequence Diagrams

17.8
The most common kind of Interaction Diagram is the Sequence Diagram, which focuses on the Message interchange 
between a number of Lifelines.
A sequence diagram describes an Interaction by focusing on the sequence of Messages that are exchanged, along with 
their corresponding OccurrenceSpecifications on the Lifelines.
Interactions that are described by Sequence Diagrams form a basis for understanding the semantics of the meta classes 
in the Interactions package. Sequence Diagrams are used for the examples in sub clauses for the Interaction sub 
packages.

17.8.1

17.8.1.1

Sequence Diagram Notation

Graphic Nodes

The graphic nodes that can be included in sequence diagrams are shown in Table 17.1.

Unified Modeling Language 2.5

593

Table 17.1  Graphic Nodes Included in Sequence Diagrams

Node Type

Frame (for Interaction)

Notation

Reference

The notation shows a rectangular 
frame around the diagram with a name 
in a compartment in the upper left 
corner. See 17.2.4 (Interaction)

Lifeline

See 17.3.4 (Lifeline)

ExecutionSpecification

See 17.2.4 (ExecutionSpecification)

InteractionUse

See 17.7.4 (InteractionUse).

CombinedFragment

See 17.6.4 (CombinedFragment)

594

Unified Modeling Language 2.5

Node Type

Notation

StateInvariant

Reference

See 17.2.4 (StateInvariant)

Continuations

See 17.6.4 (Continuation)

Coregion

See 17.6.4 (Parallel 
interactionOperator)

DestructionOccurrenceSpecification

DurationConstraint Duration 
Observation

See 17.4.4 
(DestructionOccurrenceSpecification) 
and example in Figure 17.14.

See Figure 17.5.

Unified Modeling Language 2.5

595

Node Type

Notation

Reference

TimeConstraint TimeObservation

See Figure 17.5.

17.8.1.2

Graphic Paths

The graphic paths between the graphic nodes are given in Table 17.2.
Table 17.2  Graphic Paths Included in Sequence Diagrams

Message

LostMessage

FoundMessage

GeneralOrdering

Messages come in different variants 
depending on what kind of Message 
they convey. Here we show an 
asynchronous message, a call and a 
reply. These are all complete 
messages. See 17.4.4 (Message)

Lost messages are messages for which 
the destination of the [lost] Message is 
outside the scope of the description. 
See 17.4.4 (Message)

Found messages are messages with 
known receiver, but the sending of the 
message is not described within the 
specification. See 17.4.4 (Message)

See 17.5.4 (GeneralOrdering)

Interactions are units of behavior of an enclosing Classifier. Interactions focus on the passing of information with 
Messages between the ConnectableElements of the Classifier.

596

Unified Modeling Language 2.5

17.8.2

Example Sequence Diagram

Figure 17.25  Overview of Metamodel elements of a Sequence Diagram

In order to explain the mapping of the notation onto the metamodel we have pointed out areas and their corresponding 
metamodel concept in Figure 17.25. Let us go through the simple diagram and explain how the metamodel is built up. 
The whole diagram is an Interaction (named N). There is a formal gate (with implicit name in_m3) and two Lifelines 
(named s[u] and s[k] ) that are contained in the Interaction. Furthermore the two Messages (occurrences) both of the 
same type m3, implicitly named m3_1 and m3_2 here, are also owned by the Interaction. Finally there are the three 
OccurrenceSpecifications.
We have omitted in this metamodel the objects that are more peripheral to the Interaction model, such as the Part s and 
the class B and the connector referred by the Message.

Communication Diagrams

17.9
Communication Diagrams focus on the interaction between Lifelines where the architecture of the internal structure and 
how this corresponds with the message passing is central. The sequencing of Messages is given through a sequence 
numbering scheme.
Communication Diagrams correspond to simple Sequence Diagrams that use none of the structuring mechanisms such 
as InteractionUses and CombinedFragments. It is also assumed that message overtaking (i.e., the order of the receptions 
are different from the order of sending of a given set of messages) will not take place or is irrelevant.

17.9.1

17.9.1.1

Communication Diagram Notation

Graphic Paths

Communication diagram nodes are shown in Table 17.3.

Unified Modeling Language 2.5

597

Table 17.3  Graphic Nodes Included in Communication Diagrams

Node Type

Frame (for Interaction)

Notation

Reference

The notation shows a rectangular 
frame around the diagram with a name 
in a compartment in the upper left 
corner. See 17.2.4 (Interaction)

Lifeline

See 17.3.4 (Lifeline)

17.9.1.2

Graphic Paths

Graphic paths of communication diagrams are given in Table 17.4
Table 17.4  Graphic Paths Included in Communications Diagrams

Message

See 17.4.4 (Message) and 17.9.1 
(Sequence expression). The arrow 
shown here indicates the 
communication direction.

17.9.1.3

Sequence expression

The sequence-expression is a dot-separated list of sequence-terms followed by a colon (‘:’).

sequence-term ‘.’ . . . ‘:’

Each term represents a level of procedural nesting within the overall interaction. If all the control is concurrent, then 
nesting does not occur. Each sequence-term has the following syntax:

[ integer | name ] [ recurrence ]

The integer represents the sequential order of the Message within the next higher level of procedural calling. Messages 
that differ in one integer term are sequentially related at that level of nesting. Example: Message 3.1.4 follows Message 
3.1.3 within activation 3.1. The name represents a concurrent thread of control. Messages that differ in the final name 
are concurrent at that level of nesting. Example: Message 3.1a and Message 3.1b are concurrent within activation 3.1. 
All threads of control are equal within the nesting depth.
The recurrence represents conditional or iterative execution. This represents zero or more Messages that are executed 
depending on the conditions involved. The choices are:

‘*’ ‘[’ iteration-clause ‘]’an iteration
‘[’ guard ‘]’a branch

An iteration represents a sequence of Messages at the given nesting depth. The iteration clause may be omitted (in 
which case the iteration conditions are unspecified). The iteration-clause is meant to be expressed in pseudocode or an 
actual programming language, UML does not prescribe its format. An example would be: *[i := 1..n].

598

Unified Modeling Language 2.5

A guard represents a Message whose execution is contingent on the truth of the condition clause. The guard is meant to 
be expressed in pseudocode or an actual programming language; UML does not prescribe its format. An example would 
be: [x > y].
Note that a branch is notated the same as an iteration without a star. One might think of it as an iteration restricted to a 
single occurrence.
The iteration notation assumes that the Messages in the iteration will be executed sequentially. There is also the 
possibility of executing them concurrently. The notation for this is to follow the star by a double vertical line (for 
parallelism): *||.
Note that in a nested control structure, the recurrence is not repeated at inner levels. Each level of structure specifies its 
own iteration within the enclosing context.

17.9.2

Example Communication Diagram

Figure 17.26  Communication diagram

The Interaction described by a Communication Diagram in Figure 17.26 shows messages m1 and m3 being sent 
concurrently from :r towards two instances of the part s. The sequence numbers show how the other messages are 
sequenced. 1b.1 follows after 1b and 1b.1.1 thereafter etc. 2 follows after 1a and 1b.

17.10 Interaction Overview Diagrams
Interaction Overview Diagrams define Interactions through a variant of Activity Diagrams (described in Clause 12) in a 
way that promotes overview of the control flow.
Interaction Overview Diagrams focus on the overview of the flow of control where the nodes are Interactions or 
InteractionUses. The Lifelines and the Messages do not appear at this overview level.

17.10.1

Interaction Overview Diagram Notation

17.10.1.1

Graphic Nodes

Interaction Overview Diagrams are specialization of Activity Diagrams that represent Interactions. Interaction 
Overview Diagrams differ from Activity Diagrams in some respects.

•

In place of ObjectNodes of Activity Diagrams, Interaction Overview Diagrams can only have either (inline) 
Interactions or InteractionUses. Inline Interaction diagrams and InteractionUses are considered special forms 
of CallBehaviorAction.

Unified Modeling Language 2.5

599

• Alternative Combined Fragments are represented by a Decision Node and a corresponding Merge Node.

•

•

•

•

Parallel Combined Fragments are represented by a Fork Node and a corresponding Join Node.

Loop Combined Fragments are represented by simple cycles.

Branching and joining of branches must in Interaction Overview Diagrams be properly nested. This is more 
restrictive than in Activity Diagrams.

Interaction Overview Diagrams are framed by the same kind of frame that encloses other forms of Interaction 
Diagrams. The heading text may also include a list of the contained Lifelines (that do not appear graphically).

Table 17.5  Graphic nodes included in Interaction Overview Diagrams in addition to those borrowed from Activity 
Diagrams

Node Type

Frame (for Interaction)

Notation

Reference

The notation shows a rectangular frame 
around the diagram with a name in a 
compartment in the upper left corner. See
17.2.4 (Interaction)

Interaction

InteractionUse

An Interaction diagram of any kind may 
appear inline as an ActivityInvocation. See
17.2.4 (Interaction). The inline Interaction 
diagrams may be either anonymous (as here) 
or named.

ActivityInvocation in the form of 
InteractionUse. See 17.7.4 (InteractionUse). 
The tools may choose to “explode” the view of 
an InteractionUse into an inline Interaction 
with the name of the Interaction referred by 
the occurrence. The inline Interaction will then 
replace the occurrence by a replica of the 
definition Interaction where arguments have 
replaced parameters.

Interaction Overview Diagrams use Activity diagram notation where the nodes are either Interactions or 
InteractionUses. Interaction Overview Diagrams are a way to describe Interactions where Messages and Lifelines are 
abstracted away. In the purest form all Activities are InteractionUses and then there are no Messages or Lifelines shown 
in the diagram at all.

600

Unified Modeling Language 2.5

17.10.2

Examples of Interaction Overview Diagrams

Figure 17.27  Interaction Overview Diagram representing a High Level Interaction diagram

Figure 17.27 is another way to describe the behavior shown in Figure 17.19, with some added timing constraints. The 
Interaction EstablishAccess occurs first (with argument “Illegal PIN”) followed by weak sequencing with the message 
CardOut which is shown in an inline Interaction. Then there is an alternative as we find a decision node with an 
InteractionConstraint on one of the branches. Along that control flow we find another inline Interaction and an 
InteractionUse in (weak) sequence.

17.11 Timing Diagrams
Timing diagrams focus on conditions changing within and among Lifelines along a linear time axis.
Timing diagrams describe behavior of both individual classifiers and interactions of classifiers, focusing attention on 
time of occurrence of events causing changes in the modeled conditions of the Lifelines.

Unified Modeling Language 2.5

601

17.11.1

Timing Diagram Notation

17.11.1.1

Graphic Nodes and Paths

Timing Diagram graphic nodes and paths are shown in Table 17.6.
Table 17.6  Graphic nodes and paths included in timing diagrams

Node Type

Frame (for Interaction)

Notation

Reference

The notation shows a rectangular frame around 
the diagram with a name in a compartment in 
the upper left corner. See 17.2.4 (Interaction)

Message

MessageLabel

State or condition timeline

General value lifeline

Lifeline

602

Messages come in different variants depending 
on what kind of Message they convey. Here 
we show an asynchronous message, a call and 
a reply. See 17.4.4 (Message)

Labels are only notational shorthands used to 
prevent cluttering of the diagrams with a 
number of messages crisscrossing the diagram 
between Lifelines that are far apart. The labels 
denote that a Message may be disrupted by 
introducing labels with the same name.

This is the state of the classifier or attribute, or 
some testable condition, such as a discrete 
enumerable value. See also 17.2.4 
(StateInvariant).
It is also permissible to let the state-dimension 
be continuous as well as discrete. This is 
illustrative for scenarios where certain entities 
undergo continuous state changes, such as 
temperature or density.

Shows the value of the connectable element as 
a function of time. Value is explicitly denoted 
as text. Crossing reflects the event where the 
value changed.

See 17.3.4 (Lifeline)

Unified Modeling Language 2.5

Node Type

Notation

Reference

GeneralOrdering

17.5.4 (GeneralOrdering).

DestructionOccurrenceSpecifica
tion

See 17.4.4 
(DestructionOccurrenceSpecification)

Examples of Timing Diagrams

17.11.2
Timing diagrams show change in state or other condition of a structural element over time. There are a few forms in 
use. We shall give examples of the simplest forms.
Sequence Diagrams as the primary form of Interactions may also depict time observation and timing constraints. We 
show in Figure 17.5 an example in Sequence Diagram that we will also give in Timing Diagrams.
The :User of the Sequence Diagram in Figure 17.5 is depicted with a simple Timing Diagram in Figure 17.28.

Figure 17.28  A Lifeline for a discrete object

The primary purpose of the timing diagram is to show the change in state or condition of a lifeline (representing a 
Classifier Instance or Classifier Role) over linear time. The most common usage is to show the change in state of an 
object over time in response to accepted events or stimuli. The received events are annotated as shown when it is 
desirable to show the event causing the change in condition or state.
Sometimes it is more economical and compact to show the state or condition on the vertical Lifeline as shown in Figure 
17.29.

Unified Modeling Language 2.5

603

Figure 17.29  Compact Lifeline with States

Finally we may have an elaborate form of TimingDiagrams where more than one Lifeline is shown and where the 
messages are also depicted. We show such a Timing Diagram in Figure 17.30 corresponding to the Sequence Diagram 
in Figure 17.5.

Figure 17.30  Timing Diagram with more than one Lifeline and with Messages

17.12 Classifier Descriptions
17.12.1

ActionExecutionSpecification [Class]

17.12.1.1

Description

An ActionExecutionSpecification is a kind of ExecutionSpecification representing the execution of an Action.

17.12.1.2

Diagrams

Occurrences

17.12.1.3

Generalizations

ExecutionSpecification

604

Unified Modeling Language 2.5

17.12.1.4

Association Ends

•

action : Action [1..1] (opposite A_action_actionExecutionSpecification::actionExecutionSpecification)
Action whose execution is occurring.

17.12.1.5

Constraints

•

action_referenced
The Action referenced by the ActionExecutionSpecification must be owned by the Interaction owning that 
ActionExecutionSpecification.

inv: (enclosingInteraction->notEmpty() or enclosingOperand.combinedFragment->notEmpty()) and
let parentInteraction : Set(Interaction) = enclosingInteraction.oclAsType(Interaction)-
>asSet()->union(
enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->
collect(enclosingInteraction).oclAsType(Interaction)->asSet()) in
(parentInteraction->size() = 1) and self.action.interaction->asSet() = parentInteraction

17.12.2

BehaviorExecutionSpecification [Class]

17.12.2.1

Description

A BehaviorExecutionSpecification is a kind of ExecutionSpecification representing the execution of a Behavior.

17.12.2.2

Diagrams

Occurrences

17.12.2.3

Generalizations

ExecutionSpecification

17.12.2.4

Association Ends

•

behavior : Behavior [0..1] (opposite 
A_behavior_behaviorExecutionSpecification::behaviorExecutionSpecification)
Behavior whose execution is occurring.

17.12.3

CombinedFragment [Class]

17.12.3.1

Description

A CombinedFragment defines an expression of InteractionFragments. A CombinedFragment is defined by an interaction 
operator and corresponding InteractionOperands. Through the use of CombinedFragments the user will be able to 
describe a number of traces in a compact and concise manner.

17.12.3.2

Diagrams

Fragments

17.12.3.3

Generalizations

InteractionFragment

17.12.3.4

Specializations

ConsiderIgnoreFragment

Unified Modeling Language 2.5

605

17.12.3.5

Attributes

•

interactionOperator : InteractionOperatorKind [1..1] = seq
Specifies the operation which defines the semantics of this combination of InteractionFragments.

17.12.3.6

Association Ends

•

•

♦ cfragmentGate : Gate [0..*]{subsets Element::ownedElement} (opposite 
A_cfragmentGate_combinedFragment::combinedFragment)
Specifies the gates that form the interface between this CombinedFragment and its surroundings

♦ operand : InteractionOperand [1..*]{ordered, subsets Element::ownedElement} (opposite 
A_operand_combinedFragment::combinedFragment)
The set of operands of the combined fragment.

17.12.3.7

Constraints

•

•

•

break
If the interactionOperator is break, the corresponding InteractionOperand must cover all Lifelines covered by 
the enclosing InteractionFragment.

inv: interactionOperator=InteractionOperatorKind::break  implies
enclosingInteraction.oclAsType(InteractionFragment)->asSet()->union(
   enclosingOperand.oclAsType(InteractionFragment)->asSet()).covered->asSet() = 
self.covered->asSet()

consider_and_ignore
The interaction operators 'consider' and 'ignore' can only be used for the ConsiderIgnoreFragment subtype of 
CombinedFragment.

inv: ((interactionOperator = InteractionOperatorKind::consider) or (interactionOperator =  
InteractionOperatorKind::ignore)) implies oclIsKindOf(ConsiderIgnoreFragment)

opt_loop_break_neg
If the interactionOperator is opt, loop, break, assert or neg, there must be exactly one operand.

inv: (interactionOperator =  InteractionOperatorKind::opt or interactionOperator = 
InteractionOperatorKind::loop or
interactionOperator = InteractionOperatorKind::break or interactionOperator = 
InteractionOperatorKind::assert or
interactionOperator = InteractionOperatorKind::neg)
implies operand->size()=1

17.12.4

ConsiderIgnoreFragment [Class]

17.12.4.1

Description

A ConsiderIgnoreFragment is a kind of CombinedFragment that is used for the consider and ignore cases, which require 
lists of pertinent Messages to be specified.

17.12.4.2

Diagrams

Fragments

606

Unified Modeling Language 2.5

17.12.4.3

Generalizations

CombinedFragment

17.12.4.4

Association Ends

• message : NamedElement [0..*] (opposite A_message_considerIgnoreFragment::considerIgnoreFragment)

The set of messages that apply to this fragment.

17.12.4.5

Constraints

•

•

consider_or_ignore
The interaction operator of a ConsiderIgnoreFragment must be either 'consider' or 'ignore'.

inv: (interactionOperator =  InteractionOperatorKind::consider) or (interactionOperator =  
InteractionOperatorKind::ignore)

type
The NamedElements must be of a type of element that can be a signature for a message (i.e.., an Operation, or 
a Signal).

inv: message->forAll(m | m.oclIsKindOf(Operation) or m.oclIsKindOf(Signal))

17.12.5

Continuation [Class]

17.12.5.1

Description

A Continuation is a syntactic way to define continuations of different branches of an alternative CombinedFragment. 
Continuations are intuitively similar to labels representing intermediate points in a flow of control.

17.12.5.2

Diagrams

Fragments

17.12.5.3

Generalizations

InteractionFragment

17.12.5.4

Attributes

•

setting : Boolean [1..1] = true
True: when the Continuation is at the end of the enclosing InteractionFragment and False when it is in the 
beginning.

17.12.5.5

Constraints

•

first_or_last_interaction_fragment
Continuations always occur as the very first InteractionFragment or the very last InteractionFragment of the 
enclosing InteractionOperand.

inv:  enclosingOperand->notEmpty() and
 let peerFragments : OrderedSet(InteractionFragment) =  enclosingOperand.fragment in
   ( peerFragments->notEmpty() and
   ((peerFragments->first() = self) or  (peerFragments->last() = self)))

Unified Modeling Language 2.5

607

•

•

same_name
Across all Interaction instances having the same context value, every Lifeline instance covered by a 
Continuation (self) must be common with one covered Lifeline instance of all other Continuation instances 
with the same name as self, and every Lifeline instance covered by a Continuation instance with the same 
name as self must be common with one covered Lifeline instance of self. Lifeline instances are common if they 
have the same selector and represents associationEnd values.

inv: enclosingOperand.combinedFragment->notEmpty() and
let parentInteraction : Set(Interaction) =
enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->
collect(enclosingInteraction).oclAsType(Interaction)->asSet()
in
(parentInteraction->size() = 1)
and let peerInteractions : Set(Interaction) =
 (parentInteraction->union(parentInteraction->collect(_'context')->collect(behavior)->
 select(oclIsKindOf(Interaction)).oclAsType(Interaction)->asSet())->asSet()) in
 (peerInteractions->notEmpty()) and
  let combinedFragments1 : Set(CombinedFragment) = peerInteractions.fragment->
 select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)->asSet() in
   combinedFragments1->notEmpty() and  combinedFragments1->closure(operand.fragment->
   select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment))-
>asSet().operand.fragment->
   select(oclIsKindOf(Continuation)).oclAsType(Continuation)->asSet()->
   forAll(c : Continuation |  (c.name = self.name) implies
  (c.covered->asSet()->forAll(cl : Lifeline | --  cl must be common to one lifeline covered 
by self
  self.covered->asSet()->
  select(represents = cl.represents and selector = cl.selector)->asSet()->size()=1))
   and
 (self.covered->asSet()->forAll(cl : Lifeline | --  cl must be common to one lifeline 
covered by c
 c.covered->asSet()->
  select(represents = cl.represents and selector = cl.selector)->asSet()->size()=1))
  )

global
Continuations are always global in the enclosing InteractionFragment e.g., it always covers all Lifelines 
covered by the enclosing InteractionOperator.

inv: enclosingOperand->notEmpty() and
  let operandLifelines : Set(Lifeline) =  enclosingOperand.covered in
    (operandLifelines->notEmpty() and
    operandLifelines->forAll(ol :Lifeline |self.covered->includes(ol)))

17.12.6

DestructionOccurrenceSpecification [Class]

17.12.6.1

Description

A DestructionOccurenceSpecification models the destruction of an object.

17.12.6.2

Diagrams

Messages

17.12.6.3

Generalizations

MessageOccurrenceSpecification

17.12.6.4

Constraints

•

no_occurrence_specifications_below
No other OccurrenceSpecifications on a given Lifeline in an InteractionOperand may appear below a 
DestructionOccurrenceSpecification.

inv: let o : InteractionOperand = enclosingOperand in o->notEmpty() and

608

Unified Modeling Language 2.5

let peerEvents : OrderedSet(OccurrenceSpecification) = covered.events-
>select(enclosingOperand = o)
in peerEvents->last() = self

17.12.7

ExecutionOccurrenceSpecification [Class]

17.12.7.1

Description

An ExecutionOccurrenceSpecification represents moments in time at which Actions or Behaviors start or finish.

17.12.7.2

Diagrams

Occurrences

17.12.7.3

Generalizations

OccurrenceSpecification

17.12.7.4

Association Ends

•

execution : ExecutionSpecification [1..1] (opposite 
A_execution_executionOccurrenceSpecification::executionOccurrenceSpecification)
References the execution specification describing the execution that is started or finished at this execution 
event.

17.12.8

ExecutionSpecification [Abstract Class]

17.12.8.1

Description

An ExecutionSpecification is a specification of the execution of a unit of Behavior or Action within the Lifeline. The 
duration of an ExecutionSpecification is represented by two OccurrenceSpecifications, the start 
OccurrenceSpecification and the finish OccurrenceSpecification.

17.12.8.2

Diagrams

Interactions, Occurrences

17.12.8.3

Generalizations

InteractionFragment

17.12.8.4

Specializations

ActionExecutionSpecification, BehaviorExecutionSpecification

17.12.8.5

Association Ends

•

•

finish : OccurrenceSpecification [1..1] (opposite A_finish_executionSpecification::executionSpecification)
References the OccurrenceSpecification that designates the finish of the Action or Behavior.

start : OccurrenceSpecification [1..1] (opposite A_start_executionSpecification::executionSpecification)
References the OccurrenceSpecification that designates the start of the Action or Behavior.

17.12.8.6

Constraints

•

same_lifeline
The startEvent and the finishEvent must be on the same Lifeline.

Unified Modeling Language 2.5

609

inv: start.covered = finish.covered

17.12.9 Gate [Class]

17.12.9.1

Description

A Gate is a MessageEnd which serves as a connection point for relating a Message which has a MessageEnd 
(sendEvent / receiveEvent) outside an InteractionFragment with another Message which has a MessageEnd 
(receiveEvent / sendEvent) inside that InteractionFragment.

17.12.9.2

Diagrams

Interactions, Messages, Fragments, Interaction Uses

17.12.9.3

Generalizations

MessageEnd

17.12.9.4

Operations

•

•

•

•

isOutsideCF() : Boolean [1..1]
This query returns true if this Gate is attached to the boundary of a CombinedFragment, and its other end (if 
present) is outside of the same CombinedFragment.

body: self.oppositeEnd()-> notEmpty() and combinedFragment->notEmpty() implies
let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
if oppEnd.oclIsKindOf(MessageOccurrenceSpecification)
then let oppMOS : MessageOccurrenceSpecification = 
oppEnd.oclAsType(MessageOccurrenceSpecification)
in  self.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
     union(self.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet()) =
     oppMOS.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
     union(oppMOS.enclosingOperand.oclAsType(InteractionFragment)->asSet())
else let oppGate : Gate = oppEnd.oclAsType(Gate)
in self.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
     union(self.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet()) =
     oppGate.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
     union(oppGate.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)-
>asSet())
endif

isInsideCF() : Boolean
This query returns true if this Gate is attached to the boundary of a CombinedFragment, and its other end (if 
present) is inside of an InteractionOperator of the same CombinedFragment.

body: self.oppositeEnd()-> notEmpty() and combinedFragment->notEmpty() implies
let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
if oppEnd.oclIsKindOf(MessageOccurrenceSpecification)
then let oppMOS : MessageOccurrenceSpecification
= oppEnd.oclAsType(MessageOccurrenceSpecification)
in combinedFragment = oppMOS.enclosingOperand.combinedFragment
else let oppGate : Gate = oppEnd.oclAsType(Gate)
in combinedFragment = oppGate.combinedFragment.enclosingOperand.combinedFragment
endif

isActual() : Boolean
This query returns true value if this Gate is an actualGate of an InteractionUse.

body: interactionUse->notEmpty()

isFormal() : Boolean
This query returns true if this Gate is a formalGate of an Interaction.

610

Unified Modeling Language 2.5

body: interaction->notEmpty()

•

getName() : String
This query returns the name of the gate, either the explicit name (.name) or the constructed name ('out_" or 
'in_' concatenated in front of .message.name) if the explicit name is not present.

body: if name->notEmpty() then name->asOrderedSet()->first()
else  if isActual() or isOutsideCF()
  then if isSend()
    then 'out_'.concat(self.message.name->asOrderedSet()->first())
    else 'in_'.concat(self.message.name->asOrderedSet()->first())
    endif
  else if isSend()
    then 'in_'.concat(self.message.name->asOrderedSet()->first())
    else 'out_'.concat(self.message.name->asOrderedSet()->first())
    endif
  endif
endif

• matches(gateToMatch : Gate [1..1]) : Boolean

This query returns true if the name of this Gate matches the name of the in parameter Gate, and the messages 
for the two Gates correspond. The Message for one Gate (say A) corresponds to the Message for another Gate 
(say B) if (A and B have the same name value) and (if A is a sendEvent then B is a receiveEvent) and (if A is a 
receiveEvent then B is a sendEvent) and (A and B have the same messageSort value) and (A and B have the 
same signature value).

body: self.getName() = gateToMatch.getName() and
self.message.messageSort = gateToMatch.message.messageSort and
self.message.name = gateToMatch.message.name and
self.message.sendEvent->includes(self) implies gateToMatch.message.receiveEvent-
>includes(gateToMatch)  and
self.message.receiveEvent->includes(self) implies gateToMatch.message.sendEvent-
>includes(gateToMatch) and
self.message.signature = gateToMatch.message.signature

•

•

isDistinguishableFrom(n : NamedElement, ns : Namespace) : Boolean {redefines 
NamedElement::isDistinguishableFrom()}
The query isDistinguishableFrom() specifies that two Gates may coexist in the same Namespace, without an 
explicit name property. The association end formalGate subsets ownedElement, and since the Gate name 
attribute is optional, it is allowed to have two formal gates without an explicit name, but having derived names 
which are distinct.

body: true

getOperand() : InteractionOperand
If the Gate is an inside Combined Fragment Gate, this operation returns the InteractionOperand that the 
opposite end of this Gate is included within.

body: if isInsideCF() then
  let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
    if oppEnd.oclIsKindOf(MessageOccurrenceSpecification)
    then let oppMOS : MessageOccurrenceSpecification = 
oppEnd.oclAsType(MessageOccurrenceSpecification)
        in oppMOS.enclosingOperand->asOrderedSet()->first()
    else let oppGate : Gate = oppEnd.oclAsType(Gate)
        in oppGate.combinedFragment.enclosingOperand->asOrderedSet()->first()
    endif
  else null
endif

17.12.9.5

Constraints

•

actual_gate_matched
If this Gate is an actualGate, it must have exactly one matching formalGate within the referred Interaction.

Unified Modeling Language 2.5

611

•

•

•

•

•

•

inv: interactionUse->notEmpty() implies interactionUse.refersTo.formalGate-
>select(matches(self))->size()=1

inside_cf_matched
If this Gate is inside a CombinedFragment, it must have exactly one matching Gate which is outside of that 
CombinedFragment.

inv: isInsideCF() implies combinedFragment.cfragmentGate->select(isOutsideCF() and 
matches(self))->size()=1

outside_cf_matched
If this Gate is outside an 'alt' CombinedFragment, for every InteractionOperator inside that CombinedFragment 
there must be exactly one matching Gate inside the CombinedFragment with its opposing end enclosed by that 
InteractionOperator. If this Gate is outside CombinedFragment with operator other than 'alt', there must be 
exactly one matching Gate inside that CombinedFragment.

inv: isOutsideCF() implies
 if self.combinedFragment.interactionOperator->asOrderedSet()->first() = 
InteractionOperatorKind::alt
 then self.combinedFragment.operand->forAll(op : InteractionOperand |
 self.combinedFragment.cfragmentGate->select(isInsideCF() and
 oppositeEnd().enclosingFragment()->includes(self.combinedFragment) and matches(self))-
>size()=1)
 else  self.combinedFragment.cfragmentGate->select(isInsideCF() and matches(self))->size()=1
 endif

formal_gate_distinguishable
isFormal() implies that no other formalGate of the parent Interaction returns the same getName() as returned 
for self.

inv: isFormal() implies interaction.formalGate->select(getName() = self.getName())->size()=1

actual_gate_distinguishable
isActual() implies that no other actualGate of the parent InteractionUse returns the same getName() as returned 
for self.

inv: isActual() implies interactionUse.actualGate->select(getName() = self.getName())-
>size()=1

outside_cf_gate_distinguishable
isOutsideCF() implies that no other outside cfragmentGate of the parent CombinedFragment returns the same 
getName() as returned for self.

inv: isOutsideCF() implies combinedFragment.cfragmentGate->select(getName() = 
self.getName())->size()=1

inside_cf_gate_distinguishable
isInsideCF() implies that no other inside cfragmentGate attached to a message with its other end in the same 
InteractionOperator as self, returns the same getName() as returned for self.

inv: isInsideCF() implies
let selfOperand : InteractionOperand = self.getOperand() in
  combinedFragment.cfragmentGate->select(isInsideCF() and getName() = self.getName())-
>select(getOperand() = selfOperand)->size()=1

612

Unified Modeling Language 2.5

17.12.10 GeneralOrdering [Class]

17.12.10.1

Description

A GeneralOrdering represents a binary relation between two OccurrenceSpecifications, to describe that one 
OccurrenceSpecification must occur before the other in a valid trace. This mechanism provides the ability to define 
partial orders of OccurrenceSpecifications that may otherwise not have a specified order.

17.12.10.2

Diagrams

Occurrences

17.12.10.3

Generalizations

NamedElement

17.12.10.4

Association Ends

•

•

after : OccurrenceSpecification [1..1] (opposite OccurrenceSpecification::toBefore)
The OccurrenceSpecification referenced comes after the OccurrenceSpecification referenced by before.

before : OccurrenceSpecification [1..1] (opposite OccurrenceSpecification::toAfter)
The OccurrenceSpecification referenced comes before the OccurrenceSpecification referenced by after.

17.12.10.5

Constraints

•

irreflexive_transitive_closure
An occurrence specification must not be ordered relative to itself through a series of general orderings. (In 
other words, the transitive closure of the general orderings is irreflexive.)

inv: after->closure(toAfter.after)->excludes(before)

17.12.11 Interaction [Class]

17.12.11.1

Description

An Interaction is a unit of Behavior that focuses on the observable exchange of information between connectable 
elements.

17.12.11.2

Diagrams

Interactions, Messages, Lifelines, Interaction Uses

17.12.11.3

Generalizations

InteractionFragment, Behavior

17.12.11.4

Association Ends

•

•

♦ action : Action [0..*]{subsets Element::ownedElement} (opposite A_action_interaction::interaction)
Actions owned by the Interaction.

♦ formalGate : Gate [0..*]{subsets Namespace::ownedMember} (opposite 
A_formalGate_interaction::interaction)
Specifies the gates that form the message interface between this Interaction and any InteractionUses which 
reference it.

Unified Modeling Language 2.5

613

•

•

•

♦ fragment : InteractionFragment [0..*]{ordered, subsets Namespace::ownedMember} (opposite 
InteractionFragment::enclosingInteraction)
The ordered set of fragments in the Interaction.

♦ lifeline : Lifeline [0..*]{subsets Namespace::ownedMember} (opposite Lifeline::interaction)
Specifies the participants in this Interaction.

♦ message : Message [0..*]{subsets Namespace::ownedMember} (opposite Message::interaction)
The Messages contained in this Interaction.

17.12.11.5

Constraints

•

not_contained
An Interaction instance must not be contained within another Interaction instance.

inv: enclosingInteraction->isEmpty()

17.12.12 InteractionConstraint [Class]

17.12.12.1

Description

An InteractionConstraint is a Boolean expression that guards an operand in a CombinedFragment.

17.12.12.2

Diagrams

Fragments

17.12.12.3

Generalizations

Constraint

17.12.12.4

Association Ends

•

•

♦ maxint : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_maxint_interactionConstraint::interactionConstraint)
The maximum number of iterations of a loop

♦ minint : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_minint_interactionConstraint::interactionConstraint)
The minimum number of iterations of a loop

17.12.12.5

Constraints

• minint_maxint

Minint/maxint can only be present if the InteractionConstraint is associated with the operand of a loop 
CombinedFragment.

inv: maxint->notEmpty() or minint->notEmpty() implies
interactionOperand.combinedFragment.interactionOperator =
InteractionOperatorKind::loop

• minint_non_negative

If minint is specified, then the expression must evaluate to a non-negative integer.

inv: minint->notEmpty() implies

614

Unified Modeling Language 2.5

minint->asSequence()->first().integerValue() >= 0

• maxint_positive

If maxint is specified, then the expression must evaluate to a positive integer.

inv: maxint->notEmpty() implies
maxint->asSequence()->first().integerValue() > 0

•

•

dynamic_variables
The dynamic variables that take part in the constraint must be owned by the ConnectableElement 
corresponding to the covered Lifeline.

Cannot be expressed in OCL

global_data
The constraint may contain references to global data or write-once data.

Cannot be expressed in OCL

• maxint_greater_equal_minint

If maxint is specified, then minint must be specified and the evaluation of maxint must be >= the evaluation of 
minint.

inv: maxint->notEmpty() implies (minint->notEmpty() and
maxint->asSequence()->first().integerValue() >=
minint->asSequence()->first().integerValue() )

17.12.13 InteractionFragment [Abstract Class]

17.12.13.1

Description

InteractionFragment is an abstract notion of the most general interaction unit. An InteractionFragment is a piece of an 
Interaction. Each InteractionFragment is conceptually like an Interaction by itself.

17.12.13.2

Diagrams

Interactions, Lifelines, Occurrences, Fragments, Interaction Uses

17.12.13.3

Generalizations

NamedElement

17.12.13.4

Specializations

CombinedFragment, Continuation, ExecutionSpecification, Interaction, InteractionOperand, InteractionUse, 
OccurrenceSpecification, StateInvariant

17.12.13.5

Association Ends

•

•

covered : Lifeline [0..*] (opposite Lifeline::coveredBy)
References the Lifelines that the InteractionFragment involves.

enclosingInteraction : Interaction [0..1]{subsets NamedElement::namespace} (opposite Interaction::fragment)
The Interaction enclosing this InteractionFragment.

Unified Modeling Language 2.5

615

•

•

enclosingOperand : InteractionOperand [0..1]{subsets NamedElement::namespace} (opposite 
InteractionOperand::fragment)
The operand enclosing this InteractionFragment (they may nest recursively).

♦ generalOrdering : GeneralOrdering [0..*]{subsets Element::ownedElement} (opposite 
A_generalOrdering_interactionFragment::interactionFragment)
The general ordering relationships contained in this fragment.

17.12.14 InteractionOperand [Class]

17.12.14.1

Description

An InteractionOperand is contained in a CombinedFragment. An InteractionOperand represents one operand of the 
expression given by the enclosing CombinedFragment.

17.12.14.2

Diagrams

Fragments

17.12.14.3

Generalizations

InteractionFragment, Namespace

17.12.14.4

Association Ends

•

•

♦ fragment : InteractionFragment [0..*]{ordered, subsets Namespace::ownedMember} (opposite 
InteractionFragment::enclosingOperand)
The fragments of the operand.

♦ guard : InteractionConstraint [0..1]{subsets Element::ownedElement} (opposite 
A_guard_interactionOperand::interactionOperand)
Constraint of the operand.

17.12.14.5

Constraints

•

•

guard_contain_references
The guard must contain only references to values local to the Lifeline on which it resides, or values global to 
the whole Interaction.

Cannot be expressed in OCL

guard_directly_prior
The guard must be placed directly prior to (above) the OccurrenceSpecification that will become the first 
OccurrenceSpecification within this InteractionOperand.

Cannot be expressed in OCL

17.12.15 InteractionOperatorKind [Enumeration]

17.12.15.1

Description

InteractionOperatorKind is an enumeration designating the different kinds of operators of CombinedFragments. The 
InteractionOperand defines the type of operator of a CombinedFragment.

616

Unified Modeling Language 2.5

17.12.15.2

Diagrams

•

Fragments
 
 

17.12.15.3

Literals

•

•

•

•

•

•

•

•

seq
The InteractionOperatorKind seq designates that the CombinedFragment represents a weak sequencing 
between the behaviors of the operands.

alt
The InteractionOperatorKind alt designates that the CombinedFragment represents a choice of behavior. At 
most one of the operands will be chosen. The chosen operand must have an explicit or implicit guard 
expression that evaluates to true at this point in the interaction. An implicit true guard is implied if the operand 
has no guard.

opt
The InteractionOperatorKind opt designates that the CombinedFragment represents a choice of behavior where 
either the (sole) operand happens or nothing happens. An option is semantically equivalent to an alternative 
CombinedFragment where there is one operand with non-empty content and the second operand is empty.

break
The InteractionOperatorKind break designates that the CombinedFragment represents a breaking scenario in 
the sense that the operand is a scenario that is performed instead of the remainder of the enclosing 
InteractionFragment. A break operator with a guard is chosen when the guard is true and the rest of the 
enclosing Interaction Fragment is ignored. When the guard of the break operand is false, the break operand is 
ignored and the rest of the enclosing InteractionFragment is chosen. The choice between a break operand 
without a guard and the rest of the enclosing InteractionFragment is done non-deterministically.

par
The InteractionOperatorKind par designates that the CombinedFragment represents a parallel merge between 
the behaviors of the operands. The OccurrenceSpecifications of the different operands can be interleaved in 
any way as long as the ordering imposed by each operand as such is preserved.

strict
The InteractionOperatorKind strict designates that the CombinedFragment represents a strict sequencing 
between the behaviors of the operands. The semantics of strict sequencing defines a strict ordering of the 
operands on the first level within the CombinedFragment with interactionOperator strict. Therefore 
OccurrenceSpecifications within contained CombinedFragment will not directly be compared with other 
OccurrenceSpecifications of the enclosing CombinedFragment.

loop
The InteractionOperatorKind loop designates that the CombinedFragment represents a loop. The loop operand 
will be repeated a number of times.

critical
The InteractionOperatorKind critical designates that the CombinedFragment represents a critical region. A 
critical region means that the traces of the region cannot be interleaved by other OccurrenceSpecifications (on 
those Lifelines covered by the region). This means that the region is treated atomically by the enclosing 
fragment when determining the set of valid traces. Even though enclosing CombinedFragments may imply that 
some OccurrenceSpecifications may interleave into the region, such as with par-operator, this is prevented by 
defining a region.

Unified Modeling Language 2.5

617

•

•

•

•

neg
The InteractionOperatorKind neg designates that the CombinedFragment represents traces that are defined to 
be invalid.

assert
The InteractionOperatorKind assert designates that the CombinedFragment represents an assertion. The 
sequences of the operand of the assertion are the only valid continuations. All other continuations result in an 
invalid trace.

ignore
The InteractionOperatorKind ignore designates that there are some message types that are not shown within 
this combined fragment. These message types can be considered insignificant and are implicitly ignored if they 
appear in a corresponding execution. Alternatively, one can understand ignore to mean that the message types 
that are ignored can appear anywhere in the traces.

consider
The InteractionOperatorKind consider designates which messages should be considered within this combined 
fragment. This is equivalent to defining every other message to be ignored.

17.12.16 InteractionUse [Class]

17.12.16.1

Description

An InteractionUse refers to an Interaction. The InteractionUse is a shorthand for copying the contents of the referenced 
Interaction where the InteractionUse is. To be accurate the copying must take into account substituting parameters with 
arguments and connect the formal Gates with the actual ones.

17.12.16.2

Diagrams

Interaction Uses

17.12.16.3

Generalizations

InteractionFragment

17.12.16.4

Specializations

PartDecomposition

17.12.16.5

Association Ends

•

•

•

•

618

♦ actualGate : Gate [0..*]{subsets Element::ownedElement} (opposite 
A_actualGate_interactionUse::interactionUse)
The actual gates of the InteractionUse.

♦ argument : ValueSpecification [0..*]{ordered, subsets Element::ownedElement} (opposite 
A_argument_interactionUse::interactionUse)
The actual arguments of the Interaction.

refersTo : Interaction [1..1] (opposite A_refersTo_interactionUse::interactionUse)
Refers to the Interaction that defines its meaning.

♦ returnValue : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite 
A_returnValue_interactionUse::interactionUse)
The value of the executed Interaction.

Unified Modeling Language 2.5

•

returnValueRecipient : Property [0..1] (opposite A_returnValueRecipient_interactionUse::interactionUse)
The recipient of the return value.

17.12.16.6

Constraints

•

•

•

•

•

•

gates_match
Actual Gates of the InteractionUse must match Formal Gates of the referred Interaction. Gates match when 
their names are equal and their messages correspond.

inv: actualGate->notEmpty() implies
refersTo.formalGate->forAll( fg : Gate | self.actualGate->select(matches(fg))->size()=1) and
self.actualGate->forAll(ag : Gate | refersTo.formalGate->select(matches(ag))->size()=1)

arguments_are_constants
The arguments must only be constants, parameters of the enclosing Interaction or attributes of the classifier 
owning the enclosing Interaction.

Cannot be expressed in OCL

returnValueRecipient_coverage
The returnValueRecipient must be a Property of a ConnectableElement that is represented by a Lifeline 
covered by this InteractionUse.

inv: returnValueRecipient->asSet()->notEmpty() implies
let covCE : Set(ConnectableElement) = covered.represents->asSet() in
covCE->notEmpty() and let classes:Set(Classifier) = 
covCE.type.oclIsKindOf(Classifier).oclAsType(Classifier)->asSet() in
let allProps : Set(Property) = classes.attribute->union(classes.allParents().attribute)-
>asSet() in
allProps->includes(returnValueRecipient)

arguments_correspond_to_parameters
The arguments of the InteractionUse must correspond to parameters of the referred Interaction.

Cannot be expressed in OCL

returnValue_type_recipient_correspondence
The type of the returnValue must correspond to the type of the returnValueRecipient.

inv: returnValue.type->asSequence()->notEmpty() implies returnValue.type->asSequence()-
>first() = returnValueRecipient.type->asSequence()->first()

all_lifelines
The InteractionUse must cover all Lifelines of the enclosing Interaction that are common with the lifelines 
covered by the referred Interaction. Lifelines are common if they have the same selector and represents 
associationEnd values.

inv: let parentInteraction : Set(Interaction) = enclosingInteraction->asSet()->
union(enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->
collect(enclosingInteraction).oclAsType(Interaction)->asSet()) in
parentInteraction->size()=1 and let refInteraction : Interaction = refersTo in
parentInteraction.covered-> forAll(intLifeline : Lifeline | refInteraction.covered->
forAll( refLifeline : Lifeline | refLifeline.represents = intLifeline.represents and
(
( refLifeline.selector.oclIsKindOf(LiteralString) implies
  intLifeline.selector.oclIsKindOf(LiteralString) and
  refLifeline.selector.oclAsType(LiteralString).value = 
intLifeline.selector.oclAsType(LiteralString).value ) and
( refLifeline.selector.oclIsKindOf(LiteralInteger) implies
  intLifeline.selector.oclIsKindOf(LiteralInteger) and
  refLifeline.selector.oclAsType(LiteralInteger).value = 
intLifeline.selector.oclAsType(LiteralInteger).value )

Unified Modeling Language 2.5

619

)
 implies self.covered->asSet()->includes(intLifeline)))

17.12.17 Lifeline [Class]

17.12.17.1

Description

A Lifeline represents an individual participant in the Interaction. While parts and structural features may have 
multiplicity greater than 1, Lifelines represent only one interacting entity.

17.12.17.2

Diagrams

Lifelines, Interaction Uses

17.12.17.3

Generalizations

NamedElement

17.12.17.4

Association Ends

•

•

•

•

•

coveredBy : InteractionFragment [0..*] (opposite InteractionFragment::covered)
References the InteractionFragments in which this Lifeline takes part.

decomposedAs : PartDecomposition [0..1] (opposite A_decomposedAs_lifeline::lifeline)
References the Interaction that represents the decomposition.

interaction : Interaction [1..1]{subsets NamedElement::namespace} (opposite Interaction::lifeline)
References the Interaction enclosing this Lifeline.

represents : ConnectableElement [0..1] (opposite A_represents_lifeline::lifeline)
References the ConnectableElement within the classifier that contains the enclosing interaction.

♦ selector : ValueSpecification [0..1]{subsets Element::ownedElement} (opposite A_selector_lifeline::lifeline)
If the referenced ConnectableElement is multivalued, then this specifies the specific individual part within that 
set.

17.12.17.5

Constraints

•

•

620

selector_specified
The selector for a Lifeline must only be specified if the referenced Part is multivalued.

inv:  self.selector->notEmpty() = (self.represents.oclIsKindOf(MultiplicityElement) and 
self.represents.oclAsType(MultiplicityElement).isMultivalued())

interaction_uses_share_lifeline
If a lifeline is in an Interaction referred to by an InteractionUse in an enclosing Interaction, and that lifeline is 
common with another lifeline in an Interaction referred to by another InteractonUse within that same enclosing 
Interaction, it must be common to a lifeline within that enclosing Interaction. By common Lifelines we mean 
Lifelines with the same selector and represents associations.

inv: let intUses : Set(InteractionUse) = interaction.interactionUse in
intUses->forAll
( iuse : InteractionUse |
let usingInteraction : Set(Interaction)  = iuse.enclosingInteraction->asSet()
->union(
iuse.enclosingOperand.combinedFragment->asSet()-
>closure(enclosingOperand.combinedFragment).enclosingInteraction->asSet()

Unified Modeling Language 2.5

               )
in
let peerUses : Set(InteractionUse) = usingInteraction.fragment-
>select(oclIsKindOf(InteractionUse)).oclAsType(InteractionUse)->asSet()
->union(
usingInteraction.fragment-
>select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)->asSet()
->closure(operand.fragment-
>select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)).operand.fragment->
select(oclIsKindOf(InteractionUse)).oclAsType(InteractionUse)->asSet()
               )->excluding(iuse)
 in
peerUses->forAll( peerUse : InteractionUse |
 peerUse.refersTo.lifeline->forAll( l : Lifeline | (l.represents = self.represents and
 ( self.selector.oclIsKindOf(LiteralString) implies
  l.selector.oclIsKindOf(LiteralString) and
  self.selector.oclAsType(LiteralString).value = l.selector.oclAsType(LiteralString).value )
  and
( self.selector.oclIsKindOf(LiteralInteger) implies
  l.selector.oclIsKindOf(LiteralInteger) and
  self.selector.oclAsType(LiteralInteger).value = 
l.selector.oclAsType(LiteralInteger).value )
)
implies
 usingInteraction.lifeline->select(represents = self.represents and
 ( self.selector.oclIsKindOf(LiteralString) implies
  l.selector.oclIsKindOf(LiteralString) and
  self.selector.oclAsType(LiteralString).value = l.selector.oclAsType(LiteralString).value )
and
( self.selector.oclIsKindOf(LiteralInteger) implies
  l.selector.oclIsKindOf(LiteralInteger) and
  self.selector.oclAsType(LiteralInteger).value = 
l.selector.oclAsType(LiteralInteger).value )
)
                                                )
                    )
)

same_classifier
The classifier containing the referenced ConnectableElement must be the same classifier, or an ancestor, of the 
classifier that contains the interaction enclosing this lifeline.

inv: represents.namespace->closure(namespace)->includes(interaction._'context')

selector_int_or_string
The selector value, if present, must be a LiteralString or a LiteralInteger.

inv: self.selector->notEmpty() implies
self.selector.oclIsKindOf(LiteralInteger) or
self.selector.oclIsKindOf(LiteralString)

•

•

17.12.18 Message [Class]

17.12.18.1

Description

A Message defines a particular communication between Lifelines of an Interaction.

17.12.18.2

Diagrams

Messages, Information Flows

17.12.18.3

Generalizations

NamedElement

Unified Modeling Language 2.5

621

17.12.18.4

Attributes

•

/messageKind : MessageKind [1..1]
The derived kind of the Message (complete, lost, found, or unknown).

• messageSort : MessageSort [1..1] = synchCall

The sort of communication reflected by the Message.

17.12.18.5

Association Ends

•

•

•

•

•

•

♦ argument : ValueSpecification [0..*]{ordered, subsets Element::ownedElement} (opposite 
A_argument_message::message)
The arguments of the Message.

connector : Connector [0..1] (opposite A_connector_message::message)
The Connector on which this Message is sent.

interaction : Interaction [1..1]{subsets NamedElement::namespace} (opposite Interaction::message)
The enclosing Interaction owning the Message.

receiveEvent : MessageEnd [0..1]{subsets A_message_messageEnd::messageEnd} (opposite 
A_receiveEvent_endMessage::endMessage)
References the Receiving of the Message.

sendEvent : MessageEnd [0..1]{subsets A_message_messageEnd::messageEnd} (opposite 
A_sendEvent_endMessage::endMessage)
References the Sending of the Message.

signature : NamedElement [0..1] (opposite A_signature_message::message)
The signature of the Message is the specification of its content. It refers either an Operation or a Signal.

17.12.18.6

Operations

• messageKind() : MessageKind

This query returns the MessageKind value for this Message.

body: messageKind

•

isDistinguishableFrom(n : NamedElement, ns : Namespace) : Boolean {redefines 
NamedElement::isDistinguishableFrom()}
The query isDistinguishableFrom() specifies that any two Messages may coexist in the same Namespace, 
regardless of their names.

body: true

17.12.18.7

Constraints

•

sending_receiving_message_event
If the sendEvent and the receiveEvent of the same Message are on the same Lifeline, the sendEvent must be 
ordered before the receiveEvent.

inv: receiveEvent.oclIsKindOf(MessageOccurrenceSpecification)
implies

622

Unified Modeling Language 2.5

•

•

•

•

•

let f : Lifeline = sendEvent-
>select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecificatio
n)->asOrderedSet()->first().covered in
f = receiveEvent-
>select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecificatio
n)->asOrderedSet()->first().covered  implies
f.events->indexOf(sendEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()-
>first() ) <
f.events->indexOf(receiveEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()-
>first() )

arguments
Arguments of a Message must only be: i) attributes of the sending lifeline, ii) constants, iii) symbolic values 
(which are wildcard values representing any legal value), iv) explicit parameters of the enclosing Interaction, 
v) attributes of the class owning the Interaction.

Cannot be expressed in OCL

cannot_cross_boundaries
Messages cannot cross boundaries of CombinedFragments or their operands. This is true if and only if both 
MessageEnds are enclosed within the same InteractionFragment (i.e., an InteractionOperand or an Interaction).

inv: sendEvent->notEmpty() and receiveEvent->notEmpty() implies
let sendEnclosingFrag : Set(InteractionFragment) =
sendEvent->asOrderedSet()->first().enclosingFragment()
in
let receiveEnclosingFrag : Set(InteractionFragment) =
receiveEvent->asOrderedSet()->first().enclosingFragment()
in  sendEnclosingFrag = receiveEnclosingFrag

signature_is_signal
In the case when the Message signature is a Signal, the arguments of the Message must correspond to the 
attributes of the Signal. A Message Argument corresponds to a Signal Attribute if the Argument is of the same 
Class or a specialization of that of the Attribute.

inv: (messageSort = MessageSort::asynchSignal ) and signature.oclIsKindOf(Signal) implies
   let signalAttributes : OrderedSet(Property) = 
signature.oclAsType(Signal).inheritedMember()->
             select(n:NamedElement | n.oclIsTypeOf(Property))->collect(oclAsType(Property))-
>asOrderedSet()
   in signalAttributes->size() = self.argument->size()
   and self.argument->forAll( o: ValueSpecification |
          not (o.oclIsKindOf(Expression)
          and o.oclAsType(Expression).symbol->size()=0
          and o.oclAsType(Expression).operand->isEmpty() ) implies
              let p : Property = signalAttributes->at(self.argument->indexOf(o))
              in o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier)))

occurrence_specifications
If the MessageEnds are both OccurrenceSpecifications, then the connector must go between the Parts 
represented by the Lifelines of the two MessageEnds.

Cannot be expressed in OCL

signature_refer_to
The signature must either refer an Operation (in which case messageSort is either synchCall or asynchCall or 
reply) or a Signal (in which case messageSort is asynchSignal). The name of the NamedElement referenced by 
signature must be the same as that of the Message.

inv: signature->notEmpty() implies
((signature.oclIsKindOf(Operation) and
(messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall or 
messageSort = MessageSort::reply)
) or (signature.oclIsKindOf(Signal)  and messageSort = MessageSort::asynchSignal )
 ) and name = signature.name

Unified Modeling Language 2.5

623

•

•

signature_is_operation_request
In the case when a Message with messageSort synchCall or asynchCall has a non empty Operation signature, 
the arguments of the Message must correspond to the in and inout parameters of the Operation. A Parameter 
corresponds to an Argument if the Argument is of the same Class or a specialization of that of the Parameter.

inv: (messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall) and 
signature.oclIsKindOf(Operation)  implies
 let requestParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->
 select(direction = ParameterDirectionKind::inout or direction = 
ParameterDirectionKind::_'in'  )
in requestParms->size() = self.argument->size() and
self.argument->forAll( o: ValueSpecification |
not (o.oclIsKindOf(Expression) and o.oclAsType(Expression).symbol->size()=0 and 
o.oclAsType(Expression).operand->isEmpty() ) implies
let p : Parameter = requestParms->at(self.argument->indexOf(o)) in
o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))
)

signature_is_operation_reply
In the case when a Message with messageSort reply has a non empty Operation signature, the arguments of the 
Message must correspond to the out, inout, and return parameters of the Operation. A Parameter corresponds to 
an Argument if the Argument is of the same Class or a specialization of that of the Parameter.

inv: (messageSort = MessageSort::reply) and signature.oclIsKindOf(Operation) implies
 let replyParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->
select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::out 
or direction = ParameterDirectionKind::return)
in replyParms->size() = self.argument->size() and
self.argument->forAll( o: ValueSpecification | o.oclIsKindOf(Expression) and let e : 
Expression = o.oclAsType(Expression) in
e.operand->notEmpty()  implies
let p : Parameter = replyParms->at(self.argument->indexOf(o)) in
e.operand->asSequence()-
>first().type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))
)

17.12.19 MessageEnd [Abstract Class]

17.12.19.1

Description

MessageEnd is an abstract specialization of NamedElement that represents what can occur at the end of a Message.

17.12.19.2

Diagrams

Messages

17.12.19.3

Generalizations

NamedElement

17.12.19.4

Specializations

Gate, MessageOccurrenceSpecification

17.12.19.5

Association Ends

• message : Message [0..1] (opposite A_message_messageEnd::messageEnd)

References a Message.

624

Unified Modeling Language 2.5

17.12.19.6

Operations

•

•

•

•

oppositeEnd() : MessageEnd [0..*]
This query returns a set including the MessageEnd (if exists) at the opposite end of the Message for this 
MessageEnd.

pre: message->notEmpty()

body: message->asSet().messageEnd->asSet()->excluding(self)

isSend() : Boolean
This query returns value true if this MessageEnd is a sendEvent.

pre: message->notEmpty()

body: message.sendEvent->asSet()->includes(self)

isReceive() : Boolean
This query returns value true if this MessageEnd is a receiveEvent.

pre: message->notEmpty()

body: message.receiveEvent->asSet()->includes(self)

enclosingFragment() : InteractionFragment [0..*]
This query returns a set including the enclosing InteractionFragment this MessageEnd is enclosed within.

body: if self->select(oclIsKindOf(Gate))->notEmpty()
then -- it is a Gate
let endGate : Gate =
  self->select(oclIsKindOf(Gate)).oclAsType(Gate)->asOrderedSet()->first()
  in
  if endGate.isOutsideCF()
  then endGate.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)-
>asSet()->
     union(endGate.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)-
>asSet())
  else if endGate.isInsideCF()
    then endGate.combinedFragment.oclAsType(InteractionFragment)->asSet()
    else if endGate.isFormal()
      then endGate.interaction.oclAsType(InteractionFragment)->asSet()
      else if endGate.isActual()
        then endGate.interactionUse.enclosingInteraction.oclAsType(InteractionFragment)-
>asSet()->
     union(endGate.interactionUse.enclosingOperand.oclAsType(InteractionFragment)->asSet())
        else null
        endif
      endif
    endif
  endif
else -- it is a MessageOccurrenceSpecification
let endMOS : MessageOccurrenceSpecification  =
  self-
>select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecificatio
n)->asOrderedSet()->first()
  in
  if endMOS.enclosingInteraction->notEmpty()
  then endMOS.enclosingInteraction.oclAsType(InteractionFragment)->asSet()
  else endMOS.enclosingOperand.oclAsType(InteractionFragment)->asSet()
  endif
endif

17.12.20 MessageKind [Enumeration]

17.12.20.1

Description

This is an enumerated type that identifies the type of Message.

Unified Modeling Language 2.5

625

17.12.20.2

Diagrams

• Messages

 

 

17.12.20.3

Literals

•

•

•

•

complete
sendEvent and receiveEvent are present

lost
sendEvent present and receiveEvent absent

found
sendEvent absent and receiveEvent present

unknown
sendEvent and receiveEvent absent (should not appear)

17.12.21 MessageOccurrenceSpecification [Class]

17.12.21.1

Description

A MessageOccurrenceSpecification specifies the occurrence of Message events, such as sending and receiving of 
Signals or invoking or receiving of Operation calls. A MessageOccurrenceSpecification is a kind of MessageEnd. 
Messages are generated either by synchronous Operation calls or asynchronous Signal sends. They are received by the 
execution of corresponding AcceptEventActions.

17.12.21.2

Diagrams

Messages

17.12.21.3

Generalizations

MessageEnd, OccurrenceSpecification

17.12.21.4

Specializations

DestructionOccurrenceSpecification

17.12.22 MessageSort [Enumeration]

17.12.22.1

Description

This is an enumerated type that identifies the type of communication action that was used to generate the Message.

17.12.22.2

Diagrams

• Messages

 

 

17.12.22.3

Literals

•

synchCall
The message was generated by a synchronous call to an operation.

626

Unified Modeling Language 2.5

•

•

•

•

•

asynchCall
The message was generated by an asynchronous call to an operation; i.e., a CallAction with isSynchronous = 
false.

asynchSignal
The message was generated by an asynchronous send action.

createMessage
The message designating the creation of another lifeline object.

deleteMessage
The message designating the termination of another lifeline.

reply
The message is a reply message to an operation call.

17.12.23 OccurrenceSpecification [Class]

17.12.23.1

Description

An OccurrenceSpecification is the basic semantic unit of Interactions. The sequences of occurrences specified by them 
are the meanings of Interactions.

17.12.23.2

Diagrams

Interactions, Messages, Lifelines, Occurrences

17.12.23.3

Generalizations

InteractionFragment

17.12.23.4

Specializations

ExecutionOccurrenceSpecification, MessageOccurrenceSpecification

17.12.23.5

Association Ends

•

•

•

covered : Lifeline [1..1]{redefines InteractionFragment::covered} (opposite A_covered_events::events)
References the Lifeline on which the OccurrenceSpecification appears.

toAfter : GeneralOrdering [0..*] (opposite GeneralOrdering::before)
References the GeneralOrderings that specify EventOcurrences that must occur after this 
OccurrenceSpecification.

toBefore : GeneralOrdering [0..*] (opposite GeneralOrdering::after)
References the GeneralOrderings that specify EventOcurrences that must occur before this 
OccurrenceSpecification.

17.12.24 PartDecomposition [Class]

17.12.24.1

Description

A PartDecomposition is a description of the internal Interactions of one Lifeline relative to an Interaction.

Unified Modeling Language 2.5

627

17.12.24.2

Diagrams

Lifelines, Interaction Uses

17.12.24.3

Generalizations

InteractionUse

17.12.24.4

Constraints

•

•

•

commutativity_of_decomposition
Assume that within Interaction X, Lifeline L is of class C and decomposed to D. Assume also that there is 
within X an InteractionUse (say) U that covers L. According to the constraint above U will have a counterpart 
CU within D. Within the Interaction referenced by U, L should also be decomposed, and the decomposition 
should reference CU. (This rule is called commutativity of decomposition.)

Cannot be expressed in OCL

assume
Assume that within Interaction X, Lifeline L is of class C and decomposed to D. Within X there is a sequence 
of constructs along L (such constructs are CombinedFragments, InteractionUse and (plain) 
OccurrenceSpecifications). Then a corresponding sequence of constructs must appear within D, matched one-
to-one in the same order. i) CombinedFragment covering L are matched with an extra-global 
CombinedFragment in D. ii) An InteractionUse covering L is matched with a global (i.e., covering all 
Lifelines) InteractionUse in D. iii) A plain OccurrenceSpecification on L is considered an actualGate that must 
be matched by a formalGate of D.

Cannot be expressed in OCL

parts_of_internal_structures
PartDecompositions apply only to Parts that are Parts of Internal Structures not to Parts of Collaborations.

Cannot be expressed in OCL

17.12.25 StateInvariant [Class]

17.12.25.1

Description

A StateInvariant is a runtime constraint on the participants of the Interaction. It may be used to specify a variety of 
different kinds of Constraints, such as values of Attributes or Variables, internal or external States, and so on. A 
StateInvariant is an InteractionFragment and it is placed on a Lifeline.

17.12.25.2

Diagrams

Interactions, Lifelines

17.12.25.3

Generalizations

InteractionFragment

17.12.25.4

Association Ends

covered : Lifeline [1..1]{redefines InteractionFragment::covered} (opposite 
A_covered_stateInvariant::stateInvariant)
References the Lifeline on which the StateInvariant appears.

•

628

Unified Modeling Language 2.5

•

♦ invariant : Constraint [1..1]{subsets Element::ownedElement} (opposite 
A_invariant_stateInvariant::stateInvariant)
A Constraint that should hold at runtime for this StateInvariant.

17.13 Association Descriptions
17.13.1

A_action_actionExecutionSpecification [Association]

17.13.1.1

Diagrams

Occurrences

17.13.1.2

Owned Ends

•

actionExecutionSpecification : ActionExecutionSpecification [0..*] (opposite 
ActionExecutionSpecification::action)

17.13.2

A_action_interaction [Association]

17.13.2.1

Diagrams

Interactions

17.13.2.2

Owned Ends

•

interaction : Interaction [0..1]{subsets Element::owner} (opposite Interaction::action)

17.13.3

A_actualGate_interactionUse [Association]

17.13.3.1

Diagrams

Interaction Uses

17.13.3.2

Owned Ends

•

interactionUse : InteractionUse [0..1]{subsets Element::owner} (opposite InteractionUse::actualGate)

17.13.4

A_argument_interactionUse [Association]

17.13.4.1

Diagrams

Interaction Uses

17.13.4.2

Owned Ends

•

interactionUse : InteractionUse [0..1]{subsets Element::owner} (opposite InteractionUse::argument)

17.13.5

A_argument_message [Association]

17.13.5.1

Diagrams

Messages

Unified Modeling Language 2.5

629

17.13.5.2

Owned Ends

• message : Message [0..1]{subsets Element::owner} (opposite Message::argument)

17.13.6

A_before_toAfter [Association]

17.13.6.1

Diagrams

Occurrences

17.13.6.2

Member Ends
• GeneralOrdering::before
• OccurrenceSpecification::toAfter

 

 

 

 

17.13.7

A_behavior_behaviorExecutionSpecification [Association]

17.13.7.1

Diagrams

Occurrences

17.13.7.2

Owned Ends

•

behaviorExecutionSpecification : BehaviorExecutionSpecification [0..*] (opposite 
BehaviorExecutionSpecification::behavior)

17.13.8

A_cfragmentGate_combinedFragment [Association]

17.13.8.1

Diagrams

Fragments

17.13.8.2

Owned Ends

•

combinedFragment : CombinedFragment [0..1]{subsets Element::owner} (opposite 
CombinedFragment::cfragmentGate)

17.13.9

A_connector_message [Association]

17.13.9.1

Diagrams

Messages

17.13.9.2

Owned Ends

• message : Message [0..*] (opposite Message::connector)

17.13.10 A_covered_coveredBy [Association]

17.13.10.1

Diagrams

Lifelines

630

Unified Modeling Language 2.5

17.13.10.2

Member Ends

•

•

InteractionFragment::covered
 

 

Lifeline::coveredBy
 

 

17.13.11 A_covered_events [Association]

17.13.11.1

Diagrams

Lifelines

17.13.11.2

Owned Ends

•

events : OccurrenceSpecification [0..*]{ordered, subsets Lifeline::coveredBy} (opposite 
OccurrenceSpecification::covered)

17.13.12 A_covered_stateInvariant [Association]

17.13.12.1

Diagrams

Lifelines

17.13.12.2

Owned Ends

•

stateInvariant : StateInvariant [0..*]{subsets Lifeline::coveredBy} (opposite StateInvariant::covered)

17.13.13 A_decomposedAs_lifeline [Association]

17.13.13.1

Diagrams

Lifelines, Interaction Uses

17.13.13.2

Owned Ends

•

lifeline : Lifeline [1..1] (opposite Lifeline::decomposedAs)

17.13.14 A_execution_executionOccurrenceSpecification [Association]

17.13.14.1

Diagrams

Occurrences

17.13.14.2

Owned Ends

•

executionOccurrenceSpecification : ExecutionOccurrenceSpecification [0..2] (opposite 
ExecutionOccurrenceSpecification::execution)

17.13.15 A_finish_executionSpecification [Association]

17.13.15.1

Diagrams

Occurrences

Unified Modeling Language 2.5

631

17.13.15.2

Owned Ends

•

executionSpecification : ExecutionSpecification [0..*] (opposite ExecutionSpecification::finish)

17.13.16 A_formalGate_interaction [Association]

17.13.16.1

Diagrams

Interactions

17.13.16.2

Owned Ends

•

interaction : Interaction [0..1]{subsets NamedElement::namespace} (opposite Interaction::formalGate)

17.13.17 A_fragment_enclosingInteraction [Association]

17.13.17.1

Diagrams

Interactions

17.13.17.2

Member Ends

•

•

Interaction::fragment
 

 

InteractionFragment::enclosingInteraction
 

 

17.13.18 A_fragment_enclosingOperand [Association]

17.13.18.1

Diagrams

Fragments

17.13.18.2

Member Ends

•

•

InteractionOperand::fragment
 

 

InteractionFragment::enclosingOperand
 

 

17.13.19 A_generalOrdering_interactionFragment [Association]

17.13.19.1

Diagrams

Occurrences

17.13.19.2

Owned Ends

•

interactionFragment : InteractionFragment [0..1]{subsets Element::owner} (opposite 
InteractionFragment::generalOrdering)

632

Unified Modeling Language 2.5

17.13.20 A_guard_interactionOperand [Association]

17.13.20.1

Diagrams

Fragments

17.13.20.2

Owned Ends

•

interactionOperand : InteractionOperand [1..1]{subsets Element::owner} (opposite InteractionOperand::guard)

17.13.21 A_invariant_stateInvariant [Association]

17.13.21.1

Diagrams

Interactions

17.13.21.2

Owned Ends

•

stateInvariant : StateInvariant [0..1]{subsets Element::owner} (opposite StateInvariant::invariant)

17.13.22 A_lifeline_interaction [Association]

17.13.22.1

Diagrams

Lifelines

17.13.22.2

Member Ends

•

•

Interaction::lifeline
 

 

Lifeline::interaction
 

 

17.13.23 A_maxint_interactionConstraint [Association]

17.13.23.1

Diagrams

Fragments

17.13.23.2

Owned Ends

•

interactionConstraint : InteractionConstraint [0..1]{subsets Element::owner} (opposite 
InteractionConstraint::maxint)

17.13.24 A_message_considerIgnoreFragment [Association]

17.13.24.1

Diagrams

Fragments

17.13.24.2

Owned Ends

•

considerIgnoreFragment : ConsiderIgnoreFragment [0..*] (opposite ConsiderIgnoreFragment::message)

Unified Modeling Language 2.5

633

17.13.25 A_message_interaction [Association]

17.13.25.1

Diagrams

Messages

17.13.25.2

Member Ends

•

 

Interaction::message
 
 
• Message::interaction

 

17.13.26 A_message_messageEnd [Association]

17.13.26.1

Diagrams

Messages

17.13.26.2

Owned Ends

• messageEnd : MessageEnd [0..2] (opposite MessageEnd::message)

17.13.27 A_minint_interactionConstraint [Association]

17.13.27.1

Diagrams

Fragments

17.13.27.2

Owned Ends

•

interactionConstraint : InteractionConstraint [0..1]{subsets Element::owner} (opposite 
InteractionConstraint::minint)

17.13.28 A_operand_combinedFragment [Association]

17.13.28.1

Diagrams

Fragments

17.13.28.2

Owned Ends

•

combinedFragment : CombinedFragment [0..1]{subsets Element::owner} (opposite 
CombinedFragment::operand)

17.13.29 A_receiveEvent_endMessage [Association]

17.13.29.1

Diagrams

Messages

17.13.29.2

Owned Ends

•

634

endMessage : Message [0..1]{subsets MessageEnd::message} (opposite Message::receiveEvent)

Unified Modeling Language 2.5

17.13.30 A_refersTo_interactionUse [Association]

17.13.30.1

Diagrams

Interaction Uses

17.13.30.2

Owned Ends

•

interactionUse : InteractionUse [0..*] (opposite InteractionUse::refersTo)

17.13.31 A_represents_lifeline [Association]

17.13.31.1

Diagrams

Lifelines

17.13.31.2

Owned Ends

•

lifeline : Lifeline [0..*] (opposite Lifeline::represents)

17.13.32 A_returnValueRecipient_interactionUse [Association]

17.13.32.1

Diagrams

17.13.32.2

Owned Ends

•

interactionUse : InteractionUse [0..*] (opposite InteractionUse::returnValueRecipient)

17.13.33 A_returnValue_interactionUse [Association]

17.13.33.1

Diagrams

Interaction Uses

17.13.33.2

Owned Ends

•

interactionUse : InteractionUse [0..1]{subsets Element::owner} (opposite InteractionUse::returnValue)

17.13.34 A_selector_lifeline [Association]

17.13.34.1

Diagrams

Lifelines

17.13.34.2

Owned Ends

•

lifeline : Lifeline [0..1]{subsets Element::owner} (opposite Lifeline::selector)

17.13.35 A_sendEvent_endMessage [Association]

17.13.35.1

Diagrams

Messages

Unified Modeling Language 2.5

635

17.13.35.2

Owned Ends

•

endMessage : Message [0..1]{subsets MessageEnd::message} (opposite Message::sendEvent)

17.13.36 A_signature_message [Association]

17.13.36.1

Diagrams

Messages

17.13.36.2

Owned Ends

• message : Message [0..*] (opposite Message::signature)

17.13.37 A_start_executionSpecification [Association]

17.13.37.1

Diagrams

Occurrences

17.13.37.2

Owned Ends

•

executionSpecification : ExecutionSpecification [0..*] (opposite ExecutionSpecification::start)

17.13.38 A_toBefore_after [Association]

17.13.38.1

Diagrams

Occurrences

17.13.38.2

Member Ends

 

• OccurrenceSpecification::toBefore
• GeneralOrdering::after

 

 

 

636

Unified Modeling Language 2.5

18 UseCases
Use Cases
18.1
Summary
18.1.1
UseCases are a means to capture the requirements of systems, i.e., what systems are supposed to do. The key concepts 
specified in this clause are Actors, UseCases, and subjects. Each UseCase’s subject represents a system under 
consideration to which the UseCase applies. Users and any other systems that may interact with a subject are represented 
as Actors.
A UseCase is a specification of behavior. An instance of a UseCase refers to an occurrence of the emergent behavior 
that conforms to the corresponding UseCase. Such instances are often described by Interactions.

18.1.2

Abstract Syntax

BehavioredClassifier

Classifier

+ subject

*

{subsets namespace}

0..1 + classifier

RedefinableElement

Actor

ExtensionPoint

{ordered}
+ extensionLocation

1..*

{subsets ownedMember}
+ extensionPoint

1

*

+ useCase
{subsets namespace}

{subsets namespace, subsets source}
+ extension

{subsets directedRelationship, subsets
ownedMember}
+ extend

+ useCase

*

*

{subsets ownedMember}
+ ownedUseCase

UseCase

{subsets target}
1 + extendedCase

{subsets target}
+ addition

{subsets namespace, subsets source}

1

1 + includingCase

{subsets
directedRelationship}

* + extend

{subsets
directedRelationship}
+ include

*

*

{subsets directedRelationship,
subsets ownedMember}
+ include

1

*

+ extension

Extend

Include

*

{subsets owner}
+ extend

0..1

{subsets ownedElement}
+ condition

0..1

Constraint

DirectedRelationship

NamedElement

Figure 18.1  UseCases

18.1.3

18.1.3.1

Semantics

Use Cases and Actors

A UseCase may apply to any number of subjects. When a UseCase applies to a subject, it specifies a set of behaviors 
performed by that subject, which yields an observable result that is of value for Actors or other stakeholders of the 
subject.
A UseCase is a kind of BehavioredClassifier that represents a declaration of a set of offered Behaviors. Each UseCase 
specifies some behavior that a subject can perform in collaboration with one or more Actors. UseCases define the offered 
Behaviors of the subject without reference to its internal structure. These Behaviors, involving interactions between the 
Actors and the subject, may result in changes to the state of the subject and communications with its environment. A 
UseCase can include possible variations of its basic behavior, including exceptional behavior and error handling.

Unified Modeling Language 2.5

637

A subject of a UseCase could be a system or any other element that may have behavior, such as a Component or Class. 
Each UseCase specifies a unit of useful functionality that the subject provides to its users (i.e., a specific way of 
interacting with the subject). This functionality must always be completed for the UseCase to complete. It is deemed 
complete if, after its execution, the subject will be in a state in which no further inputs or actions are expected and the 
UseCase can be initiated again, or in an error state.
UseCases can be used both for specification of the (external) requirements on a subject and for the specification of the 
functionality offered by a subject. Moreover, the UseCases may also state the requirements the specified subject poses on 
its environment by defining how the Actors should interact with the subject so that it will be able to perform its services.
The behaviors of a UseCase can be described by a set of Behaviors (through its ownedBehavior relationship), such as 
Interactions, Activities, and StateMachines, as well as by pre-conditions, post-conditions and natural language text 
where appropriate. It may also be described indirectly through a Collaboration that uses the UseCase and its Actors as 
the Classifiers that type its parts. Which of these techniques to use depends on the nature of the UseCase behavior as 
well as on the intended reader. These descriptions can be combined. An example of a UseCase with an associated 
StateMachine is shown in Figure 18.12.
UseCases may have associated Actors, which describe how an instance of the Classifier realizing the UseCase and a 
user playing one of the roles of the Actor interact. Two UseCases specifying the same subject cannot be associated as 
each of them individually describes a complete usage of the subject.
When a UseCase has an association to an Actor with a multiplicity that is greater than one at the Actor end, it means 
that more than one Actor instance is involved in the UseCase. The manner in which multiple Actors participate in the 
UseCase depends on the specific situation on hand and is not defined in this specification. For instance, a particular 
UseCase might require simultaneous (concurrent) action by two separate Actors (e.g., in launching a nuclear missile) or 
it might require complementary and successive actions by the Actors (e.g., one Actor starting something and the other 
one stopping it).
A UseCase may be owned either by a Package or by a Classifier. Although the owning Classifier typically represents a 
subject to which the owned UseCases apply, this is not necessarily the case, as illustrated by the example in Figure 18.10
and Figure 18.11.
An Actor models a type of role played by an entity that interacts with the subjects of its associated UseCases (e.g., by 
exchanging signals and data). Actors may represent roles played by human users, external hardware, or other systems.
NOTE. An Actor does not necessarily represent a specific physical entity but instead a particular role of some entity 
that is relevant to the specification of its associated UseCases. Thus, a single physical instance may play the role of 
several different Actors and, conversely, a given Actor may be played by multiple different instances.
NOTE. The term “role” is used informally here and does not imply any technical definition of that term found 
elsewhere in this specification.
When an Actor has an association to a UseCase with a multiplicity that is greater than one at the UseCase end, it means 
that a given Actor can be involved in multiple UseCases of that type. The specific nature of this multiple involvement 
depends on the case on hand and is not defined in this specification. Thus, an Actor may initiate multiple UseCases in 
parallel (concurrently) or at different points in time.

18.1.3.2

Extends

An Extend is a relationship from an extending UseCase (the extension) to an extended UseCase (the extendedCase) that 
specifies how and when the behavior defined in the extending UseCase can be inserted into the behavior defined in the 
extended UseCase. The extension takes place at one or more specific extension points defined in the extended UseCase.
Extend is intended to be used when there is some additional behavior that should be added, possibly conditionally, to 
the behavior defined in one or more UseCases.
The extended UseCase is defined independently of the extending UseCase and is meaningful independently of the 
extending UseCase. On the other hand, the extending UseCase typically defines behavior that may not necessarily be 
meaningful by itself. Instead, the extending UseCase defines a set of modular behavior increments that augment an 
execution of the extended UseCase under specific conditions.

638

Unified Modeling Language 2.5

NOTE. The same extending UseCase can extend more than one UseCase. Furthermore, an extending UseCase may 
itself be extended.
Extend is a kind of DirectedRelationship, such that the source is the extending UseCase and the target is the extended 
UseCase. It is also a kind of NamedElement so that it can have a name in the context of its owning UseCase. The Extend 
relationship itself is owned by the extension.
An ExtensionPoint identifies a point in the behavior of a UseCase where that behavior can be extended by an Extend 
relationship. Each ExtensionPoint has a unique name within a UseCase.
The specific manner in which the location of an ExtensionPoint is defined is intentionally unspecified. This is because 
UseCases may be specified in various formats such as natural language, tables, trees, etc. The intuition behind the 
notion of extensionLocation is best explained through the example of a textually described UseCase: Usually, a UseCase 
with ExtensionPoints consists of a set of finer-grained behavioral fragment descriptions, which are most often executed 
in sequence. This segmented structuring of the UseCase text allows the original behavioral description to be extended 
by merging in supplementary behavioral fragment descriptions at the appropriate insertion points between the original 
fragments (extension points). Thus, an extending UseCase typically consists of one or more behavior fragment 
descriptions that are to be inserted into the appropriate spots of the extended UseCase. An extensionLocation, therefore, is 
a specification of all the various ExtensionPoints in a UseCase where supplementary behavioral increments can be 
merged.
If the condition of the Extend is missing or evaluates to true at the time the first ExtensionPoint is reached during the 
execution of the extended UseCase, then all of the appropriate behavior fragments of the extending UseCase will also 
be executed. If the condition is false, this does not happen. The individual fragments are executed as the corresponding 
ExtensionPoints of the extended UseCase are reached. Once a given fragment is completed, execution continues with 
the behavior of the extended UseCase following the ExtensionPoint. Note that even though there are multiple UseCases 
involved, there is just a single behavior execution.

18.1.3.3

Includes

Include is a DirectedRelationship between two UseCases, indicating that the behavior of the included UseCase (the 
addition) is inserted into the behavior of the including UseCase (the includingCase). It is also a kind of NamedElement so 
that it can have a name in the context of its owning UseCase (the includingCase). The including UseCase may depend on 
the changes produced by executing the included UseCase. The included UseCase must be available for the behavior of 
the including UseCase to be completely described.
The Include relationship is intended to be used when there are common parts of the behavior of two or more UseCases. 
This common part is then extracted to a separate UseCase, to be included by all the base UseCases having this part in 
common. As the primary use of the Include relationship is for reuse of common parts, what is left in a base UseCase is 
usually not complete in itself but dependent on the included parts to be meaningful. This is reflected in the direction of 
the relationship, indicating that the base UseCase depends on the addition but not vice versa.
All of the behavior of the included UseCase is executed at a single location in the included UseCase before execution of 
the including UseCase is resumed.
The Include relationship allows hierarchical composition of UseCases as well as reuse of UseCases.

Notation

18.1.4
A UseCase is shown as an ellipse, either containing the name of the UseCase or with the name of the UseCase placed 
below the ellipse. An optional stereotype keyword may be placed above the name.
A subject for a set of UseCases (sometimes called a system boundary) may be shown as a rectangle with its name in the 
top-left corner, with the UseCase ellipses visually located inside this rectangle. The same modeled UseCase may be 
visually depicted as separate ellipses within multiple subject rectangles. Where a subject is a Classifier with a standard 
stereotype, the keyword for the stereotype shall be shown in guillemets above the name of the subject. In cases where the 
metaclass of a subject is ambiguous, the keyword . corresponding to the notation for the metaclass of Classifier (see 
9.2.4) shall be shown in guillemets above the name. Where multiple keywords and/or stereotype names apply, the 

Unified Modeling Language 2.5

639

notational options defined by 9.2.4 shall apply. The subject notation is illustrated by the example in Figure 18.2 which 
shows a Component with the standard stereotype «Subsystem».

Note that this notation for the subject classifier differs from the normal Classifier notation – it has no header or 
compartments.
Note also that the subject rectangle does not imply that the subject classifier owns the contained UseCases, but merely 
that the UseCases apply to that classifier. In particular, there is scope for confusion between a UseCase appearing 
visually contained in a boundary rectangle representing a Classifier that is its subject, and appearing visually contained 
in a compartment of a Classifier that is its owner (see Figure 18.9).
Attributes and operations may be shown in compartments within the UseCase oval, with the same content as though 
they were in a normal Classifier rectangle.
ExtensionPoints may be listed in a compartment of the UseCase with the heading extension points. Each 
ExtensionPoint is denoted by a text string within the UseCase oval symbol according to the syntax below:
<extension point> ::= <name> [: <explanation>]
Note that explanation, which is optional, may be any informal text or a more precise definition of the location in the 
behavior of the UseCase where the extension point occurs, such as the name of a State in a StateMachine, an Activity in 
an activity diagram, a precondition, or a postcondition.
UseCases may have other Associations and Dependencies to other Classifiers (e.g., to denote input/output, events, and 
behaviors).
The detailed behaviors defined by a UseCase are notated according to the chosen description technique, in a separate 
diagram or textual document.
A UseCase may also be shown using the standard rectangle notation for Classifiers with an ellipse icon in the upper-
right-hand corner of the rectangle, as illustrated by the example in Figure 18.5. In this case, “extension points” is an 
optional compartment. This rendering is more suitable when there are a large number of extension points or features.
An Actor is represented by a “stick man” icon with the name of the Actor in the vicinity (usually above or below) the 
icon, as illustrated by the example in Figure 18.6.
An Actor may also be shown as a Classifier rectangle with the keyword «actor», with the usual notation for all 
compartments, as illustrated by the example in Figure 18.7.
Other icons that convey the kind of Actor may also be used to denote an Actor, such as using a separate icon for non-
human Actors, as illustrated by the example in Figure 18.8.
The nesting (owning) of a UseCase by a Classifier may optionally be represented by nesting the UseCase ellipse inside 
the Classifier rectangle in a separate compartment, as illustrated by the example in Figure 18.9. This is a case of the 
optional compartment for ownedMembers described in 9.2.4.
An Extend relationship between UseCases is shown by a dashed arrow with an open arrowhead pointing from the 
extending UseCase towards the extended UseCase. The arrow is labeled with the keyword «extend». The condition of 
the Extend as well as references to the ExtensionPoints are optionally shown in a note symbol (see 7.2.4) attached to the 
corresponding arrow, as illustrated by the example in Figure 18.3.
An Include relationship between UseCases is shown by a dashed arrow with an open arrowhead pointing from the base 
UseCase to the included UseCase. The arrow is labeled with the keyword «include», as illustrated by the example in
Figure 18.4.

640

Unified Modeling Language 2.5

18.1.5

Examples

Figure 18.2  Class diagram of a Package owning a set of UseCases, Actors, and a Subsystem

Figure 18.2 illustrates a class diagram corresponding to the Package ATMtopPkg which owns a set of UseCases, Actors, 
and a Subsystem that is the subject of the UseCases. In this example the subject is a Component with the Subsystem 
standard stereotype. The metaclass need not be shown because the Subsystem stereotype necessarily implies that the 
subject is a Component - see Clause 22.
The example shows that a Customer or Administrator may or may not participate in any of their associated UseCases 
(hence the 0..1 multiplicity). From the UseCase perspective, every UseCase in the example must have an Actor to 
initiate it (hence the 1 multiplicity). The Deposit and Register ATM UseCases require participation by the Bank, while 
the bank can participate with many Deposit and Register ATM UseCases at the same time.
In the UseCase diagram in Figure 18.3 below, the UseCase “Perform ATM Transaction” has an ExtensionPoint 
“Selection.” This UseCase is extended via that ExtensionPoint by the UseCase “On-Line Help” whenever execution of 
the “Perform ATM Transaction” UseCase occurrence is at the location referenced by the “Selection” extension point 
and the customer selects the HELP key.
NOTE. The “Perform ATM Transaction” UseCase is defined independently of the “On-Line Help” UseCase.

condition: {customer selected HELP} 
extension point: selection

extension points  

selection

«extend» 

Perform ATM Transaction
Figure 18.3  Example Extend

On-line Help

In Figure 18.4 below a UseCase “Withdraw” includes an independently defined UseCase “Card Identification.”

Unified Modeling Language 2.5

641

Figure 18.4  Example Include

Figure 18.5 shows a UseCase using the standard rectangle notation for Classifiers with an ellipse icon, and the optional 
“extension points” compartment.

Figure 18.5  UseCase using Classifier rectangle notation

Figure 18.6, Figure 18.7 and Figure 18.8 exemplify the three different notations for Actors.

Figure 18.6  Actor notation using stick-man

Figure 18.7  Actor notation using Class rectangle

Figure 18.8  Actor notation using icon

Figure 18.9 illustrates an ownedUseCase of a Class using an optional ownedMember compartment. The compartment 
name “owned use cases” is derived from the property name ownedUseCase according to the rules specified in 9.2.4.

642

Unified Modeling Language 2.5

Figure 18.9  Notation for UseCase owned by Classifier

UseCases need not be owned by their subject. For example, the UseCases shown in Figure 18.10 below (which are 
functionally the same as those shown in Figure 18.2) apply to the “ATMsystem” subsystem but are owned by various 
packages as shown in Figure 18.11.

Figure 18.10  Example ATM system with UseCases and Actors

Unified Modeling Language 2.5

643

TransactionUseCases

condition: {customer selected HELP} 
extension point: Selection

Card  

Identification

Perform ATM  
Transaction

«extend» 

On-line Help

ATM Services

Card  

Identification

«include» 

«import» 

Perform ATM  
Transaction

«include» 

Withdraw

Transfer

Deposit

Administration

Read Log

Register ATM

Figure 18.11  Example UseCases owned by Packages

Figure 18.12 shows a UseCase which has a StateMachine as one of its ownedBehaviors. The Classifier symbol for the 
StateMachine may be shown in the optional “owned behaviors” compartment, and the internal details of the 
StateMachine are shown in the state machine diagram on the right.

Figure 18.12  Example UseCase with associated StateMachine

644

Unified Modeling Language 2.5

18.2
18.2.1

Classifier Descriptions
Actor [Class]

18.2.1.1

Description

An Actor specifies a role played by a user or any other system that interacts with the subject.

18.2.1.2

Diagrams

Use Cases

18.2.1.3

Generalizations

BehavioredClassifier

18.2.1.4

Constraints

•

associations
An Actor can only have Associations to UseCases, Components, and Classes. Furthermore these Associations 
must be binary.

inv: Association.allInstances()->forAll( a |
  a.memberEnd->collect(type)->includes(self) implies
  (
    a.memberEnd->size() = 2 and
    let actorEnd : Property = a.memberEnd->any(type = self) in
      actorEnd.opposite.class.oclIsKindOf(UseCase) or
      ( actorEnd.opposite.class.oclIsKindOf(Class) and not
         actorEnd.opposite.class.oclIsKindOf(Behavior))
      )
  )

• must_have_name

An Actor must have a name.

inv: name->notEmpty()

18.2.2

18.2.2.1

Extend [Class]

Description

A relationship from an extending UseCase to an extended UseCase that specifies how and when the behavior defined in 
the extending UseCase can be inserted into the behavior defined in the extended UseCase.

18.2.2.2

Diagrams

Use Cases

18.2.2.3

Generalizations

NamedElement, DirectedRelationship

18.2.2.4

Association Ends

•

♦ condition : Constraint [0..1]{subsets Element::ownedElement} (opposite A_condition_extend::extend)
References the condition that must hold when the first ExtensionPoint is reached for the extension to take 
place. If no constraint is associated with the Extend relationship, the extension is unconditional.

Unified Modeling Language 2.5

645

•

•

•

extendedCase : UseCase [1..1]{subsets DirectedRelationship::target} (opposite 
A_extendedCase_extend::extend)
The UseCase that is being extended.

extension : UseCase [1..1]{subsets NamedElement::namespace, subsets DirectedRelationship::source} 
(opposite UseCase::extend)
The UseCase that represents the extension and owns the Extend relationship.

extensionLocation : ExtensionPoint [1..*]{ordered} (opposite A_extensionLocation_extension::extension)
An ordered list of ExtensionPoints belonging to the extended UseCase, specifying where the respective 
behavioral fragments of the extending UseCase are to be inserted. The first fragment in the extending UseCase 
is associated with the first extension point in the list, the second fragment with the second point, and so on. 
Note that, in most practical cases, the extending UseCase has just a single behavior fragment, so that the list of 
ExtensionPoints is trivial.

18.2.2.5

Constraints

•

extension_points
The ExtensionPoints referenced by the Extend relationship must belong to the UseCase that is being extended.

inv: extensionLocation->forAll (xp | extendedCase.extensionPoint->includes(xp))

18.2.3

18.2.3.1

ExtensionPoint [Class]

Description

An ExtensionPoint identifies a point in the behavior of a UseCase where that behavior can be extended by the behavior 
of some other (extending) UseCase, as specified by an Extend relationship.

18.2.3.2

Diagrams

Use Cases

18.2.3.3

Generalizations

RedefinableElement

18.2.3.4

Association Ends

•

useCase : UseCase [1..1]{subsets NamedElement::namespace} (opposite UseCase::extensionPoint)
The UseCase that owns this ExtensionPoint.

18.2.3.5

Constraints

• must_have_name

An ExtensionPoint must have a name.

inv: name->notEmpty ()

18.2.4

18.2.4.1

Include [Class]

Description

An Include relationship specifies that a UseCase contains the behavior defined in another UseCase.

646

Unified Modeling Language 2.5

18.2.4.2

Diagrams

Use Cases

18.2.4.3

Generalizations

DirectedRelationship, NamedElement

18.2.4.4

Association Ends

•

•

addition : UseCase [1..1]{subsets DirectedRelationship::target} (opposite A_addition_include::include)
The UseCase that is to be included.

includingCase : UseCase [1..1]{subsets NamedElement::namespace, subsets DirectedRelationship::source} 
(opposite UseCase::include)
The UseCase which includes the addition and owns the Include relationship.

18.2.5

18.2.5.1

UseCase [Class]

Description

A UseCase specifies a set of actions performed by its subjects, which yields an observable result that is of value for one 
or more Actors or other stakeholders of each subject.

18.2.5.2

Diagrams

Use Cases, Classifiers

18.2.5.3

Generalizations

BehavioredClassifier

18.2.5.4

Association Ends

•

•

•

•

♦ extend : Extend [0..*]{subsets A_source_directedRelationship::directedRelationship, subsets 
Namespace::ownedMember} (opposite Extend::extension)
The Extend relationships owned by this UseCase.

♦ extensionPoint : ExtensionPoint [0..*]{subsets Namespace::ownedMember} (opposite 
ExtensionPoint::useCase)
The ExtensionPoints owned by this UseCase.

♦ include : Include [0..*]{subsets A_source_directedRelationship::directedRelationship, subsets 
Namespace::ownedMember} (opposite Include::includingCase)
The Include relationships owned by this UseCase.

subject : Classifier [0..*] (opposite Classifier::useCase)
The subjects to which this UseCase applies. Each subject or its parts realize all the UseCases that apply to it.

18.2.5.5

Operations

•

allIncludedUseCases() : UseCase [0..*]
The query allIncludedUseCases() returns the transitive closure of all UseCases (directly or indirectly) included 
by this UseCase.

Unified Modeling Language 2.5

647

body: self.include.addition->union(self.include.addition->collect(uc | 
uc.allIncludedUseCases()))->asSet()

18.2.5.6

Constraints

•

•

•

binary_associations
UseCases can only be involved in binary Associations.

inv: Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies 
a.memberEnd->size() = 2)

no_association_to_use_case
UseCases cannot have Associations to UseCases specifying the same subject.

inv: Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies
   (
   let usecases: Set(UseCase) = a.memberEnd.type->select(oclIsKindOf(UseCase))-
>collect(oclAsType(UseCase))->asSet() in
   usecases->size() > 1 implies usecases->collect(subject)->size() > 1
   )
)

cannot_include_self
A UseCase cannot include UseCases that directly or indirectly include it.

inv: not allIncludedUseCases()->includes(self)

• must_have_name

A UseCase must have a name.

inv: name -> notEmpty ()

18.3
18.3.1

Association Descriptions
A_addition_include [Association]

18.3.1.1

Diagrams

Use Cases

18.3.1.2

Owned Ends

•

include : Include [0..*]{subsets A_target_directedRelationship::directedRelationship} (opposite 
Include::addition)

18.3.2

18.3.2.1

A_condition_extend [Association]

Diagrams

Use Cases

18.3.2.2

Owned Ends

extend : Extend [0..1]{subsets Element::owner} (opposite Extend::condition)

•

648

Unified Modeling Language 2.5

18.3.3

18.3.3.1

A_extend_extension [Association]

Diagrams

Use Cases

18.3.3.2

Member Ends

 

• UseCase::extend
•

Extend::extension
 
 

 

18.3.4

18.3.4.1

A_extendedCase_extend [Association]

Diagrams

Use Cases

18.3.4.2

Owned Ends

•

extend : Extend [0..*]{subsets A_target_directedRelationship::directedRelationship} (opposite 
Extend::extendedCase)

18.3.5

18.3.5.1

A_extensionLocation_extension [Association]

Diagrams

Use Cases

18.3.5.2

Owned Ends

•

extension : Extend [0..*] (opposite Extend::extensionLocation)

18.3.6

18.3.6.1

A_extensionPoint_useCase [Association]

Diagrams

Use Cases

18.3.6.2

Member Ends
• UseCase::extensionPoint
•

ExtensionPoint::useCase
 
 

 

 

18.3.7

18.3.7.1

A_include_includingCase [Association]

Diagrams

Use Cases

18.3.7.2

Member Ends

• UseCase::include

 

 

Unified Modeling Language 2.5

649

•

Include::includingCase
 

 

18.3.8

18.3.8.1

A_subject_useCase [Association]

Diagrams

Use Cases, Classifiers

18.3.8.2

Member Ends

 

• UseCase::subject
 
• Classifier::useCase

 

 

650

Unified Modeling Language 2.5

Summary

19 Deployments
19.1
The Deployments package specifies constructs that can be used to define the execution architecture of systems and the 
assignment of software artifacts to system elements. A streamlined model of deployment, sufficient for the majority of 
modern applications, is provided. Where more elaborate deployment models are required, the package can be extended 
through profiles or metamodels to represent specific hardware and/or software environments.

Deployments
Summary

19.2
19.2.1
Deployments capture relationships between logical and/or physical elements of systems and information technology 
assets assigned to them.

19.2.2

Abstract Syntax

NamedElement

Dependency

{readOnly}

+ /deployedElement

PackageableElement

*

+ deploymentTarget

*

DeploymentTarget

Node

Property

1
+ location
{subsets client,
subsets owner}

{subsets supplierDependency}
+ deploymentForArtifact

{subsets supplier}
+ deployedArtifact

*

*

{subsets ownedElement,
subsets clientDependency}

+ deployment
*

Deployment

{subsets owner}
+ deployment

0..1

{subsets
ownedElement}
+ configuration

DeploymentSpecification

*

+ deploymentLocation : String [0..1]
+ executionLocation : String [0..1]

InstanceSpecification

DeployedArtifact

Artifact

Figure 19.1  Deployments

NamedElement

Semantics

19.2.3
A Deployment captures the relationship between a particular conceptual or physical element of a modeled system and 
the information assets assigned to it. System elements are represented as DeployedTargets, and information assets, as 
DeployedArtifacts. DeploymentTargets and DeploymentArtifacts are abstract classes that cannot be directly 
instantiated. They are, however, elaborated as concrete classes as described in the Artifacts and Nodes sub clauses that 
follow.
Individual Deployment relationships can be tailored for specific uses by adding DeploymentSpecifications containing 
configurational and/or parametric information and may be extended in specific component profiles. For example, 
standard, non-normative stereotypes that a profile might add to DeploymentSpecification include «concurrencyMode»,
with tagged values {thread, process, none}, and «transactionMode», with tagged values {transaction, 
nestedTransaction, none}.
DeploymentSpecification information becomes execution-time input to components associated with DeploymentTargets 
via their deployedElements links. Using these links, DeploymentSpecifications can be targeted at specific container 
types, as long as the containers are kinds of Components. As shown in Figure 19.1, DeploymentSpecifications can be 
captured as elements of the Deployment relationships because they are Artifacts (described in the following sub clause). 
Furthermore, DeploymentSpecifications can only be associated with DeploymentTargets that are 
ExecutionEnvironments (described in the Nodes sub clause, below).

Unified Modeling Language 2.5

651

The Deployment relationship between a DeployedArtifact and a DeploymentTarget can be defined at the “type” level 
and at the “instance” level. At the “type” level, the Deployment connects kinds of DeploymentTargets to kinds of 
DeployedArtifacts. Whereas, at the “instance” level, the Deployment connects particular DeploymentTargets instances 
to particular DeployedArtifacts instances. For example, a ”type” level Deployment might connect an “application 
server” with an “order entry request handler.” In contrast, at the ”instance” level, three specific application services (say, 
“app-server1”, “app-server-2” and “app-server3”) may be the DeploymentTargets for six different “request handler” 
instances.
For modeling complex models consisting of composite structures, a Property, functioning as a part (i.e., owned by a 
composition), may be the target of a Deployment. Likewise, InstanceSpecifications can be DeploymentTargets in a 
Deployment relationship, if they represent a Node that functions as a part within an encompassing Node composition 
hierarchy, or if they represent an Artifact.

Notation

19.2.4
DeployedTargets are shown as a perspective view of cube labeled with the name of the DeployedTarget shown 
prepended by a colon. System elements deployed on a DeployedTarget, and Deployments that connect them, may be 
drawn inside the perspective cube. Alternately, deployed system elements can be shown as a textual list of element 
names.
Deployments are depicted using the same dashed line notation as Dependencies. When Deployment relationships are 
shown within a DeploymentTarget graphic, no labeling is required. Alternately, Deployment relationships can be 
decorated with the «deploy» keyword when not contained inside a DeployedTarget graphic. Deployment arrows are 
generally drawn from DeployedArtifacts to the DeployedTargets.
DeploymentSpecifications are graphically displayed as classifier rectangles and may be decorated with the «deployment 
spec» keyword. They may be attached to a component deployed on a container using a regular dependency arrow.

19.2.5

Examples

Figure 19.2  A visual representation of the deployment location of artifacts, including a dependency between 
them, inside a DeployedTarget graphic.

Figure 19.3  Alternative deployment representation of using a dependency called «deploy» used when 
DeployedArtifacts are visually outside their DeployedTarget graphics

652

Unified Modeling Language 2.5

Figure 19.4  Textual list based representation of DeployedArtifacts.

Figure 19.5  DeploymentSpecification for an artifact. On the left, a type-level specification, and on the right, an 
instance-level specification.

Figure 19.6  DeploymentSpecifications related to the DeployedArtifacts that they parameterize.

Unified Modeling Language 2.5

653

Figure 19.7  A DeploymentSpecification for a DeployedArtifact.

Artifacts
Summary

19.3
19.3.1
An Artifact represents some (usually reifiable) item of information that is used or produced by a software development 
process or by operation of a system. Examples of Artifacts include model files, source files, scripts, executable files, 
database tables, development deliverables, word-processing documents, and mail messages.

19.3.2

Abstract Syntax

*

Classifier

DeployedArtifact

Abstraction

+ nestedArtifact
{subsets ownedMember}

0..1

+ artifact

Artifact

+ fileName : String [0..1]

{subsets client,
subsets owner}
+ artifact

1

{subsets namespace,
subsets classifier}

{subsets namespace}

{subsets featuringClassifier,
subsets namespace, subsets
redefinitionContext}

+ artifact

0..1

0..1 + artifact

{ordered, subsets feature,
subsets redefinableElement,
subsets ownedMember}

+ ownedOperation

*

{ordered, subsets
attribute, subsets
ownedMember}
+ ownedAttribute

*

Operation

Property

Figure 19.8  Artifacts

{subsets ownedElement,
subsets clientDependency}

+ manifestation

Manifestation

*

{subsets supplierDependency}

* + manifestation

{subsets supplier}

1 + utilizedElement

PackageableElement

Semantics

19.3.3
Artifacts elaborate and reify the abstract notion of DeployedArtifact. They represent concrete elements in the physical 
world, may have Properties representing their features and Operations that can be performed their instances, and may be 
multiply-instantiated so that different instances may be deployed to various DeploymentTargets, each with separate 
property values.

654

Unified Modeling Language 2.5

More complex Artifacts can be created by organizing them into composition hierarchies. In this way, a 
DeploymentSpecification for a component may be contained within an Artifact, allowing a component and its 
parameters to be deployed as a single Artifact instance.
Artifacts may be extended to better represent the needs of specific information items. For example, profiles may extend 
Artifact to model sets of files. UML defines several standard stereotypes for Artifacts, including «source» and 
«executable», that may be further specialized as needed. For example, an EJB profile might define «jar» as a subclass of 
«executable» for executable Java archives.
An Artifact may embody, or manifest, a number of model elements. The Artifact owns the Manifestations, each 
representing the utilization of some PackageableElement. Profiles may extend the Manifestation relationship to indicate 
particular forms of embodiment. For example, «tool generated» and «custom code» might be two Manifestations for 
different Classes embodied in an Artifact.

Notation

19.3.4
An Artifact is presented using an ordinary Class rectangle with the keyword «artifact». Alternatively, it may be depicted 
by an icon (such as the document icon shown in Figure 19.9). Optionally, the underlining of the name of an artifact 
instance may be omitted, as the context is assumed to be known to users.
A Manifestation is notated in the same way as an Abstraction, that is, as a dashed line with an open arrow-head, labeled 
with the keyword «manifest».

19.3.5

Examples

Figure 19.9  An Artifact instance

Figure 19.10  A Manifestation relationship between an Artifact and a Component

Nodes
Summary

19.4
19.4.1
Nodes elaborate and reify the abstract notion of DeploymentTargets. They can be nested and can be connected into 
systems of arbitrary complexity using communication paths. Typically, Nodes represent either hardware devices or 
software execution environments.

Unified Modeling Language 2.5

655

19.4.2

Abstract Syntax

{subsets ownedMember}

+ nestedNode

*

0..1

+ node

{subsets namespace}

Class

DeploymentTarget

Node

Association

Device

ExecutionEnvironment

CommunicationPath

Figure 19.11  Nodes

Semantics

19.4.3
A Node is computational resource upon which Artifacts may be deployed, via Deployment relationships, for execution. 
For advanced modeling applications, Nodes may have complex internal structure defined by nesting and may be 
interconnected to represent specific situations. The internal structure of Nodes can only consist of other Nodes. Besides 
participating in Deployments, Nodes acquire a set of associated elements derived from the Manifestation relationships 
of the Artifacts deployed on them.
Nodes may be further sub-typed as Devices and ExecutionEnvironments. Devices represent physical machine 
components. ExecutionEnvironments represent standard software systems that application components may require at 
execution time. Specific profiles might, for example, define stereotypes for ExecutionEnvironments such as «OS», 
«workflow engine», «database system», and «J2EE container».
A Device is a physical computational resource with processing capability upon which Artifacts may be deployed for 
execution. Devices may be complex (i.e., they may consist of other devices) either through namespace ownership or 
through attributes that are themselves typed by Devices. Entire physical computing systems may be decomposed into 
their constituents in this way. Examples of Devices might include «application server», «client workstation», «mobile 
device», and «embedded device».
Typically, ExecutionEnvironments are assigned to some, often higher level, Device or general system Node via the 
composition relationship defined on Node. ExecutionEnvironments can be nested (for example, a database 
ExecutionEnvironment might be nested in an operating system ExecutionEnvironment). ExecutionEnvironment may 
have explicit interfaces for system level services that can be called by the deployed elements. In such cases, software 
ExecutionEnvironment services should be explicitly modeled. Application Components of the appropriate type are then 
deployed, with a Deployment relationship, to specific ExecutionEnvironment nodes or the Manifestations relationships 
of DeployedArtifacts. For each component Deployment, aspects of these services may be determined by properties in a 
DeploymentSpecification for a particular kind of ExecutionEnvironment.
Nodes can be connected to represent specific network topologies using CommunicationPaths defining specific 
connections between Node instances. A CommunicationPath is an Association between two DeploymentTargets, 
through which they may exchange Signals and Messages.

Notation

19.4.4
A Node is depicted using the same graphic representation as a DeployedTarget.
A Device is shown as a Node graphic with the keyword «device».
An ExecutionEnvironment is notated by a Node annotated with the keyword «executionEnvironment».

656

Unified Modeling Language 2.5

CommunicationPaths between Nodes are depicted using the same as normal Association links.
Dashed arrows with the keyword «deploy» show the capability of a Node to support an externally depicted 
DeployedArtifact. Alternatively, this may be shown by nesting DeployedArtifact graphics inside Node symbols.

19.4.5

Examples

Figure 19.12  Notation for a Device containing an ExecutionEnvironment and connected to another Device by a 
CommunicationPath link

Figure 19.13  Notation for a ExecutionEnvironment

Figure 19.14  An instance of a Node

Figure 19.15  CommunicationPath between AppServer with deployed Artifacts and a DBServer.

Figure 19.16  Deployed component Artifacts on a Node.

Unified Modeling Language 2.5

657

19.5
19.5.1

Classifier Descriptions
Artifact [Class]

19.5.1.1

Description

An artifact is the specification of a physical piece of information that is used or produced by a software development 
process, or by deployment and operation of a system. Examples of artifacts include model files, source files, scripts, and 
binary executable files, a table in a database system, a development deliverable, or a word-processing document, a mail 
message. An artifact is the source of a deployment to a node.

19.5.1.2

Diagrams

Deployments, Artifacts

19.5.1.3

Generalizations

Classifier, DeployedArtifact

19.5.1.4

Specializations

DeploymentSpecification

19.5.1.5

Attributes

•

fileName : String [0..1]
A concrete name that is used to refer to the Artifact in a physical context. Example: file system name, universal 
resource locator.

19.5.1.6

Association Ends

•

•

•

•

♦ manifestation : Manifestation [0..*]{subsets Element::ownedElement, subsets 
NamedElement::clientDependency} (opposite A_manifestation_artifact::artifact)
The set of model elements that are manifested in the Artifact. That is, these model elements are utilized in the 
construction (or generation) of the artifact.

♦ nestedArtifact : Artifact [0..*]{subsets Namespace::ownedMember} (opposite 
A_nestedArtifact_artifact::artifact)
The Artifacts that are defined (nested) within the Artifact. The association is a specialization of the 
ownedMember association from Namespace to NamedElement.

♦ ownedAttribute : Property [0..*]{ordered, subsets Classifier::attribute, subsets Namespace::ownedMember} 
(opposite A_ownedAttribute_artifact::artifact)
The attributes or association ends defined for the Artifact. The association is a specialization of the 
ownedMember association.

♦ ownedOperation : Operation [0..*]{ordered, subsets Classifier::feature, subsets 
A_redefinitionContext_redefinableElement::redefinableElement, subsets Namespace::ownedMember} 
(opposite A_ownedOperation_artifact::artifact)
The Operations defined for the Artifact. The association is a specialization of the ownedMember association.

658

Unified Modeling Language 2.5

19.5.2

19.5.2.1

CommunicationPath [Class]

Description

A communication path is an association between two deployment targets, through which they are able to exchange 
signals and messages.

19.5.2.2

Diagrams

Nodes

19.5.2.3

Generalizations

Association

19.5.2.4

Constraints

•

association_ends
The association ends of a CommunicationPath are typed by DeploymentTargets.

inv: endType->forAll (oclIsKindOf(DeploymentTarget))

19.5.3

19.5.3.1

DeployedArtifact [Abstract Class]

Description

A deployed artifact is an artifact or artifact instance that has been deployed to a deployment target.

19.5.3.2

Diagrams

Deployments, Artifacts, Instances

19.5.3.3

Generalizations

NamedElement

19.5.3.4

Specializations

Artifact, InstanceSpecification

19.5.4

19.5.4.1

Deployment [Class]

Description

A deployment is the allocation of an artifact or artifact instance to a deployment target. A component deployment is the 
deployment of one or more artifacts or artifact instances to a deployment target, optionally parameterized by a 
deployment specification. Examples are executables and configuration files.

19.5.4.2

Diagrams

Deployments

19.5.4.3

Generalizations

Dependency

Unified Modeling Language 2.5

659

19.5.4.4

Association Ends

•

•

•

♦ configuration : DeploymentSpecification [0..*]{subsets Element::ownedElement} (opposite 
DeploymentSpecification::deployment)
The specification of properties that parameterize the deployment and execution of one or more Artifacts.

deployedArtifact : DeployedArtifact [0..*]{subsets Dependency::supplier} (opposite 
A_deployedArtifact_deploymentForArtifact::deploymentForArtifact)
The Artifacts that are deployed onto a Node. This association specializes the supplier association.

location : DeploymentTarget [1..1]{subsets Dependency::client, subsets Element::owner} (opposite 
DeploymentTarget::deployment)
The DeployedTarget which is the target of a Deployment.

19.5.5

19.5.5.1

DeploymentSpecification [Class]

Description

A deployment specification specifies a set of properties that determine execution parameters of a component artifact that 
is deployed on a node. A deployment specification can be aimed at a specific type of container. An artifact that reifies or 
implements deployment specification properties is a deployment descriptor.

19.5.5.2

Diagrams

Deployments

19.5.5.3

Generalizations

Artifact

19.5.5.4

Attributes

•

•

deploymentLocation : String [0..1]
The location where an Artifact is deployed onto a Node. This is typically a 'directory' or 'memory address.'

executionLocation : String [0..1]
The location where a component Artifact executes. This may be a local or remote location.

19.5.5.5

Association Ends

•

deployment : Deployment [0..1]{subsets Element::owner} (opposite Deployment::configuration)
The deployment with which the DeploymentSpecification is associated.

19.5.5.6

Constraints

•

•

660

deployment_target
The DeploymentTarget of a DeploymentSpecification is a kind of ExecutionEnvironment.

inv: deployment->forAll (location.oclIsKindOf(ExecutionEnvironment))

deployed_elements
The deployedElements of a DeploymentTarget that are involved in a Deployment that has an associated 
Deployment-Specification is a kind of Component (i.e., the configured components).

Unified Modeling Language 2.5

inv: deployment->forAll (location.deployedElement->forAll (oclIsKindOf(Component)))

19.5.6

19.5.6.1

DeploymentTarget [Abstract Class]

Description

A deployment target is the location for a deployed artifact.

19.5.6.2

Diagrams

Deployments, Nodes, Properties, Instances

19.5.6.3

Generalizations

NamedElement

19.5.6.4

Specializations

Node, InstanceSpecification, Property

19.5.6.5

Association Ends

•

•

/deployedElement : PackageableElement [0..*]{} (opposite 
A_deployedElement_deploymentTarget::deploymentTarget)
The set of elements that are manifested in an Artifact that is involved in Deployment to a DeploymentTarget.

♦ deployment : Deployment [0..*]{subsets Element::ownedElement, subsets 
NamedElement::clientDependency} (opposite Deployment::location)
The set of Deployments for a DeploymentTarget.

19.5.6.6

Operations

•

deployedElement() : PackageableElement [0..*]
Derivation for DeploymentTarget::/deployedElement

body: deployment.deployedArtifact->select(oclIsKindOf(Artifact))-
>collect(oclAsType(Artifact).manifestation)->collect(utilizedElement)->asSet()

19.5.7

19.5.7.1

Device [Class]

Description

A device is a physical computational resource with processing capability upon which artifacts may be deployed for 
execution. Devices may be complex (i.e., they may consist of other devices).

19.5.7.2

Diagrams

Nodes

19.5.7.3

Generalizations

Node

Unified Modeling Language 2.5

661

19.5.8

19.5.8.1

ExecutionEnvironment [Class]

Description

An execution environment is a node that offers an execution environment for specific types of components that are 
deployed on it in the form of executable artifacts.

19.5.8.2

Diagrams

Nodes

19.5.8.3

Generalizations

Node

19.5.9

19.5.9.1

Manifestation [Class]

Description

A manifestation is the concrete physical rendering of one or more model elements by an artifact.

19.5.9.2

Diagrams

Artifacts

19.5.9.3

Generalizations

Abstraction

19.5.9.4

Association Ends

•

utilizedElement : PackageableElement [1..1]{subsets Dependency::supplier} (opposite 
A_utilizedElement_manifestation::manifestation)
The model element that is utilized in the manifestation in an Artifact.

19.5.10

Node [Class]

19.5.10.1

Description

A Node is computational resource upon which artifacts may be deployed for execution. Nodes can be interconnected 
through communication paths to define network structures.

19.5.10.2

Diagrams

Deployments, Nodes

19.5.10.3

Generalizations

Class, DeploymentTarget

19.5.10.4

Specializations

Device, ExecutionEnvironment

662

Unified Modeling Language 2.5

19.5.10.5

Association Ends

•

♦ nestedNode : Node [0..*]{subsets Namespace::ownedMember} (opposite A_nestedNode_node::node)
The Nodes that are defined (nested) within the Node.

19.5.10.6

Constraints

•

internal_structure
The internal structure of a Node (if defined) consists solely of parts of type Node.

inv: part->forAll(oclIsKindOf(Node))

19.6
19.6.1

Association Descriptions
A_configuration_deployment [Association]

19.6.1.1

Diagrams

Deployments

19.6.1.2

Member Ends

 

• Deployment::configuration
• DeploymentSpecification::deployment

 

 

 

19.6.2

19.6.2.1

A_deployedArtifact_deploymentForArtifact [Association]

Diagrams

Deployments

19.6.2.2

Owned Ends

•

deploymentForArtifact : Deployment [0..*]{subsets A_supplier_supplierDependency::supplierDependency} 
(opposite Deployment::deployedArtifact)

19.6.3

19.6.3.1

A_deployedElement_deploymentTarget [Association]

Diagrams

Deployments

19.6.3.2

Owned Ends

•

deploymentTarget : DeploymentTarget [0..*] (opposite DeploymentTarget::deployedElement)

19.6.4

19.6.4.1

A_deployment_location [Association]

Diagrams

Deployments

Unified Modeling Language 2.5

663

19.6.4.2

Member Ends

 

• DeploymentTarget::deployment
• Deployment::location
 

 

 

19.6.5

19.6.5.1

A_manifestation_artifact [Association]

Diagrams

Artifacts

19.6.5.2

Owned Ends

•

artifact : Artifact [1..1]{subsets Dependency::client, subsets Element::owner} (opposite 
Artifact::manifestation)

19.6.6

19.6.6.1

A_nestedArtifact_artifact [Association]

Diagrams

Artifacts

19.6.6.2

Owned Ends

•

artifact : Artifact [0..1]{subsets NamedElement::namespace} (opposite Artifact::nestedArtifact)

19.6.7

19.6.7.1

A_nestedNode_node [Association]

Diagrams

Nodes

19.6.7.2

Owned Ends

•

node : Node [0..1]{subsets NamedElement::namespace} (opposite Node::nestedNode)

19.6.8

19.6.8.1

A_ownedAttribute_artifact [Association]

Diagrams

Artifacts

19.6.8.2

Owned Ends

•

artifact : Artifact [0..1]{subsets NamedElement::namespace, subsets A_attribute_classifier::classifier} 
(opposite Artifact::ownedAttribute)

19.6.9

19.6.9.1

A_ownedOperation_artifact [Association]

Diagrams

Artifacts

664

Unified Modeling Language 2.5

19.6.9.2

Owned Ends

•

artifact : Artifact [0..1]{subsets Feature::featuringClassifier, subsets NamedElement::namespace, subsets 
RedefinableElement::redefinitionContext} (opposite Artifact::ownedOperation)

19.6.10

A_utilizedElement_manifestation [Association]

19.6.10.1

Diagrams

Artifacts

19.6.10.2

Owned Ends

• manifestation : Manifestation [0..*]{subsets A_supplier_supplierDependency::supplierDependency} (opposite 

Manifestation::utilizedElement)

Unified Modeling Language 2.5

665

InformationFlows
Information Flows
Summary

20
20.1
20.1.1
The InformationFlows package supports exchange of information between system entities at high levels of abstraction. 
InformationFlows may be useful during top-down model development, representing aspects of models not yet fully 
specified, and for recording less detailed, heuristic representations of more complex model areas. In these ways, 
InformationFlows can help to clarify and document overall understanding of the intent of large or complicated models.
InformationFlows describe circulation of information through a system in a general manner. They do not specify the 
nature of the information, mechanisms by which it is conveyed, sequences of exchange, or any control conditions. 
During more detailed modeling, representation and realization links may be added to specify which model elements 
implement an InformationFlow and to show how information is conveyed. Similarly, InformationItems can be used to 
represent the information that flows along InformationFlows even before details of their realization have been designed.
The contents of the InformationFlows package are shown in Figure 20.1.

20.1.2

Abstract Syntax

Classifier

+ conveyed

1..*

* + represented

* + representation

+ conveyingFlow

*

PackageableElement

DirectedRelationship

Relationship

* + realization

* + abstraction

InformationItem

InformationFlow

{subsets directedRelationship}
+ informationFlow

*

{subsets directedRelationship}

* + informationFlow

* + informationFlow

*

+ informationFlow

* + informationFlow

{subsets source}
+ informationSource

1..*

{subsets target}

1..* + informationTarget

* + realizingConnector

*

+ realizingActivityEdge

*

+ realizingMessage

NamedElement

Connector

ActivityEdge

Message

Figure 20.1  Information Flows

Semantics

20.1.3
InformationFlows require some kind of “information channel” for unidirectional transmission of information items from 
sources to targets. They specify the information channel’s realizations, if any, and identify the information that flows 
along them. Information moving along the information channel may be represented by abstract InformationItems and by 
concrete Classifiers.
The sources and targets of an InformationFlow designate sets of objects that can send (sources) or receive (targets) 
conveyed InformationItems or Classifiers. In Figure 20.1, sources and targets are shown as NamedElements. In practice, 
a constraint on InformationFlow requires that sources and targets must be one of the following types: Actor, Node, 
UseCase, Artifact, Class, Component, Port, Property, Interface, Package, ActivityNode, ActivityPartition, Behavior, and 
InstanceSpecification. Furthermore, when a source or target is an InstanceSpecification, it cannot be a link (i.e., the 
InstanceSpecification may not be classified by a Relationship).
An InformationFlow’s sources and targets represent all potential instances typed or contained (i.e., owned) by them. For 
example, if a source or target is a

Unified Modeling Language 2.5

667

•

•

•

Classifier, it represents all potential instances of the Classifier.

Part, it represents all instances that can play the role specified by the Part.

Package, it represents all potential instances of the directly or indirectly owned Classifiers in the Package.

The information channel can be realized in various ways depending on the nature of sources and targets. As shown in
Figure 20.1, information channels can be realized by Relationships, Connectors, ActivityEdges, and Messages. The 
types of sources and targets must be compatible with the types of information that flow along the information channel. 
For example, if the source and target are parts of some composite structure such as a Collaboration, the information 
channel is likely to be represented by a Connector between them. Or, if the source and target are objects (which are 
kinds of InstanceSpecifications), the information channel may be represented by a link that joins them. Multiple sources 
and targets are allowed, but they must have compatible types.
Typically, InformationFlows identify InformationItems flowing from sources to targets. However, concrete Classifiers, 
such as Class, may be conveyed as well.
InformationItems represent many kinds of information that can flow from sources to targets in very abstract ways. They 
represent the kinds of information that may move within a system, but do not elaborate details of the transferred 
information. Details of transferred information are the province of other Classifiers that may ultimately define 
InformationItems. Consequently, InformationItems cannot be instantiated and do not themselves have features, 
generalizations, or associations. In this respect, InformationItems are similar to Interfaces -- a constraint in the 
metamodel enforces the inability to instantiate them.
An important use of InformationItems is to represent information during early design stages, possibly before the 
detailed modeling decisions that will ultimately define them have been made. Another purpose of InformationItems is to 
abstract portions of complex models in less precise, but perhaps more general and communicable, ways.
InformationItems may be decomposed into more specific InformationItems or Classifiers. Representation links between 
them express the idea that, in the context a particular InformationFlow, specific information is exchanged.
InformationItems may only be realized by Classes (of all kinds, including Components, AssociationClasses, Behaviors, 
etc.), Interfaces, Signals, and other InformationItems.
The principal goal of InformationFlows is to convey that information moves from one area of a model to another. 
Consequently, the metamodel is intentionally very permissive about the realization of information channels and the 
types of information that can flow along them. InformationFlows can be simultaneously realized by multiple types of 
information channels, and InformationItems can represent many different varieties of Classifiers.

Notation

20.1.4
An InformationFlow is represented using the same notation as Dependency, with the keyword «flow» adorning its 
dashed line.
Representation of InformationItems is determined by the context in which they are displayed:

• When attached to the dashed «flow» lines of an InformationFlow, the InformationItem’s name is displayed 

close to the appropriate «flow» line.

• When displayed independently of their InformationFlows, InformationItems may be represented, because they 
are Classifiers, as names inside rectangles. The rectangle is adorned with the «information» keyword or with a 
solid, black-filled isosceles triangle; in this usage, the triangle has no directional significance. Because they 
have neither attributes nor operations, InformationItem rectangles are shown without visible subcompartments.

• When attached to a realization of an InformationFlow’s information channel, a black-filled isosceles triangle 
on the information channel indicates the direction of information flow. The InformationItem’s name is placed 

668

Unified Modeling Language 2.5

close to the triangle. When representing several InformationItems having the same direction, only one triangle 
is shown, with a nearby list of InformationItem names separated by commas.

• When an InformationItem represents other InformationItems or Classifiers, they are connected with dashed 

line arrows adorned with the keyword «representation».

Examples

20.1.5
Figure 20.2 shows information about products and wages (InformationItems) flowing from a Company to its Customers 
and Employees along two separate InformationFlows. The information channels realizing these flows are not depicted.

Figure 20.2  Example of InformationFlows conveying InformationItems

The wage InformationItem is represented independently of any InformationFlow in Figure 20.3. The two 
representations are equivalent. When used in this way, the black triangle merely identifies the box as an 
InformationItem; it has no directional flow meaning.

Figure 20.3  Information Item represented as a classifier

InformationItems can represent other InformationItems and concrete Classifiers. The travel document InformationItem 
represents both passports and plane tickets (themselves InformationItems), whereas the Wage InformationItem acts as a 
“stand-in” for both the concrete Classes Salary and Bonus (Figure 20.4).

Figure 20.4  Examples of «representation» notation

When InformationItems are displayed on an information channel realizing an InformationFlow, triangles indicate the 
directional flow of information. In Figure 20.5, InformationItems adorn a Connector between m1:myC1 and m2:myC2. 
InformationItem “a” moves from source m2:myC to target m1:myC1, whereas InformationItems “b” and “d” move 
from source m1:myC1 to target m2:myC. In the latter, only one triangle is used to indicate flow of the multiple, named 
InformationItems. At least two InformationFlows are required to describe this situation – one for “a” and one for “b” 
and “d”. Alternately, “b” and “d” might be described by separate InformationFlows, bringing the total to three.

Figure 20.5  InformationItems attached to Connectors

Unified Modeling Language 2.5

669

In Figure 20.6, the InformationItems product and wage are attached to Associations realizing the information channels 
of their respective InformationFlows. Here, again, the triangles indicate direction of information flow.

Figure 20.6  InformationItems attached to Associations

20.2
20.2.1

Classifier Descriptions
InformationFlow [Class]

20.2.1.1

Description

InformationFlows describe circulation of information through a system in a general manner. They do not specify the 
nature of the information, mechanisms by which it is conveyed, sequences of exchange or any control conditions. 
During more detailed modeling, representation and realization links may be added to specify which model elements 
implement an InformationFlow and to show how information is conveyed. InformationFlows require some kind of 
“information channel” for unidirectional transmission of information items from sources to targets.  They specify the 
information channel’s realizations, if any, and identify the information that flows along them.  Information moving 
along the information channel may be represented by abstract InformationItems and by concrete Classifiers.

20.2.1.2

Diagrams

Information Flows

20.2.1.3

Generalizations

DirectedRelationship, PackageableElement

20.2.1.4

Association Ends

•

•

•

•

•

670

conveyed : Classifier [1..*] (opposite A_conveyed_conveyingFlow::conveyingFlow)
Specifies the information items that may circulate on this information flow.

informationSource : NamedElement [1..*]{subsets DirectedRelationship::source} (opposite 
A_informationSource_informationFlow::informationFlow)
Defines from which source the conveyed InformationItems are initiated.

informationTarget : NamedElement [1..*]{subsets DirectedRelationship::target} (opposite 
A_informationTarget_informationFlow::informationFlow)
Defines to which target the conveyed InformationItems are directed.

realization : Relationship [0..*] (opposite A_realization_abstraction_flow::abstraction)
Determines which Relationship will realize the specified flow.

realizingActivityEdge : ActivityEdge [0..*] (opposite 
A_realizingActivityEdge_informationFlow::informationFlow)
Determines which ActivityEdges will realize the specified flow.

Unified Modeling Language 2.5

•

•

realizingConnector : Connector [0..*] (opposite A_realizingConnector_informationFlow::informationFlow)
Determines which Connectors will realize the specified flow.

realizingMessage : Message [0..*] (opposite A_realizingMessage_informationFlow::informationFlow)
Determines which Messages will realize the specified flow.

20.2.1.5

Constraints

• must_conform

The sources and targets of the information flow must conform to the sources and targets or conversely the 
targets and sources of the realization relationships.

Cannot be expressed in OCL

•

•

sources_and_targets_kind
The sources and targets of the information flow can only be one of the following kind: Actor, Node, UseCase, 
Artifact, Class, Component, Port, Property, Interface, Package, ActivityNode, ActivityPartition, Behavior and 
InstanceSpecification except when its classifier is a relationship (i.e. it represents a link).

inv: (self.informationSource->forAll( sis |
  oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact) 
or
  oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) 
or
  oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or 
oclIsKindOf(ActivityPartition) or
  (oclIsKindOf(InstanceSpecification) and not 
sis.oclAsType(InstanceSpecification).classifier->exists(oclIsKindOf(Relationship)))))

and

(self.informationTarget->forAll( sit |
  oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact) 
or
  oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) 
or
  oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or 
oclIsKindOf(ActivityPartition) or
(oclIsKindOf(InstanceSpecification) and not sit.oclAsType(InstanceSpecification).classifier-
>exists(oclIsKindOf(Relationship)))))

convey_classifiers
An information flow can only convey classifiers that are allowed to represent an information item.

inv: self.conveyed->forAll(oclIsKindOf(Class) or oclIsKindOf(Interface)
  or oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component))

20.2.2

20.2.2.1

InformationItem [Class]

Description

InformationItems represent many kinds of information that can flow from sources to targets in very abstract ways.  They 
represent the kinds of information that may move within a system, but do not elaborate details of the transferred 
information.  Details of transferred information are the province of other Classifiers that may ultimately define 
InformationItems.  Consequently, InformationItems cannot be instantiated and do not themselves have features, 
generalizations, or associations. An important use of InformationItems is to represent information during early design 
stages, possibly before the detailed modeling decisions that will ultimately define them have been made. Another 
purpose of InformationItems is to abstract portions of complex models in less precise, but perhaps more general and 
communicable, ways.

Unified Modeling Language 2.5

671

20.2.2.2

Diagrams

Information Flows

20.2.2.3

Generalizations

Classifier

20.2.2.4

Association Ends

•

represented : Classifier [0..*] (opposite A_represented_representation::representation)
Determines the classifiers that will specify the structure and nature of the information. An information item 
represents all its represented classifiers.

20.2.2.5

Constraints

•

•

•

sources_and_targets
The sources and targets of an information item (its related information flows) must designate subsets of the 
sources and targets of the representation information item, if any. The Classifiers that can realize an 
information item can only be of the following kind: Class, Interface, InformationItem, Signal, Component.

inv: (self.represented->select(oclIsKindOf(InformationItem))->forAll(p |
  p.conveyingFlow.source->forAll(q | self.conveyingFlow.source->includes(q)) and
    p.conveyingFlow.target->forAll(q | self.conveyingFlow.target->includes(q)))) and
      (self.represented->forAll(oclIsKindOf(Class) or oclIsKindOf(Interface) or
        oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component)))

has_no
An informationItem has no feature, no generalization, and no associations.

inv: self.generalization->isEmpty() and self.feature->isEmpty()

not_instantiable
It is not instantiable.

inv: isAbstract

20.3
20.3.1

Association Descriptions
A_conveyed_conveyingFlow [Association]

20.3.1.1

Diagrams

Information Flows

20.3.1.2

Owned Ends

•

conveyingFlow : InformationFlow [0..*] (opposite InformationFlow::conveyed)

20.3.2

20.3.2.1

A_informationSource_informationFlow [Association]

Diagrams

Information Flows

672

Unified Modeling Language 2.5

20.3.2.2

Owned Ends

•

informationFlow : InformationFlow [0..*]{subsets A_source_directedRelationship::directedRelationship} 
(opposite InformationFlow::informationSource)

20.3.3

20.3.3.1

A_informationTarget_informationFlow [Association]

Diagrams

Information Flows

20.3.3.2

Owned Ends

•

informationFlow : InformationFlow [0..*]{subsets A_target_directedRelationship::directedRelationship} 
(opposite InformationFlow::informationTarget)

20.3.4

20.3.4.1

A_realization_abstraction_flow [Association]

Diagrams

Information Flows

20.3.4.2

Owned Ends

•

abstraction : InformationFlow [0..*] (opposite InformationFlow::realization)

20.3.5

20.3.5.1

A_realizingActivityEdge_informationFlow [Association]

Diagrams

Information Flows

20.3.5.2

Owned Ends

•

informationFlow : InformationFlow [0..*] (opposite InformationFlow::realizingActivityEdge)

20.3.6

20.3.6.1

A_realizingConnector_informationFlow [Association]

Diagrams

Information Flows

20.3.6.2

Owned Ends

•

informationFlow : InformationFlow [0..*] (opposite InformationFlow::realizingConnector)

20.3.7

20.3.7.1

A_realizingMessage_informationFlow [Association]

Diagrams

Information Flows

Unified Modeling Language 2.5

673

20.3.7.2

Owned Ends

•

informationFlow : InformationFlow [0..*] (opposite InformationFlow::realizingMessage)

20.3.8

20.3.8.1

A_represented_representation [Association]

Diagrams

Information Flows

20.3.8.2

Owned Ends

•

representation : InformationItem [0..*] (opposite InformationItem::represented)

674

Unified Modeling Language 2.5

21 Primitive Types
21.1
The PrimitiveTypes package is an independent package that defines a set of reusable PrimitiveTypes that are commonly 
used in the definition of metamodels. The UML metamodel uses the PrimitiveTypes package.

Summary

«primitive»

Integer

«primitive»

Boolean

«primitive»

String

«primitive»

UnlimitedNatural

«primitive»

Real

Figure  21.1 Primitive Types

Semantics

21.2
Table 21.1  PrimitiveType domains

Integer

Boolean

String

An instance of Integer is a value in the (infinite) set of integers (…-2, -1, 0, 1, 2…).

An instance of Boolean is one of the predefined values true and false.

An instance of String defines a sequence of characters. Character sets may include non-Roman 
alphabets. The semantics of the string itself depends on its purpose; it can be a comment, 
computational language expression, OCL expression, etc.

UnlimitedNatural An instance of UnlimitedNatural is a value in the (infinite) set of natural numbers (0, 1, 2…) plus

unlimited. The value of unlimited is shown using an asterisk (‘*’). UnlimitedNatural values are 
typically used to denote the upper bound of a range, such as a multiplicity; unlimited is used 
whenever the range is specified to have no upper bound.

Real

An instance of Real is a value in the (infinite) set of real numbers. Typically an implementation 
will internally represent Real numbers using a floating point standard such as ISO/IEC/IEEE 
60559:2011 (whose content is identical to the predecessor IEEE 754 standard).

Notation

21.3
There is no notation for PrimitiveTypes. There is notation for literal values of PrimitiveTypes; this notation is covered in
sub clause 8.2.

21.4

Examples

Figure  21.2  An Integer used as a type for an attribute, with a default value

Unified Modeling Language 2.5

675

Figure 21.3  A Boolean used as a type for an attribute, with a default value

Figure 21.4  A String used as a type for an attribute, with a default value

Figure 21.5  An UnlimitedNatural used as an upper bound for a multiplicity

Figure 21.6  Two attributes with type Real

676

Unified Modeling Language 2.5

22 Standard Profile
22.1
The Standard Profile specifies a set of predefined standard stereotypes. A conforming tool shall support all of the 
stereotypes in the Standard Profile.

Summary

22.2 Model

UML::Classification::

Classifier

«stereotype»
Realization

UML::CommonStructure::

Abstraction

«stereotype»
Specification

UML::Deployments::

Artifact

«stereotype»

File

«stereotype»

Derive

«stereotype»

Refine

«stereotype»

Trace

UML::Packages::

Package

«stereotype»
Framework

«stereotype»
ModelLibrary

UML::StructuredClassifiers::

Component

«stereotype»
Document

«stereotype»
Executable

«stereotype»

Library

«stereotype»

Script

«stereotype»

Source

«stereotype»

Destroy

UML::Classification::
BehavioralFeature

UML::StructuredClassifiers::

Class

UML::CommonStructure::

Usage

UML::Packages::

Model

«stereotype»

Create

«stereotype»

Call

«stereotype»
Instantiate

«stereotype»
Responsibility

«stereotype»

Send

«stereotype»
Metamodel

«stereotype»
SystemModel

Figure 22.1  Model of StandardProfile

«stereotype»

Entity

«stereotype»
Implement

«stereotype»

Process

«stereotype»

Service

«stereotype»
Subsystem

«stereotype»

BuildComponent

«stereotype»
Auxiliary

«stereotype»

Focus

«stereotype»
Metaclass

«stereotype»

ImplementationClass

«stereotype»

Type

«stereotype»

Utility

Standard Stereotypes

22.3
The stereotypes belonging to the profile are described using a tabular form. The first column gives the name of the 
stereotype label corresponding to the stereotype. The actual name of the stereotype is the same as the stereotype label. 
The second column identifies the metaclass to which the stereotype applies and the last column provides a description 
of the meaning of the stereotype.

Unified Modeling Language 2.5

677

Table 22.1  Description of the Stereotypes in the UML StandardProfile

Name

Applies to

Description

«Auxiliary»

Class

A class that supports another more central or fundamental class, typically 
by implementing secondary logic or control flow. Auxiliary classes are 
typically used together with Focus classes, and are particularly useful for 
specifying the secondary business logic or control flow of components 
during design. See also: «Focus».

«BuildComponent»

Component

A collection of elements defined for the purpose of system level 
development activities, such as compilation and versioning.

«Call»

Usage

A usage dependency whose source is an operation and whose target is an 
operation. The relationship may also be subsumed to the class containing 
an operation, with the meaning that there exists an operation in the class 
to which the dependency applies. A call dependency specifies that the 
source operation or an operation in the source class invokes the target 
operation or an operation in the target class. A call dependency may 
connect a source operation to any target operation that is within scope 
including, but not limited to, operations of the enclosing classifier and 
operations of other visible classifiers.

Usage

A usage dependency denoting that the client classifier creates instances 
of the supplier classifier.

BehavioralFeatu
re

Specifies that the designated feature creates an instance of the classifier 
to which the feature is attached.

Abstraction

Specifies a derivation relationship among model elements that are 
usually, but not necessarily, of the same type. A derived dependency 
specifies that the client may be computed from the supplier. The mapping 
specifies the computation. The client may be implemented for design 
reasons, such as efficiency, even though it is logically redundant.

BehavioralFeatu
re

Specifies that the designated feature destroys an instance of the classifier 
to which the feature is attached.

Artifact

A human-readable file. Subclass of «File».

Component

A persistent information component representing a business concept.

«Create»

«Create»

«Derive»

«Destroy»

«Document»

«Entity»

«Executable»

«File»

«Focus»

Artifact

Artifact

Class

A program file that can be executed on a computer system. Subclass of 
«File».

A physical file in the context of the system developed.

A class that defines the core logic or control flow for one or more 
auxiliary classes that support it. Focus classes are typically used together 
with one or more Auxiliary classes, and are particularly useful for 
specifying the core business logic or control flow of components during 
design. See also: «Auxiliary».

A package that contains model elements that specify a reusable 
architecture for all or part of a system. Frameworks typically include 
classes, patterns, or templates. When frameworks are specialized for an 
application domain they are sometimes referred to as application 
frameworks.

«Framework»

Package

678

Unified Modeling Language 2.5

Name

Applies to

«Implement»

Component

«Implementation 
Class»

Class

«Instantiate»

Usage

«Library»

«Metaclass»

«Metamodel»

Artifact

Class

Model

«ModelLibrary»

Package

Description

A component definition that is not intended to have a specification itself. 
Rather, it is an implementation for a separate «Specification» to which it 
has a Dependency.

The implementation of a class in some programming language (e.g., C+
+, Smalltalk, Java) in which an instance may not have more than one 
class. This is in contrast to Class, for which an instance may have 
multiple classes at one time and may gain or lose classes over time, and 
an object may dynamically have multiple classes. An Implementation 
class is said to realize a Classifier if it provides all of the operations 
defined for the Classifier with the same behavior as specified for the 
Classifier's operations. An Implementation Class may realize a number of 
different Types. The physical attributes and associations of the 
Implementation class do not have to be the same as those of any 
Classifier it realizes and the Implementation Class may provide methods 
for its operations in terms of its physical attributes and associations. See 
also: «Type».

A usage dependency among classifiers indicating that operations on the 
client create instances of the supplier.

A static or dynamic library file. Subclass of «File».

A class whose instances are also classes.

A model that specifies the modeling concepts of some modeling language 
(e.g., a MOF model). See «Metaclass».

A package that contains model elements that are intended to be reused by 
other packages. It is analogous to a class library in some programming 
languages. The model library may not include instances of the 
metamodel extension metaclasses specified in Clause 12.3, such as 
Profiles and Stereotypes. However it may include ProfileApplications 
and Stereotype applications, and a model library is often used in 
conjunction with an applied Profile.

«Process»

Component

A transaction based component.

«Realization»

Classifier

«Refine»

Abstraction

A classifier that specifies a domain of objects and that also defines the 
physical implementation of those objects. For example, a Component 
stereotyped by «Realization» will only have realizing Classifiers that 
implement behavior specified by a separate «Specification» Component. 
See «Specification». This differs from «Implementation class» because 
an «Implementation class» is a realization of a Class that can have 
features such as attributes and methods that are useful to system 
designers.

Specifies a refinement relationship between model elements at different 
semantic levels, such as analysis and design. The mapping specifies the 
relationship between the two elements or sets of elements. The mapping 
may or may not be computable, and it may be unidirectional or 
bidirectional. Refinement can be used to model transformations from 
analysis to design and other such changes.

Unified Modeling Language 2.5

679

Name

Applies to

Description

«Responsibility»

Usage

«Script»

«Send»

«Service»

«Source»

Artifact

Usage

A contract or an obligation of an element in its relationship to other 
elements.

A script file that can be interpreted by a computer system. Subclass of 
«File».

A Usage whose client is an Operation and whose supplier is a Signal, 
specifying that the Operation sends the Signal.

Component

A stateless, functional component.

Artifact

A source file that can be compiled into an executable file. Subclass of 
«File».

«Specification»

Classifier

«Subsystem»

Component

«SystemModel»

Model

«Trace»

Abstraction

«Type»

Class

«Utility»

Class

A classifier that specifies a domain of objects without defining the 
physical implementation of those objects. For example, a Component 
stereotyped by «Specification» will only have provided and required 
interfaces, and is not intended to have any realizingClassifiers as part of 
its definition. This differs from «Type» because a «Type» can have 
features such as attributes and methods that are useful to analysts 
modeling systems. Also see: «Realization»

A unit of hierarchical decomposition for large systems. A subsystem is 
commonly instantiated indirectly. Definitions of subsystems vary widely 
among domains and methods, and it is expected that domain and method 
profiles will specialize this construct. A subsystem may be defined to 
have specification and realization elements. See also: «Specification» 
and «Realization».

A SystemModel is a stereotyped model that contains a collection of 
models of the same system. A SystemModel also contains all 
relationships and constraints between model elements contained in 
different models.

Specifies a trace relationship between model elements or sets of model 
elements that represent the same concept in different models. Traces are 
mainly used for tracking requirements and changes across models. As 
model changes can occur in both directions, the directionality of the 
dependency can often be ignored. The mapping specifies the relationship 
between the two, but it is rarely computable and is usually informal.

A class that specifies a domain of objects together with the operations 
applicable to the objects, without defining the physical implementation of 
those objects. However, it may have attributes and associations. 
Behavioral specifications for type operations may be expressed using, for 
example, activity diagrams. An object may have at most one 
implementation class, however it may conform to multiple different 
types. See also: «ImplementationClass».

A class that has no instances, but rather denotes a named collection of 
attributes and operations, all of which are static.

680

Unified Modeling Language 2.5

Annex A: Diagrams

(normative)

This annex describes the general properties of UML diagrams and how they relate to a UML (repository) model and to 
elements of this. It also introduces the different diagram types of UML.
A UML model consists of elements such as packages, classes, and associations. The corresponding UML diagrams are 
graphical representations of parts of the UML model. UML diagrams contain graphical elements (nodes connected by 
paths) that represent elements in the UML model. As an example, two associated classes defined in a package will, in a 
diagram for the package, be represented by two class symbols and an association path connecting these two class 
symbols.
Each diagram has a contents area. As an option, it may have a frame and a heading as shown in Figure A.1.

Figure A.1  UML Diagram

The frame is a rectangle. The frame is primarily used in cases where the diagrammed element has graphical border 
elements, like ports for classes and components (in connection with composite structures), and entry/exit points on 
statemachines. In cases where not needed, the frame may be omitted and implied by the border of the diagram area 
provided by a tool. In case the frame is omitted, the heading is also omitted.
The diagram contents area contains the graphical symbols; the primary graphical symbols define the type of the diagram 
(e.g., a class diagram is a diagram where the primary symbols in the contents area are class symbols).
The heading is a string contained in a name tag (rectangle with cutoff corner) in the upper leftmost corner of the 
rectangle, with the following syntax:

[<kind>]<name>[<parameters>]

The heading of a diagram represents the kind, name, and parameters of the namespace enclosing or the model element 
owning elements that are represented by symbols in the contents area. Most elements of a diagram contents area 
represent model elements that are defined in the namespace or are owned by another model element.
As an example, Figure A.2  is a class diagram of a package P: classes C1 and C2 are defined in the namespace of the 
package P.

Figure A.2  Class diagram of package P

Figure A.3 illustrates that a package symbol for package P (in some containing package CP) may show the same 
contents as the class diagram for the package. i) is a package diagram for package CP with graphical symbols 
representing the fact that the CP package contains a package P. ii) is a class diagram for this package P.

Unified Modeling Language 2.5

681

NOTE. The package symbol in i) does not have to contain the class symbols and the association symbol; for more 
realistic models, the package symbols will typically just have the package names, while the class diagrams for the 
packages will have class symbols for the classes defined in the packages.

i) Package symbol (as part of a larger package diagram)

ii) Class diagram for the same package

package CP

package P

P

C1

C2

C1

C2

Figure A.3  Two diagrams of packages

In Figure A.4 i) is a class diagram for the package Cars, with a class symbol representing the fact that the Cars package 
contains a class Car. ii) is a composite structure diagram for this class Car. The class symbol in i) does not have to 
contain the structure of the class in a compartment; for more realistic models, the class symbols will typically just have 
the class names, while the composite structure diagrams for the classes will have symbols for the composite structures.

Figure A.4  A class diagram and a composite structure diagram

UML diagrams may have the following kinds of frame names as part of the heading:

•
•
•
•
•
•
•
•

activity
class
component
deployment
interaction
package
state machine
use case

In addition to the long form names for diagram heading types, the following abbreviated forms can also be used:

•
•
•
•
•
•
•

act (for activity frames)
cmp (for component frames)
dep (for deployment frames)
sd (for interaction frames)
pkg (for package frames)
stm (for state machine frames)
uc (for use case frames)

682

Unified Modeling Language 2.5

As is shown in Figure A.5, there are two major kinds of diagram types: structure diagrams and behavior diagrams.

Figure A.5  The taxonomy of structure and behavior diagrams

Structure diagrams show the static structure of the objects in a system. That is, they depict those elements in a 
specification that are irrespective of time. The elements in a structure diagram represent the meaningful concepts of an 
application, and may include abstract, real-world and implementation concepts. For example, a structure diagram for an 
airline reservation system might include classifiers that represent seat assignment algorithms, tickets, and a credit 
authorization service. Structure diagrams do not show the details of dynamic behavior, which are illustrated by 
behavioral diagrams. However, they may show relationships to the behaviors of the classifiers exhibited in the structure 
diagrams.
Behavior diagrams show the dynamic behavior of the objects in a system, including their methods, collaborations, 
activities, and state histories. The dynamic behavior of a system can be described as a series of changes to the system 
over time. Behavior diagrams can be further classified into several other kinds as illustrated in Figure A.5.
NOTE. This taxonomy provides a logical organization for the various major kinds of diagrams. However, it does not 
preclude mixing different kinds of diagram types, as one might do when one combines structural and behavioral 
elements (e.g., showing a state machine nested inside an internal structure). Consequently, the boundaries between the 
various kinds of diagram types are not strictly enforced.
The constructs contained in each of the UML diagrams are described in the clauses indicated below.

Interaction Overview Diagram - Interactions

Class Diagram - Structured Classifiers
Communication Diagram - Interactions
Component Diagram - Structured Classifiers
Composite Structure Diagram - Structured Classifiers

• Activity Diagram - Activities
•
•
•
•
• Deployment diagram - Deployments
•
• Object Diagram - Classification
•
Package Diagram - Packages
•
Profile Diagram - Packages
•
State Machine Diagram - State Machines
•
Sequence Diagram - Interactions
•
Timing Diagram - Interactions
• Use Case Diagram - Use Cases

Unified Modeling Language 2.5

683

Annex B: UML Diagram Interchange

(normative)

Summary

B.1
This Annex enables interchange of the purely graphical aspects of UML models that modelers have control over, such 
as the position of shapes on a diagram and line routing points (UML DI). This information must be interchanged 
between tools to reproduce UML diagrams reliably. This annex does not address the graphical aspects of UML models 
that are determined solely by UML, rather than the modeler, such as most geometric shapes and line styles for the 
various kinds of model elements. This information is the same for all diagrams conforming to UML, and does not need 
to be interchanged. Tools can determine which part of UML specifies the uninterchanged graphical aspects by links 
provided between the interchanged diagram information and the interchanged instances of abstract syntax.
UML DI is based on Diagram Definition (DD, http://www.omg.org/spec/DD), specifically its Diagram Interchange (DI) 
and Diagram Common (DC) packages. As illustrated informally in Figure B.1, UML DI specializes classes and 
associations from DI, and references elements of the UML abstract syntax to specify diagram interchange for those 
elements. UML diagrams are interchanged by instantiating classes and associations in UML abstract syntax and in UML 
DI, then linking them together by reference. Figure B.1 shows an instance of UseCase from UML’s abstract syntax on 
the lower left and an instance of UMLDI’s UMLShape referencing it. The shape instance specifies the location of the 
graphic on the diagram and a label it contains. Note that there are no runtime instances due to UML DI, because 
diagrams are design time elements only. Stereotypes can be based on elements of UML DI and applied to instances of 
those elements. Conforming tools shall give stereotype applications MOF equivalent semantics and XMI serialization as 
specified in sub clause 12.3.3.

Figure B.1  UML Diagram Interchange Architecture

Receivers of interchange files containing instances of UML DI elements render the instances visually as specified by 
UML. In most cases, the rendering can be determined using only the location and size given by the UML DI instances, 
the referenced instances of the UML abstract syntax, and the UML specification of notation. In cases where UML gives 
multiple notations to choose from for the same abstract syntax, UML DI includes additional information to indicate 
which notation shall be used.

Unified Modeling Language 2.5

685

B.2 Generic
B.2.1 Summary
The Generic portion of UML DI captures graphical aspects that are common across multiple kinds of UML diagrams.

B.2.2 UML Diagrams and Diagram Elements

DI::DiagramElement

{redefines owningElement}
+ owningElement

UMLDiagramElement
isIcon : Boolean = false

0..1
+ ownedElement
{ordered, redefines
ownedElement}

*

{subsets diagramElement}
+ umlDiagramElement
*

*
+ modelElement
{redefines modelElement}

UML::CommonStructure::Element

UML::CommonStructure::PackageableElement

DI::Diagram

UMLDiagram

isFrame : Boolean = true
isIso : Boolean = true
isInheritedLighter : Boolean = false

*

+ heading

UMLLabel

+ headedDiagram

0..1

Figure B.2  UML Diagrams and Diagram Elements

The model in Figure B.2 specializes DI’s Diagram and DiagramElement into UMLDiagram and UMLDiagramElement, 
respectively, to make UMLDiagram concrete, add properties and associations, and redefine inherited properties.
UMLDiagramElement is the most general class for UML DI. It redefines modelElement from DI’s DiagramElement to 
restrict UMLDiagramElements to be notation for UML Elements, rather than other language elements. It also redefines 
ownedElement from DI’s DiagramElement to restrict UMLDiagramElements to own only UMLDiagramElements, and to 
be ordered (for specifying how diagram elements hide each other, see the DD specification). It introduces  isIcon for 
modelElements that have an option to be shown with geometric figures other than rectangles, such as Actors, or that have 
an option to be shown with lines other than solid with open arrow heads, such as Realization. A value of true for isIcon 
indicates the alternative notation shall be rendered. UMLShapes may use both notations at the same time, with the small 
alternative notation rendered inside the regular notation. This is interchanged as two UMLShapes with the same 
modelElement, one having a value of false for isIcon and the other true, with the first having the second as an 
ownedElement, and the first having much larger bounds than the second.
Some things to note about UMLDiagramElement:

•

•

The ownedElements of UMLDiagramElements may have bounds that do not intersect (are visually outside) the 
bounds of their owningElements.

The modelElements of ownedElements of UMLDiagramElements may have different owners than the 
modelElements of owningElements.

UMLDiagram is the most general class for UML diagrams, and is the root of the diagram taxonomy defined in this 
Annex (also see in Figure A.5 in Annex A). It is specialized from PackageableElement for ownership by Packages. 
UMLDiagram introduces isFrame to indicate whether diagram frames shall be shown (see Annex A). If isFrame has the 
value true, heading shall give a string to be shown in the pentagonal header of the frame (see sub clause B.2.4 about 
UMLLabel). The heading shall have the same modelElement as its headedDiagram, if any. The diagram kind in the heading 
shall be rendered in boldface. UMLDiagram also introduces isIso to indicate whether ISO notation rules shall be 
followed. It introduces isInheritedLighter to indicate whether inherited elements shall be shown in a lighter color.

686

Unified Modeling Language 2.5

B.2.3 UML Shapes and Edges

DI::Edge

UMLDiagramElement

+ source
{redefines source}

1

1

+ target
{redefines target}

DI::Shape

UMLDiagramElement

UMLShape

UMLEdge

+ sourceEdge
{redefines sourceEdge}

*
+ targetEdge
{redefines targetEdge}

*

Figure B.3  UML Shapes and Edges

The model in Figure B.3 specializes DI’s Shape and Edge into UMLShape and UMLEdge, respectively, to make them 
concrete and redefine inherited properties.
UMLShape is the most general class for UMLDiagramElements that are never rendered as lines. Some notes about 
UMLShapes are:

• UMLShapes that are not UMLLabels, and have no modelElements, and have as the only ownedElement a single 

UMLLabel (including specializations) with at least one modelElement, shall be rendered as note symbols. 
UMLEdges between such UMLShapes and other UMLDiagramElements shall be rendered with dashed lines.

• Arrows showing a Dependency with more than two ends are interchanged as UMLEdges that have the 
Dependency as a modelElement, and either a source or target that is a UMLShape with the Dependency as 
modelElement. If the bounds of the UMLShape give an area greater than zero, it shall be rendered as a dot, 
otherwise nothing is rendered for the UMLShape. All UMLLabels annotating the Dependency shall be owned 
by the UMLShape.

UMLEdge is the most general class for UMLDiagramElements that are always rendered as lines. It redefines  source and 
target from DI’s Edge to restrict UMLEdges to link UMLDiagramElements.

B.2.4 Labels

UMLShape

UMLLabel
text : String

UMLKeywordLabel

UMLNameLabel

UMLTypedElementLabel

UMLRedefinesLabel

{redefines umlDiagramElement}
+ umlDiagramElement

*

{redefines modelElement}
+ modeElement

1

UML::CommonStructure::NamedElement

{redefines umlDiagramElement}
+ umlDiagramElement

*

{redefines modelElement}
+ modelElement
1

UML::Classification::RedefinableElement

Figure B.4  Labels

The model in Figure B.4 specializes UMLShape into the most general class for shapes that shall be rendered only as 
character strings (UMLLabel), and specializes it into various kinds of labels used in multiple kinds of UMLDiagrams. 
Specializations of UMLLabel enable receivers of interchange files to determine which portions of the modelElements are 
intended to be shown, enabling them to update renderings when portions of the modelElements change. For example, 
receivers need to know when a UMLLabel is intended to show the name of its modelElement, to update the string 

Unified Modeling Language 2.5

687

rendered when the name of the modelElement changes. UMLNameLabel shall be used in this case to indicate the intent. 
Specializations of UMLLabel are introduced only when it is ambiguous or cumbersome to determine which portions of 
the modelElements are intended to be shown by parsing text as UML specifies. Many strings are interchanged with 
instances of UMLLabel that are not instances of its specializations.
All UMLLabels shall have at least one modelElement, except those which are classified only by UMLLabel and none of 
its specializations, which might have no modelElements (most UMLLabels are constrained to have exactly one 
modelElement). The modelElements shall be same as those of the UMLDiagramElement being labeled, if any, except 
where noted in this Annex, and shall be ownedElements of that UMLDiagramElement, including when the UMLLabel is 
positioned outside the UMLDiagramElement (not all UMLLabels are positioned near UMLDiagramElements having 
the same modelElements, for example UMLLabels in UMLCompartments showing Properties of Classifiers). This 
enables receivers of interchange files to determine where to position renderings of UMLLabels as positions change for 
renderings of the UMLDiagramElement being labeled, in particular when multiple UMLDiagramElements in the same 
UMLDiagram have the same modelElement as the UMLLabel. All UMLLabels shall have values of false for isIcon. 
UMLLabels shall always specify text to be rendered, which shall conform to UML specifications for labeling each kind 
of modelElement, including BNF, if any.
The specializations of UMLLabel are for showing information about the portions of their modelElements defined by the 
type of the modelElement Property. For example, UMLNameLabel’s modelElement is restricted to NamedElements, which 
have Properties for name and visibility, and these are the portions of the modelElement UMLNameLabel shows. If no 
specialization shows all the information needed, use UMLLabel directly. For example, a wide range of information 
about Properties is shown textually in UMLCompartments, including redefinition and default values. Text for these 
Properties shall be interchanged with UMLLabel directly (see sub clause B.3.3), even when it only includes name and 
visibility.
UMLNameLabels are for showing information about NamedElements, which always includes their name, or 
nameExpression, or ElementImport alias if the NamedElement is imported, and may also include package containment 
(qualified names) and visibility.
UMLKeywordLabels are for showing various kinds of information about modelElements using wording and punctuation 
specified by UML between guillemets (see Annex C). UMLKeywords shall have exactly one modelElement. The text 
shall include only the guillemets and keyword.
UMLTypedElementLabel is for showing name, type, and role information about exactly one Slot, InstanceSpecification, 
InstanceValue, or element with a type, such as TypedElement or Connector. Some other things to note about 
interchanging UMLTypedElementLabels are:

•

•

•

•

•

If modelElement is a Slot, the text may include the name of the definingFeature, the name of the type of the 
definingFeature, and the value of the modelElement.

If modelElement is an InstanceSpecification or an InstanceValue, the text may include the name of the 
InstanceSpecification or of the instance of the InstanceValue, and the names of the classifiers of the 
InstanceSpecification or of the instance of the InstanceValue.

If modelElement is an InstanceSpecification that has a specification, the text may include the specification.

If modelElement is an InstanceValue that is a value of a slot of an InstanceSpecification that has a 
StructuredClassifier as classifier, and the UMLTypedElementLabel is appearing in a shape with the 
InstanceValue as modelElement, in a UMLCompositeStructureDiagram that has the InstanceSpecification as a 
modelElement (see sub clause 11.2.4), the text may include the name of the Property that is the defining 
definingFeature of the Slot owning the InstanceValue that is a modelElement of the UMLTypedElementLabel.

If modelElement has a type, as in TypedElements or Connectors, the text may include the name of the 
modelElement, and the name of the type of the modelElement.

688

Unified Modeling Language 2.5

UMLRedefinesLabel is for showing information about exactly one RedefinableElement, which may include the name of 
the redefinedElement.

B.2.5 Compartmentable Shapes

UMLDiagramElement

*

+ elementInCompartment
{ordered, subsets ownedElement}

UMLShape

UMLCompartmentableShape

{subsets owningElement}
+ compartmentedShape

{ordered, subsets
ownedElement}
+ compartment

1

*

Figure B.5  UML Compartmentable Shapes

{subsets owningElement}
+ owningCompartment
0..1

UMLCompartment

The model in Figure B.5 specializes UMLDiagramElement and UMLShape into UMLCompartmentableShape and 
UMLCompartment, respectively, to make them concrete, add properties, and redefine inherited properties for shapes 
with segregated contents.
UMLCompartmetableShape is the most general class for UML elements that may have information shown in separated 
portions inside their shapes, usually arranged linearly and separated by solid lines (compartments). It subsets 
ownedElement from UMLDiagramElement to specify compartments that are to appear vertically ordered (first in order is 
shown at the top), where are captured with UMLCompartment. UMLCompartment subsets ownedElement from 
UMLDiagramElement to specify contents of compartments that are to appear vertically ordered (first in order is shown 
at the top). UMLCompartments have no modelElements.
Compartment titles shall be interchanged as UMLLabels with no modelElements, and as the first orderedElement of 
UMLCompartments.

B.2.6 Stereotype Applications

UMLLabel

UMLStereotypePropertyValueLabel

{redefines umlDiagramElement}
+ umlDiagramElement

1

*

+ modelElement
{redefines modelElement}

UML::Classification::Property

+ labelShowingStereotypeValue

1

*

+ stereotypedElement

UML::CommonStructure::Element

Figure B.6  Stereotype Application Labels

The model in Figure B.6 specializes UMLLabel into UMLStereotypePropertyValueLabel to introduce associations for 
showing Property values of Stereotypes applied to UML abstract syntax elements. See sub clauses B.3.2 through B.3.4 
about interchanging notation for Stereotype definitions.
UMLStereotypePropertyValueLabels have attributes of Stereotypes as modelElements, and give the Element to which the 
Stereotype is applied. UMLStereotypePropertyValueLabels shall be rendered as strings showing the values of applied 
Stereotypes, in the syntax specified by UML (see sub clause 12.3.4). UMLStereotypePropertyValueLabels are 
ownedElements of

• UMLShapes with no modelElements (rendered as note symbols, see sub clause B.2.3) that are the source or target

of UMLEdges with no modelElements, where the other end of the UMLEdges are UMLShapes with 
modelElements that are the stereotypedElements.

Unified Modeling Language 2.5

689

• UMLCompartments where all the UMLStereotypePropertyValueLabels have

o

o

as their stereotypedElement the modelElement of the owningElement of the UMLCompartment, and

as their modelElements Properties of the same Stereotype, which is applied to the modelElement of the 
owningElement of the UMLCompartment.

Some other things to note about interchanging Stereotype applications are:

•

Stereotypes applied to UML abstract syntax elements may be shown:

o

o

textually, interchanged with UMLLabels that have modeler-defined Stereotypes as modelElements, and 
that are ownedElements of UMLDiagramElements that have modelElements with the Stereotypes 
applied. These UMLLabels shall be rendered as strings giving the names of the Stereotype between 
guillemets. The UMLLabels may have multiple Stereotypes as modelElements, which shall be rendered 
as a comma-delimited list of Stereotype names between one set of guillemets.

graphically with modeler-defined icons. The icons are specified on Stereotypes, and are interchanged 
with UML abstract syntax, rather than UML DI. The rules for rendering the icon are specified in sub 
clause 12.3.4, and below in terms of UML DI.

• UMLShapes that

o

o

o

have a modelElement with exactly one Stereotype applied that have a value for icon, and

have a value of true for isIcon, and

are rendered with rectangles when they have a value of false for isIcon,

shall be rendered as the icon. Any icons rendered when no Stereotypes are applied are not rendered in this case.

• UMLShapes that

o

o

o

have a Stereotype as modelElement that has a value for icon, and

are ownedElements of UMLDiagramElements that have modelElements with the modelElement Stereotype 
applied, and

have a value of true for isIcon,

shall be rendered as the Stereotype icon. These UMLShapes shall be rendered either

o

Inside geometrical figures rendered for UMLShapes that are their owningElements, which shall have a 
value of false for isIcon. Or,

o Near lines rendered for UMLEdges that are their owningElements.

o To the left of strings rendered for UMLLabels that are their owningElements.

690

Unified Modeling Language 2.5

B.2.7 UML Styles

UML::CommonStructure::PackageableElement

DI::DiagramElement

UMLDiagramElement

Figure B.7  UML Styles

{redefines styledElement}
+ styledElement

DI::Style

0..1

0..1

{redefines styledElement}
+ styledElement

+ localStyle
{redefines localStyle}

0..1

*

+ sharedStyle
{redefines sharedStyle}

UMLStyle

fontName : String [0..1]
fontSize : Real [0..1]

The model in Figure B.7 specializes DI Style into the most general class for styles in UML (UMLStyle) to make it 
concrete, add properties, and redefine inherited style-related properties on UMLDiagramElement. UMLStyle introduces 
properties to specify the name and size of fonts used in rendering UMLDiagramElements. The fontSize is given in 
typographical points.

Structure
B.3
B.3.1 Summary
The Structure portion of UML DI captures graphical aspects of structure diagrams and their contents.

B.3.2 Structure Diagrams

UMLDiagram

UMLDiagramWithAssociations

isAssociationDotShown : Boolean = false
navigabilityNotation : UMLNavigabilityNotationKind = oneWay
nonNavigabilityNotation : UMLNavigabilityNotationKind = never

UMLStructureDiagram

«enumeration»

UMLNavigabilityNotationKind
always
oneWay
never

UMLClassDiagram

UMLPackageDiagram

UMLComponentDiagram

UMLProfileDiagram

UMLCompositeStructureDiagram

UMLObjectDiagram

UMLDeploymentDiagram

Figure B.8  Structure Diagrams

The model in Figure B.8 indirectly specializes UMLDiagram into the most general class for diagrams depicting 
structural elements (UMLStructureDiagram), and specializes it into various kinds of structure diagrams (see Annex A). 
All UMLStructureDiagrams have no modelElements, except for UMLCompositeStructureDiagrams, which have exactly 
one, and all have graphical options for associations (UMLDiagramWithAssociations), as explained below.
Some notes about the contents of UMLDiagramWithAssociations are:

•

These diagrams may use the dot notation for associations, or not, as indicated by isAssociationDotShown. They 
may show navigability (by an open arrowhead) or nonnavigability (by an X) either always, only for 
unidirectional associations (oneWay), or never, as indicated by navigabilityNotation and nonnavigabilityNotation, 
respectively.

Unified Modeling Language 2.5

691

• Navigability notation as determined by navigabilityNotation and nonnavigabilityNotation applies to UMLEdges that 
have as modelElements Associations, InstanceSpecifications that have an Association as classifier, Properties, or 
Slots.

• Generalization arrows between association lines are interchanged as UMLEdges with Generalizations as 

modelElements, and sources and targets that are UMLEdges with Associations (including AssociationClasses 
shown as lines) as modelElements.

• Dashed lines showing GeneralizationSets are interchanged as UMLShapes with GeneralizationSets as 

modelElements. UMLLabels associated with GeneralizationSets (UMLNameLabels with GeneralizationSets as 
modelElements, UMLLabels with powerTypes as modelElements, and UMLLabels showing GeneralizationSet 
constraints) appearing in diagrams not showing a UMLShape for their GeneralizationSet are owned by a 
UMLEdge that has as modelElement one of the Generalizations in the GeneralizationSet. Otherwise they are 
owned by a UMLShape that has their GeneralizationSet as modelElement.

•

The notation for qualified Association memberEnds is interchanged as UMLShapes with the memberEnd as 
modelElement, owned by the UMLEdges that have the Association as modelElement, and owning UMLLabels 
with qualifiers (UMLProperties) as modelElements.

• UMLEdges between UMLShapes that have InstanceSpecifications as modelElements and that are intended to 

show links have InstanceSpecifications as modelElements that have an Association classifying the link as 
classifier. UMLLabels showing the names of the Association memberEnds have Slots as modelElements.

Some notes about the contents of UMLStructureDiagrams are:

•

Properties or Slots shown with lines are interchanged with UML Edges with Properties or Slots as 
modelElements, respectively.

• UMLShapes with Packages as modelElements that do not have UMLShapes rendered inside them show the name

of the Package in the large rectangle, rather than the tab. Otherwise the name of the Package is shown in the 
tab. The same applies to keywords and icon adornments.

• UMLEdges with no modelElements between UMLShapes that have a Namespace and a NamedElement as 

modelElement are shown with cross hairs in a circle on the Namespace end.

• UMLClassifierShapes with Interfaces as modelElements, and rendered with ball or socket notations (see notes 

on UMLClassDiagrams and UMLCompositeStructureDiagrams above), may be the source or target of 
UMLEdges that have Dependencies as modelElements between:

o

o

Ports requiring or providing the Interfaces.

InterfaceRealization or Usage Dependencies with the Interfaces as suppliers.

•

Ball and socket notations for required and provided Interfaces are interchanged as UMLClassifierShapes with a 
value of true for isIcon. The lines between these notations and port rectangles are interchanged as UMLEdges 
with InterfaceRealization or Usage Dependencies as modelElements with the Interfaces as suppliers, which 
determine whether the UMLClassifierShapes shall be rendered as balls or sockets (used Interfaces are  required 
and realized Interfaces are provided).

UMLCompositeStructureDiagrams have modelElements that are StructuredClassifiers or InstanceSpecifications with a 
classifier that is a StructuredClassifier (see UMLTypedElementLabel in sub clause B.2.4, next to last bullet).
Some notes about the contents of UMLCompositeStructureDiagrams specifically are:

692

Unified Modeling Language 2.5

• UMLClassifierShapes with Interfaces as modelElements, and rendered with ball or socket notations (see notes 

on UMLClassDiagrams and UMLCompositeStructureDiagrams above), may be the source or target of 
UMLEdges that have Connectors as modelElements that have ConnectorEnds with roles that are Ports requiring 
or providing the Interfaces.

• UMLEdges with Connectors as modelElements may have as source and/or target UMLClassifierShapes with 

Interfaces as modelElements, and rendered as ball or socket notation (see sub clause B.3.3), when the Connector 
end roles are Ports with a value for partWithPort and requiring or providing exactly one Interface (simple ports).

• UMLClassifierShapes with Interfaces as modelElements, and rendered as ball or socket notation (see sub clause

B.3.3), may be rendered near each other (with the ball “in” the socket, and no line between them) to show 
Connectors with end roles that are the Ports with a value for partWithPort and requiring or providing exactly one 
Interface (simple ports). These UMLClassifierShapes may be the source or target of multiple UMLEdges that 
have all InterfaceRealization or all Usage Dependencies as modelElements when the Connector has more than 
two ends.

Some notes about UMLProfileDiagrams are:

•

Stereotype definitions shall be shown with UMLClassifierShapes (see sub clause B.3.3, Stereotypes are 
Classes and are shown the same way).

• UMLEdges with Extensions as modelElements shall be rendered as solid lines with filled arrowheads, without 
navigability arrows or other association adornments. See sub clause B.3.4 about ExtensionEnd labels on these 
UMLEdges.

• UMLEdges with ProfileApplications as modelElements shall be rendered as dashed lines with open arrowheads.

Template signature rectangles shall be interchanged as UMLShapes with TemplateSignatures as modelElements, 
containing either a single UMLLabel with the TemplateSignature as modelElement, or multiple UMLLabels with one 
TemplateParameter per UMLLabel as modelElement.

B.3.3 Classifier Shapes

UMLCompartmentableShape

UMLClassifierShape

{redefines umlDiagramElement}
+ umlDiagramElement

1

isIndentForVisibility : Boolean = false
isDoubleSided : Boolean = false

*

+ modelElement
{redefines modelElement}

UML::Classification::Classifier

Figure B.9  Classifier Shapes

The model in Figure B.9 specializes UMLCompartmentableShape into UMLClassifierShape, to add properties, and 
restrict them to show exactly one Classifier. UMLClassifierShape introduces isIndentForVisibility for modelElements that 
are shown with feature compartments, to indicate features are shown indented under visibility headings. It also 
introduces isDoubleSided for modelElements that are Classes with true as a value for isActive that are shown as rectangles, 
to indicate whether the vertical sides shall be rendered as double lines.
Some notes about UMLClassifierShapes are:

• UMLLabels that are ownedElements UMLClassifierShapes, and have Classifiers as modelElements, and are not 
classified by any specialization of UMLLabel, shall have text specified by UML giving information about the 
Classifier.

Unified Modeling Language 2.5

693

•

•

Classifier features shown in order textually in UMLClassifierShape compartments shall be interchanged with 
UMLLabels having a single Feature each as modelElements.

Ellipsis appearing below Classifier features shown in order textually in UMLClassifierShape compartments shall 
be interchanged as UMLLabels with no modelElements, and as the last orderedElement of UMLCompartments.

• UMLClassifierShapes with Components as modelElements may have UMLCompartments as ownedElements that 

have UMLLabels as ownedElements with required and provided Interfaces of the Components as modelElements, 
where the UMLLabels show names of the Interfaces. The UMLLabels shall have InterfaceRealization or Usage 
Dependencies as modelElements with Interfaces as suppliers , which determine whether the Interfaces are required
and/or provided (used Interfaces are required and realized Interfaces are provided).

•

See sub clause B.3.3 for more notes on interchanging UMLClassifierShapes.

B.3.4 Multiplicity and Association End Labels

UMLLabel

UMLAssociationEndLabel

{redefines umlDiagramElement}
+ umlDiagramElement

1

*

+ modelElement
{redefines modelElement}

UML::Classification::Property

UMLMultiplicityLabel

{redefines umlDiagramElement}
+ umlDiagramElement

1

*

+ modelElement
{redefines modelElement}

UML::CommonStructure::MultiplicityElement

Figure B.10  Multiplicity and Association End Labels

The model in Figure B.10 specializes UMLLabel into UMLMultiplicityLabel and UMLAssociationEndLabel to restrict 
them to show information about exactly one MultiplicityElement or exactly one Association memberEnd, respectively.
Some notes about UMLMultiplicityLabels and UMLAssociationEndLabels are:

•

Information about Properties shown textually in UMLCompartments shall be interchanged with UMLLabel 
directly (see sub clause B.3.3), rather than UMLMultiplicityLabels or UMLAssociationEndLabel, even when 
the Property is an Association memberEnd or when Multiplicity is shown (see sub clause B.2.4 about when to 
use specializations of UMLLabel generally).

• UMLMultiplicityLabel shall be used to show information about the portions of their modelElements defined by 

MultiplicityElement, rather than other specializations of MultiplicityElement that might classify the 
modelElements, such as Property (see sub clause B.2.4 about when to use specializations of UMLLabel 
generally).

•

ConnectorEnds shall be shown with UMLMultiplicityLabel (the only underived Property introduced by 
ConnectorEnds, role, is shown by the targets of UMLEdges with Connectors as modelElements, and the only 
generalization of ConnectorEnd is MultiplicityElement). Information about definingEnds of ConnectorEnds is 
shown with UMLAssociationEndLabels (definingEnds are Properties).

• UMLAssociationEndLabels shall be used to show information about Association memberEnds, other than that 

shown with UMLMultiplicityLabel (Properties are MultiplicityElements). Multiple 
UMLAssociationEndLabels can have the same modelElement, each showing its own aspect of the modelElement.

694

Unified Modeling Language 2.5

• UMLAssociationEndLabels with ExtensionEnds as modelElements may only be used when the modelElements 
have an value of 1 for lower, in which case UMLAssociationEndLabels shall have the value “{required}” for 
text (ExtensionEnds are Extension ownedEnds, a kind of memberEnd, and Extensions are Associations).

B.3.5 Association, Connector, and Link Shapes

UMLShape

UMLAssociationOrConnectorOrLinkShape

kind : UMLAssociationOrConnectorOrLinkShapeKind

«enumeration»

UMLAssociationOrConnectorOrLinkShapeKind
diamond
triangle

Figure B.11  Association, Connector, and Link Shapes

The model in Figure B.11 specializes UMLShape into UMLAssociationOrConnectorOrLinkShape, to add a property, 
and restrict them to show exactly one Association, Connector, or InstanceSpecification with an Association classifier. It 
introduces kind to indicate to how the modelElement shall be shown.
UMLAssociationOrConnectorOrLinkShapes with a value of diamond for kind shall be rendered as rhombuses, and shall 
have a modelElement that is either an Association with two memberEnds, a Connector with two ends, or an 
InstanceSpecification with an Association classifier that has two memberEnds (when there are more than two ends these 
elements are always shown this way, and the notation shall be interchanged with UMLShapes). Regardless of the 
number of ends, exactly two of the lines from the rhombus shall be interchanged with UMLEdges with modelElements 
that are either Properties (the memberEnds of the Association modelElement of the 
UMLAssociationOrConnectorOrLinkShape, or memberEnds of an Association that is a classifier of the 
InstanceSpecification modelElement UMLAssociationOrConnectorOrLinkShape) or ConnectorEnds (the ends of a 
Connector modelElement of UMLAssociationOrConnectorOrLinkShape).
UMLAssociationOrConnectorOrLinkShape with a value of triangle for kind shall be rendered as a filled triangle 
annotating a UMLEdge that has the same modelElement as the UMLAssociationOrConnectorOrLinkShape.

Behavior
B.4
B.4.1 Summary
The Behavior portion of UML DI captures graphical aspects of behavior diagrams and their contents.

B.4.2 Behavior Diagrams

UMLDiagram

UMLBehaviorDiagram

{redefines umlDiagramElement}
+ umlDiagramElement

{redefines modelElement}
+ modelElement

UMLDiagramWithAssociations

UMLUseCaseDiagram

«enumeration»

UMLInteractionDiagramKind
sequence
communication
overview
timing
table

*

UMLStateMachineDiagram

isCollapseStateIcon : Boolean = true
isInheritedDashed : Boolean = false
isTransitionOriented : Boolean = false

*

{redefines umlDiagramElement}
+ umlDiagramElement

1
+ modelElement
{redefines modelElement}

UMLActivityDiagram

isActivityFrame : Boolean = false

UMLInteractionDiagram

{redefines umlDiagramElement}
+ umlDiagramElement

*

{redefines umlDiagramElement}
+ umlDiagramElement

1

+ modelElement
{redefines modelElement}

UML::Activities::Activity

1

UML::Interactions::Interaction

kind : UMLInteractionDiagramKind = sequence
isLifelineDashed : Boolean = false

*

{redefines modelElement}
+ modelElement

0..1

UML::CommonBehavior::Behavior

UML::StateMachines::StateMachine

Figure B.12  Behavior Diagrams

Unified Modeling Language 2.5

695

The model in Figure B.12 specializes UMLDiagram into the most general class for diagrams depicting behavioral 
elements (UMLBehaviorDiagram), and specializes it into various kinds of behavior diagrams (see Annex A). 
UMLBehaviorDiagrams are restricted to have no more than one modelElement, which must be a Behavior.
UMLUseCaseDiagrams have no modelElements. Some notes about the contents of UMLUseCaseDiagrams are:

• UseCase notations shall be interchanged with UMLClassifierShapes, rendered as ovals when true is a value of 

isIcon and as rectangles when false is a value.

• Actor notations shall be interchanged with UMLClassifierShapes, rendered as stick figures when true is a value 

of isIcon and as a rectangles when false is a value.

• Modeler-defined icons showing Actors may be specified with Stereotype icons.

•

Extends and Includes notations shall be interchanged with UMLEdges with Extends and Includes as 
modelElements.

• UMLShapes with Extends as modelElements shall be rendered as note symbols, and have UMLLabels (not 

specializations) as the only two ownedElements. The UMLLabels shall have the condition or extensionLocations of 
the Extend as modelElements, and text giving the condition specification or extensionLocation names, respectively, in 
the syntax specified by UML. UMLEdges between such UMLShapes and other UMLDiagramElements shall 
have no modelElements and be rendered with dashed lines.

UMLStateMachineDiagrams are restricted to have exactly one modelElement, which must be a StateMachine. 
UMLStateMachineDiagram introduces isCollapseStateIcon to indicate whether UMLShapes for composite States shall 
contain a small icon distinguishing them from non-composite States. It also introduces isInheritedDashed to indicate 
whether borders of UMLShapes that have an inherited State as modelElement shall be dashed. This property and 
isInheritedLighter from UMLDiagram cannot both have a value of true at the same time, and one of them must have a 
value of true for UMLStateMachineDiagrams that show inherited States.
StateMachines may be shown in a “flow-chart” style (StateMachineDiagrams with a value of true for 
isTransitionOriented), where Transition triggers are shown as concave pentagons, and executableNodes in SequenceNodes in 
Transition effects are shown as round-cornered rectangles, except when they are SendSignalActions, which are shown as 
convex pentagons (this information about Transitions is shown only textually in StateMachineDiagrams with a value of 
false for isTransitionOriented). Transition-oriented UMLStateMachineDiagrams may have UMLShapes as ownedElements 
that have Triggers or ExecutableNodes as modelElements (other UMLStateMachineDiagrams shall not have these 
UMLShapes). UMLEdges that have these UMLShapes as source or target shall have Transitions as modelElements, and 
the modelElements shall be the same for UMLEdges that share the same UMLShape as source or target. In transition-
oriented UMLStateMachineDiagrams, UMLEdges that have Transitions as modelElements, and have as source or target 
UMLShapes with States as modelElements with a value true for isSubmachineState, where the Transition’s corresponding 
source or target is a ConnectionPointReference, the ConnectionPointReference shall be shown textually overlaying the 
line rendered by the UMLEdge, with semicircles at both ends of the text. The text shall be interchanged with a 
UMLLabel that has the ConnectionPointReference as modelElement.
Some notes about the contents of UMLStateMachineDiagrams are:

• UMLShapes with Regions as modelElements that are adjacent to each other shall be rendered with a dashed line 

between them.

•

Regions that are the only ones in their StateMachines or States are not shown.

UMLActivityDiagrams are restricted to have exactly one modelElement, which must be an Activity. 
UMLActivityDiagram introduces isActivityFrame to indicate whether the diagram frame shall be a round-cornered 
rectangle without a pentagonal header (isFrame shall have a value of false when isActivityFrame has a value of true). When 
true is a value of isActivityFrame, the name of the Activity is shown by a UMLNameLabel in the upper left of the diagram 
without showing the diagram kind.

696

Unified Modeling Language 2.5

Some notes about the contents of UMLActivityDiagrams are:

• UMLShapes with CallBehaviorActions as modelElements and Activities as behaviors shall be rendered with a 
rake symbol inside it when collapsed (when the UMLShape has no UMLShapes as ownedElements that have 
ActivityNodes as modelElements). When expanded, the behavior shall be shown with activity frame notation, 
including UMLEdges that have ActivityEdges as modelElements and UMLShapes as sources or targets that have 
the Activity or its ActivityParameterNodes as modelElements.

•

Some information about InputPins and OutputPins may be shown graphically, as follows:

o UMLShapes with a single InputPin or OutputPin as modelElement and a true value for isIcon shall be 
rendered with a small arrows in the rectangle directed towards or the round rectangle they are next to 
for InputPins, or away for OutputPins. If the InputPin or OutputPin corresponds to a Parameter that 
has a value of true for isStream the UMLShape shall be rendered as filled, inverting the arrow, if any.

o UMLShapes with a single InputPin or OutputPin as modelElement corresponding to a Parameter that 
has a value of true for isStream, and with a true value for isIcon, shall be rendered as filled, inverting 
the arrow inside it.

• ObjectFlows between OutputPins and InputPins may be shown with shorthand notations, as follows:

o UMLEdges shall have the same ActivityEdge as modelElement when their source or target are the same 
UMLShape with multiple Pins as modelElements (specifically an InputPin and OutputPin that are the 
source and target of the ActivityEdge, respectively). The UMLShape may be rendered as a small 
square, with a UMLLabel rendered near the small square. These UMLEdges shall be shown with 
filled arrowheads when they have ObjectFlows as modelElements, a true value for isIcon, and as source 
or target UMLShapes with multiple Pins as modelElements (specifically an InputPin and OutputPin), 
and all the Pins correspond to Parameters that have a value of true for isStream.

o UMLEdges with ObjectFlows as modelElements where the UMLEdges have as source and target the 

same UMLShapes with Actions as modelElements, shall be rendered with a small square near the line. 
The small square shall be interchanged with a UMLShape with the same ObjectFlows as modelElement
as the UML Edge (a single UMLEdge may have multiple ObjectFlows as modelElement).

• A single UMLShape may be used as a shorthand for two ControlNodes that are the target and source an 

ActivityEdge as follows:

o A single UMLShape may have as modelElements a MergeNode, ActivityEdge, and DecisionNode, with 
the MergeNode and DecisionNode as source and target of the ActivityEdge, respectively. UMLEdges 
that have such UMLShapes as target have an ActivityEdge as modelElement with the MergeNode as 
target. UMLEdges that have such UMLShape as source have an ActivityEdge as modelElement with the 
DecisionNode as source.

o A single UMLShape may have as modelElements a JoinNode, ActivityEdge, and ForkNode, with the 
JoinNode and ForkNode as source and target of the ActivityEdge, respectively. UMLEdges that have 
such UMLShapes as target have an ActivityEdge as modelElement with the JoinNode as target. 
UMLEdges that have such UMLShape as source have an ActivityEdge as modelElement with the 
ForkNode as source.

• UMLEdges may have as targets UMLShapes that have as modelElement a handlerBody of an ExceptionHandler. 

These UMLEdges with a value of true for isIcon shall be rendered as zigzag lines, and with a value of false 
shall be rendered as a zigzag graphic near the line.

Unified Modeling Language 2.5

697

•

•

•

ExpansionRegions that have exactly one inputElement, outputElement, and Action node, and two ObjectFlow 
edges, (one with the inputElement as source and an inputValue of the node as target, the other with an outputValue of 
the node as source and the outputElement as target) may be shown with one of two kinds of shorthand notation, 
both of which include a UMLShape with the ExpansionRegion as modelElement, and containing a UMLLabel 
with the Action node as modelElement, rendered in the center of the UMLShape:

o One notation shall have on the border of the UMLShape two other UMLShapes with the 
ExpansionRegion’s inputElement and outputElement as modelElements, where these two other 
UMLShapes shall be ownedElements of the first UMLShape, and shall be the target and source of two 
UMLEdges with ObjectFlows as modelElements, respectively, where the ObjectFlows shall have the 
inputElement and outputElement as target and source, respectively. The UMLShape with 
ExpansionRegion as modelElement shall have an additional ownedElement that is a UMLKeywordLabel 
with the ExpansionRegion as modelElement showing the mode of the ExpansionRegion in the upper 
left.

o The other notation is for parallel mode ExpansionRegions only. It may not show the inputElement and 
outputElement. The UMLShape with ExpansionRegion as modelElement shall be the target and source of 
the two UMLEdges with ObjectFlows as modelElements described above, respectively, and shall have 
an additional ownedElement in the upper right that is a UMLLabel with the ExpansionRegion as 
modelElement, and the value “*” for text.

Interrupting activity edges are identified by interruptible regions. UMLEdges with ActivityEdges as 
modelElements that are interruptingEdges of an InterruptibleRegion, and have a true value for isIcon, are shown as 
zigzag lines. When these UMLEdges have and have a false value for isIcon, UMLShapes with the ActivityEdge 
as modelElement shall be rendered as zigzag graphics near the lines.

The outside line segments of UMLShapes with ActivityPartitions as modelElements that are ownedElements of an 
Activity that is the modelElement of a UMLActivityDiagram with a value of true for isActivityFrame may be 
merged with the activity frame.

• ActivityEdge connector notations shall be interchanged with UMLShapes that have the same ActivityEdge as 

modelElements, and have as ownedElements UMLLabels with that ActivityEdge as modelElement.

•

See sub clause B.4.3 about UMLLabels in UMLActivityDiagrams.

UMLInteractionDiagrams are restricted to have exactly one modelElement, which must be an Interaction. 
UMLInteractionDiagram introduced kind, which affects the rendering of diagram contents in some cases. For example, 
UMLShapes with alt CombinedFragments as modelElements in UMLInteractionDiagrams with the value overview for 
kind shall be rendered as rhombuses. When the value for kind is table, the ownedElements that are UMLShapes and not 
UMLLabels shall be rendered as rectangles (see sub clause B.4.5). UMLInteractionDiagram also introduces 
isLifelineDashed, which indicates whether lifelines on the diagram shall be rendered as dashed.
Some notes about the contents of UMLInteractionDiagrams are:

•

Properties of Interactions (as Classes) may be shown as text below the upper left corner of diagram (below the 
heading pentagon), interchanged with UMLLabels in the same way as notation for Properties in Classes. These 
UMLLabels may appear in other UMLShapes that are the source or target of UMLEdges. These UMLShapes 
shall be rendered as notes, and the UMLEdges as dashed lines.

• UMLEdges with GeneralOrderings as modelElements shall be rendered with filled arrowheads in the middle of 

the lines. The arrowheads shall not be interchanged as separate UMLShapes.

698

Unified Modeling Language 2.5

• UMLEdges with Messages as modelElements that have lost or found as the value of messageKind shall be 

rendered with small filled circles at the target or source ends, respectively. The circles shall not be interchanged 
as separate UMLShapes.

• UMLShapes that have CombinedFragments as modelElements with a value of par for interactionOperand, and that 

have a value of true for isIcon, shall be rendered as brackets at the top and bottom of the shape (coregion 
notation).

• All CombinedFragments, regardless of the interactionOperand, shall be shown with text in pentagons in the 

upper left corners of their UMLShapes, where the text is interchanged with UMLLabels that have 
CombinedFragments as modelElements, possibly multiple labels per pentagon. The extra labels have 
immediately nested combined fragments as modelElements.

• UMLShapes with ExecutionSpecifications as modelElements a value of true for isIcon shall be rendered with 

shaded fill patterns.

B.4.3 Activity Diagram Labels
Some notes about UMLLabels in UMLActivityDiagrams are:

• UMLLabels that are ownedElements of UMLActivityDiagrams, and have Activities as modelElements, and are 
not classified by any specialization of UMLLabel, shall have text beginning with keywords specified by UML 
in guillemets indicating the kind of information they show about the Activity.

• UMLLabels that are ownedElements of UMLShapes with ActivityParameterNodes as modelElements, and have 
Parameters as modelElements, and are not classified by any specialization of UMLLabel, shall have text giving 
information about the Parameter, in the syntax specified by UML.

• UMLLabels that are ownedElements of UMLShapes with CallOperationAction as modelElements, and have 

Classes or Operations as modelElements, and are not classified by any specialization of UMLLabel, shall have 
text giving the name of the Class or Operation, or both, in the syntax specified by UML.

• UMLLabels that are ownedElements of UMLShapes with Actions as modelElements, and have ActivityPartitions 
as modelElements, and are not classified by any specialization of UMLLabel, shall have text giving the names of 
the ActivityPartitions in the syntax specified by UML.

• UMLLabels that are ownedElements of UMLShapes with no modelElements, and have ActivityNodes as 
modelElements, and are not classified by any specialization of UMLLabel, shall have text beginning with 
keywords specified by UML in guillemets indicating the kind of information they show about the ActivityNode 
(these UMLShapes are rendered as note symbols, see sub clause B.2.3).

• UMLLabels that are ownedElements of UMLShapes with ObjectNodes as modelElements, and have States as 

modelElements, and are not classified by any specialization of UMLLabel, shall be rendered as comma 
delimited lists of the names of the UMLLabel’s modelElements, enclosed in square brackets.

• UMLLabels that have text beginning and ending with braces (curly brackets), and are not classified by any 
specialization of UMLLabel, shall have ActivityNodes or ActivityEdges as modelElements, and the text shall 
give values for properties of the modelElements in a syntax specified by UML.

• UMLLabels that have text beginning and ending with square brackets, and are not classified by any 

specialization of UMLLabel, shall have ActivityEdges as modelElements, and the text between the square 
brackets shall show the guard of the ActivityEdge.

Unified Modeling Language 2.5

699

• UMLLabels may have Parameters as modelElements and be placed near UMLShapes that have InputPins or 

OutputPins of CallActions as modelElements (or near where the Pins would be if they are elided) to show 
Parameters of behaviors or operations of InvocationActions.

• UMLLabels near UMLShapes showing InputPins or OutputPins may be used to interchange shorthand 

notations as follows:

o Actions that have an InputPin as the target of an ObjectFlow with an ActivityParameterNode as source, 

may be shown in a shorthand notation that shows only the Action, its InputPin, and the name of the 
parameter of the ActivityParameterNode interchanged as a UMLLabel with the parameter as 
modelElement (see Figure 15-52 in sub clause 15.4.4).

o Actions that have an OutputPin as the source of an ObjectFlow with an ActivityParameterNode as 

target, may be shown in a shorthand notation that shows only the Action, its OutputPin, and nearby the
name of the parameter of the ActivityParameterNode interchanged as a UMLLabel with the parameter 
as modelElement (see Figure 15-52 in sub clause 15.4.4).

o AddVariableValueActions that have an InputPin as the target of an ObjectFlow with an OutputPin of 

another Action as source, and that have an OutputPin that is the source of an ObjectFlow having a 
FlowFinal as target, may be shown in a shorthand notation that shows only the other Action, its 
OutputPin, and nearby the name of the AddVariableValueAction’s variable shown by a UMLLabel with 
the variable as modelElement (see Figure 16-38 in sub clause 16.9.4).

o ActionInputPins with fromActions that are ReadVariableActions may be shown in a shorthand notation 

that i only the ActionInputPin and nearby the name of the variable of the ReadVariableAction 
interchanged as a UMLNameLabel with the variable as modelElement.

o ActionInputPins with fromActions that are ReadSelfObjectActions may be shown in a shorthand 

notation that shows only the ActionInputPin and nearby the string “self” interchanged as a UMLLabel 
with the ReadSelfObjectAction as modelElement.

o

 ActionInputPins with fromActions that are ValueSpecificationActions may be shown in a shorthand 
notation that shows only the ActionInputPin and nearby the value of the ValueSpecificationAction 
interchanged as a UMLLabel with the value as modelElement.

• ActivityPartitions headings shall be interchanged with UMLLabels with their ActivityPartition as modelElement.

B.4.4 State Shapes

UMLCompartmentableShape

UMLStateShape

{redefines umlDiagramElement}
+ umlDiagramElement

1..*

isTabbed : Boolean = false

*

{redefines modelElement}
+ modelElement

UML::StateMachines::State

Figure B.13  State Shapes

The model in Figure B.13 specializes UMLCompartmentableShape into UMLStateShape, to add a property, and restrict 
them to show one or more States. It introduces isTabbed to indicate whether a tab shall be added to the top of the shape 
to show the name of the State. UMLStateShapes may have multiple modelElements “when interchanging state list 
notation, see sub clause 14.2.4. In this case, the names of the modelElements are shown by a UMLLabel with the same 
modelElements, with the UMLStateShape as owningElement, and the UMLLabel shall be rendered as a comma delimited 
list of the names of its modelElements.

700

Unified Modeling Language 2.5

Some notes about the contents of UMLStateShapes are:

• UMLLabels showing entry, do, exit Behaviors shall have the Behaviors as modelElements, and text in the syntax 

specified by UML.

• UMLLabels showing internal or local Transitions have the Transitions as modelElements, and text in the syntax 

specified by UML.

• UMLLabels that are ownedElements of UMLStateShapes, and have States as modelElements, and are not 

classified by any specialization of UMLLabel, shall have text specified by UML giving information about the 
State.

B.4.5

Interaction Tables

UMLLabel

UMLInteractionTableLabel

kind : UMLInteractionTableLabelKind

«enumeration»

UMLInteractionTableLabelKind
lifelineClass
lifelineInstance
constraint
messageSendingClass
messageSendingInstance
diagramIdentifier
generatedInstanceName
sequenceNumber
weakOrder
messageName
parameter
returnValue
messageReceivingClass
messageReceivingInstance
otherEnd

Figure B.14  Interaction Shapes

The model in Figure B.14 specializes UMLLabel into UMLInteractionTableLabel to add a property for labels in the 
tabular format of UMLInteractionDiagrams.
UMLInteractionTableLabels shall be ownedElements of UMLShapes that are ownedElements of a single UMLShape that 
is an ownedElement of a UMLInteractionDiagram with a value of table for kind. All these UMLShapes shall be rendered 
as rectangles, one for the entire table (an ownedElement of the UMLInteractionDiagram), and one for each cell in the 
table (the second layer of ownedElements). UMLShapes for the whole table shall have an InteractionDiagram as 
modelElement that is the same as the modelElement of their owningElement. UMLShapes for cells shall be ownedElements in 
the UMLShape for the table, and have no more than one ownedElement, which shall be a UMLInteractionTableLabel. 
UMLShapes for cells in the top row shall have one ownedElement that has no modelElement, while all the UMLShapes for 
cells and their ownedElements shall have exactly one modelElement, which shall be the same for each UMLShape and its 
ownedElement. UMLInteractionTableLabels for cells in the same column shall all have the same value for kind.

Information Flows

B.5
Some notes about UMLDiagramElements related to InformationFlows are:

• UMLLabels with InformationFlows as modelElements show the names of the kinds of things conveyed. Multiple 
conveyed names for the InformationFlows shall be shown with one UMLLabel rendered as a comma-delimited 
list of the names, which may be due to multiple modelElements for the same UMLLabel, or multiple conveyed 
names for the same modelElement, or both.

• UMLShapes with InformationFlows as modelElements and a value of true for isIcon shall be rendered as filled 
triangles overlaying and aligned with UMLEdges with the same InformationFlows as modelElements, pointing 
towards the informationTarget. There shall be one triangle for all InformationFlows going in the same direction 
realized by the same element (a maximum of two triangles for the same realizing element).

Unified Modeling Language 2.5

701

UML Notations and UML DI Representations

B.6
This sub clause summarizes Annex B by showing how UML notations shall be modeled using UML DI. It does not 
cover all of Annex B or all notations in previous Clauses.
Table B.1 and Table B.2 cover shapes and edges respectively. The left column shows an example of UML notation. The 
table attempts to cover as many options as possible, but does not specify whether elements are mandatory or optional. 
The middle column shows UML DI elements corresponding to the notation. These elements are presented in a 
containment hierarchy. Elements with the same container are ordered according to the notation shown in the left 
column, read from left to right, and top to bottom. For each element, the type of diagram element is given, followed by 
the type of modelElement and sometimes other constraints that apply to the diagram element, put between parentheses. 
The type of modelElement is followed by a ’+’ when multiple modelElements of this type can be assigned to one 
diagram element. The right column references “Notation” clauses and figures where the notation is defined, as well as 
Annex B clauses where the UML DI representation is defined.
Table B.1  UML Shapes

Notation

Diagram elements

Ref.

UMLDiagram (Element, 
isFrame=true)
- UMLLabel (Element)

A, B.2.2
Fig. A.1, A.2, 
A.3, A.4

UMLShape
- UMLLabel (Comment)
UMLEdge

7.2.4, B.2.3
Fig 7.2

UMLShape (TemplateSignature)
- UMLLabel (TemplateSignature)

7.3.4, B.2.3
Fig 9.5, 9.7

UMLShape (TemplateSignature)
- UMLLabel (TemplateParameter)
- UMLLabel (TemplateParameter)

B.2.3
Fig 7.6

UMLShape
- UMLKeywordLabel (Constraint)
- UMLLabel (Constraint)
UMLEdge

7.6.4, B.2.3
Fig 7.14

702

Unified Modeling Language 2.5

Notation

Diagram elements

Ref.

9.2.4, B.2.3, 
B.2.5, B.3.3
Fig 7.11, 7.15, 
9.11, 10.2, 10.3, 
10.6, 11.16, 
11.17, 15.3

9.2.4, B.3.3
Fig. 11.18

11.4.4, B.3.3
Fig. 11.19, 11.20, 
11.50, 11.52, 
11.54

11.5.4, B.3.3
Fig 11.35, 11.36

9.8.4, B.2.4
Fig. 9.28, 9.29, 
9.31, 11.21

UMLClassifierShape (Classifier)
- UMLKeywordLabel (Classifier)
- UMLNameLabel (Classifier)
- UMLLabel (Classifier)
- UMLCompartment
--- UMLLabel
--- UMLLabel (Property)
--- UMLLabel (Property, inherited)
--- UMLLabel
- UMLCompartment
--- UMLLabel
--- UMLLabel (Operation)

UMLClassifierShape (Class, 
modelElement.isActive=true, 
isDoubleSided=true)
- UMLNameLabel (Class)

UMLClassifierShape (Class)
- UMLNameLabel (Class)
- UMLCompartment
--- UMLLabel
--- UMLShape (Property)
----- UMLTypedElementLabel 
(Property)
--- UMLEdge (Connector)
----- UMLTypedElementLabel 
(Connector)
--- UMLShape (Property)
----- UMLTypedElementLabel 
(Property)

UMLEdge
UMLClassifierShape 
(AssociationClass)
- UMLNameLabel (AssociationClass)

UMLCompartmentableShape 
(InstanceSpecification)
- UMLTypedElementLabel 
(InstanceSpecification)
- UMLCompartment
--- UMLTypedElementLabel (Slot)
- UMLCompartment
--- UMLLabel
--- UMLCompartmentableShape 
(InstanceSpecification)
----- UMLTypedElementLabel 
(InstanceSpecification)

Unified Modeling Language 2.5

703

Notation

Diagram elements

Ref.

UMLShape (InstanceValue)
- UMLTypedElementLabel 
(InstanceValue)

UMLClassifierShape (Enumeration)
- UMLKeywordLabel (Enumeration)
- UMLNameLabel (Enumeration)
- UMLCompartment
--- UMLNameLabel 
(EnumerationLiteral)

UMLShape (Interface+, isIcon=true, 
provided)
- UMLNameLabel (Interface+)
UMLEdge (InterfaceGeneralization)

UMLShape (Interface, isIcon=true, 
required)
- UMLNameLabel (Interface)
UMLEdge (Usage)

UMLCompartmentableShape 
(Property, 
modelElement.isComposite=true)
- UMLMultiplicityLabel (Property)
- UMLTypedElementLabel (Property)

UMLCompartmentableShape 
(Property, 
modelElement.isComposite=false)
- UMLTypedElementLabel (Property)

UMLShape (Port)
- UMLTypedElementLabel (Port)

UMLShape (Port)
UMLEdge
UMLShape (Interface+, isIcon=true, 
provided)

UMLShape (Port)
UMLEdge
UMLShape (Interface+, isIcon=true, 
required)

B.2.4

10.2.4, B.3.3
Fig. 10.4

10.4.4, B.2.2,
Fig. 10.8, 10.9, 
11.40

10.4.4, B.2.2
Fig. 10.10, 11.40

11.2.4, B.2.4
Fig. 11.2, 11.3, 
11.19, 11.20,

11.2.4, B.2.3
Fig 11.2, 11.3

11.2.4, 11.3.4, 
B.2.3
Fig. 11.3, 11.4, 
11.11, 11.12, 
11.13, 11.14

10.4.4, B.3.2
Fig 11.3, 11.4, 
11.11, 11.12, 
11.13, 11.14

10.4.4, B.3.2
Fig 11.3, 11.4, 
11.11, 11.12, 
11.13, 11.14

704

Unified Modeling Language 2.5

Notation

Diagram elements

Ref.

11.6.4, B.3.3
Fig. 11.39, 11.40, 
11.41, 11.42, 
11.43, 11.45, 
11.45, 11.46, 
11.47, 11.48, 
19.10

11.7.4, B.3.3
Fig 11.50, 11.52

UMLClassifierShape (Component)
- UMLNameLabel (Component)
- UMLCompartment
--- UMLLabel
--- UMLLabel (Interface, provided)
- UMLCompartment
--- UMLLabel
--- UMLLabel (Interface, required)

UMLClassifierShape (Collaboration, 
isIcon=true)
- UMLNameLabel (Collaboration)
- UMLCompartment
--- UMLClassifierShape (Classifier)
----- UMLNameLabel (Classifier)
--- UMLEdge (Property)
----- UMLLabel (Property)
--- UMLShape (CollaborationUse)
----- UMLTypedElementLabel 
(CollaborationUse)
--- UMLEdge (Property)
----- UMLLabel (Property)
--- UMLClassifierShape (Classifier)
----- UMLNameLabel (Classifier)

UMLCompartmentableShape 
(Package, with no contained shapes)
- UMLNameLabel (Package)

12.2.4, B.2.5
Fig 12.4, 12.5, 
12.8, 12.23

12.2.4, B.2.5
Fig. 12.2, 12.3, 
12.5, 12.6, 12.7, 
12.9, 12.13, 
12.14, 12.21, 
12.22

12.2.4, B.2.5
Fig. 12.10, 
12.11, 12.14

12.3.4, B.2.6
Fig. 12.29, 12.30

UMLCompartmentableShape 
(Package, with contained shapes)
- UMLNameLabel (Package)
- UMLShape (PackageableElement)
--- UMLNameLabel 
(PackageableElement)

UMLCompartmentableShape (Model)
- UMLNameLabel (Model)

UMLShape
- UMLLabel (Stereotype)
- UMLStereotypePropertyValueLabel 
(Element)
- UMLStereotypePropertyValueLabel 
(Element)
UMLEdge

Unified Modeling Language 2.5

705

Notation

Diagram elements

UMLClassifierShape (Classifier)
- UMLNameLabel (Classifier)
- UMLCompartment
--- UMLLabel
--- 
UMLStereotypePropertyValueLabel 
(Classifier)

Ref.

12.3.4, B.2.6
Fig. 12.31

UMLLabel (Stereotype+)

12.3.4, B.2.6

UMLShape (Stereotype, isIcon=true)

12.3.4, B.2.6

UMLShape (Region)
- UMLNameLabel (Region)
UMLShape (Region)
- UMLNameLabel (Region)

14.2.4, B.4.2
Fig. 14.3, 14.9

UMLStateShape (State)
- UMLNameLabel (State)
- UMLLabel (Constraint)
- UMLKeywordLabel (State)
- UMLCompartment
--- UMLStateShape (State, owned)
----- UMLNameLabel (State)
- UMLCompartment
--- UMLLabel (Behavior)
- UMLCompartment
--- UMLLabel (Transition)

UMLStateShape (State,diagram. 
diagram.isInheritedLighter=false, 
diagram.isInheritedDashed=true)
- UMLNameLabel (State)

UMLStateShape (State, 
diagram.isInheritedLighter=true, 
diagram.isInheritedDashed=false)
- UMLNameLabel (State)

14.2.4, B.4.4
Fig. 14.4, 14.6, 
14.7, 14.9, 14.10, 
14.45

14.2.4, B.4.2
Fig. 14.39, 14.40

14.2.4, B.4.2

UMLStateShape (State)
- UMLNameLabel (State)

14.2.4, B.4.4
Fig. 14.3, 14.5

UMLStateShape (State+)
- UMLNameLabel (State+)

14.2.4, B.4.4
Fig 14.15

706

Unified Modeling Language 2.5

Notation

Diagram elements

UMLStateShape (State, 
modelElement.isComposite=true, 
diagram.isCollapseStateIcon=true)
 - UMLNameLabel (State)

UMLStateShape (State)
- UMLNameLabel (State)
- UMLShape 
(ConnectionPointReference, entry 
point)
--- UMLNameLabel 
(ConnectionPointReference)

UMLStateShape (State)
- UMLNameLabel (State)
- UMLShape 
(ConnectionPointReference, exit 
point)
--- UMLNameLabel 
(ConnectionPointReference)

UMLShape (Pseudostate, initial)

UMLShape (FinalState)

UMLShape (Pseudostate, 
shallowHistory)

UMLShape (Pseudostate, deepHistory)

Ref.

14.2.4, B.4.2
Fig. 14.8

14.2.4, B.4.4
Fig. 14.11, 14.28

14.2.4, B.4.4
Fig. 14.11, 
14.14, 14.29

14.2.4, B.2.3
Fig. 14.18

14.2.4, B.2.3
Fig 14.17

14.2.4, B.2.3
Fig. 14.19

14.2.4, B.2.3
Fig 14.20

UMLShape (Pseudostate, entryPoint)

14.2.4, B.2.3
Fig 14.21, 14.23

UMLShape (Pseudostate, exitPoint)

UMLShape (Pseudostate, junction)

UMLShape (Pseudostate, choice)

UMLShape (Pseudostate, terminate)

14.2.4, B.2.3
Fig. 14.12, 
14.13, 14.14, 
14.22, 14.23

14.2.4, B.2.3
Fig. 14.24

14.2.4, B.2.3
Fig 14.25

14.2.4, B.2.3
Fig 14.26

Unified Modeling Language 2.5

707

Notation

Diagram elements

UMLShape (Pseudostate, join/fork)

UMLShape (OpaqueAction, in 
StateMachine diagrams when 
isTransitionOriented=true)
- UMLLabel (OpaqueAction)

UMLShape (Trigger, in StateMachine 
diagrams when 
isTransitionOriented=true )
- UMLNameLabel (Trigger)

UMLShape (SendSignalAction, in 
StateMachine diagrams when 
isTransitionOriented=true )
- UMLNameLabel (SendSignalAction)

Ref.

14.2.4, B.2.3
Fig 14.27

14.2.4, B.4.2
Fig. 14.32

14.2.4, B.4.2
Fig. 14.32

14.2.4, B.4.2
Fig. 14.32

UMLActivityDiagram (Activity, 
isActivityFrame=true)
- UMLKeywordLabel (Activity)

15.2.4, B.4.3
Fig 15.2

UMLShape (ObjectNode)
- UMLLabel (Parameter)
- UMLShape (ObjectNode, exception, 
isIcon=true)

15.2.4, B.4.3
Fig 15.52, 15.56, 
16.19, 16.27

UMLShape (Action)
- UMLNameLabel (Action)

UMLShape (Action)
- UMLKeywordLabel 
(ActivityPartition)
- UMLNameLabel (Action)
- UMLLabel (ActivityPartition)

UMLShape (ObjectNode not typed by 
Signal)
- UMLTypedElementLabel 
(ObjectNode)
- UMLLabel (State+)
- UMLLabel (ObjectNode)

15.2.4, B.2.3
Fig. 15.4, 15.61, 
16.14

15.6.4, B.2.3
Fig. 15.67, 
15.71, 16.2, 16.7, 
16.8

15.2.4, B.4.3
Fig. 15.4, 15.49, 
15.50, 15.54, 
15.55, 15.58, 
15.59, 16.20, 
16.21, 16.26, 
16.28

708

Unified Modeling Language 2.5

Notation

Diagram elements

Ref.

UMLShape (ActivityParameterNode)
- UMLLabel (Parameter)
- UMLLabel (ActivityParameterNode)

UMLShape (ObjectNode, typed by 
signal)
- UMLTypedElementLabel 
(ObjectNode)

UMLShape
- UMLKeywordLabel (Behavior, 
selection/ 
transformation/decisionInput)
- UMLLabel (Behavior)
UMLEdge

UMLShape (InitialNode)

UMLShape (ActivityFinalNode)

UMLShape (FlowFinalNode)

UMLShape (JoinNode)
- UMLLabel (JoinNode)

UMLShape (ForkNode)

15.4.4, B.4.2
Fig. 15.22, 
15.52, 15.56, 
15.57

15.2.4, B.4.2

15.2.4, B.2.3
Fig 15.10, 15.16, 
15.33, 15.41, 
15.51, 16.11

15.3.4, B.2.3
Fig. 15.4, 15.27, 
15.35

15.3.4, B.2.3
Fig. 15.4, 15.28, 
15.42, 15.43, 
15.44

15.3.4, B.2.3
Fig. 15.4, 15.28, 
15.45, 15.46

15.3.4, B.4.3
Fig. 15.4, 15.29, 
15.30, 15.37, 
15.38

15.3.4, B.2.3
Fig. 15.4, 15.29, 
15.36

UMLShape 
(JoinNode+ActivityEdge+ForkNode)

15.3.4, B.4.2
Fig. 15.4, 15.32

Unified Modeling Language 2.5

709

Notation

Diagram elements

Ref.

UMLShape (MergeNode)

UMLShape (DecisionNode)

UMLShape 
(MergeNode+ActivityEdge+Decision
Node)

UMLShape (ActivityPartition, 
modelElement.isDimension=true)
- UMLNameLabel (ActivityPartition)
- UMLShape (ActivityPartition)
--- UMLNameLabel 
(ActivityPartition)
- UMLShape (ActivityPartition)
--- UMLNameLabel 
(ActivityPartition)
UMLShape (ActivityPartition, 
isDimension=true)
- UMLShape (ActivityPartition)
--- UMLNameLabel 
(ActivityPartition)
- UMLShape (ActivityPartition)
--- UMLNameLabel 
(ActivityPartition)

UMLShape 
(InterruptibleActivityRegion)

UMLShape
- UMLKeywordLabel (Constraint, 
precondition, postcondition)
- UMLLabel (Constraint)
UMLEdge

UMLShape (Pin)
- UMLNameLabel (Pin)
- UMLLabel (State+)
- UMLLabel (Pin)
- UMLLabel (Parameter)

15.3.4, B.2.3
Fig. 15.4, 15.32, 
15.39

15.3.4, B.2.3
Fig. 15.4, 15.33, 
15.40

15.3.4, B.4.2
Fig. 15.4, 15.34

15.6.4, B.4.3
Fig. 15.66, 
15.67, 15.70, 
15.72

15.6.4, B.2.3
Fig. 15.68, 
15.69, 15.73

16.2.4, B.2.3
Fig. 16.3, 16.9

B.4.3
Fig. 16.4, 16.6

UMLEdge (ObjectFlow)
UMLShape (InputPin, OutputPin)
UMLEdge (ObjectFlow)

B.4.2
Fig. 16.6

710

Unified Modeling Language 2.5

Notation

Diagram elements

UMLShape (Pin, isIcon=true, 
streaming parameter)

UMLShape (InputPin)
UMLShape (InputPin, isIcon=true, 
streaming parameter)

UMLShape (OutputPin)
UMLShape (OutputPin, isIcon=true, 
streaming parameter)

Ref.

16.2.4, B.4.2
Fig. 16.22

16.2.4, B.4.2
Fig. 16.5

16.2.4, B.4.2
Fig. 16.5

UMLShape (CallBehaviorAction, with 
an Activity as behavior)
- UMLNameLabel 
(CallBehaviorAction)

16.3.4, B.4.2
Fig. 16.15, 16.24

16.3.4, B.4.3
Fig. 16.16, 16.17

16.4.4, B.4.3
Fig. 16.31, 16.32

B.4.3

B.4.3

B.4.3

B.4.3

UMLShape (CallOperationAction)
- UMLNameLabel 
(CallOperationAction)
- UMLNameLabel (Operation)

UMLShape 
(ValueSpecificationAction)
- UMLLabel (ValueSpecification)

UMLShape (Action)
- UMLNameLabel (Action)
- UMLShape (OutputPin)
--- UMLLabel (Variable)

UMLShape (ReadVariableAction)
- UMLNameLabel 
(ReadVariableAction)
- UMLShape (ActionInputPin)
--- UMLLabel (Variable)

UMLShape (ReadSelfObjectAction)
- UMLNameLabel 
(ReadSelfObjectAction)
- UMLShape (ActionInputPin)
--- UMLLabel (ReadSelfObjectAction)

UMLShape 
(ValueSpecificationAction)
- UMLNameLabel 
(ValueSpecificationAction)
- UMLShape (ActionInputPin)
--- UMLLabel 
(ValueSpecificationAction)

UMLShape (SendSignalAction)
- UMLNameLabel (SendSignalAction)

16.3.4, B.4.2
Fig. 16.18, 
16.25, 16.42

Unified Modeling Language 2.5

711

Notation

Diagram elements

UMLShape (SendObjectAction with 
signal type)
- UMLNameLabel 
(SendObjectAction)

UMLShape (AcceptEventAction 
without TimeEvent trigger)
- UMLNameLabel 
(AcceptEventAction)

Ref.

16.3.4, B.4.2

16.10.4, B.2.3
Fig. 16.40, 16.41, 
16.42

UMLShape (AcceptEventAction with 
TimeEvent trigger)

16.10.4, B.2.3
Fig. 16.40, 16.43

UMLShape (Action)
- UMLNameLabel (Action)
- UMLShape (ParameterSet)
--- UMLShape (Parameter)
--- UMLShape (Parameter)

16.3.4, B.2.3
Fig. 16.23, 16.29

UMLShape (StructuredActivityNode)
- UMLKeywordLabel 
(StructuredActivityNode)

16.11.4, B.4.2
Fig. 16.46

UMLShape (ExpansionRegion)
- UMLShape (ExpansionNode)
- UMLKeywordLabel 
(ExpansionRegion)
- UMLShape (ExpansionNode)

16.12.4, B.4.2
Fig. 16.48, 
16.50, 16.52, 
16.53

UMLShape (ExecutionRegion, parallel 
mode, with one action)
- UMLNameLabel (Action)
- UMLLabel (ExecutionRegion)

16.12.4, B.4.2
Fig. 16.51, 16.55

UMLShape (ExecutionRegion, with 
one action)
- UMLShape (ExecutionNode)
- UMLNameLabel 
(CallBehaviorAction)
- UMLShape (ExecutionNode)

16.12.4, B.4.2
Fig. 16.49, 16.54

712

Unified Modeling Language 2.5

Notation

Diagram elements

UMLInteractionDiagram (Interaction)
- UMLLabel (heading)
- UMLLabel (Property)
- UMLShape ()
--- UMLLabel (Property)

Ref.

17.2.4, B.4.2
Fig. 17.3

UMLShape (Lifeline, line)
- UMLLabel (Lifeline, rectangle)
UMLShape (Lifeline, line)
- UMLLabel (Lifeline, rectangle)

17.3.4, B.2.3
Fig. 17.3

17.3.4, B.4.2
Fig. 17.2

UMLShape (Lifeline, dashed line)
- UMLLabel (Lifeline, rectangle)
UMLShape (ExecutionSpecification)
UMLShape (Lifeline, line)
- UMLLabel (Lifeline, rectangle)
UMLShape (ExecutionSpecification, 
isIcon=true)

UMLShape (Lifeline, dashed line)
- UMLLabel (Lifeline, rectangle)
UMLShape 
(DestructionOccurrenceSpecification)

17.4.4, B.2.3
Fig. 17.8

Unified Modeling Language 2.5

713

Notation

Diagram elements

UMLShape (CombinedFragment)
- UMLLabel (CombinedFragment)
- UMLShape (InteractionOperand)
--- UMLLabel (InteractionConstraint)
- UMLShape (InteractionOperand)
--- UMLLabel (InteractionConstraint)

UMLShape (Lifeline)
- UMLLabel (Lifeline)
UMLShape (Lifeline)
- UMLLabel (Lifeline)
UMLShape (Continuation)
- UMLLabel (Continuation)

UMLShape (Lifeline)
- UMLLabel (Lifeline)
- UMLShape (StateInvariant)
--- UMLLabel (StateInvariant)
- UMLLabel (StateInvariant)

Ref.

17.6.4, B.2.3
Fig. 17.12, 
17.13, 17.14

17.6.4, B.2.3
Fig. 17.14

17.2.4, B.2.3
Fig. 17.17

UMLShape (InteractionUse)
- UMLLabel (InteractionUse)
- UMLNameLabel (InteractionUse)

17.10.1, B.2.3
Fig. 17.19, 17.20

UMLShape (Lifeline)
- UMLLabel (Lifeline)
UMLShape (CombinedFragment, 
isIcon=true, mode=parallel)

17.6.4, B.4.2

714

Unified Modeling Language 2.5

Notation

Diagram elements

UMLClassifierShape (Classifier)
- UMLCompartment
---  UMLShape (Interaction)
----- UMLLabel (Interaction)
----- UMLNameLabel (Interaction)

UMLEdge
UMLLabel (Observation)

UMLEdge
UMLLabel (TimeConstraint)

UMLLabel (DurationConstraint)
UMLEdge (DurationConstraint)

UMLClassifierShape (UseCase, 
isIcon=true)
- UMLNameLabel (UseCase)
- UMLCompartment
--- UMLLabel
--- UMLLabel (ExtensionPoint)

UMLClassifierShape (UseCase, 
isIcon=false)
- UMLNameLabel (UseCase)
- UMLCompartment
--- UMLLabel
--- UMLLabel (ExtensionPoint)

UMLShape (Actor, isIcon=true)

UMLClassifierShape (Actor)
- UMLKeywordLabel (Actor)
- UMLNameLabel (Actor)

UMLShape
- UMLLabel (Extend)
- UMLLabel (ExtensionPoint)
UMLEdge

Ref.

17.7.5, B.3.3
Fig. 17.23

B.2.3
Fig 8.5, 17.5

B.2.3
Fig 8.5, 17.5

B.2.3
Fig 8.5, 17.5

18.1.4, B.4.2
Fig. 18.2, 18.3, 
18.11

18.1.4, B.4.2
Fig. 18.5, 18.12

18.1.4, B.4.2
Fig. 18.2, 18.6

18.1.4, B.4.2
Fig. 18.7

18.1.4, B.4.2

Unified Modeling Language 2.5

715

Notation

Diagram elements

Ref.

UMLShape (DeploymentTarget, in 
UMLDeploymentDiagram)
- UMLNameLabel 
(DeploymentTarget)
- UMLShape (Node)
--- UMLNameLabel (Node)

19.2.4, B.2.3
Fig. 19.2, 19.3, 
19.4, 19.6, 19.7, 
19.12, 19.13, 
19.14

Table B.2  UML Edges

Notation

UMLClassifierShape 
(DeploymentSpecification)
- UMLKeywordLabel 
(DeploymentSpecification)
- UMLNameLabel 
(DeploymentSpecification)

UMLClassifierShape (Artifact)
- UMLKeywordLabel (Artifact)
- UMLNameLabel (Artifact)

UMLShape (InformationItem)
- UMLNameLabel (InformationItem)
UMLEdge

19.2.4, B.3.3
Fig. 19.5, 19.6, 
19.7

19.3.4, B.3.3
Fig. 19.2, 19.3, 
19.6, 19.7, 19.9, 
19.10

20.1.4, B.2.3
Fig. 20.3, 20.4

Diagram elements

UMLEdge (TemplateBinding)
- UMLKeywordLabel 
(TemplateBinding)
- UMLLabel (TemplateBinding)

Ref.

7.3.4, B.2.3
Fig 7.6, 9.5

UMLEdge (between Namespace and 
NamedElement shapes)

7.4.4, B.3.2
Fig. 12.5

UMLEdge (ElementImport)
- UMLKeywordLabel 
(ElementImport)

UMLEdge (PackageImport)
- UMLKeywordLabel 
(PackageImport)

UMLEdge (Constraint)
- UMLLabel (Constraint)

7.4.4, B.2.3
Fig 7.7, 7.8

7.4.4, B.2.3
Fig 7.9

7.6.4, B.2.3
Fig 7.16

716

Unified Modeling Language 2.5

Notation

Diagram elements

Ref.

UMLEdge (Dependency)
- UMLKeywordLabel (Dependency)
- UMLNameLabel (Dependency)

UMLEdge (Dependency)
UMLEdge (Dependency)
UMLShape (Dependency)
- UMLKeywordLabel (Dependency)
- UMLNameLabel (Dependency)
UMLEdge (Dependency)
UMLEdge (Dependency)

UMLEdge (Realization)

7.7.4, B.2.3
Fig 7.18, 7.19, 
7.20, 11.22, 
11.23, 12.14

7.7.4, B.2.3

7.7.4, B.2.3
Fig 7.21, 10.11

UMLEdge (Substitution)
- UMLKeywordLabel (Substitution)

9.2.4, B.2.3
Fig 9.3

UMLEdge (Generalization)
- UMLNameLabel (GeneralizationSet)
- UMLLabel (Classifier)
- UMLLabel (GeneralizationSet)

UMLShape (GeneralizationSet)
- UMLNameLabel (GeneralizationSet)
- UMLLabel (Classifier)
- UMLLabel (GeneralizationSet)

UMLEdge 
(Association/Connector/InstanceSpecif
ication/Property/ConnectorEnd)

UMLEdge 
(Association/Connector/InstanceSpecif
ication/Property/ConnectorEnd , 
navigabilityNotation enabled)

UMLEdge 
(Association/Connector/InstanceSpecif
ication/Property/ConnectorEnd , 
isAssociationDotShown enabled)

UMLEdge 
(Association/Connector/InstanceSpecif
ication/Property/ConnectorEnd, 
nonNavigabilityNotation enabled)

9.2.4, B.2.3
Fig 9.2, 9.15, 
9.16, 9.18, 9.20, 
9.22, 9.23, 9.24, 
9.25, 9.26

9.7.4, B.2.3
Fig 9.17, 9.19, 
9.22, 9.22

11.5.4, B.2.3

11.5.4, B.3.2
Fig 11.29

11.5.4, B.3.2
Fig. 11.30

11.5.4, B.3.2
Fig 11.29

Unified Modeling Language 2.5

717

Notation

Diagram elements

UMLEdge 
(Association/Connector/InstanceSpecif
ication/Property/ConnectorEnd, shared 
associationEnd)

UMLEdge 
(Association/Connector/InstanceSpecif
ication/Property/ConnectorEnd, 
composite associationEnd)

UMLEdge (Property/ConnectorEnd)
UMLAssociationOrConnectorLinkSha
pe 
(Association/InstanceSpecification/Co
nnector, kind=Diamond)
UMLEdge (Property/ConnectorEnd)

UMLEdge 
(Association/Connector/InstanceSpecif
ication)
- 
UMLAssociationOrConnectorLinkSha
pe 
(Association/Connector/InstanceSpecif
ication, kind=Triangle)

UMLEdge (Association)
- UMLAssociationEndLabel 
(Property)
- UMLNameLabel (Association)
- UMLMultiplicityLabel (Property)
- UMLRedefinesLabel (Property)
- UMLLabel (Property)

UMLEdge (Association)
- UMLShape (Property)
--- UMLLabel (Property)

UMLEdge (Connector)
- UMLAssociationEndLabel 
(Property)
- UMLTypedElementLabel 
(Connector)
- UMLMultiplicityLabel 
(ConnectorEnd)

Ref.

11.5.4, B.2.3

11.5.4, B.2.3
Fig 11.33, 11.34

11.5.4, B.3.5
Fig. 11.27, 11.36

11.5.4, B.3.5

11.5.4, B.3.4
Fig 7.12, 9.12, 
11.5, 11.26, 
11.28, 11.32

9.5.4, B.3.2
Fig 11.37

11.2.4, B.2.4, 
B.3.4
Fig 11.5, 11.6, 
11.7, 11.19, 
11.20,

718

Unified Modeling Language 2.5

Notation

Diagram elements

Ref.

UMLEdge (InterfaceGeneralization)
UMLShape (Interface, isIcon=true, 
provided)
UMLEdge (Connector)
UMLShape (Interface, isIcon=true, 
required)
UMLEdge (InterfaceGeneralization)

UMLEdge (InstanceSpecification)
- UMLNameLabel (StructuralFeature)

UMLClassifierShape (Classifier)
UMLEdge (Usage)
UMLClassifierShape (Interface, 
isIcon=true)

UMLClassifierShape (Collaboration)
- UMLNameLabel (Collaboration)
UMLEdge (ConnectableElement)
- UMLNameLabel 
(ConnectableElement)
UMLClassifierShape (Classifier)
- UMLNameLabel (Classifier)

UMLEdge (CollaborationUse)
- UMLKeywordLabel 
(CollaborationUse)

UMLEdge (PackageMerge)
- UMLLabel (PackageMerge)

UMLEdge (Extension)
- UMLAssociationEndLabel 
(ExtensionEnd)

UMLEdge (ProfileApplication)
UMLKeywordLabel 
(ProfileApplication)

UMLEdge (Transition)
- UMLLabel (Transition)
- UMLLabel 
(ConnectionPointReference)

UMLEdge (ActivityEdge)
- UMLNameLabel (ActivityEdge)
- UMLLabel (ActivityEdge)
- UMLLabel (ActivityEdge)

10.4.4, B.3.2
Fig 11.4, 11.8, 
11.9

9.8.4, B.3.2
Fig. 9.30, 9.32, 
11.21

10.4.4, B.3.3

11.7.4, B.2.3

11.7.4, B.2.3

12.2.4, B.2.3
Fig. 12.2, 12.3, 
12.4, 12.6, 12.8

B.3.4

B.2.3

14.2.4, B.2.3
Fig. 14.30, 
14.31, 14.34, 
14.35, 14.42, 
14.43, 14.46

15.2.4, B.4.3
Fig. 15.5, 15.7, 
15.9, 15.13, 
15.14, 15.21

Unified Modeling Language 2.5

719

Notation

Diagram elements

Ref.

UMLEdge (ControlFlow)
 - UMLKeywordLabel (ControlFlow)

15.2.4, B.2.3
Fig 15.8, 15.18

UMLShape (Action)
UMLEdge (ObjectFlow+)
 - UMLShape (ObjectFlow+, 
isIcon=true)
UMLShape (Action)

15.2.4, B.4.2
Fig 15.11, 15.15

UMLEdge (ObjectFlow, isIcon=true)
UMLShape (ObjectNode, streaming 
parameter)

16.3.4, B.2.3

UMLEdge (ActivityEdge)
UMLShape (ActivityEdge)
UMLShape (ActivityEdge)
UMLEdge (ActivityEdge)

UMLEdge (ActivityEdge, isIcon=true, 
interruptible or going to an 
ExceptionHandler body)

UMLEdge (ActivityEdge)
- UMLShape (ActivityEdge, 
isIcon=true, interruptible or going to 
an ExceptionHandler body)

UMLEdge (Message, asynchronous 
signal/call)
 - UMLLabel (Message)

UMLEdge (Message, synchronous 
call)

15.2.4, B.4.2
Fig. 15.6, 15.13, 
15.19

15.6.4, B.4.2
Fig. 15.5, 15.7, 
15.62, 15.64, 
15.68

15.6.4, B.4.2
Fig. 15.63, 15.69

17.4.4, B.2.3
Fig. 17.3

17.4.4, B.2.3

UMLEdge (Message, reply)

17.4.4, B.2.3

UMLEdge (Message, createMessage)

17.4.4, B.2.3

UMLEdge (Message, lost)

UMLEdge (Message, found)

UMLEdge (GeneralOrdering)

17.4.4, B.4.2

17.4.4, B.4.2

17.5.4, B.4.2
Fig. 17.10

720

Unified Modeling Language 2.5

Notation

Diagram elements

UMLShape (Lifeline, line)
- UMLLabel (Lifeline, rectangle)
UMLShape (Gate)
UMLEdge (Message)
UMLShape (ExecutionSpecification)

UMLEdge (Message)
UMLShape (Message)
- UMLLabel (Message)

UMLShape (Message)
- UMLLabel (Message)
UMLEdge (Message)

Ref.

17.2.4, B.2.3
Fig. 17.4

17.11.1, B.2.3

UMLEdge (Extend)
- UMLKeywordLabel (Extend)

UMLEdge (Include)
- UMLKeywordLabel (Include)

18.1.4, B.4.2
Fig. 18.3

18.1.4, B.4.2
Fig. 18.4

UMLEdge (Deployment)
- UMLKeywordLabel (Deployment)

19.2.4, B.2.3
Fig. 19.15, 19.16

UMLEdge (InformationFlow)
- UMLKeywordLabel 
(InformationFlow)
- UMLShape (InformationFlow, 
isIcon=true)

20.1.4, B.5
Fig. 20.2, 20.5, 
20.6

Unified Modeling Language 2.5

721

B.7
B.7.1

Classifier Descriptions
UMLActivityDiagram [Class]

B.7.1.1

Description

Shows an Activity and its elements. Also see Annex A.

B.7.1.2

Generalizations

UMLBehaviorDiagram

B.7.1.3

Attributes

•

isActivityFrame : Boolean [1..1] = false
Indicates whether the UMLActivityDiagram shall be shown with a frame that is a round-cornered rectangle 
without a pentagonal header.

B.7.1.4

Association Ends

• modelElement : Activity [1..1]{redefines UMLBehaviorDiagram::modelElement} (opposite 

A_UMLActivityDiagram_modelElement_umlDiagramElement::umlDiagramElement)
Restricts UMLActivityDiagrams to show Activities.

B.7.1.5

Constraints

•

frame
isFrame and isActivityFrame must not be true at the same time.

inv: not (isActivityFrame and isFrame)

B.7.2

UMLAssociationEndLabel [Class]

B.7.2.1

Description

Shows text about Properties that are Association ends.

B.7.2.2

Generalizations

UMLLabel

B.7.2.3

Association Ends

• modelElement : Property [1..1]{redefines UMLDiagramElement::modelElement} (opposite 
A_UMLAssociationEndLabel_modelElement_umlDiagramElement::umlDiagramElement)
Restricts UMLAssociationEndLabels to show only Properties (that are AssociationEnds, see constraint).

B.7.2.4

Constraints

• modelElement_type

modelElement must be an Association end.

inv: not modelElement->forAll(association->isEmpty())

722

Unified Modeling Language 2.5

B.7.3

UMLAssociationOrConnectorOrLinkShape [Class]

B.7.3.1

Description

Shows shapes for binary relationships.

B.7.3.2

Generalizations

UMLShape

B.7.3.3

Attributes

•

kind : UMLAssociationOrConnectorOrLinkShapeKind [1..1]

B.7.3.4

Constraints

• modelElement_mult

UMLAssociationOrConnectorOrLinkShapes must have exactly one modelElement.

inv: modelElement->size()=1

• modelElement_type

modelElement must be an Association, Connector, or InstanceSpecification with an Association classifier.

inv: modelElement->asSequence()->first().oclIsKindOf(Association) or modelElement-
>asSequence()->first().oclIsKindOf(Connector)
or (       modelElement->asSequence()->first().oclIsKindOf(InstanceSpecification)
      and (modelElement->asSequence()->first().oclAsType(InstanceSpecification).classifier-
>select(oclIsKindOf(Association))->size() > 0))

edge_association
For diamond kind and an Association modelElement, the Association has exactly two memberEnds, and 
exactly two of the UMLEdges linked to the shape have those memberEnds as modelElements.

inv: (kind=UMLAssociationOrConnectorOrLinkShapeKind::diamond and modelElement-
>forAll(oclIsKindOf(Association))) implies
let association : Association = modelElement->any(true).oclAsType(Association) in
   ((association.memberEnd->size() = 2) and
      (sourceEdge.modelElement->union(targetEdge.modelElement)->select(em |  
association.memberEnd->includes(em))->size()=2))

edge_instancespec
For diamond kind and an InstanceSpecification modelElement, exactly one Association classifier of the 
InstanceSpecification has exactly two memberEnds and exactly two of the UMLEdges linked to the shape have 
those memberEnds as modelElements.

inv: (kind=UMLAssociationOrConnectorOrLinkShapeKind::diamond and modelElement-
>forAll(oclIsKindOf(InstanceSpecification))) implies
let instanceSpecification : InstanceSpecification = modelElement-
>any(true).oclAsType(InstanceSpecification) in
  (instanceSpecification.classifier->select(a | a.oclIsKindOf(Association) and
  (a.oclAsType(Association).memberEnd->size() = 2) and
  (sourceEdge.modelElement->union(targetEdge.modelElement)
    ->select(e |  a.oclAsType(Association).memberEnd->includes(e.modelElement))
    ->size()=2))
    ->size()=1)

edge_connector
For diamond kind and a Connector modelElement, the Connector has exactly two ends, and exactly two of the 
UMLEdges linked to the shape have definingEnds of those ends as modelElements.

•

•

•

Unified Modeling Language 2.5

723

inv: (kind=UMLAssociationOrConnectorOrLinkShapeKind::diamond and modelElement-
>forAll(oclIsKindOf(Connector))) implies
let connector : Connector = modelElement->any(true).oclAsType(Connector) in
   ((connector.end->size() = 2) and
      (sourceEdge.modelElement->union(targetEdge.modelElement)->select(em |  
connector.end.definingEnd->includes(em))->size()=2))

UMLAssociationOrConnectorOrLinkShapeKind [Enumeration]

Description

Literals

B.7.4

B.7.4.1

B.7.4.2

•

•

diamond

triangle

B.7.5

UMLBehaviorDiagram [Abstract Class]

B.7.5.1

Description

The most general class for UMLDiagrams depicting behavioral elements.

B.7.5.2

Generalizations

UMLDiagram

B.7.5.3

Specializations

UMLActivityDiagram, UMLInteractionDiagram, UMLStateMachineDiagram, UMLUseCaseDiagram

B.7.5.4

Association Ends

• modelElement : Behavior [0..1]{redefines UMLDiagramElement::modelElement} (opposite 

A_UMLBehaviorDiagram_modelElement_umlDiagramElement::umlDiagramElement)
Restricts UMLBehaviorDiagrams to showing Behaviors.

B.7.6

UMLClassDiagram [Class]

B.7.6.1

Description

See Annex A.

B.7.6.2

Generalizations

UMLStructureDiagram

B.7.6.3

Constraints

•

no_modelElement
UMLClassDiagrams must have no modelElements.

inv: modelElement->isEmpty()

724

Unified Modeling Language 2.5

B.7.7

UMLClassifierShape [Class]

B.7.7.1

Description

Shows Classifiers with shapes that may have compartments.

B.7.7.2

Generalizations

UMLCompartmentableShape

B.7.7.3

Attributes

•

•

isIndentForVisibility : Boolean [1..1] = false
For modelElements that are shown with feature compartments, indicates whether features are shown indented 
under visibility headings.

isDoubleSided : Boolean [1..1] = false
For modelElements that are Classes with true as a value for isActive that are shown as rectangles, indicates 
whether the vertical sides shall be rendered as double lines.

B.7.7.4

Association Ends

• modelElement : Classifier [1..1]{redefines UMLDiagramElement::modelElement} (opposite 

A_UMLClassifierShape_modelElement_umlDiagramElement::umlDiagramElement)
Restricts UMLClassifierShapes to showing exactly one Classifier.

B.7.7.5

Constraints

•

doubleSided_isActive
isDoubleSided may be true only when modelElement is an active Class.

inv: isDoubleSided implies (modelElement->forAll(oclIsKindOf(Class)) and 
modelElement.oclAsType(Class)->forAll(isActive))

B.7.8

UMLCompartment [Class]

B.7.8.1

Description

A separated portion of a UMLCompartmentableShape.

B.7.8.2

Generalizations

UMLDiagramElement

B.7.8.3

Association Ends

•

♦ elementInCompartment : UMLDiagramElement [0..*]{ordered, subsets DiagramElement::ownedElement} 
(opposite A_UMLCompartment_elementInCompartment_owningCompartment::owningCompartment)
Contents of the compartment.

B.7.8.4

Constraints

•

no_modelElement
UMLCompartments have no modelElements.

Unified Modeling Language 2.5

725

inv: modelElement->isEmpty()

B.7.9

UMLCompartmentableShape [Class]

B.7.9.1

Description

The most general class for UML elements that may have contents shown in separated portions inside the shape.

B.7.9.2

Generalizations

UMLShape

B.7.9.3

Specializations

UMLClassifierShape, UMLStateShape

B.7.9.4

Association Ends

•

♦ compartment : UMLCompartment [0..*]{ordered, subsets DiagramElement::ownedElement} (opposite 
A_UMLCompartmentableShape_compartmentedShape_shape::compartmentedShape)
Separated portions of the shape.

B.7.10

UMLComponentDiagram [Class]

B.7.10.1

Description

See Annex A.

B.7.10.2

Generalizations

UMLStructureDiagram

B.7.10.3

Constraints

•

no_modelElement

inv: modelElement->isEmpty()

B.7.11

UMLCompositeStructureDiagram [Class]

B.7.11.1

Description

Shows the internal structure of a StructuredClassifier. Also see Annex A.

B.7.11.2

Generalizations

UMLStructureDiagram

B.7.11.3

Constraints

• modelElement_mult

UMLCompositeStructureDiagrams must have exactly one modelElement.

inv: modelElement->size() = 1

726

Unified Modeling Language 2.5

• modelElement_type

modelElement must be a StructuredClassifier or an InstanceSpecification with a classifier that is a 
StructuredClassifier.

inv: modelElement->asSequence()->first().oclIsKindOf(StructuredClassifier)
or (       modelElement->asSequence()->first().oclIsKindOf(InstanceSpecification)
      and (modelElement->asSequence()->first().oclAsType(InstanceSpecification).classifier-
>select(c | c.oclIsKindOf(StructuredClassifier))->size() > 0))

B.7.12

UMLDeploymentDiagram [Class]

B.7.12.1

Description

See Annex A.

B.7.12.2

Generalizations

UMLStructureDiagram

B.7.12.3

Constraints

•

no_modelElement
UMLDeploymentDiagrams must have no modelElement.

inv: modelElement->isEmpty()

B.7.13

UMLDiagram [Abstract Class]

B.7.13.1

Description

The most general class for UML diagrams.

B.7.13.2

Generalizations

Diagram, PackageableElement, UMLDiagramElement

B.7.13.3

Specializations

UMLDiagramWithAssociations, UMLBehaviorDiagram

B.7.13.4

Attributes

•

•

•

isFrame : Boolean [1..1] = true
Indicates when diagram frames shall be shown.

isIso : Boolean [1..1] = true
Indicate when ISO notation rules shall be followed.

isInheritedLighter : Boolean [1..1] = false

B.7.13.5

Association Ends

•

heading : UMLLabel [0..1] (opposite A_UMLDiagram_heading_headedDiagram::headedDiagram)

Unified Modeling Language 2.5

727

B.7.13.6

Constraints

•

•

no-frame-no-heading
UMLDiagrams cannot have headings without frames, or vice-versa.

inv: (isFrame = false) = (heading->isEmpty())

heading_modelElement
The modelElement of the heading is the same as the modelElement of the diagram it heads.

inv: (heading->isEmpty()) or (heading.modelElement = modelElement)

B.7.14

UMLDiagramElement [Abstract Class]

B.7.14.1

Description

The most general class for UML diagram interchange.

B.7.14.2

Generalizations

DiagramElement

B.7.14.3

Specializations

UMLCompartment, UMLDiagram, UMLEdge, UMLShape

B.7.14.4

Attributes

•

isIcon : Boolean [1..1] = false
For modelElements that have an option to be shown with shapes other than rectangles, such as Actors, or with 
other identifying shapes inside them, such as arrows distinguishing InputPins and OutputPins, or edges that 
have an option to be shown with lines other than solid with open arrow heads, such as Realization. A value of 
true for isIcon indicates the alternative notation shall be shown.

B.7.14.5

Association Ends

• modelElement : Element [0..*]{redefines DiagramElement::modelElement} (opposite 
A_UMLDiagramElement_modelElement_umlDiagramElement::umlDiagramElement)
Restricts UMLDiagramElements to show UML Elements, rather than other language elements.

•

•

•

728

sharedStyle : UMLStyle [0..1]{redefines DiagramElement::sharedStyle} (opposite 
A_UMLDiagramElement_sharedStyle_styledElement::styledElement)
Restricts shared styles to UMLStyles.

♦ localStyle : UMLStyle [0..1]{redefines DiagramElement::localStyle} (opposite 
A_UMLDiagramElement_localStyle_styledElement::styledElement)
Restricts owned styles to UMLStyles.

owningElement : UMLDiagramElement [0..1]{redefines DiagramElement::owningElement} (opposite 
UMLDiagramElement::ownedElement)
Restricts UMLDiagramElements to be owned by only UMLDiagramElements.

Unified Modeling Language 2.5

•

♦ ownedElement : UMLDiagramElement [0..*]{ordered, redefines DiagramElement::ownedElement} 
(opposite UMLDiagramElement::owningElement)
Restricts UMLDiagramElements to own only UMLDiagramElements.

B.7.15

UMLDiagramWithAssociations [Abstract Class]

B.7.15.1

Description

Specifies the common aspects of diagrams that show associations.

B.7.15.2

Generalizations

UMLDiagram

B.7.15.3

Specializations

UMLStructureDiagram, UMLUseCaseDiagram

B.7.15.4

Attributes

•

•

•

isAssociationDotShown : Boolean [1..1] = false
Indicates whether dot notation for associations shall be used.

navigabilityNotation : UMLNavigabilityNotationKind [1..1] = oneWay
Indicates when to show navigability of associations or connectors typed by associations.

nonNavigabilityNotation : UMLNavigabilityNotationKind [1..1] = never
Indicates when to show non-navigability of associations or connectors typed by associations.

B.7.16

UMLEdge [Class]

B.7.16.1

Description

The most general class for UML diagram elements that are rendered as lines.

B.7.16.2

Generalizations

Edge, UMLDiagramElement

B.7.16.3

Association Ends

•

•

source : UMLDiagramElement [1..1]{redefines Edge::source} (opposite 
A_UMLEdge_source_sourceEdge::sourceEdge)
Restricts the sources of UMLEdges to UMLDiagramElements.

target : UMLDiagramElement [1..1]{redefines Edge::target} (opposite 
A_UMLEdge_target_targetEdge::targetEdge)
Restricts the targets of UMLEdges to UMLDiagramElements.

B.7.17

UMLInteractionDiagram [Class]

B.7.17.1

Description

Shows an Interaction and its elements. Also see Annex A.

Unified Modeling Language 2.5

729

B.7.17.2

Generalizations

UMLBehaviorDiagram

B.7.17.3

Attributes

•

•

kind : UMLInteractionDiagramKind [1..1] = sequence
Indicates how an Interaction shall be shown.

isLifelineDashed : Boolean [1..1] = false
Indicates whether lifelines on the diagram shall be rendered as dashed.

B.7.17.4

Association Ends

• modelElement : Interaction [1..1]{redefines UMLBehaviorDiagram::modelElement} (opposite 

A_UMLInteractionDiagram_modelElement_umlDiagramElement::umlDiagramElement)
Restricts UMLInteractionDiagrams to showing Interactions.

B.7.18

UMLInteractionDiagramKind [Enumeration]

B.7.18.1

Description

Alternatives for diagramming Interactions.

B.7.18.2

Literals

•

•

•

•

•

sequence
See sub clause 17.8.

communication
See sub clause 17.9.

overview
See sub clause 17.10.

timing
See sub clause 17.11.

table
See Annex D.

B.7.19

UMLInteractionTableLabel [Class]

B.7.19.1

Description

B.7.19.2

Generalizations

UMLLabel

B.7.19.3

Attributes

•

kind : UMLInteractionTableLabelKind [1..1]

730

Unified Modeling Language 2.5

B.7.20

UMLInteractionTableLabelKind [Enumeration]

B.7.20.1

Description

B.7.20.2

Literals

•

•

•

lifelineClass

lifelineInstance

constraint

• messageSendingClass

• messageSendingInstance

•

•

•

diagramIdentifier

generatedInstanceName

sequenceNumber

• weakOrder

• messageName

•

•

parameter

returnValue

• messageReceivingClass

• messageReceivingInstance

•

otherEnd

B.7.21

UMLKeywordLabel [Class]

B.7.21.1

Description

For showing the keywords of the modelElement.

B.7.21.2

Generalizations

UMLLabel

B.7.21.3

Constraints

• modeElement_mult

UMLKeywords must have exactly one modelElement.

inv: modelElement->size() = 1

Unified Modeling Language 2.5

731

B.7.22

UMLLabel [Class]

B.7.22.1

Description

The most general class for UML shapes that are rendered only as text.

B.7.22.2

Generalizations

UMLShape

B.7.22.3

Specializations

UMLAssociationEndLabel, UMLMultiplicityLabel, UMLKeywordLabel, UMLNameLabel, 
UMLRedefinesLabel, UMLStereotypePropertyValueLabel, UMLTypedElementLabel, 
UMLInteractionTableLabel

B.7.22.4

Attributes

•

text : String [1..1]
String to be rendered.

B.7.22.5

Constraints

• modelElement_mult

UMLLabels must have no more than one modelElement.

inv: modelElement->size() <= 1

•

no_icon
UMLLabels must have the value of false for isIcon.

inv: isIcon=false

B.7.23

UMLMultiplicityLabel [Class]

B.7.23.1

Description

Shows text about MultiplicityElements.

B.7.23.2

Generalizations

UMLLabel

B.7.23.3

Association Ends

• modelElement : MultiplicityElement [1..1]{redefines UMLDiagramElement::modelElement} (opposite 

A_UMLMultiplicityElement_modelElement_umlDiagramElement::umlDiagramElement)
Restricts UMLMultiplicityLabels to show only MultiplicityElements.

B.7.24

UMLNameLabel [Class]

B.7.24.1

Description

For showing text about NamedElements.

732

Unified Modeling Language 2.5

B.7.24.2

Generalizations

UMLLabel

B.7.24.3

Association Ends

• modeElement : NamedElement [1..1]{redefines UMLDiagramElement::modelElement} (opposite 

A_UMLNameLabel_modelElement_umlDiagramElement::umlDiagramElement)
Restricts UMLNameLabels to be notation for NamedElements.

B.7.25

UMLNavigabilityNotationKind [Enumeration]

B.7.25.1

Description

Alternatives for showing navigability or non-navigability of associations and connectors typed associations.

B.7.25.2

Literals

•

•

•

always
Always show navigability or non-navigability.

oneWay
Show navigability or non-navigability only for unidirectional associations and connectors typed by 
unidirectional associations.

never
Never show navigability or non-navigability.

B.7.26

UMLObjectDiagram [Class]

B.7.26.1

Description

See Annex A.

B.7.26.2

Generalizations

UMLStructureDiagram

B.7.26.3

Constraints

•

no_modelElement
UMLObjectDiagrams must have no modelElement.

inv: modelElement->isEmpty()

B.7.27

UMLPackageDiagram [Class]

B.7.27.1

Description

See Annex A.

B.7.27.2

Generalizations

UMLStructureDiagram

Unified Modeling Language 2.5

733

B.7.27.3

Constraints

•

no_modelElement
UMLPackageDiagrams must have no modelElement.

inv: modelElement->isEmpty()

B.7.28

UMLProfileDiagram [Class]

B.7.28.1

Description

See Annex A.

B.7.28.2

Generalizations

UMLStructureDiagram

B.7.28.3

Constraints

•

no_modelElement
UMLProfileDiagrams must have no modelElement.

inv: modelElement->isEmpty()

B.7.29

UMLRedefinesLabel [Class]

B.7.29.1

Description

For showing redefinition.

B.7.29.2

Generalizations

UMLLabel

B.7.29.3

Association Ends

• modelElement : RedefinableElement [1..1]{redefines UMLDiagramElement::modelElement} (opposite 

A_UMLRedefines_modelElement_umlDiagramElement::umlDiagramElement)
Restricts UMLRedefinesLabels to be notation for RedefinableElements.

B.7.30

UMLShape [Class]

B.7.30.1

Description

The most general class for UML diagram elements that are not rendered as lines.

B.7.30.2

Generalizations

Shape, UMLDiagramElement

B.7.30.3

Specializations

UMLAssociationOrConnectorOrLinkShape, UMLCompartmentableShape, UMLLabel

734

Unified Modeling Language 2.5

B.7.31

UMLStateMachineDiagram [Class]

B.7.31.1

Description

Shows a StateMachine and its elements. Also see Annex A.

B.7.31.2

Generalizations

UMLBehaviorDiagram

B.7.31.3

Attributes

•

•

•

isCollapseStateIcon : Boolean [1..1] = true
Indicates whether UMLShapes for composite States shall contain a small icon distinguishing them from non-
composite States.

isInheritedDashed : Boolean [1..1] = false
Indicates how borders shall be rendered on UMLShapes that have an inherited State as modelElement.

isTransitionOriented : Boolean [1..1] = false
Indicates whether properties of Transitions shall be shown graphically.

B.7.31.4

Association Ends

• modelElement : StateMachine [1..1]{redefines UMLBehaviorDiagram::modelElement} (opposite 

A_UMLStateMachine_modelElement_umlDiagramElement::umlDiagramElement)

B.7.31.5

Constraints

•

•

isd_isl_xor
isInheritedDashed and isInheritedLighter cannot both have a value of true.

inv: not (isInheritedDashed and isInheritedLighter)

isd_isl_req
Either isInheritedDashed or isInheritedLighter must have a value of true if the diagram shows any inherited 
states.

inv:

B.7.32

UMLStateShape [Class]

B.7.32.1

Description

B.7.32.2

Generalizations

UMLCompartmentableShape

B.7.32.3

Attributes

•

isTabbed : Boolean [1..1] = false

Unified Modeling Language 2.5

735

B.7.32.4

Association Ends

• modelElement : State [1..*]{redefines UMLDiagramElement::modelElement} (opposite 

A_UMLStateShape_modelElement_umlDiagramElement::umlDiagramElement)

B.7.32.5

Constraints

•

state_list
UMLStateShapes may have multiple modelElements only when their outgoing Transitions have no triggers or 
effects, and target the same junction State that has one outgoing Transition.

inv: (modelElement->size() > 1) implies
(         modelElement->forAll(outgoing->forAll(trigger->isEmpty() and
                                                                         effect->isEmpty() 
and
                                                                         
target.oclIsKindOf(Pseudostate) and
                                                                         
target.oclAsType(Pseudostate).kind = PseudostateKind::junction and
                                                                         target.outgoing-
>size() = 1))
  and  modelElement.outgoing.target->asSet()->size()=1)

B.7.33

UMLStereotypePropertyValueLabel [Class]

B.7.33.1

Description

For showing Property values of Stereotypes applied to UML abstract syntax elements.

B.7.33.2

Generalizations

UMLLabel

B.7.33.3

Association Ends

• modelElement : Property [1..1]{redefines UMLDiagramElement::modelElement} (opposite 

A_UMLStereotypePropertyValueLabel_modelElement_umlDiagramElement::umlDiagramElement)
A Property of a Stereotype applied to the stereotypedElement.

•

stereotypedElement : Element [1..1] (opposite 
A_UMLStereotypePropertyValueLabel_stereotypedElement_labelShowingStereotypeValue::labelShowingSter
eotypeValue)
Element to which a Stereotype having the modelElement (Property) is applied.

B.7.33.4

Constraints

prop_on_stereotype
modelElement is a Property of a Stereotype.

inv: modelElement->forAll(classifier.oclIsKindOf(Stereotype))

stereotypedElement
Property must be on Stereotype applied to stereotypedElement.

inv:

•

•

736

Unified Modeling Language 2.5

B.7.34

UMLStructureDiagram [Abstract Class]

B.7.34.1

Description

The most general class for UMLDiagrams depicting structural elements.

B.7.34.2

Generalizations

UMLDiagramWithAssociations

B.7.34.3

Specializations

UMLClassDiagram, UMLComponentDiagram, UMLCompositeStructureDiagram, UMLDeploymentDiagram,
UMLObjectDiagram, UMLPackageDiagram, UMLProfileDiagram

B.7.35

UMLStyle [Class]

B.7.35.1

Description

The most general class for Styles in UML.

B.7.35.2

Generalizations

Style, PackageableElement

B.7.35.3

Attributes

•

•

fontName : String [0..1]
Name of a font used to render strings.

fontSize : Real [0..1]
Size of a font for rendering strings, given in typographical points.

B.7.35.4

Constraints

•

fontsize_positive
fontSize must be greater than zero.

inv: fontSize > 0

B.7.36

UMLTypedElementLabel [Class]

B.7.36.1

Description

For showing text about Slots, InstanceSpecifications, InstanceValues, or elements with a type, such as TypedElements 
or Connectors.

B.7.36.2

Generalizations

UMLLabel

B.7.36.3

Constraints

• modelElement_mult

UMLTypedElementLabels must have exactly one modelElement.

Unified Modeling Language 2.5

737

inv: modelElement->size() = 1

• modelElement_type

modelElement must be a Slot, InstanceSpecification, InstanceValue, or an element with a type, such as a 
TypedElement or Connector.

Cannot be expressed in OCL

B.7.37

UMLUseCaseDiagram [Class]

B.7.37.1

Description

See Annex A.

B.7.37.2

Generalizations

UMLBehaviorDiagram, UMLDiagramWithAssociations

B.7.37.3

Constraints

•

no_modelElement
UMLUseCaseDiagrams must have no modelElements.

inv: modelElement->isEmpty()

B.8
B.8.1

Association Descriptions
A_UMLActivityDiagram_modelElement_umlDiagramElement [Association]

B.8.1.1

Owned Ends

•

umlDiagramElement : UMLActivityDiagram [0..*]{redefines 
A_UMLBehaviorDiagram_modelElement_umlDiagramElement::umlDiagramElement} (opposite 
UMLActivityDiagram::modelElement)

B.8.2

A_UMLAssociationEndLabel_modelElement_umlDiagramElement 
[Association]

B.8.2.1

Owned Ends

•

umlDiagramElement : UMLAssociationEndLabel [0..*]{redefines 
A_UMLDiagramElement_modelElement_umlDiagramElement::umlDiagramElement} (opposite 
UMLAssociationEndLabel::modelElement)

B.8.3

A_UMLBehaviorDiagram_modelElement_umlDiagramElement 
[Association]

B.8.3.1

Owned Ends

•

738

umlDiagramElement : UMLBehaviorDiagram [0..*]{redefines 
A_UMLDiagramElement_modelElement_umlDiagramElement::umlDiagramElement} (opposite 
UMLBehaviorDiagram::modelElement)

Unified Modeling Language 2.5

B.8.4

A_UMLClassifierShape_modelElement_umlDiagramElement [Association]

B.8.4.1

Owned Ends

•

umlDiagramElement : UMLClassifierShape [0..*]{redefines 
A_UMLDiagramElement_modelElement_umlDiagramElement::umlDiagramElement} (opposite 
UMLClassifierShape::modelElement)

B.8.5

A_UMLCompartment_elementInCompartment_owningCompartment 
[Association]

B.8.5.1

Owned Ends

•

B.8.6

owningCompartment : UMLCompartment [0..1]{subsets DiagramElement::owningElement} (opposite 
UMLCompartment::elementInCompartment)

A_UMLCompartmentableShape_compartmentedShape_shape 
[Association]

B.8.6.1

Owned Ends

•

compartmentedShape : UMLCompartmentableShape [1..1]{subsets DiagramElement::owningElement} 
(opposite UMLCompartmentableShape::compartment)

B.8.7

A_UMLDiagramElement_localStyle_styledElement [Association]

B.8.7.1

Owned Ends

•

styledElement : UMLDiagramElement [0..*]{redefines A_sharedStyle_styledElement::styledElement} 
(opposite UMLDiagramElement::localStyle)

B.8.8

A_UMLDiagramElement_modelElement_umlDiagramElement [Association]

B.8.8.1

Owned Ends

•

umlDiagramElement : UMLDiagramElement [0..*]{subsets 
A_modelElement_diagramElement::diagramElement} (opposite UMLDiagramElement::modelElement)

B.8.9

A_UMLDiagramElement_ownedElement_owningElement [Association]

B.8.9.1

Member Ends

 

• UMLDiagramElement::ownedElement
 
• UMLDiagramElement::owningElement

 

 

Unified Modeling Language 2.5

739

B.8.10

A_UMLDiagramElement_sharedStyle_styledElement [Association]

B.8.10.1

Owned Ends

•

styledElement : UMLDiagramElement [0..*]{redefines A_sharedStyle_styledElement::styledElement} 
(opposite UMLDiagramElement::sharedStyle)

B.8.11

A_UMLDiagram_heading_headedDiagram [Association]

B.8.11.1

Owned Ends

•

headedDiagram : UMLDiagram [0..*] (opposite UMLDiagram::heading)

B.8.12

A_UMLEdge_source_sourceEdge [Association]

B.8.12.1

Owned Ends

•

sourceEdge : UMLEdge [0..*]{redefines A_source_sourceEdge::sourceEdge} (opposite UMLEdge::source)

B.8.13

A_UMLEdge_target_targetEdge [Association]

B.8.13.1

Owned Ends

•

B.8.14

targetEdge : UMLEdge [0..*]{redefines A_target_targetEdge::targetEdge} (opposite UMLEdge::target)

A_UMLInteractionDiagram_modelElement_umlDiagramElement 
[Association]

B.8.14.1

Owned Ends

•

umlDiagramElement : UMLInteractionDiagram [0..*]{redefines 
A_UMLBehaviorDiagram_modelElement_umlDiagramElement::umlDiagramElement} (opposite 
UMLInteractionDiagram::modelElement)

B.8.15

A_UMLMultiplicityElement_modelElement_umlDiagramElement 
[Association]

B.8.15.1

Owned Ends

•

umlDiagramElement : UMLMultiplicityLabel [0..*]{redefines 
A_UMLDiagramElement_modelElement_umlDiagramElement::umlDiagramElement} (opposite 
UMLMultiplicityLabel::modelElement)

B.8.16

A_UMLNameLabel_modelElement_umlDiagramElement [Association]

B.8.16.1

Owned Ends

•

740

umlDiagramElement : UMLNameLabel [0..*]{redefines 
A_UMLDiagramElement_modelElement_umlDiagramElement::umlDiagramElement} (opposite 
UMLNameLabel::modeElement)

Unified Modeling Language 2.5

B.8.17

A_UMLRedefines_modelElement_umlDiagramElement [Association]

B.8.17.1

Owned Ends

•

umlDiagramElement : UMLRedefinesLabel [0..*]{redefines 
A_UMLDiagramElement_modelElement_umlDiagramElement::umlDiagramElement} (opposite 
UMLRedefinesLabel::modelElement)

B.8.18

A_UMLStateMachine_modelElement_umlDiagramElement [Association]

B.8.18.1

Owned Ends

•

umlDiagramElement : UMLStateMachineDiagram [0..*]{redefines 
A_UMLBehaviorDiagram_modelElement_umlDiagramElement::umlDiagramElement} (opposite 
UMLStateMachineDiagram::modelElement)

B.8.19

A_UMLStateShape_modelElement_umlDiagramElement [Association]

B.8.19.1

Owned Ends

•

umlDiagramElement : UMLStateShape [0..*]{redefines 
A_UMLDiagramElement_modelElement_umlDiagramElement::umlDiagramElement} (opposite 
UMLStateShape::modelElement)

B.8.20

A_UMLStereotypePropertyValueLabel_modelElement_umlDiagramElement
[Association]

B.8.20.1

Owned Ends

•

umlDiagramElement : UMLStereotypePropertyValueLabel [0..*]{redefines 
A_UMLDiagramElement_modelElement_umlDiagramElement::umlDiagramElement} (opposite 
UMLStereotypePropertyValueLabel::modelElement)

B.8.21

A_UMLStereotypePropertyValueLabel_stereotypedElement_labelShowing
StereotypeValue [Association]

B.8.21.1

Owned Ends

•

labelShowingStereotypeValue : UMLStereotypePropertyValueLabel [0..*] (opposite 
UMLStereotypePropertyValueLabel::stereotypedElement)

Unified Modeling Language 2.5

741

Annex C: Keywords

(normative)

UML keywords are reserved words that are an integral part of the UML notation and normally appear as text 
annotations attached to a UML graphic element or as part of a text line in a UML diagram.
In UML, keywords are used for three different purposes:

1

2

3

To distinguish a particular UML concept (metaclass) from others sharing the same general graphical form. For 
instance, the «interface» keyword in the header box of a classifier rectangle is used to distinguish an Interface 
from other kinds of Classifiers.

To distinguish a particular kind of relationship between UML concepts (meta-association) from other 
relationships sharing the same general graphical form. For example, dashed lines between elements are used 
for a number of different relationships, including Dependencies, relationships between UseCases and an 
extending UseCases, and so on.

To specify the value of some modifier attached to a UML concept (meta-attribute value). Thus, the keyword 
«singleExecution» appearing within an Activity signifies that the “isSingleExecution” attribute of that Activity 
is true.

Keywords are always enclosed in guillemets («keyword»), which serve as visual cues to more readily distinguish when 
a keyword is being used.
NOTE. Guillemets are a special kind of quotation marks and should not be confused with or replaced by duplicated 
“greater than” (>>) or “less than” (<<) symbols, except in situations where the available character set may not include 
guillemets.
In addition to identifying keywords, guillemets are also used to distinguish the usage of stereotypes. This means that:

• Not all words appearing between guillemets are necessarily keywords, and

• words appearing in guillemets do not necessarily represent stereotypes.

If multiple keywords and/or stereotype names apply to the same model element, each stereotype may be enclosed in a 
separate pair of guillemets and listed one after the other. Alternatively they all appear between the same pair of 
guillemets, separated by commas:

“«” <label> [“,” <label>]* “»”

where:

<label> ::= <keyword> | <stereotype-label>

Keywords are context sensitive and, in a few cases, the same keyword is used for different purposes in different 
contexts. For instance, the «create» keyword can appear next to an operation name to indicate that it as a constructor 
operation, and it can also be used to label a Usage dependency between two Classes to indicate that one Class creates 
instances of the other. This means that it is possible in principle to use a keyword for a user-defined stereotype 
(provided that it is used in a context that does not conflict with the keyword context). However, such practices are 
discouraged as they are likely to lead to confusion.
The keywords currently defined as part of standard UML are specified in Table C.1, sorted in alphabetical order. The 
following is the interpretation of the individual columns in this table:

•

Keyword provides the exact spelling of the keyword (without the guillemets).

Unified Modeling Language 2.5

743

• Metamodel Element specifies the element of the UML metamodel (either a metaclass or a metaclass feature) 

that the keyword denotes.

•

•

Semantics gives a brief description of the semantics of the keyword (see further explanations below); more 
detailed explanations are provided in the Notation clauses of the corresponding metaclass description. The 
following formats are used:

1

2

If the entry contains the name of a UML metaclass or feature, this indicates that the keyword is simply 
used to identify the corresponding metaclass or feature.

If the entry is a constraint (usually but not necessarily an OCL expression), it specifies a constraint 
that applies to metamodel elements that are tagged with that keyword.

Notation Placement indicates where the keyword appears (see further explanations below). The following 
conventions are used to specify the notation placement:

1

2

3

4

5

6

7

8

“box header” means that the keyword appears in the name compartment of a classifier rectangle.

“dashed-line label” means that the keyword is used as a label on some dashed line, such as a 
Dependency.

‘line label” means the keyword is used as a label on some line.

“inline label” means that the keyword appears as part of a text line (usually at the front), such as an 
attribute definition.

 “swimlane header” means that the keyword appears as the header of a swimlane in an activity 
diagram.

“note label” means that the keyword is used in a note symbol.

“top left corner” means that the keyword appears in the top left corner of a symbol.

“after name” means that the keyword appears after the name of the associated element.

Table C.1  Keywords

Keyword

Metamodel Element

Semantics

Notation Placement

abstraction

access

activity

actor

apply

artifact

Abstraction

PackageImport

Activity

Actor

Abstraction

visibility <> 
VisibilityKind::public

Activity

Actor

dashed-line label

dashed-line label

box header

box header

ProfileApplication

ProfileApplication

dashed-line label

box header

box header

Artifact

Artifact

centralBuffer

CentralBufferNode

CentralBufferNode

744

Unified Modeling Language 2.5

Keyword

Metamodel Element

Semantics

Notation Placement

TemplateBinding

TemplateBinding

dashed-line label

bind

collaboration

component

datastore

dataType

decisionInput

Collaboration

Component

DataStoreNode

DataType

Behavior

decisionInputFlow

ObjectFlow

Collaboration

Component

DataStoreNode

DataType

box header

box header

box header

box header

DecisionNode::decisionInput

note label

DecisionNode::decisionInputFl
ow

line label

deploy

Deployment

Deployment

dashed-line label

deployment spec

DeploymentSpecification

DeploymentSpecification

device

Device

Device

element access

ElementImport

element import

ElementImport

visibility <> 
VisibilityKind::public

visibility = 
VisibilityKind::public

enumeration

Enumeration

Enumeration

executionEnvironment

ExecutionEnvironment

ExecutionEnvironment

box header

box header

dashed-line label

dashed-line label

box header

box header

dashed-line label

swimlane header

After name

dashed-line label

dashed-line label

dashed-line label

box header

box header

top left corner

extend

extended

extended

external

final

flow

import

include

information

interface

iterative

Extend

Region

StateMachine

ActivityPartition

State

InformationFlow

PackageImport

Extend

extendedRegion->notEmpty()

after name

extendedStateMachine-
>notEmpty()

after name

isExternal = true

State::isLeaf

InformationFlow

visibility = 
VisibilityKind::public

Include

Include

InformationItem

InformationItem

Interface

ExpansionRegion

Interface

mode = 
ExpansionKind::iterative

localPostcondition

localPrecondition

Constraint

Constraint

Action::localPostcondition

Action::localPrecondition

box header

box header

Unified Modeling Language 2.5

745

Keyword

Metamodel Element

Semantics

Notation Placement

manifest

merge

model

multicast

multireceive

occurrence

parallel

postcondition

protocol

precondition

primitive

profile

reference

reference

Manifestation

PackageMerge

Model

ObjectFlow

ObjectFlow

CollaborationUse

ExpansionRegion

Manifestation

PackageMerge

Model

isMulticast =true

isMultireceive = true

CollaborationUse

mode = 
ExpansionKind::parallel

dashed-line label

dashed-line label

box header

line label

line label

dashed-line label

top left corner

Constraint

Behavior::postcondition

box header

ProtocolStateMachine

ProtocolStateMachine

after name / box header

Constraint

PrimitiveType

Profile

ElementImport

PackageImport

Behavior::precondition

PrimitiveType

Profile

box header

box header

box header

Profile::metaclassReference

dashed-line label

Profile::metamodelReference

dashed-line label

representation

InformationItem::represented

represented

dashed-line label

selection

signal

singleExecution

statemachine

stream

Stereotype

strict

structured

substitute

transformation

use

Behavior

Signal

Activity

StateMachine

ExpansionRegion

Stereotype

ProfileApplication

ObjectFlow::selection

Signal

isSingleExecution = true

StateMachine

mode = 
ExpansionKind::stream

Stereotype

isStrict = true

note label

box header

inside box

box header

top left corner

box header

dashed-line label

StructuredActivityNode

StructuredActivityNode

box header

Substitution

Behavior

Usage

Substitution

dashed-line label

ObjectFlow::transformation

note label

Usage

dashed-line label

746

Unified Modeling Language 2.5

Annex D: Tabular Notation for Sequence Diagrams

(normative)

This annex describes an optional tabular notation for sequence diagrams. The table row descriptions for this notation 
follow:

1

2

Lifeline Class: Designates Class name of Lifeline. If there is no Class name on the Lifeline symbol, this class 
name is omitted.

Lifeline Instance: Designates Instance name of Lifeline. If there is no Instance name on the Lifeline symbol, 
this instance name is omitted.

3 Constraint: Designates some kind of constraint. For example, indication of oblique line is denoted as 

“{delay}.” To represent CombinedFragments, those operators are denoted with an index adorned by square 
bracket. In a case of InteractionUse, it is shown as parenthesized “Diagram ID,” which designates referred 
Interaction Diagram, with “ref” tag, like “ref(M.sq).”

4 Message Sending Class: Designates the message sending class name for each incoming arrow.

5 Message Sending Instance: Designates the message sending instance name for each incoming arrow. In a case 

of Gate message that is outgoing message from InteractionUse, it is shown as parenthesized “Diagram ID,” 
which designates referred Interaction Diagram, with underscore, like “_(M.sq).”

6 Diagram ID: Identifies the document that describes the corresponding sequence/communication diagram and 

can be the name of the file that contains the corresponding sequence or communication diagram.

7 Generated instance name: An identifier name that is given to each instance symbol in the 

sequence/communication diagram. The identifier name is unique in each document.

8

Sequence Number: The corresponding message number on the sequence/communication diagram.

9 Weak Order: Designates partial (relative) orders of events, as ordered on individual lifelines and across 

lifelines, given a message receive event has to occur after its message send event. Events are shown as “e” + 
event order + event direction (incoming or outgoing).

10 Message name: The corresponding message name on the sequence/communication diagram.

11 Parameter: A set of parameter variable names and parameter types of the corresponding message on the 

sequence/ communication diagrams.

12 Return value: The return value type of the corresponding message on the sequence/communication diagram.

13 Message Receiving Class: Designates the message receiving class name for each outgoing arrow.

14 Message Receiving Instance: Designates the message receiving instance name for each outgoing arrow. In a 
case of Gate message that is outgoing message from ordinary instance symbol, it is shown as parenthesized 
message name with “out_” tag, like “(out_s).”

15 Other End: Designates event order of another end on the each message.

Unified Modeling Language 2.5

747

D.1 Examples

Figure D.1  Sequence diagram enhanced with identification of the Event occurrences

Table D.1  Interaction Table describing Figure D.1

e
c
n
a
t
s
n
I
 
e
n

i
l
e
f
i
L

s
s
a
l
C
 
e
n

i
l
e
f
i
L

t
n
i
a
r
t
s
n
o
C

 

i

g
n
d
n
e
S
 
e
g
a
s
s
e

M

s
s
s
a
l
C

 

g
n

i

d
n
e
S
 
e
g
a
s
s
e

M

e
c
n
a
t
s
n
I

D
I
 

m
a
r
g
a
i
D

r
e
b
m
u
N
 
e
c
n
e
u
q
e
S

e
m
a
N
 
e
g
a
s
s
e

M

r
e
t
e
m
a
r
a
P

r
e
d
r
O
k
a
e

 

W

e
u

 

l
a
V
n
r
u
t
e
R

 

g
n

i
v
i
e
c
e
R
 
e
g
a
s
s
e

M

s
s
a
l
C

 

g
n

i
v
i
e
c
e
R
 
e
g
a
s
s
e

M

e
c
n
a
t
s
n
I

e
m
a
N
 
e
c
n
a
t
s
n
I

 

d
e
t
a
r
e
n
e
G

C
B
A Ref(M.sq)
B
Ref(M.sq)
C
C
B
C

alt[1]x==5
alt[1]x==5
alt[2]x==0

C

N.sq
N.sq
N.sq
N.sq
_(M.sq) N.sq
N.sq
N.sq
N.sq

e1o
e2i

e3o(ref)
e3o(ref)

e4i
e5o
e6i
e7o

t
t
s
s
s
u
u
v

B

C
C

B

out_v

d
n
E
 
r
e
h
t
O

e2i
e1o
e4i
e4i

e3o(ref)

e6i
e5o

748

Unified Modeling Language 2.5

Figure D.2  Sequence diagram with guards, parallel composition and alternatives

Table D.2  Interaction Table for Figure D.2

 

i

g
n
d
n
e
S
 
e
g
a
s
s
e

M

s
s
s
a
l
C

s
s
a
l
C
 
e
n

i
l
e
f
i
L

e
c
n
a
t
s
n
I
 
e
n

i
l
e
f
i
L

A
A

A

t
n
i
a
r
t
s
n
o
C

par[1]

par[2].alt[1]
{after e1o}

a > 0

par[2].alt[2]

else

 

g
n

i

d
n
e
S
 
e
g
a
s
s
e

M

e
c
n
a
t
s
n
I

D
I
 

m
a
r
g
a
i
D

r
e
b
m
u
N
 
e
c
n
e
u
q
e
S

r
e
d
r
O
k
a
e

 

W

e
m
a
N
 
e
c
n
a
t
s
n
I

 

d
e
t
a
r
e
n
e
G

para.sq
para.sq

in_y

in_z

para.sq

e1o
e2i

e3i

 

g
n

i
v
i
e
c
e
R
 
e
g
a
s
s
e

M

e
c
n
a
t
s
n
I

out_x

d
n
E
 
r
e
h
t
O

 

g
n

i
v
i
e
c
e
R
 
e
g
a
s
s
e

M

s
s
a
l
C

e
u

 

l
a
V
n
r
u
t
e
R

r
e
t
e
m
a
r
a
P

e
m
a
N
 
e
g
a
s
s
e

M

x
y

z

Unified Modeling Language 2.5

749

Annex E: XMI Serialization and Schema

(normative)

Summary

E.1
UML 2 models are serialized in XMI 2 according to the rules specified by the MOF 2 XMI Mapping Specification.
As is common policy for OMG, the normative representation of MOF 2 and UML 2 models is an XMI file. The 
normative XMI document for UML 2 itself consists of a single XMI document. There are related XMI documents to 
specify the StandardProfile and the UML Diagram Interchange model. PrimitiveTypes, on which UML 2 depends and 
other specifications may depend, is specified in a separate XMI document.

XMI Serialization of the UML 2 metamodel

E.2
XMI allows the use of tags to tailor the schemas that are produced and the documents that are produced using XMI. The 
following are the tag settings that appear in the UML 2 metamodel for the XMI interchange of UML 2 models:

•

tag “org.omg.xmi.nsPrefix” set to “uml”

No other tags are explicitly set, which means they assume their default values as documented in the MOF 2 XMI 
Mappings Specification.
The xmi:ids for metamodel elements in UML 2.5 are the same as for equivalent elements in UML 2.4.1, except for 
those ids corresponding to associations and properties whose name changed between UML 2.4.1 and UML 2.5. The 
metaclasses and associations in UML 2.5 are organized in a package structure that corresponds to the specification 
clause structure. All of these packages are imported into the top-level UML package, so that all metamodel elements can 
be referred to unqualified in the top-level package.
Changes that have been made to the metamodel from 2.4.1 include: the package organization described above; the 
amalgamation of StandardProfileL2 and StandardProfileL3 into a single StandardProfile; the relaxation (to 0) of some 
lower multiplicities in order to represent default values; the introduction of ordered on some properties in order to 
clarify the semantics; the renaming of some association-owned properties and corresponding associations; making 
NamedElement::clientDependency derived; and identifying LoopNodes as the owner of their loopVariables. As a 
consequence, UML 2.5 and UML 2.4.1 model files are interchangeable by substituting version numbers, apart from:

loopVariables of LoopNodes (which could not be interchanged in a standard way in UML 2.4.1);

•
• NamedElements that are the clients of Dependencies, which in UML 2.4.1 would contain a clientDependency 

attribute;
references to the StandardProfile.

•

Apart from LoopNodes, a UML 2.4.1 tool should be able to load the XMI for a UML 2.5 model if the version numbers 
are edited back to 20110701, and all NamedElements that are the clients of Dependencies have a clientDependency 
attribute inserted. Additionally, if there are any references in the UML 2.5 model to the StandardProfile, then references 
to either or both of http://www.omg.org/spec/UML/20110701/StandardProfileL2 and 
http://www.omg.org/spec/UML/20110701/StandardProfileL3 will need to be used instead.
A conforming UML 2.5 tool shall be able to load and save either UML 2.5 or UML 2.4.1 models.
NOTE. Because UML 2.5 has many more OCL constraints formalized, it may be the case that a model that validates in 
a UML 2.4.1 tool may not validate in a UML 2.5 tool.

Unified Modeling Language 2.5

751

XMI Serialization of the PrimitiveTypes model library

E.3
The following are the tag settings that appear in the PrimitiveTypes model library for the XMI interchange of models 
importing that library directly or indirectly:

•

•

•

•

•

•

tag “org.omg.xmi.nsPrefix” set to “primitives”

For PrimitiveTypes::Boolean, tag “org.omg.xmi.schemaType” set to
“http://www.w3.org/2001/XMLSchema#boolean”

For PrimitiveTypes::Integer, tag “org.omg.xmi.schemaType” set to
“http://www.w3.org/2001/XMLSchema#integer”

For PrimitiveTypes::Real, tag “org.omg.xmi.schemaType” set to
“http://www.w3.org/2001/XMLSchema#double”

For PrimitiveTypes::String, tag “org.omg.xmi.schemaType” set to
“http://www.w3.org/2001/XMLSchema#string”

For PrimitiveTypes::UnlimitedNatural, tag “org.omg.xmi.schemaType” set to
“http://www.w3.org/2001/XMLSchema#string”

The unlimited value of UnlimitedNatural, whose notation is “*”, shall be serialized as “*”, whereas all numerical values 
of UnlimitedNatural shall be serialized as the string representation of the number as an integer.

XMI Serialization of the StandardProfile

E.4
The following are the tag settings that appear in the StandardProfile profile for the XMI interchange of models 
importing that profile directly or indirectly:

•

tag “org.omg.xmi.nsPrefix” set to “StandardProfile”

XMI Serialization of the UMLDI

E.5
The following are the tag settings that appear in the UMLDI metamodel extension for the XMI interchange of model 
diagrams:

•

tag “org.omg.xmi.nsPrefix” set to “umldi”

752

Unified Modeling Language 2.5

